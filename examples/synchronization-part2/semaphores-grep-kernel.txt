arch/avr32/include/uapi/asm/sembuf.h:        unsigned long   sem_nsems;              /* no. of semaphores in array */
arch/m32r/mm/fault.c:		goto bad_area_nosemaphore;
arch/m32r/mm/fault.c:			goto bad_area_nosemaphore;
arch/m32r/mm/fault.c:bad_area_nosemaphore:
arch/m32r/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/m32r/include/asm/spinlock.h: * Changed to use the same technique as rw semaphores.  See
arch/m32r/include/asm/spinlock.h: * semaphore.h for details.  -ben
arch/powerpc/mm/fault.c:		 * If we have retry set, the mmap semaphore will have
arch/powerpc/mm/fault.c:			goto bad_area_nosemaphore;
arch/powerpc/mm/fault.c:bad_area_nosemaphore:
arch/powerpc/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;	/* no. of semaphores in array */
arch/powerpc/include/asm/pmac_pfunc.h: * Note that irq_enable & irq_disable are called within a semaphore held
arch/powerpc/sysdev/ppc4xx_hsta_msi.c:#include <linux/semaphore.h>
arch/powerpc/platforms/powernv/opal-async.c:#include <linux/semaphore.h>
arch/powerpc/platforms/powernv/opal-async.c:static struct semaphore opal_async_sem;
arch/powerpc/kernel/eeh_event.c:#include <linux/semaphore.h>
arch/powerpc/kernel/eeh_event.c:static struct semaphore eeh_eventlist_sem;
arch/powerpc/kernel/eeh_event.c:	/* Initialize semaphore */
arch/cris/mm/fault.c: bad_area_nosemaphore:
arch/cris/mm/fault.c:			goto bad_area_nosemaphore;
arch/cris/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/cris/arch-v32/drivers/cryptocop.c:	/* Acquire the mm page semaphore. */
arch/parisc/mm/fault.c:			 * Check for LDCWX and LDCWS (semaphore instructions).
arch/parisc/mm/init.c:	    BUG_ON(recycle_inuse);  /* FIXME: Use a semaphore/wait queue here */
arch/parisc/include/uapi/asm/errno.h:#define	ENAVAIL		179	/* No XENIX semaphores available */
arch/parisc/include/uapi/asm/sembuf.h:	unsigned int	sem_nsems;		/* no. of semaphores in array */
arch/parisc/include/asm/ldcw.h:   for the semaphore.  */
arch/parisc/kernel/entry.S:	 * semaphore held). If the translation doesn't exist, we can't
arch/score/mm/fault.c:		goto bad_area_nosemaphore;
arch/score/mm/fault.c:bad_area_nosemaphore:
arch/metag/mm/fault.c:				goto bad_area_nosemaphore;
arch/metag/mm/fault.c:			goto bad_area_nosemaphore;
arch/metag/mm/fault.c:			goto bad_area_nosemaphore;
arch/metag/mm/fault.c:			goto bad_area_nosemaphore;
arch/metag/mm/fault.c:bad_area_nosemaphore:
arch/tile/mm/pgtable.c: * We only _try_ to acquire the mmap_sem semaphore; if we can't acquire it,
arch/tile/mm/fault.c:		 * Don't take the mm semaphore here. If we fixup a prefetch
arch/tile/mm/fault.c:		goto bad_area_nosemaphore;
arch/tile/mm/fault.c:		goto bad_area_nosemaphore;
arch/tile/mm/fault.c:			goto bad_area_nosemaphore;
arch/tile/mm/fault.c:bad_area_nosemaphore:
arch/tile/include/asm/mmu.h:	 * Written under the mmap_sem semaphore; read without the
arch/tile/include/asm/mmu.h:	 * semaphore but atomically, but it is conservatively set.
arch/m68k/atari/stdma.c:static int stdma_locked;			/* the semaphore */
arch/arc/mm/fault.c:			goto bad_area_nosemaphore;
arch/arc/mm/fault.c:bad_area_nosemaphore:
arch/x86/mm/fault.c:__bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
arch/x86/mm/fault.c:bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
arch/x86/mm/fault.c:	__bad_area_nosemaphore(regs, error_code, address, SEGV_MAPERR);
arch/x86/mm/fault.c:	__bad_area_nosemaphore(regs, error_code, address, si_code);
arch/x86/mm/fault.c:		 * Don't take the mm semaphore here. If we fixup a prefetch
arch/x86/mm/fault.c:		bad_area_nosemaphore(regs, error_code, address);
arch/x86/mm/fault.c:		bad_area_nosemaphore(regs, error_code, address);
arch/x86/mm/fault.c:		bad_area_nosemaphore(regs, error_code, address);
arch/x86/mm/fault.c:			bad_area_nosemaphore(regs, error_code, address);
arch/x86/include/uapi/asm/sembuf.h:	__kernel_ulong_t sem_nsems;	/* no. of semaphores in array */
arch/x86/include/asm/rwsem.h:/* rwsem.h: R/W semaphores implemented using XADD/CMPXCHG for i486+
arch/x86/include/asm/rwsem.h: * Derived from asm-x86/semaphore.h
arch/x86/include/asm/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline int __down_read_trylock(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline void __down_write_nested(struct rw_semaphore *sem, int subclass)
arch/x86/include/asm/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline int __down_write_trylock(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline void rwsem_atomic_add(long delta, struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline long rwsem_atomic_update(long delta, struct rw_semaphore *sem)
arch/x86/lib/rwsem.S: * x86 semaphore implementation.
arch/x86/lib/rwsem.S: * rw semaphores implemented November 1999 by Benjamin LaHaise <bcrl@kvack.org>
arch/x86/lib/rwsem.S: * The semaphore operations have a special calling sequence that
arch/x86/lib/rwsem.S: * there is contention on the semaphore.
arch/x86/lib/rwsem.S: * %eax contains the semaphore pointer on entry. Save the C-clobbered
arch/x86/lib/rwsem.S: * will always return the semaphore pointer in %rax (which
arch/xtensa/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/xtensa/include/asm/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
arch/xtensa/include/asm/rwsem.h:static inline int __down_read_trylock(struct rw_semaphore *sem)
arch/xtensa/include/asm/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
arch/xtensa/include/asm/rwsem.h:static inline int __down_write_trylock(struct rw_semaphore *sem)
arch/xtensa/include/asm/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
arch/xtensa/include/asm/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
arch/xtensa/include/asm/rwsem.h:static inline void rwsem_atomic_add(int delta, struct rw_semaphore *sem)
arch/xtensa/include/asm/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
arch/xtensa/include/asm/rwsem.h:static inline int rwsem_atomic_update(int delta, struct rw_semaphore *sem)
arch/frv/include/uapi/asm/sembuf.h:	unsigned long		sem_nsems;	/* no. of semaphores in array */
arch/um/drivers/port_kern.c:		 * the semaphore regardless of whether it got a successful
arch/um/drivers/xterm_kern.c:	/* This is a locked semaphore... */
arch/um/drivers/mmapper_kern.c:	 * called when the mm semaphore is held
arch/um/drivers/chan_user.c:	 * kernel semaphores. We don't use SysV semaphores because they are
arch/um/kernel/trap.c:		goto out_nosemaphore;
arch/um/kernel/trap.c:			goto out_nosemaphore;
arch/um/kernel/trap.c:out_nosemaphore:
arch/um/kernel/trap.c:		goto out_nosemaphore;
arch/alpha/include/uapi/asm/errno.h:#define	ENAVAIL		119	/* No XENIX semaphores available */
arch/alpha/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/alpha/include/asm/rwsem.h: * Based on asm-alpha/semaphore.h and asm-i386/rwsem.h
arch/alpha/include/asm/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline int __down_read_trylock(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline int __down_write_trylock(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline void rwsem_atomic_add(long val, struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline long rwsem_atomic_update(long val, struct rw_semaphore *sem)
arch/openrisc/mm/fault.c:bad_area_nosemaphore:
arch/openrisc/mm/fault.c:			goto bad_area_nosemaphore;
arch/openrisc/kernel/or32_ksyms.c:#include <linux/semaphore.h>
arch/microblaze/mm/fault.c:			goto bad_area_nosemaphore;
arch/microblaze/mm/fault.c:			goto bad_area_nosemaphore;
arch/microblaze/mm/fault.c:bad_area_nosemaphore:
arch/microblaze/include/uapi/asm/unistd.h:#define __NR_semtimedop		325 /* ok - semaphore group */
arch/microblaze/kernel/sys_microblaze.c:#include <linux/semaphore.h>
arch/mn10300/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/mn10300/include/asm/rwlock.h: * Helpers used by both rw spinlocks and rw semaphores.
arch/mn10300/include/asm/rwlock.h: * Based in part on code from semaphore.h and
arch/mips/mm/fault.c:		goto bad_area_nosemaphore;
arch/mips/mm/fault.c:bad_area_nosemaphore:
arch/mips/include/uapi/asm/errno.h:#define ENAVAIL		138	/* No XENIX semaphores available */
arch/mips/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/mips/include/asm/sgi/mc.h:	volatile u32 syssembit;		/* Uni-bit system semaphore */
arch/sh/mm/fault.c:__bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
arch/sh/mm/fault.c:bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
arch/sh/mm/fault.c:	__bad_area_nosemaphore(regs, error_code, address, SEGV_MAPERR);
arch/sh/mm/fault.c:	__bad_area_nosemaphore(regs, error_code, address, si_code);
arch/sh/mm/fault.c:		bad_area_nosemaphore(regs, error_code, address);
arch/sh/mm/fault.c:		bad_area_nosemaphore(regs, error_code, address);
arch/sh/include/asm/rwsem.h: * include/asm-sh/rwsem.h: R/W semaphores for SH using the stuff
arch/sh/include/asm/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
arch/sh/include/asm/rwsem.h:static inline int __down_read_trylock(struct rw_semaphore *sem)
arch/sh/include/asm/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
arch/sh/include/asm/rwsem.h:static inline int __down_write_trylock(struct rw_semaphore *sem)
arch/sh/include/asm/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
arch/sh/include/asm/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
arch/sh/include/asm/rwsem.h:static inline void rwsem_atomic_add(int delta, struct rw_semaphore *sem)
arch/sh/include/asm/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
arch/sh/include/asm/rwsem.h:static inline void __down_write_nested(struct rw_semaphore *sem, int subclass)
arch/sh/include/asm/rwsem.h:static inline int rwsem_atomic_update(int delta, struct rw_semaphore *sem)
arch/ia64/mm/fault.c:	 * is no vma for region 5 addr's anyway, so skip getting the semaphore
arch/ia64/mm/tlb.c: * Implement "spinaphores" ... like counting semaphores, but they
arch/ia64/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/ia64/include/asm/rwsem.h: * R/W semaphores for ia64
arch/ia64/include/asm/rwsem.h:__down_read (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__down_write (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__up_read (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__up_write (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__down_read_trylock (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__down_write_trylock (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__downgrade_write (struct rw_semaphore *sem)
arch/ia64/kernel/unaligned.c:			/* oops, really a semaphore op (cmpxchg, etc) */
arch/ia64/kernel/unaligned.c:			/* oops, really a semaphore op (cmpxchg, etc) */
arch/ia64/kernel/unaligned.c:			/* oops, really a semaphore op (cmpxchg, etc) */
arch/ia64/kernel/salinfo.c: *   Replace the counting semaphore with a mutex and a test if the cpumask is non-empty.
arch/ia64/kernel/salinfo.c:#include <linux/semaphore.h>
arch/ia64/kernel/salinfo.c:	struct semaphore	mutex;
arch/ia64/kernel/perfmon.c:		 * init restart semaphore to locked
arch/ia64/kernel/perfmon.c:	/* can only be applied to current task, need to have the mm semaphore held when called */
arch/ia64/kernel/perfmon.c:	 * if blocking, then post the semaphore is PFM_CTX_MASKED, i.e.
arch/arm/lib/uaccess_with_memcpy.c:	/* the mmap semaphore is taken only if not in an atomic context */
arch/arm/mach-vexpress/spc.c:#include <linux/semaphore.h>
arch/arm/mach-vexpress/spc.c:	struct semaphore sem;
arch/arm/mach-omap2/control.c:	u32 sdrc_module_semaphore;
arch/arm/mach-omap2/control.c:	scratchpad_contents.sdrc_module_semaphore = 0x0;
arch/s390/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/s390/include/asm/kvm_host.h:	struct rw_semaphore maps_lock;
arch/s390/include/asm/rwsem.h: *  Based on asm-alpha/semaphore.h and asm-i386/rwsem.h
arch/s390/include/asm/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline int __down_read_trylock(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline void __down_write_nested(struct rw_semaphore *sem, int subclass)
arch/s390/include/asm/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline int __down_write_trylock(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline void rwsem_atomic_add(long delta, struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline long rwsem_atomic_update(long delta, struct rw_semaphore *sem)
arch/s390/oprofile/hwsampler.c:#include <linux/semaphore.h>
arch/sparc/mm/srmmu.c: * hammer, but a semaphore like system to make sure we only have N TLB
arch/sparc/mm/fault_32.c:bad_area_nosemaphore:
arch/sparc/mm/fault_32.c:				goto bad_area_nosemaphore;
arch/sparc/mm/fault_32.c:			goto bad_area_nosemaphore;
arch/sparc/include/uapi/asm/errno.h:#define	ENAVAIL		119	/* No XENIX semaphores available */
arch/sparc/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/sparc/include/asm/rwsem.h: * rwsem.h: R/W semaphores implemented using CAS
arch/sparc/include/asm/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
arch/sparc/include/asm/rwsem.h:static inline int __down_read_trylock(struct rw_semaphore *sem)
arch/sparc/include/asm/rwsem.h:static inline void __down_write_nested(struct rw_semaphore *sem, int subclass)
arch/sparc/include/asm/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
arch/sparc/include/asm/rwsem.h:static inline int __down_write_trylock(struct rw_semaphore *sem)
arch/sparc/include/asm/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
arch/sparc/include/asm/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
arch/sparc/include/asm/rwsem.h:static inline void rwsem_atomic_add(long delta, struct rw_semaphore *sem)
arch/sparc/include/asm/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
arch/sparc/include/asm/rwsem.h:static inline long rwsem_atomic_update(long delta, struct rw_semaphore *sem)
arch/sparc/kernel/process_32.c:	/* do_fork() grabs the parent semaphore, we must release it
CREDITS:D: shm fs, SYSV semaphores, af_unix
crypto/internal.h:extern struct rw_semaphore crypto_alg_sem;
Documentation/RCU/arrayRCU.txt:semaphore, message-queue, and shared-memory IDs to the data structure
Documentation/RCU/arrayRCU.txt:ids->sem semaphore.
Documentation/RCU/rcuref.txt:reader/writer spinlocks or semaphores are straightforward:
Documentation/RCU/whatisRCU.txt:o	Use some solid scheme (such as locks or semaphores) to
Documentation/RCU/checklist.txt:	Therefore, SRCU should be used in preference to rw_semaphore
Documentation/namespaces/compatibility-list.txt:   object inside the kernel. E.g. semaphore with IPCID or
Documentation/infiniband/core_locking.txt:  semaphores that could cause deadlock if a consumer calls back into
Documentation/vm/unevictable-lru.txt:mlock_vma_pages_range() downgrades the mmap semaphore to read mode before
Documentation/vm/unevictable-lru.txt:attempting to fault/allocate and mlock the pages and "upgrades" the semaphore
Documentation/vm/unevictable-lru.txt:     try_to_unmap_anon() attempts to acquire in read mode the mmap semaphore of
Documentation/vm/unevictable-lru.txt:     If the mmap semaphore cannot be acquired, we are not sure whether the page
Documentation/vm/unevictable-lru.txt:     mm_struct's mmap semaphore to mlock the page, returning SWAP_MLOCK if this
Documentation/vm/unevictable-lru.txt:	mmap semaphore of the associated mm_struct for read without blocking.
Documentation/vm/unevictable-lru.txt:	try_to_unmap_cluster() will retain the mmap semaphore for the scan;
Documentation/vm/unevictable-lru.txt:	Then, for each page in the cluster, if we're holding the mmap semaphore
Documentation/vm/unevictable-lru.txt:attempt to acquire the associated mmap semaphore, mlock the page via
Documentation/vm/unevictable-lru.txt:semaphore, it will return SWAP_AGAIN.  This will allow shrink_page_list() to
Documentation/vm/unevictable-lru.txt:successfully acquire the VMA's mmap semaphore for read and mlock the page.
Documentation/vm/unevictable-lru.txt:     acquire the VMA's mmap semaphore to test the flags and set PageMlocked.
Documentation/00-INDEX:percpu-rw-semaphore.txt
Documentation/00-INDEX:	- RCU based read-write semaphore optimized for locking for reading
Documentation/PCI/pci-error-recovery.txt:to complete; it can take semaphores, schedule, etc... everything but
Documentation/PCI/pci-error-recovery.txt:>>> *not* schedule or semaphore in this routine; the current powerpc
Documentation/memory-barriers.txt: (*) semaphores
Documentation/memory-barriers.txt: (*) R/W semaphores
Documentation/memory-barriers.txt:Locks and semaphores may not provide any guarantee of ordering on UP compiled
Documentation/memory-barriers.txt:Consider, for example, the R/W semaphore slow path.  Here a waiting process is
Documentation/memory-barriers.txt:queued on the semaphore, by virtue of it having a piece of its stack linked to
Documentation/memory-barriers.txt:the semaphore's list of waiting processes:
Documentation/memory-barriers.txt:	struct rw_semaphore {
Documentation/memory-barriers.txt: (3) clear the task pointer to tell the waiter it has been given the semaphore;
Documentation/memory-barriers.txt:Once it has queued itself and dropped the semaphore lock, the waiter does not
Documentation/memory-barriers.txt:This could be dealt with using the semaphore lock, but then the down_xxx()
Documentation/devices.txt:		179 = /dev/xsvc		High-speed shared-mem/semaphore service
Documentation/sysctl/kernel.txt:object: message, semaphore or shared memory respectively.
Documentation/usb/power-management.txt:autoresume -- the device semaphore (udev->dev.sem) will be held when a
Documentation/usb/power-management.txt:critical section).  Holding the device semaphore will block all
Documentation/security/Smack.txt:IPC objects, message queues, semaphore sets, and memory segments exist in flat
Documentation/security/keys.txt: (2) The key's semaphore.
Documentation/security/keys.txt:     The semaphore could be used to govern access to the payload and to control
Documentation/security/keys.txt:     RCU must be used when the semaphore isn't already held; if the semaphore
Documentation/security/keys.txt:     semaphore must still be used to serialise modifications to the key. The
Documentation/security/keys.txt:     payload just dereferenced if the key's semaphore is not held.
Documentation/security/keys.txt:     before a key is created (add key) or the key semaphore is taken (update or
Documentation/security/keys.txt:     The key will have its semaphore write-locked before this method is called,
Documentation/security/keys.txt:     data upon a key being revoked.  The caller will have the key semaphore
Documentation/security/keys.txt:     a deadlock against the key semaphore.
Documentation/security/keys.txt:     This method will be called with the key's semaphore read-locked. This will
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:  deadlocked on a semaphore or something similar.  In this case, when
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:       #5  0x1006a744 in __down (sem=0x507d241c) at semaphore.c:71
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:       #6  0x1006aa10 in __down_failed () at semaphore.c:157
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:       #5  0x1006a744 in __down (sem=0x507d241c) at semaphore.c:71
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:       #6  0x1006aa10 in __down_failed () at semaphore.c:157
Documentation/percpu-rw-semaphore.txt:Percpu rw semaphores
Documentation/percpu-rw-semaphore.txt:Percpu rw semaphores is a new read-write semaphore design that is
Documentation/percpu-rw-semaphore.txt:The problem with traditional read-write semaphores is that when multiple
Documentation/percpu-rw-semaphore.txt:cores take the lock for reading, the cache line containing the semaphore
Documentation/percpu-rw-semaphore.txt:The lock is declared with "struct percpu_rw_semaphore" type.
Documentation/sound/alsa/ALSA-Configuration.txt:    buggy_semaphore - Enable workaround for hardware with buggy
Documentation/sound/alsa/ALSA-Configuration.txt:		    semaphores (e.g. on some ASUS laptops)
Documentation/scsi/ChangeLog.ips:        4.80.14  - Take all semaphores off stack                    
Documentation/scsi/ChangeLog.lpfc:	  waiting on a semaphore and "modprobe -r lpfc" is not always
Documentation/scsi/ChangeLog.lpfc:	  semaphore for the interruptable sleep.
Documentation/scsi/ChangeLog.1992-1997:    option for no-multi lun scan.  Add semaphore for possible problems
Documentation/scsi/ChangeLog.1992-1997:    * sr.h: Add needs_sector_size semaphore.
Documentation/scsi/ChangeLog.1992-1997:    * scsi.c: Add lockable semaphore for removable devices that can have
Documentation/scsi/ChangeLog.1992-1997:    to lock door for devices that do not have lockable semaphore set.
Documentation/scsi/ChangeLog.sym53c8xx_2:	  semaphore in order to behave synchronously as required by the eh 
Documentation/networking/netdevices.txt:	Synchronization: rtnl_lock() semaphore.
Documentation/networking/netdevices.txt:	Synchronization: rtnl_lock() semaphore.
Documentation/networking/netdevices.txt:	Synchronization: rtnl_lock() semaphore.
Documentation/filesystems/cifs/CHANGES:creation and file open to such servers.  Fix semaphore conflict which causes 
Documentation/filesystems/coda.txt:  object in NT and a semaphore in Windows 95.
Documentation/filesystems/xfs-delayed-logging-design.txt:time will tell if using a read-write semaphore for exclusion will limit
Documentation/filesystems/vfs.txt:	This method is called with the directory inode semaphore held
Documentation/filesystems/fuse.txt: |    [acquire inode semaphore        |
Documentation/filesystems/fuse.txt: |                                    |    [acquire inode semaphore
Documentation/ia64/err_inject.txt:	/* clear old semaphore */
Documentation/ia64/err_inject.txt:	/* get one semaphore */
Documentation/ia64/err_inject.txt:		printf("Please remove semaphore with key=0x%lx, then run the tool.\n",
Documentation/ia64/err_inject.txt:	/* initialize the semaphore to 1: */
Documentation/ia64/err_inject.txt:	/* Create semaphore: If one_lock, one semaphore for all processors.
Documentation/ia64/err_inject.txt:	   Otherwise, one semaphore for each processor. */
Documentation/ia64/err_inject.txt:			printf("Can not create semaphore...exit\n");
Documentation/ia64/err_inject.txt:			printf("Can not create semaphore for cpu%d...exit\n",i);
Documentation/kernel-docs.txt:       Keywords: locks, locking, spinlock, semaphore, atomic, race
Documentation/mutex-design.txt:behave similarly to binary semaphores, and were introduced in 2006[1]
Documentation/mutex-design.txt:number of workloads. Note that this technique is also used for rw-semaphores.
Documentation/mutex-design.txt:as large as 'struct semaphore' (24 bytes) and 8 bytes shy of the
Documentation/mutex-design.txt:'struct rw_semaphore' variant. Larger structure sizes mean more CPU
Documentation/kprobes.txt:non-recursive and can never relinquish the CPU (e.g., via a semaphore
Documentation/kprobes.txt:a semaphore).
Documentation/DocBook/kernel-locking.tmpl:      <type>rwlock_t</type> and <structname>struct rw_semaphore</structname>.
Documentation/DocBook/filesystems.tmpl:were semaphores and include them in your semaphore ordering rules to prevent
Documentation/DocBook/writing-an-alsa-driver.tmpl:      or semaphores.  In general, if a race condition can happen
Documentation/DocBook/writing-an-alsa-driver.tmpl:      should use mutexes or semaphores instead.
Documentation/serial/driver:There are three locks.  A per-port spinlock, a per-port tmpbuf semaphore,
Documentation/serial/driver:and an overall semaphore.
Documentation/serial/driver:The port_sem semaphore is used to protect against ports being added/
Documentation/serial/tty.txt:			termios semaphore so allowed to sleep. Serialized
Documentation/serial/tty.txt:			itself by a semaphore. May sleep.
drivers/parport/ieee1284.c:		   semaphore. */
drivers/gpu/host1x/cdma.h:#include <linux/semaphore.h>
drivers/gpu/host1x/cdma.h:	struct semaphore sem;		/* signalled when event occurs */
drivers/gpu/drm/gma500/gtt.h:	struct rw_semaphore sem;
drivers/gpu/drm/gma500/mmu.c:	   since we have the semaphore in write mode. */
drivers/gpu/drm/gma500/mmu.h:	struct rw_semaphore sem;
drivers/gpu/drm/vmwgfx/vmwgfx_drv.h:	struct rw_semaphore rwsem;
drivers/gpu/drm/i915/i915_dma.c:		value = i915_semaphore_is_enabled(dev);
drivers/gpu/drm/i915/intel_ringbuffer.h:	} semaphore;
drivers/gpu/drm/i915/i915_irq.c:ipehr_is_semaphore_wait(struct drm_device *dev, u32 ipehr)
drivers/gpu/drm/i915/i915_irq.c:		 * FIXME: gen8 semaphore support - currently we don't emit
drivers/gpu/drm/i915/i915_irq.c:		 * semaphores on bdw anyway, but this needs to be addressed when
drivers/gpu/drm/i915/i915_irq.c:semaphore_wait_to_signaller_ring(struct intel_engine_cs *ring, u32 ipehr)
drivers/gpu/drm/i915/i915_irq.c:		 * FIXME: gen8 semaphore support - currently we don't emit
drivers/gpu/drm/i915/i915_irq.c:		 * semaphores on bdw anyway, but this needs to be addressed when
drivers/gpu/drm/i915/i915_irq.c:			if (sync_bits == signaller->semaphore.mbox.wait[ring->id])
drivers/gpu/drm/i915/i915_irq.c:semaphore_waits_for(struct intel_engine_cs *ring, u32 *seqno)
drivers/gpu/drm/i915/i915_irq.c:	if (!ipehr_is_semaphore_wait(ring->dev, ipehr))
drivers/gpu/drm/i915/i915_irq.c:	 * point at at batch, and semaphores are always emitted into the
drivers/gpu/drm/i915/i915_irq.c:	return semaphore_wait_to_signaller_ring(ring, ipehr);
drivers/gpu/drm/i915/i915_irq.c:static int semaphore_passed(struct intel_engine_cs *ring)
drivers/gpu/drm/i915/i915_irq.c:	signaller = semaphore_waits_for(ring, &seqno);
drivers/gpu/drm/i915/i915_irq.c:	    semaphore_passed(signaller) < 0)
drivers/gpu/drm/i915/i915_irq.c:static void semaphore_clear_deadlocks(struct drm_i915_private *dev_priv)
drivers/gpu/drm/i915/i915_irq.c:		switch (semaphore_passed(ring)) {
drivers/gpu/drm/i915/i915_irq.c:					  "Kicking stuck semaphore on %s",
drivers/gpu/drm/i915/i915_irq.c:		semaphore_clear_deadlocks(dev_priv);
drivers/gpu/drm/i915/i915_drv.h:		u32 semaphore_seqno[I915_NUM_RINGS - 1];
drivers/gpu/drm/i915/i915_drv.h:		u32 semaphore_mboxes[I915_NUM_RINGS - 1];
drivers/gpu/drm/i915/i915_drv.h:	 * replaced with a semaphore.  It also needs to be
drivers/gpu/drm/i915/i915_drv.h:	int semaphores;
drivers/gpu/drm/i915/i915_drv.h:extern bool i915_semaphore_is_enabled(struct drm_device *dev);
drivers/gpu/drm/i915/i915_gem.c:		for (j = 0; j < ARRAY_SIZE(ring->semaphore.sync_seqno); j++)
drivers/gpu/drm/i915/i915_gem.c:			ring->semaphore.sync_seqno[j] = 0;
drivers/gpu/drm/i915/i915_gem.c:	if (to == NULL || !i915_semaphore_is_enabled(obj->base.dev))
drivers/gpu/drm/i915/i915_gem.c:	if (seqno <= from->semaphore.sync_seqno[idx])
drivers/gpu/drm/i915/i915_gem.c:	ret = to->semaphore.sync_to(to, from, seqno);
drivers/gpu/drm/i915/i915_gem.c:		from->semaphore.sync_seqno[idx] = obj->last_read_seqno;
drivers/gpu/drm/i915/i915_gem.c:	 * We need to replace this with a semaphore, or something.
drivers/gpu/drm/i915/i915_gpu_error.c:			   ring->semaphore_mboxes[0],
drivers/gpu/drm/i915/i915_gpu_error.c:			   ring->semaphore_seqno[0]);
drivers/gpu/drm/i915/i915_gpu_error.c:			   ring->semaphore_mboxes[1],
drivers/gpu/drm/i915/i915_gpu_error.c:			   ring->semaphore_seqno[1]);
drivers/gpu/drm/i915/i915_gpu_error.c:				   ring->semaphore_mboxes[2],
drivers/gpu/drm/i915/i915_gpu_error.c:				   ring->semaphore_seqno[2]);
drivers/gpu/drm/i915/i915_gpu_error.c:		ering->semaphore_mboxes[0]
drivers/gpu/drm/i915/i915_gpu_error.c:		ering->semaphore_mboxes[1]
drivers/gpu/drm/i915/i915_gpu_error.c:		ering->semaphore_seqno[0] = ring->semaphore.sync_seqno[0];
drivers/gpu/drm/i915/i915_gpu_error.c:		ering->semaphore_seqno[1] = ring->semaphore.sync_seqno[1];
drivers/gpu/drm/i915/i915_gpu_error.c:		ering->semaphore_mboxes[2] =
drivers/gpu/drm/i915/i915_gpu_error.c:		ering->semaphore_seqno[2] = ring->semaphore.sync_seqno[2];
drivers/gpu/drm/i915/i915_drv.c:bool i915_semaphore_is_enabled(struct drm_device *dev)
drivers/gpu/drm/i915/i915_drv.c:	if (i915.semaphores >= 0)
drivers/gpu/drm/i915/i915_drv.c:		return i915.semaphores;
drivers/gpu/drm/i915/i915_drv.c:	/* Enable semaphores on SNB when IO remapping is off */
drivers/gpu/drm/i915/intel_ringbuffer.c:	/* NB: In order to be able to do semaphore MBOX updates for varying
drivers/gpu/drm/i915/intel_ringbuffer.c:	if (i915_semaphore_is_enabled(dev))
drivers/gpu/drm/i915/intel_ringbuffer.c:		u32 mbox_reg = signaller->semaphore.mbox.signal[i];
drivers/gpu/drm/i915/intel_ringbuffer.c: * gen6_add_request - Update the semaphore mailbox registers
drivers/gpu/drm/i915/intel_ringbuffer.c: * This acts like a signal in the canonical semaphore.
drivers/gpu/drm/i915/intel_ringbuffer.c:	ret = ring->semaphore.signal(ring, 4);
drivers/gpu/drm/i915/intel_ringbuffer.c:	u32 wait_mbox = signaller->semaphore.mbox.wait[waiter->id];
drivers/gpu/drm/i915/intel_ringbuffer.c:	memset(ring->semaphore.sync_seqno, 0, sizeof(ring->semaphore.sync_seqno));
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.sync_to = gen6_ring_sync;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.signal = gen6_signal;
drivers/gpu/drm/i915/intel_ringbuffer.c:		 * The current semaphore is only applied on pre-gen8 platform.
drivers/gpu/drm/i915/intel_ringbuffer.c:		 * semaphore between RCS and VCS2 is initialized as INVALID.
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.wait[RCS] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.wait[VCS] = MI_SEMAPHORE_SYNC_RV;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.wait[BCS] = MI_SEMAPHORE_SYNC_RB;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.wait[VECS] = MI_SEMAPHORE_SYNC_RVE;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.wait[VCS2] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.signal[RCS] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.signal[VCS] = GEN6_VRSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.signal[BCS] = GEN6_BRSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.signal[VECS] = GEN6_VERSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.signal[VCS2] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.sync_to = gen6_ring_sync;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.signal = gen6_signal;
drivers/gpu/drm/i915/intel_ringbuffer.c:		 * The current semaphore is only applied on pre-gen8 platform.
drivers/gpu/drm/i915/intel_ringbuffer.c:		 * semaphore between VCS and VCS2 is initialized as INVALID.
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.wait[RCS] = MI_SEMAPHORE_SYNC_VR;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.wait[VCS] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.wait[BCS] = MI_SEMAPHORE_SYNC_VB;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.wait[VECS] = MI_SEMAPHORE_SYNC_VVE;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.wait[VCS2] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.signal[RCS] = GEN6_RVSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.signal[VCS] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.signal[BCS] = GEN6_BVSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.signal[VECS] = GEN6_VEVSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:		ring->semaphore.mbox.signal[VCS2] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.sync_to = gen6_ring_sync;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.signal = gen6_signal;
drivers/gpu/drm/i915/intel_ringbuffer.c:	 * The current semaphore is only applied on the pre-gen8. And there
drivers/gpu/drm/i915/intel_ringbuffer.c:	 * is no bsd2 ring on the pre-gen8. So now the semaphore_register
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[RCS] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[VCS] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[BCS] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[VECS] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[VCS2] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[RCS] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[VCS] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[BCS] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[VECS] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[VCS2] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.sync_to = gen6_ring_sync;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.signal = gen6_signal;
drivers/gpu/drm/i915/intel_ringbuffer.c:	 * The current semaphore is only applied on pre-gen8 platform. And
drivers/gpu/drm/i915/intel_ringbuffer.c:	 * there is no VCS2 ring on the pre-gen8 platform. So the semaphore
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[RCS] = MI_SEMAPHORE_SYNC_BR;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[VCS] = MI_SEMAPHORE_SYNC_BV;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[BCS] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[VECS] = MI_SEMAPHORE_SYNC_BVE;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[VCS2] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[RCS] = GEN6_RBSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[VCS] = GEN6_VBSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[BCS] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[VECS] = GEN6_VEBSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[VCS2] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.sync_to = gen6_ring_sync;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.signal = gen6_signal;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[RCS] = MI_SEMAPHORE_SYNC_VER;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[VCS] = MI_SEMAPHORE_SYNC_VEV;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[BCS] = MI_SEMAPHORE_SYNC_VEB;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[VECS] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.wait[VCS2] = MI_SEMAPHORE_SYNC_INVALID;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[RCS] = GEN6_RVESYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[VCS] = GEN6_VVESYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[BCS] = GEN6_BVESYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[VECS] = GEN6_NOSYNC;
drivers/gpu/drm/i915/intel_ringbuffer.c:	ring->semaphore.mbox.signal[VCS2] = GEN6_NOSYNC;
drivers/gpu/drm/i915/i915_params.c:	.semaphores = -1,
drivers/gpu/drm/i915/i915_params.c:module_param_named(semaphores, i915.semaphores, int, 0400);
drivers/gpu/drm/i915/i915_params.c:MODULE_PARM_DESC(semaphores,
drivers/gpu/drm/i915/i915_params.c:	"Use semaphores for inter-ring sync "
drivers/gpu/drm/nouveau/nv50_display.c:	/* small shared memory area we use for notifiers and semaphores */
drivers/gpu/drm/nouveau/nv84_fence.c:	/* map display semaphore buffers into channel's vm */
drivers/gpu/drm/nouveau/nv50_fence.c:	/* dma objects for display sync channel semaphore blocks */
drivers/gpu/drm/udl/udl_drv.h:	struct semaphore limit_sem;
drivers/gpu/drm/radeon/uvd_v1_0.c: * uvd_v1_0_semaphore_emit - emit semaphore command
drivers/gpu/drm/radeon/uvd_v1_0.c: * @semaphore: semaphore to emit commands for
drivers/gpu/drm/radeon/uvd_v1_0.c: * Emit a semaphore command (either wait or signal) to the UVD ring.
drivers/gpu/drm/radeon/uvd_v1_0.c:bool uvd_v1_0_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/uvd_v1_0.c:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/uvd_v1_0.c:	uint64_t addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/radeon_fence.c: * radeon_fence_need_sync - do we need a semaphore
drivers/gpu/drm/radeon/radeon_fence.c: * (all asics).  If so, we need to emit a semaphore.
drivers/gpu/drm/radeon/r100.c:bool r100_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/r100.c:			      struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/r100.c:	/* Unused on older asics, since we don't have semaphores or multiple rings */
drivers/gpu/drm/radeon/radeon_asic.h:bool r100_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			      struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool r600_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			      struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool r600_dma_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:				  struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool cik_sdma_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:				  struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool cik_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool uvd_v1_0_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool uvd_v3_1_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_trace.h:DECLARE_EVENT_CLASS(radeon_semaphore_request,
drivers/gpu/drm/radeon/radeon_trace.h:	    TP_PROTO(int ring, struct radeon_semaphore *sem),
drivers/gpu/drm/radeon/radeon_trace.h:DEFINE_EVENT(radeon_semaphore_request, radeon_semaphore_signale,
drivers/gpu/drm/radeon/radeon_trace.h:	    TP_PROTO(int ring, struct radeon_semaphore *sem),
drivers/gpu/drm/radeon/radeon_trace.h:DEFINE_EVENT(radeon_semaphore_request, radeon_semaphore_wait,
drivers/gpu/drm/radeon/radeon_trace.h:	    TP_PROTO(int ring, struct radeon_semaphore *sem),
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r100_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r100_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_dma_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &uvd_v1_0_semaphore_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_dma_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_dma_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &uvd_v3_1_semaphore_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_dma_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &cik_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &cik_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &cik_sdma_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &radeon_vce_semaphore_emit,
drivers/gpu/drm/radeon/r600.c: * CP fences/semaphores
drivers/gpu/drm/radeon/r600.c:bool r600_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/r600.c:			      struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/r600.c:	uint64_t addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/r600.c:	struct radeon_semaphore *sem = NULL;
drivers/gpu/drm/radeon/r600.c:	r = radeon_semaphore_create(rdev, &sem);
drivers/gpu/drm/radeon/r600.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/r600.c:	radeon_semaphore_sync_to(sem, *fence);
drivers/gpu/drm/radeon/r600.c:	radeon_semaphore_sync_rings(rdev, sem, ring->idx);
drivers/gpu/drm/radeon/r600.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/r600.c:	radeon_semaphore_free(rdev, &sem, *fence);
drivers/gpu/drm/radeon/uvd_v3_1.c: * uvd_v3_1_semaphore_emit - emit semaphore command
drivers/gpu/drm/radeon/uvd_v3_1.c: * @semaphore: semaphore to emit commands for
drivers/gpu/drm/radeon/uvd_v3_1.c: * Emit a semaphore command (either wait or signal) to the UVD ring.
drivers/gpu/drm/radeon/uvd_v3_1.c:bool uvd_v3_1_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/uvd_v3_1.c:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/uvd_v3_1.c:	uint64_t addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/si_dma.c:	struct radeon_semaphore *sem = NULL;
drivers/gpu/drm/radeon/si_dma.c:	r = radeon_semaphore_create(rdev, &sem);
drivers/gpu/drm/radeon/si_dma.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/si_dma.c:	radeon_semaphore_sync_to(sem, *fence);
drivers/gpu/drm/radeon/si_dma.c:	radeon_semaphore_sync_rings(rdev, sem, ring->idx);
drivers/gpu/drm/radeon/si_dma.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/si_dma.c:	radeon_semaphore_free(rdev, &sem, *fence);
drivers/gpu/drm/radeon/evergreen_dma.c:	struct radeon_semaphore *sem = NULL;
drivers/gpu/drm/radeon/evergreen_dma.c:	r = radeon_semaphore_create(rdev, &sem);
drivers/gpu/drm/radeon/evergreen_dma.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/evergreen_dma.c:	radeon_semaphore_sync_to(sem, *fence);
drivers/gpu/drm/radeon/evergreen_dma.c:	radeon_semaphore_sync_rings(rdev, sem, ring->idx);
drivers/gpu/drm/radeon/evergreen_dma.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/evergreen_dma.c:	radeon_semaphore_free(rdev, &sem, *fence);
drivers/gpu/drm/radeon/r600_dma.c: * r600_dma_semaphore_ring_emit - emit a semaphore on the dma ring
drivers/gpu/drm/radeon/r600_dma.c: * @semaphore: radeon semaphore object
drivers/gpu/drm/radeon/r600_dma.c: * @emit_wait: wait or signal semaphore
drivers/gpu/drm/radeon/r600_dma.c: * Add a DMA semaphore packet to the ring wait on or signal
drivers/gpu/drm/radeon/r600_dma.c:bool r600_dma_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/r600_dma.c:				  struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/r600_dma.c:	u64 addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/r600_dma.c:	struct radeon_semaphore *sem = NULL;
drivers/gpu/drm/radeon/r600_dma.c:	r = radeon_semaphore_create(rdev, &sem);
drivers/gpu/drm/radeon/r600_dma.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/r600_dma.c:	radeon_semaphore_sync_to(sem, *fence);
drivers/gpu/drm/radeon/r600_dma.c:	radeon_semaphore_sync_rings(rdev, sem, ring->idx);
drivers/gpu/drm/radeon/r600_dma.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/r600_dma.c:	radeon_semaphore_free(rdev, &sem, *fence);
drivers/gpu/drm/radeon/Makefile:	atombios_encoders.o radeon_semaphore.o radeon_sa.o atombios_i2c.o si.o \
drivers/gpu/drm/radeon/radeon_vm.c:		radeon_semaphore_sync_to(ib.semaphore, pd->tbo.sync_obj);
drivers/gpu/drm/radeon/radeon_vm.c:		radeon_semaphore_sync_to(ib.semaphore, vm->last_id_use);
drivers/gpu/drm/radeon/radeon_vm.c:		radeon_semaphore_sync_to(ib->semaphore, pt->tbo.sync_obj);
drivers/gpu/drm/radeon/radeon_vm.c:	radeon_semaphore_sync_to(ib.semaphore, vm->fence);
drivers/gpu/drm/radeon/rv770_dma.c:	struct radeon_semaphore *sem = NULL;
drivers/gpu/drm/radeon/rv770_dma.c:	r = radeon_semaphore_create(rdev, &sem);
drivers/gpu/drm/radeon/rv770_dma.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/rv770_dma.c:	radeon_semaphore_sync_to(sem, *fence);
drivers/gpu/drm/radeon/rv770_dma.c:	radeon_semaphore_sync_rings(rdev, sem, ring->idx);
drivers/gpu/drm/radeon/rv770_dma.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/rv770_dma.c:	radeon_semaphore_free(rdev, &sem, *fence);
drivers/gpu/drm/radeon/cik_sdma.c: * cik_sdma_semaphore_ring_emit - emit a semaphore on the dma ring
drivers/gpu/drm/radeon/cik_sdma.c: * @semaphore: radeon semaphore object
drivers/gpu/drm/radeon/cik_sdma.c: * @emit_wait: wait or signal semaphore
drivers/gpu/drm/radeon/cik_sdma.c: * Add a DMA semaphore packet to the ring wait on or signal
drivers/gpu/drm/radeon/cik_sdma.c:bool cik_sdma_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/cik_sdma.c:				  struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/cik_sdma.c:	u64 addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/cik_sdma.c:	struct radeon_semaphore *sem = NULL;
drivers/gpu/drm/radeon/cik_sdma.c:	r = radeon_semaphore_create(rdev, &sem);
drivers/gpu/drm/radeon/cik_sdma.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/cik_sdma.c:	radeon_semaphore_sync_to(sem, *fence);
drivers/gpu/drm/radeon/cik_sdma.c:	radeon_semaphore_sync_rings(rdev, sem, ring->idx);
drivers/gpu/drm/radeon/cik_sdma.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/cik_sdma.c:	radeon_semaphore_free(rdev, &sem, *fence);
drivers/gpu/drm/radeon/radeon_semaphore.c:int radeon_semaphore_create(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_semaphore.c:			    struct radeon_semaphore **semaphore)
drivers/gpu/drm/radeon/radeon_semaphore.c:	*semaphore = kmalloc(sizeof(struct radeon_semaphore), GFP_KERNEL);
drivers/gpu/drm/radeon/radeon_semaphore.c:	if (*semaphore == NULL) {
drivers/gpu/drm/radeon/radeon_semaphore.c:	r = radeon_sa_bo_new(rdev, &rdev->ring_tmp_bo, &(*semaphore)->sa_bo,
drivers/gpu/drm/radeon/radeon_semaphore.c:		kfree(*semaphore);
drivers/gpu/drm/radeon/radeon_semaphore.c:		*semaphore = NULL;
drivers/gpu/drm/radeon/radeon_semaphore.c:	(*semaphore)->waiters = 0;
drivers/gpu/drm/radeon/radeon_semaphore.c:	(*semaphore)->gpu_addr = radeon_sa_bo_gpu_addr((*semaphore)->sa_bo);
drivers/gpu/drm/radeon/radeon_semaphore.c:	cpu_addr = radeon_sa_bo_cpu_addr((*semaphore)->sa_bo);
drivers/gpu/drm/radeon/radeon_semaphore.c:		(*semaphore)->sync_to[i] = NULL;
drivers/gpu/drm/radeon/radeon_semaphore.c:bool radeon_semaphore_emit_signal(struct radeon_device *rdev, int ridx,
drivers/gpu/drm/radeon/radeon_semaphore.c:			          struct radeon_semaphore *semaphore)
drivers/gpu/drm/radeon/radeon_semaphore.c:	trace_radeon_semaphore_signale(ridx, semaphore);
drivers/gpu/drm/radeon/radeon_semaphore.c:	if (radeon_semaphore_ring_emit(rdev, ridx, ring, semaphore, false)) {
drivers/gpu/drm/radeon/radeon_semaphore.c:		--semaphore->waiters;
drivers/gpu/drm/radeon/radeon_semaphore.c:		ring->last_semaphore_signal_addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/radeon_semaphore.c:bool radeon_semaphore_emit_wait(struct radeon_device *rdev, int ridx,
drivers/gpu/drm/radeon/radeon_semaphore.c:			        struct radeon_semaphore *semaphore)
drivers/gpu/drm/radeon/radeon_semaphore.c:	trace_radeon_semaphore_wait(ridx, semaphore);
drivers/gpu/drm/radeon/radeon_semaphore.c:	if (radeon_semaphore_ring_emit(rdev, ridx, ring, semaphore, true)) {
drivers/gpu/drm/radeon/radeon_semaphore.c:		++semaphore->waiters;
drivers/gpu/drm/radeon/radeon_semaphore.c:		ring->last_semaphore_wait_addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/radeon_semaphore.c: * radeon_semaphore_sync_to - use the semaphore to sync to a fence
drivers/gpu/drm/radeon/radeon_semaphore.c: * @semaphore: semaphore object to add fence to
drivers/gpu/drm/radeon/radeon_semaphore.c: * Sync to the fence using this semaphore object
drivers/gpu/drm/radeon/radeon_semaphore.c:void radeon_semaphore_sync_to(struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_semaphore.c:        other = semaphore->sync_to[fence->ring];
drivers/gpu/drm/radeon/radeon_semaphore.c:        semaphore->sync_to[fence->ring] = radeon_fence_later(fence, other);
drivers/gpu/drm/radeon/radeon_semaphore.c: * radeon_semaphore_sync_rings - sync ring to all registered fences
drivers/gpu/drm/radeon/radeon_semaphore.c: * @semaphore: semaphore object to use for sync
drivers/gpu/drm/radeon/radeon_semaphore.c:int radeon_semaphore_sync_rings(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_semaphore.c:				struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_semaphore.c:		struct radeon_fence *fence = semaphore->sync_to[i];
drivers/gpu/drm/radeon/radeon_semaphore.c:		/* emit the signal semaphore */
drivers/gpu/drm/radeon/radeon_semaphore.c:		if (!radeon_semaphore_emit_signal(rdev, i, semaphore)) {
drivers/gpu/drm/radeon/radeon_semaphore.c:		if (!radeon_semaphore_emit_wait(rdev, ring, semaphore)) {
drivers/gpu/drm/radeon/radeon_semaphore.c:		semaphore->gpu_addr += 8;
drivers/gpu/drm/radeon/radeon_semaphore.c:void radeon_semaphore_free(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_semaphore.c:			   struct radeon_semaphore **semaphore,
drivers/gpu/drm/radeon/radeon_semaphore.c:	if (semaphore == NULL || *semaphore == NULL) {
drivers/gpu/drm/radeon/radeon_semaphore.c:	if ((*semaphore)->waiters > 0) {
drivers/gpu/drm/radeon/radeon_semaphore.c:		dev_err(rdev->dev, "semaphore %p has more waiters than signalers,"
drivers/gpu/drm/radeon/radeon_semaphore.c:			" hardware lockup imminent!\n", *semaphore);
drivers/gpu/drm/radeon/radeon_semaphore.c:	radeon_sa_bo_free(rdev, &(*semaphore)->sa_bo, fence);
drivers/gpu/drm/radeon/radeon_semaphore.c:	kfree(*semaphore);
drivers/gpu/drm/radeon/radeon_semaphore.c:	*semaphore = NULL;
drivers/gpu/drm/radeon/radeon_vce.c: * radeon_vce_semaphore_emit - emit a semaphore command
drivers/gpu/drm/radeon/radeon_vce.c: * @semaphore: address of semaphore
drivers/gpu/drm/radeon/radeon_vce.c:bool radeon_vce_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_vce.c:			       struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_vce.c:	uint64_t addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/radeon_ring.c:	r = radeon_semaphore_create(rdev, &ib->semaphore);
drivers/gpu/drm/radeon/radeon_ring.c:	radeon_semaphore_free(rdev, &ib->semaphore, ib->fence);
drivers/gpu/drm/radeon/radeon_ring.c:        	radeon_semaphore_sync_to(ib->semaphore, vm_id_fence);
drivers/gpu/drm/radeon/radeon_ring.c:	r = radeon_semaphore_sync_rings(rdev, ib->semaphore, ib->ring);
drivers/gpu/drm/radeon/radeon_ring.c:		radeon_semaphore_free(rdev, &const_ib->semaphore, NULL);
drivers/gpu/drm/radeon/radeon_ring.c:	seq_printf(m, "last semaphore signal addr : 0x%016llx\n",
drivers/gpu/drm/radeon/radeon_ring.c:		   ring->last_semaphore_signal_addr);
drivers/gpu/drm/radeon/radeon_ring.c:	seq_printf(m, "last semaphore wait addr   : 0x%016llx\n",
drivers/gpu/drm/radeon/radeon_ring.c:		   ring->last_semaphore_wait_addr);
drivers/gpu/drm/radeon/radeon.h: * like the indirect buffer or semaphore, which both have their
drivers/gpu/drm/radeon/radeon.h:struct radeon_semaphore {
drivers/gpu/drm/radeon/radeon.h:int radeon_semaphore_create(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon.h:			    struct radeon_semaphore **semaphore);
drivers/gpu/drm/radeon/radeon.h:bool radeon_semaphore_emit_signal(struct radeon_device *rdev, int ring,
drivers/gpu/drm/radeon/radeon.h:				  struct radeon_semaphore *semaphore);
drivers/gpu/drm/radeon/radeon.h:bool radeon_semaphore_emit_wait(struct radeon_device *rdev, int ring,
drivers/gpu/drm/radeon/radeon.h:				struct radeon_semaphore *semaphore);
drivers/gpu/drm/radeon/radeon.h:void radeon_semaphore_sync_to(struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon.h:int radeon_semaphore_sync_rings(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon.h:				struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon.h:void radeon_semaphore_free(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon.h:			   struct radeon_semaphore **semaphore,
drivers/gpu/drm/radeon/radeon.h:	struct radeon_semaphore		*semaphore;
drivers/gpu/drm/radeon/radeon.h:	u64			last_semaphore_signal_addr;
drivers/gpu/drm/radeon/radeon.h:	u64			last_semaphore_wait_addr;
drivers/gpu/drm/radeon/radeon.h:	struct rw_semaphore	mclk_lock;
drivers/gpu/drm/radeon/radeon.h:bool radeon_vce_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon.h:			       struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon.h:	bool (*emit_semaphore)(struct radeon_device *rdev, struct radeon_ring *cp,
drivers/gpu/drm/radeon/radeon.h:			       struct radeon_semaphore *semaphore, bool emit_wait);
drivers/gpu/drm/radeon/radeon.h:	struct rw_semaphore		exclusive_lock;
drivers/gpu/drm/radeon/radeon.h:#define radeon_semaphore_ring_emit(rdev, r, cp, semaphore, emit_wait) (rdev)->asic->ring[(r)]->emit_semaphore((rdev), (cp), (semaphore), (emit_wait))
drivers/gpu/drm/radeon/radeon_test.c:	struct radeon_semaphore *semaphore = NULL;
drivers/gpu/drm/radeon/radeon_test.c:	r = radeon_semaphore_create(rdev, &semaphore);
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Failed to create semaphore\n");
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_wait(rdev, ringA->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_wait(rdev, ringA->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Fence 1 signaled without waiting for semaphore.\n");
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_signal(rdev, ringB->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Fence 2 signaled without waiting for semaphore.\n");
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_signal(rdev, ringB->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_free(rdev, &semaphore, NULL);
drivers/gpu/drm/radeon/radeon_test.c:	struct radeon_semaphore *semaphore = NULL;
drivers/gpu/drm/radeon/radeon_test.c:	r = radeon_semaphore_create(rdev, &semaphore);
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Failed to create semaphore\n");
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_wait(rdev, ringA->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_wait(rdev, ringB->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Fence A signaled without waiting for semaphore.\n");
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Fence B signaled without waiting for semaphore.\n");
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_signal(rdev, ringC->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_signal(rdev, ringC->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_free(rdev, &semaphore, NULL);
drivers/gpu/drm/radeon/radeon_cs.c:		radeon_semaphore_sync_to(p->ib.semaphore,
drivers/gpu/drm/radeon/radeon_cs.c:	p->ib.semaphore = NULL;
drivers/gpu/drm/radeon/radeon_cs.c:	p->const_ib.semaphore = NULL;
drivers/gpu/drm/radeon/radeon_cs.c:	radeon_semaphore_sync_to(parser->ib.semaphore, vm->fence);
drivers/gpu/drm/radeon/cik.c:bool cik_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/cik.c:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/cik.c:	uint64_t addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/cik.c:	struct radeon_semaphore *sem = NULL;
drivers/gpu/drm/radeon/cik.c:	r = radeon_semaphore_create(rdev, &sem);
drivers/gpu/drm/radeon/cik.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/cik.c:	radeon_semaphore_sync_to(sem, *fence);
drivers/gpu/drm/radeon/cik.c:	radeon_semaphore_sync_rings(rdev, sem, ring->idx);
drivers/gpu/drm/radeon/cik.c:		radeon_semaphore_free(rdev, &sem, NULL);
drivers/gpu/drm/radeon/cik.c:	radeon_semaphore_free(rdev, &sem, *fence);
drivers/mmc/card/queue.h:	struct semaphore	thread_sem;
drivers/md/persistent-data/dm-block-manager.c: * This is a read/write semaphore with a couple of differences.
drivers/md/dm-region-hash.c:	struct semaphore recovery_count;
drivers/md/bcache/bcache.h:	struct semaphore	sb_write_mutex;
drivers/md/bcache/bcache.h:	struct rw_semaphore	writeback_lock;
drivers/md/bcache/bcache.h:	struct semaphore	in_flight;
drivers/md/bcache/bcache.h:	struct semaphore	sb_write_mutex;
drivers/md/bcache/bcache.h:	struct semaphore	moving_in_flight;
drivers/md/bcache/bcache.h:	struct semaphore	uuid_write_mutex;
drivers/md/bcache/btree.h:	struct rw_semaphore	lock;
drivers/md/bcache/btree.h:	struct semaphore	io_mutex;
drivers/md/dm-thin-metadata.c:	struct rw_semaphore root_lock;
drivers/md/dm-snap.c:	struct rw_semaphore lock;
drivers/md/dm-snap.c:static struct rw_semaphore _origins_lock;
drivers/md/dm-cache-metadata.c:	struct rw_semaphore root_lock;
drivers/infiniband/core/user_mad.c:#include <linux/semaphore.h>
drivers/infiniband/core/user_mad.c:	struct semaphore       sm_sem;
drivers/infiniband/hw/qib/qib_eeprom.c:	/* Grab semaphore and read current EEPROM. If we get an
drivers/infiniband/hw/mlx5/mlx5_ib.h:	struct semaphore	sem;
drivers/infiniband/hw/ipath/ipath_eeprom.c:	/* Grab semaphore and read current EEPROM. If we get an
drivers/infiniband/hw/mthca/mthca_mcg.c: * Caller must hold MCG table semaphore.  gid and mgm parameters must
drivers/infiniband/hw/mthca/mthca_dev.h:#include <linux/semaphore.h>
drivers/infiniband/hw/mthca/mthca_dev.h:	struct semaphore 	  poll_sem;
drivers/infiniband/hw/mthca/mthca_dev.h:	struct semaphore 	  event_sem;
drivers/infiniband/ulp/isert/ib_isert.c:#include <linux/semaphore.h>
drivers/infiniband/ulp/isert/ib_isert.h:	struct semaphore	np_sem;
drivers/infiniband/ulp/ipoib/ipoib.h:	struct rw_semaphore vlan_rwsem;
drivers/mtd/ubi/ubi.h:	struct rw_semaphore mutex;
drivers/mtd/ubi/ubi.h:	struct rw_semaphore fm_sem;
drivers/mtd/ubi/ubi.h:	struct rw_semaphore work_sem;
drivers/message/fusion/mptctl.c: *	mptctl_syscall_down - Down the MPT adapter syscall semaphore.
drivers/misc/genwqe/card_base.h:#include <linux/semaphore.h>
drivers/misc/sgi-gru/grutables.h:	struct rw_semaphore	bs_kgts_sema;		/* lock for kgts */
drivers/pci/pci.h:extern struct rw_semaphore pci_bus_sem;
drivers/pci/hotplug/ibmphp_hpc.c:#include <linux/semaphore.h>
drivers/pci/hotplug/ibmphp_hpc.c:static struct semaphore semOperations;	// lock all operations and
drivers/pci/hotplug/ibmphp_hpc.c:static struct semaphore sem_exit;	// make sure polling thread goes away
drivers/pci/hotplug/ibmphp_hpc.c:* Action:  initialize semaphores and variables
drivers/pci/hotplug/ibmphp_hpc.c:		/* give up the hardware semaphore */
drivers/xen/xen-pciback/pciback_ops.c: * use of semaphores). This function is intended to be called from a work
drivers/xen/xenbus/xenbus_xs.c:	struct rw_semaphore watch_mutex;
drivers/hv/hv_fcopy.c:#include <linux/semaphore.h>
drivers/hv/hv_fcopy.c:	struct semaphore read_sema;
drivers/hv/hv_fcopy.c:	 * the thread blocked on the semaphore and we will use the opened
drivers/hv/hv_fcopy.c:	 * on the read semaphore.
drivers/hv/hv_fcopy.c:	 * Signal the semaphore as the device is
drivers/leds/leds.h:extern struct rw_semaphore leds_list_lock;
drivers/leds/leds-bd2802.c:	struct rw_semaphore		rwsem;
drivers/tty/vt/vt_ioctl.c: * semaphore.
drivers/tty/vt/vc_screen.c:		/* Finally, release the console semaphore while we push
drivers/tty/vt/vc_screen.c:		 * AKPM: Even though it's a semaphore, we should drop it because
drivers/tty/vt/vt.c: *	Caller must hold the console semaphore. Takes the termios rwsem and
drivers/tty/tty_ldsem.c: * Ldisc rw semaphore
drivers/tty/tty_ldsem.c: * The ldisc semaphore is semantically a rw_semaphore but which enforces
drivers/tty/tty_ldsem.c: *   1) Upper half of semaphore count is a wait count (differs from rwsem
drivers/tty/tty_ldsem.c:static inline long ldsem_atomic_update(long delta, struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:void __init_ldsem(struct ld_semaphore *sem, const char *name,
drivers/tty/tty_ldsem.c:	 * Make sure we are not reinitializing a held semaphore:
drivers/tty/tty_ldsem.c:static void __ldsem_wake_readers(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static inline int writer_trylock(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static void __ldsem_wake_writer(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static void __ldsem_wake(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static void ldsem_wake(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static struct ld_semaphore __sched *
drivers/tty/tty_ldsem.c:down_read_failed(struct ld_semaphore *sem, long count, long timeout)
drivers/tty/tty_ldsem.c:static struct ld_semaphore __sched *
drivers/tty/tty_ldsem.c:down_write_failed(struct ld_semaphore *sem, long count, long timeout)
drivers/tty/tty_ldsem.c:static inline int __ldsem_down_read_nested(struct ld_semaphore *sem,
drivers/tty/tty_ldsem.c:static inline int __ldsem_down_write_nested(struct ld_semaphore *sem,
drivers/tty/tty_ldsem.c:int __sched ldsem_down_read(struct ld_semaphore *sem, long timeout)
drivers/tty/tty_ldsem.c:int ldsem_down_read_trylock(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:int __sched ldsem_down_write(struct ld_semaphore *sem, long timeout)
drivers/tty/tty_ldsem.c:int ldsem_down_write_trylock(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:void ldsem_up_read(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:void ldsem_up_write(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:int ldsem_down_read_nested(struct ld_semaphore *sem, int subclass, long timeout)
drivers/tty/tty_ldsem.c:int ldsem_down_write_nested(struct ld_semaphore *sem, int subclass,
drivers/tty/tty_mutex.c:#include <linux/semaphore.h>
drivers/tty/rocket.c: * rp_write() and rp_write_char() functions use a per port semaphore to protect against
drivers/tty/serial/serial_core.c: * uart_shutdown are serialised by the per-port semaphore.
drivers/tty/serial/serial_core.c:	 * This semaphore protects port->count.  It is also
drivers/tty/serial/serial_core.c:	 * port configuration semaphore to make sure that a
drivers/tty/serial/serial_core.c:	 * Take the per-port semaphore.  This prevents count from
drivers/tty/serial/serial_core.c:	 * We take the semaphore here to guarantee that we won't be re-entered
drivers/tty/serial/ioc4_serial.c:	 * Getting interrupted here is okay.  It'll just v() our semaphore, and
drivers/atm/ambassador.c:  use a semaphore.
drivers/atm/ambassador.c:      // semaphore for txer/rxer modifications - we cannot use a
drivers/video/fbdev/core/fbmem.c: *	It must be called with the console semaphore held
drivers/video/fbdev/omap/hwa742.c:	struct semaphore	req_sema;
drivers/video/fbdev/smscufx.c:	struct semaphore limit_sem;
drivers/video/fbdev/matrox/matroxfb_base.h:	struct rw_semaphore	lock;
drivers/video/fbdev/matrox/matroxfb_base.h:	struct rw_semaphore	lock;
drivers/video/fbdev/omap2/omapfb/omapfb.h:	struct rw_semaphore lock;
drivers/video/fbdev/omap2/dss/dsi.c:#include <linux/semaphore.h>
drivers/video/fbdev/omap2/dss/dsi.c:	struct semaphore bus_lock;
drivers/video/fbdev/omap2/dss/rfbi.c:#include <linux/semaphore.h>
drivers/video/fbdev/omap2/dss/rfbi.c:	struct semaphore bus_lock;
drivers/video/fbdev/aty/radeonfb.h: * by a semaphore (currently the console semaphore) so that no conflict
drivers/media/parport/c-qcam.c:	/* Probably should have a semaphore against multiple users */
drivers/media/pci/cx18/cx18-scb.h:	u32 semaphores[8];  /* Semaphores */
drivers/media/pci/ngene/ngene.h:	struct semaphore reslock;
drivers/media/pci/ngene/ngene.h:	struct semaphore      cmd_mutex;
drivers/media/pci/ngene/ngene.h:	struct semaphore      stream_mutex;
drivers/media/pci/ngene/ngene.h:	struct semaphore      pll_mutex;
drivers/media/pci/ngene/ngene.h:	struct semaphore      i2c_switch_mutex;
drivers/media/platform/davinci/vpif_display.c:				 * done and unlock semaphore on it */
drivers/media/dvb-frontends/bcm3510.c:/* not needed, we use a semaphore to prevent HAB races */
drivers/media/firewire/firedtv-ci.c:	/* Do we need a semaphore for this? */
drivers/media/radio/radio-si476x.c: * @core_lock: An r/w semaphore to brebvent the deletion of underlying
drivers/media/usb/em28xx/em28xx-dvb.c:	struct semaphore      pll_mutex;
drivers/media/usb/em28xx/em28xx-dvb.c:		/* FIXME: do we need a pll semaphore? */
drivers/media/usb/em28xx/em28xx-dvb.c:		/* FIXME: do we need a pll semaphore? */
drivers/media/usb/tlg2300/pd-common.h:#include <linux/semaphore.h>
drivers/media/usb/dvb-usb/dvb-usb.h: * @usb_mutex: semaphore of USB control messages (reading needs two messages)
drivers/media/usb/dvb-usb/dvb-usb.h: * @i2c_mutex: semaphore for i2c-transfers
drivers/media/dvb-core/dvb_frontend.c:#include <linux/semaphore.h>
drivers/media/dvb-core/dvb_frontend.c:	struct semaphore sem;
drivers/media/v4l2-core/videobuf2-core.c:	struct rw_semaphore *mmap_sem;
drivers/media/v4l2-core/videobuf2-core.c:		 * the mmap semaphore for read access in the current process
drivers/media/v4l2-core/videobuf2-core.c:		 * structure. The same semaphore is taken before calling mmap
drivers/base/dd.c: * Should somehow figure out how to use a semaphore, not an atomic variable...
drivers/staging/vt6655/device.h:	struct semaphore	mlme_semaphore;
drivers/staging/android/ion/ion.c:	struct rw_semaphore lock;
drivers/staging/android/ashmem.c:	 * semaphore and will be waiting for ashmem_mutex, there by leading to
drivers/staging/rtl8188eu/include/rtw_io.h:#include <linux/semaphore.h>
drivers/staging/rtl8188eu/include/rtw_io.h:	struct semaphore sema;
drivers/staging/rtl8188eu/include/rtw_event.h:#include <linux/semaphore.h>
drivers/staging/rtl8188eu/include/drv_types.h:	struct semaphore usb_suspend_sema;
drivers/staging/rtl8188eu/include/rtw_cmd.h:	struct semaphore cmd_queue_sema;
drivers/staging/rtl8188eu/include/rtw_cmd.h:	struct semaphore terminate_cmdthread_sema;
drivers/staging/rtl8188eu/include/rtw_pwrctrl.h:static inline void _init_pwrlock(struct semaphore  *plock)
drivers/staging/rtl8188eu/include/rtw_pwrctrl.h:static inline void _enter_pwrlock(struct semaphore  *plock)
drivers/staging/rtl8188eu/include/rtw_pwrctrl.h:static inline void _exit_pwrlock(struct semaphore  *plock)
drivers/staging/rtl8188eu/include/rtw_pwrctrl.h:	struct semaphore lock;
drivers/staging/rtl8188eu/include/rtw_mp.h:	struct semaphore MPh2c_Sema;
drivers/staging/rtl8188eu/include/osdep_intf.h:	struct semaphore  io_retevt;
drivers/staging/rtl8188eu/include/rtw_xmit.h:	struct semaphore xmit_sema;
drivers/staging/rtl8188eu/include/rtw_xmit.h:	struct semaphore terminate_xmitthread_sema;
drivers/staging/rtl8188eu/include/rtw_xmit.h:	struct semaphore tx_retevt;/* all tx return event; */
drivers/staging/rtl8188eu/include/osdep_service.h:#include <linux/semaphore.h>
drivers/staging/rtl8188eu/include/osdep_service.h:u32  _rtw_down_sema(struct semaphore *sema);
drivers/staging/rtl8188eu/os_dep/osdep_service.c:u32 _rtw_down_sema(struct semaphore *sema)
drivers/staging/cxt1e1/musycc.c:	/* no semaphore taken, no double checks */
drivers/staging/cxt1e1/musycc.h:#define SACK_IMAGE          0x00100000  /* Used in IRQ for semaphore test */
drivers/staging/cxt1e1/sbecom_inline_linux.h:     * NOOP - since semaphores structures predeclared w/in structures, no
drivers/staging/cxt1e1/pmcc4_private.h:#include <linux/semaphore.h>
drivers/staging/cxt1e1/pmcc4_private.h:    struct semaphore sr_sem_busy;       /* service request exclusion
drivers/staging/cxt1e1/pmcc4_private.h:                                         * semaphore */
drivers/staging/cxt1e1/pmcc4_private.h:    struct semaphore sr_sem_wait;       /* service request handshake
drivers/staging/cxt1e1/pmcc4_private.h:                                         * semaphore */
drivers/staging/cxt1e1/pmcc4_private.h:    struct semaphore sem_wdbusy;/* watchdog exclusion semaphore */
drivers/staging/cxt1e1/functions.c:	    sema_init((struct semaphore *) sem, 0);
drivers/staging/cxt1e1/functions.c:	    sema_init((struct semaphore *) sem, 1);
drivers/staging/unisys/include/timskmod.h:/** lock read/write semaphore for reading.
drivers/staging/unisys/include/timskmod.h:    Note that all read/write semaphores are of the "uninterruptible" variety.
drivers/staging/unisys/include/timskmod.h:    @param sem (rw_semaphore *) points to semaphore to lock
drivers/staging/unisys/include/timskmod.h:/** unlock read/write semaphore for reading.
drivers/staging/unisys/include/timskmod.h:    Note that all read/write semaphores are of the "uninterruptible" variety.
drivers/staging/unisys/include/timskmod.h:    @param sem (rw_semaphore *) points to semaphore to unlock
drivers/staging/unisys/include/timskmod.h:/** lock read/write semaphore for writing.
drivers/staging/unisys/include/timskmod.h:    Note that all read/write semaphores are of the "uninterruptible" variety.
drivers/staging/unisys/include/timskmod.h:    @param sem (rw_semaphore *) points to semaphore to lock
drivers/staging/unisys/include/timskmod.h:/** unlock read/write semaphore for writing.
drivers/staging/unisys/include/timskmod.h:    Note that all read/write semaphores are of the "uninterruptible" variety.
drivers/staging/unisys/include/timskmod.h:    @param sem (rw_semaphore *) points to semaphore to unlock
drivers/staging/unisys/include/uisqueue.h:#include <linux/semaphore.h>
drivers/staging/unisys/include/uisqueue.h:	struct semaphore interrupt_callback_lock;
drivers/staging/unisys/include/timskmodutils.h:	struct semaphore nQEntries;
drivers/staging/gdm724x/netlink_k.c:static struct semaphore netlink_mutex;
drivers/staging/silicom/bpctl_mod.c:static struct semaphore bpctl_sema;
drivers/staging/silicom/bpctl_mod.c:static void bp75_put_hw_semaphore_generic(struct bpctl_dev *pbpctl_dev)
drivers/staging/silicom/bpctl_mod.c:static s32 bp75_get_hw_semaphore_generic(struct bpctl_dev *pbpctl_dev)
drivers/staging/silicom/bpctl_mod.c:	/* Get the SW semaphore */
drivers/staging/silicom/bpctl_mod.c:	/* Get the FW semaphore. */
drivers/staging/silicom/bpctl_mod.c:		/* Release semaphores */
drivers/staging/silicom/bpctl_mod.c:		bp75_put_hw_semaphore_generic(pbpctl_dev);
drivers/staging/silicom/bpctl_mod.c:		ret_val = bp75_get_hw_semaphore_generic(pbpctl_dev);
drivers/staging/silicom/bpctl_mod.c:	bp75_put_hw_semaphore_generic(pbpctl_dev);
drivers/staging/silicom/bpctl_mod.c:		if (bp75_get_hw_semaphore_generic(pbpctl_dev)) {
drivers/staging/silicom/bpctl_mod.c:		bp75_put_hw_semaphore_generic(pbpctl_dev);
drivers/staging/silicom/bpctl_mod.c:	bp75_put_hw_semaphore_generic(pbpctl_dev);
drivers/staging/bcm/Misc.c:	 * if [ semaphore is available ]
drivers/staging/bcm/Misc.c:	 * if [ semaphore is available ]
drivers/staging/bcm/Adapter.h:	struct semaphore	RxAppControlQueuelock;
drivers/staging/bcm/Adapter.h:	struct semaphore	fw_download_sema;
drivers/staging/bcm/Adapter.h:	struct semaphore	rdmwrmsync;
drivers/staging/bcm/Adapter.h:	struct semaphore	NVMRdmWrmLock;
drivers/staging/bcm/Adapter.h:	struct semaphore	LowPowerModeSync;
drivers/staging/dgnc/dgnc_tty.c:	struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)
drivers/staging/dgnc/dgnc_tty.c:	 * control access to it with a semaphore.  If we are paging, we
drivers/staging/rtl8192e/rtllib.h:#include <linux/semaphore.h>
drivers/staging/rtl8192e/rtllib.h:	struct semaphore wx_sem;
drivers/staging/rtl8192e/rtllib.h:	struct semaphore scan_sem;
drivers/staging/rtl8192e/rtllib.h:	struct semaphore ips_sem;
drivers/staging/rtl8192e/rtl8192e/rtl_core.h:	struct semaphore			wx_sem;
drivers/staging/rtl8192e/rtl8192e/rtl_core.h:	struct semaphore			rf_sem;
drivers/staging/rtl8192e/rtllib_softmac.c:	 * on the semaphore
drivers/staging/sep/sep_dev.h:	struct semaphore sep_doublebuf;
drivers/staging/lustre/include/linux/libcfs/linux/linux-lock.h: * rw_semaphore "implementation" (use Linux kernel's primitives)
drivers/staging/lustre/include/linux/libcfs/linux/linux-lock.h: * semaphore "implementation" (use Linux kernel's primitives)
drivers/staging/lustre/include/linux/lnet/lib-types.h:	struct semaphore		ln_rc_signal;
drivers/staging/lustre/lustre/mdc/mdc_reint.c:/* mdc_setattr does its own semaphore handling */
drivers/staging/lustre/lustre/llite/lloop.c:	struct semaphore	lo_sem;
drivers/staging/lustre/lustre/llite/file.c:	struct rw_semaphore	ioc_sem;
drivers/staging/lustre/lustre/llite/llite_internal.h:			 * struct rw_semaphore {
drivers/staging/lustre/lustre/llite/llite_internal.h:			struct rw_semaphore		f_trunc_sem;
drivers/staging/lustre/lustre/llite/llite_internal.h:			struct rw_semaphore		f_glimpse_sem;
drivers/staging/lustre/lustre/llite/llite_internal.h:	struct rw_semaphore		lli_xattrs_list_rwsem;
drivers/staging/lustre/lustre/include/obd.h:	struct rw_semaphore  cl_sem;
drivers/staging/lustre/lustre/include/obd.h:	struct rw_semaphore op_rw_sem;     /* to protect ost_pool use */
drivers/staging/lustre/lustre/include/obd.h:	struct rw_semaphore lq_rw_sem;
drivers/staging/lustre/lustre/include/obd.h:	struct rw_semaphore     lov_notify_lock;
drivers/staging/lustre/lustre/include/obd.h:	/* a spinlock is OK for what we do now, may need a semaphore later */
drivers/staging/lustre/lustre/include/obd.h:	struct rw_semaphore	obd_observer_link_sem;
drivers/staging/lustre/lustre/include/lustre/lustre_errno.h:#define LUSTRE_ENAVAIL		119	/* No XENIX semaphores available */
drivers/staging/lustre/lustre/include/lustre_log.h:	struct rw_semaphore	 lgh_lock;
drivers/staging/lustre/lustre/include/linux/lvfs.h:/* We need to hold the inode semaphore over the dcache lookup itself, or we
drivers/staging/lustre/lustre/include/md_object.h:	struct rw_semaphore	mu_upcall_sem;
drivers/staging/lustre/lustre/mgc/mgc_request.c:	   semaphore to make the check non-racy. */
drivers/staging/lustre/lustre/ptlrpc/gss/gss_keyring.c: * - key/ctx binding is protected by key semaphore (if the key present)
drivers/staging/lustre/lustre/ptlrpc/gss/gss_keyring.c: * called with key semaphore write locked. it means we can operate
drivers/staging/lustre/lustre/lov/lov_cl_internal.h: * happens, lov_object::lo_type_guard semaphore is taken in exclusive mode,
drivers/staging/lustre/lustre/lov/lov_cl_internal.h: * constructed. All object methods take said semaphore in the shared mode,
drivers/staging/lustre/lustre/lov/lov_cl_internal.h:	 * This semaphore is taken in shared mode by all object methods, and
drivers/staging/lustre/lustre/lov/lov_cl_internal.h:	struct rw_semaphore	lo_type_guard;
drivers/staging/lustre/lustre/lov/lov_lock.c:		 * lck->lls_sub[i].sub_lock under semaphores, just before
drivers/staging/lustre/lustre/libcfs/module.c:static struct rw_semaphore ioctl_list_sem;
drivers/staging/lustre/lustre/libcfs/module.c:extern struct rw_semaphore cfs_tracefile_sem;
drivers/staging/lustre/lustre/libcfs/linux/linux-tracefile.c:struct rw_semaphore cfs_tracefile_sem;
drivers/staging/lustre/lustre/osc/osc_lock.c:		 * to take a semaphore on a parent lock. This is safe, because
drivers/staging/comedi/drivers/vmk80xx.c:	struct semaphore limit_sem;
drivers/staging/comedi/drivers/s626.h:						 * semaphores. */
drivers/staging/comedi/drivers/s626.h:#define S626_RPS_SIG0		0x00200000	/* RPS semaphore 0
drivers/staging/comedi/drivers/s626.h:#define S626_RPS_SIG1		0x00400000	/* RPS semaphore 1
drivers/staging/comedi/drivers/s626.h:#define S626_RPS_SIG2		0x00800000	/* RPS semaphore 2
drivers/staging/comedi/drivers/dt9812.c:	struct semaphore sem;
drivers/staging/comedi/drivers/usbduxsigma.c:	struct semaphore sem;
drivers/staging/comedi/drivers/quatech_daqp_cs.c:#include <linux/semaphore.h>
drivers/staging/comedi/drivers/quatech_daqp_cs.c:	enum { semaphore, buffer } interrupt_mode;
drivers/staging/comedi/drivers/quatech_daqp_cs.c:	devpriv->interrupt_mode = semaphore;
drivers/staging/comedi/drivers/quatech_daqp_cs.c: * 'semaphore', just signal the devpriv->eos completion and return
drivers/staging/comedi/drivers/quatech_daqp_cs.c:	case semaphore:
drivers/staging/comedi/drivers/quatech_daqp_cs.c:	devpriv->interrupt_mode = semaphore;
drivers/staging/comedi/drivers/usbduxfast.c:	struct semaphore sem;
drivers/staging/comedi/drivers/usbdux.c:	struct semaphore sem;
drivers/staging/comedi/comedi_fops.c:	This function isn't protected by the semaphore, since
drivers/staging/comedi/comedidev.h:	struct rw_semaphore attach_lock;
drivers/staging/rtl8192u/r8192U.h:	struct semaphore wx_sem;
drivers/staging/rtl8192u/r8192U.h:	struct semaphore rf_sem;	/* Used to lock rf write operation */
drivers/staging/rtl8192u/ieee80211/ieee80211.h:#include <linux/semaphore.h>
drivers/staging/rtl8192u/ieee80211/ieee80211.h:	struct semaphore wx_sem;
drivers/staging/rtl8192u/ieee80211/ieee80211.h:	struct semaphore scan_sem;
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:	 * on the semaphore
drivers/staging/speakup/main.c:/* Allocation concurrency is protected by the console semaphore */
drivers/staging/gdm72xx/netlink_k.c:static struct semaphore netlink_mutex;
drivers/staging/olpc_dcon/olpc_dcon.c:		 * messing with semaphores.
drivers/staging/tidspbridge/include/dspbridge/nodepriv.h: *      Get node information without holding semaphore.
drivers/staging/tidspbridge/include/dspbridge/host_os.h:#include <linux/semaphore.h>
drivers/staging/dgrp/dgrp_specproc.c:	sema_init(&nd->nd_mon_semaphore, 1);
drivers/staging/dgrp/dgrp_specproc.c:	sema_init(&nd->nd_net_semaphore, 1);
drivers/staging/dgrp/dgrp_mon_ops.c:	down(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:	up(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:	down(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:	up(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:	down(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:	up(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:	down(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:		up(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:		down(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:			up(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:		up(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_mon_ops.c:	up(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	down(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:			up(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:			down(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	up(&nd->nd_mon_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	down(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	up(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	down(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	up(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	down(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	up(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	down(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	up(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	down(&nd->nd_net_semaphore);
drivers/staging/dgrp/dgrp_net_ops.c:	up(&nd->nd_net_semaphore);
drivers/staging/dgrp/drp.h:#include <linux/semaphore.h>
drivers/staging/dgrp/drp.h:	struct semaphore nd_net_semaphore; /* Net read/write lock	    */
drivers/staging/dgrp/drp.h:	struct semaphore nd_mon_semaphore; /* Monitor buffer lock	    */
drivers/staging/ced1401/ced_ioc.c:	/*  To pin down user pages we must first acquire the mapping semaphore. */
drivers/staging/rtl8723au/include/rtw_io.h:#include <linux/semaphore.h>
drivers/staging/rtl8723au/include/rtw_io.h:	struct semaphore	sema;
drivers/staging/rtl8723au/include/rtw_pwrctrl.h:	struct semaphore lock;
drivers/staging/rtl8723au/include/rtw_xmit.h:	struct semaphore	xmit_sema;
drivers/staging/rtl8723au/include/rtw_xmit.h:	struct semaphore	terminate_xmitthread_sema;
drivers/staging/rtl8723au/include/rtw_xmit.h:	struct semaphore	tx_retevt;/* all tx return event; */
drivers/staging/rtl8723au/include/osdep_service.h:#include <linux/semaphore.h>
drivers/staging/rtl8712/rtl871x_cmd.h:	struct semaphore cmd_queue_sema;
drivers/staging/rtl8712/rtl871x_cmd.h:	struct semaphore terminate_cmdthread_sema;
drivers/staging/rtl8712/rtl871x_ioctl_linux.c:#include <linux/semaphore.h>
drivers/staging/rtl8712/rtl8712_cmd.c:#include <linux/semaphore.h>
drivers/staging/rtl8712/rtl871x_event.h:#include <linux/semaphore.h>
drivers/staging/rtl8712/rtl871x_cmd.c:#include <linux/semaphore.h>
drivers/staging/rtl8712/rtl871x_pwrctrl.h:static inline void _enter_pwrlock(struct semaphore *plock)
drivers/staging/rtl8712/rtl871x_pwrctrl.h:	struct semaphore lock;
drivers/staging/rtl8712/rtl871x_security.c:#include <linux/semaphore.h>
drivers/staging/rtl8712/osdep_intf.h:	struct semaphore io_retevt;
drivers/staging/rtl8712/osdep_service.h:#include <linux/semaphore.h>
drivers/staging/rtl8712/osdep_service.h:static inline u32 _down_sema(struct semaphore *sema)
drivers/crypto/mxs-dcp.c:	/* Increment the semaphore to start the DMA transfer. */
drivers/crypto/ux500/hash/hash_core.c: * @device_allocation:	A semaphore initialized with number of devices.
drivers/crypto/ux500/hash/hash_core.c:	struct semaphore	device_allocation;
drivers/crypto/ux500/hash/hash_core.c:	 * The down_interruptible part for this semaphore is called in
drivers/crypto/ux500/hash/hash_core.c:	/* Initialize the semaphore to 0 devices (locked state) */
drivers/crypto/ux500/cryp/cryp_core.c:#include <linux/semaphore.h>
drivers/crypto/ux500/cryp/cryp_core.c: * @device_allocation: A semaphore initialized with number of devices.
drivers/crypto/ux500/cryp/cryp_core.c:	struct semaphore device_allocation;
drivers/crypto/ux500/cryp/cryp_core.c:	 * The down_interruptible part for this semaphore is called in
drivers/crypto/ux500/cryp/cryp_core.c:	 * The down_interruptible part for this semaphore is called in
drivers/crypto/ux500/cryp/cryp_core.c:	/* Initialize the semaphore to 0 devices (locked state) */
drivers/firewire/core.h:extern struct rw_semaphore fw_device_rwsem;
drivers/target/iscsi/iscsi_target_core.h:	struct semaphore	np_login_sem;
drivers/target/iscsi/iscsi_target_tq.h:	struct semaphore	ts_activate_sem;
drivers/target/iscsi/iscsi_target.c:	 * up the connection reinstatement semaphore that is being blocked on
drivers/target/iscsi/iscsi_target.c:	 * connection wait rcfr semaphore that is being blocked on
drivers/uwb/umc-bus.c:	 * it tries to retake the dev->parent semaphore.
drivers/uwb/whc-rc.c: * When we up the command semaphore, everybody possibly held trying to
drivers/usb/core/usb.c: * USB devices and interfaces are locked using the semaphore in their
drivers/usb/core/hub.c: * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */
drivers/usb/core/hub.c: * without having to wait for any semaphores to be released.  As a result,
drivers/usb/core/urb.c: *       semaphores), or
drivers/usb/misc/cytherm.c:#define BRIGHTNESS_SEM 0x2b /* RAM location for brightness semaphore */
drivers/usb/misc/sisusbvga/sisusb_con.c:	 * the disconnect semaphore; we can't
drivers/usb/misc/sisusbvga/sisusb_con.c:	 * and while disconnect and lock semaphores
drivers/usb/misc/ftdi-elan.c:	struct semaphore sw_lock;
drivers/usb/misc/usblcd.c:	struct semaphore	limit_sem;		/* to stop writes at
drivers/usb/chipidea/udc.c:	/* clear setup token semaphores */
drivers/usb/early/ehci-dbgp.c:#define EHCI_USBLEGSUP_BIOS	(1 << 16)	/* BIOS semaphore */
drivers/usb/image/mdc800.c: * a semaphore from a spinlock.
drivers/usb/usb-skeleton.c:	struct semaphore	limit_sem;		/* limiting the number of writes in progress */
drivers/usb/wusbcore/wa-xfer.c: *     rpipe to the endpoint is done under the wa->rpipe_sem semaphore
drivers/usb/gadget/mv_udc_core.c:			/* start with setting the semaphores */
drivers/usb/gadget/mv_udc_core.c:			 * Reread the ATDTW semaphore bit to check if it is
drivers/usb/gadget/mv_udc_core.c:		/* Clear the semaphore */
drivers/usb/gadget/mv_udc_core.c:	/* Clear all the setup token semaphores */
drivers/usb/gadget/f_mass_storage.c:	struct rw_semaphore	filesem;
drivers/usb/gadget/f_mass_storage.c:	struct rw_semaphore	*filesem = dev_get_drvdata(dev);
drivers/usb/gadget/f_mass_storage.c:	struct rw_semaphore	*filesem = dev_get_drvdata(dev);
drivers/usb/gadget/f_mass_storage.c:	struct rw_semaphore	*filesem = dev_get_drvdata(dev);
drivers/usb/gadget/fsl_udc_core.c:	/* Clear all the setup token semaphores */
drivers/usb/gadget/storage_common.c:ssize_t fsg_show_file(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/storage_common.c:ssize_t fsg_store_ro(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/storage_common.c:ssize_t fsg_store_file(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/storage_common.c:ssize_t fsg_store_cdrom(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/storage_common.h:ssize_t fsg_show_file(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/storage_common.h:ssize_t fsg_store_ro(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/storage_common.h:ssize_t fsg_store_file(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/storage_common.h:ssize_t fsg_store_cdrom(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/host/pci-quirks.c:#define EHCI_USBLEGSUP_BIOS	(1 << 16)	/* BIOS semaphore */
drivers/usb/host/pci-quirks.c:#define EHCI_USBLEGSUP_OS	(1 << 24)	/* OS semaphore */
drivers/usb/host/pci-quirks.c:	 * The HASEE E200 hangs when the semaphore is set (bugzilla #77021).
drivers/usb/host/pci-quirks.c:		/* some systems get upset if this semaphore is
drivers/usb/host/xhci-pci.c:	 * BIOS/OS semaphore is written, but we all know we can't trust BIOS
drivers/usb/host/isp1760-hcd.c:	 * the semaphore while doing so.
drivers/hwspinlock/u8500_hsem.c: * Implements u8500 semaphore handling for protocol 1, no interrupts.
drivers/hwspinlock/u8500_hsem.c:#define U8500_MAX_SEMAPHORE		32	/* a total of 32 semaphore */
drivers/hwspinlock/u8500_hsem.c:	 * if equal, we have the semaphore, otherwise
drivers/char/ipmi/ipmi_watchdog.c: * The semaphore is claimed when the set_timeout is sent and freed
drivers/char/snsc.h:#include <linux/semaphore.h>
drivers/char/snsc.h:	struct semaphore sd_rbs;	/* semaphore for read buffer */
drivers/char/snsc.h:	struct semaphore sd_wbs;	/* semaphore for write buffer */
drivers/input/misc/hp_sdc_rtc.c:#include <linux/semaphore.h>
drivers/input/misc/hp_sdc_rtc.c:static struct semaphore i8042tregs;
drivers/input/misc/hp_sdc_rtc.c:	struct semaphore tsem;
drivers/input/misc/hp_sdc_rtc.c:	t.act.semaphore =	&tsem;
drivers/input/misc/hp_sdc_rtc.c:	t.act.semaphore =	&i8042tregs;
drivers/input/serio/hp_sdc_mlc.c:#include <linux/semaphore.h>
drivers/input/serio/hp_sdc_mlc.c:	/* Try to down the semaphore */
drivers/input/serio/hp_sdc_mlc.c:	/* Try to down the semaphores -- they should be up. */
drivers/input/serio/hp_sdc_mlc.c:		if (priv->trans.act.semaphore != &mlc->csem)
drivers/input/serio/hp_sdc_mlc.c:	priv->trans.act.semaphore = &mlc->csem;
drivers/input/serio/hp_sdc_mlc.c:	priv->trans.act.semaphore = &mlc->osem;
drivers/input/serio/hp_sdc_mlc.c:	/* Try to down the semaphore -- it should be up. */
drivers/input/serio/hp_sdc_mlc.c:	priv->trans.act.semaphore = &mlc->osem;
drivers/input/serio/hp_sdc_mlc.c:	priv->trans.act.semaphore = &mlc->osem;
drivers/input/serio/hp_sdc_mlc.c:	hp_sdc_mlc_priv.trans.act.semaphore = &mlc->osem;
drivers/input/serio/hp_sdc.c:#include <linux/semaphore.h>
drivers/input/serio/hp_sdc.c:			if (curr->act.semaphore)
drivers/input/serio/hp_sdc.c:				up(curr->act.semaphore);
drivers/input/serio/hp_sdc.c:				if (curr->act.semaphore)
drivers/input/serio/hp_sdc.c:					up(curr->act.semaphore);
drivers/input/serio/hp_sdc.c:		up(curr->act.semaphore);
drivers/input/serio/hp_sdc.c:	struct semaphore s_sync;
drivers/input/serio/hp_sdc.c:	t_sync.act.semaphore = &s_sync;
drivers/input/serio/hp_sdc.c:	struct semaphore tq_init_sem;
drivers/input/serio/hp_sdc.c:	tq_init.act.semaphore	= &tq_init_sem;
drivers/input/serio/hil_mlc.c: *	termination or packet match, at which point a semaphore must
drivers/input/touchscreen/ucb1400_ts.c: * access completion and uses semaphores for access control to the
drivers/input/mouse/psmouse-base.c: * sysfs). We could use a per-device semaphore but since there
drivers/input/mouse/psmouse-base.c: * rarely more than one PS/2 mouse connected and since semaphore
drivers/i2c/busses/i2c-nomadik.c: * semaphore set in the kernel i2c_transfer() function.
drivers/i2c/i2c-core.h:extern struct rw_semaphore	__i2c_board_lock;
drivers/watchdog/sc1200wdt.c:#include <linux/semaphore.h>
drivers/dma/mxs-dma.c:#include <linux/semaphore.h>
drivers/dma/mxs-dma.c:	 * we use cyclic DMA with semaphores, that are enhanced in
drivers/dma/mxs-dma.c:	 * into the semaphore counter.
drivers/dma/mxs-dma.c:		 * the semaphore with 2 so we have enough time to add 1 to the
drivers/dma/mxs-dma.c:		 * semaphore if we need to */
drivers/dma/imx-sdma.c:#include <linux/semaphore.h>
drivers/isdn/i4l/isdn_common.c: * to be dangerous and for debugging purpose only). The inode semaphore
drivers/isdn/i4l/isdn_common.c: * to be dangerous and for debugging purpose only). The inode semaphore
drivers/isdn/i4l/isdn_common.c: * are serialized by means of a semaphore.
drivers/isdn/i4l/isdn_net.c: * This might sleep and must be called with the isdn semaphore down.
drivers/isdn/gigaset/isocdata.c: * acquire the write semaphore
drivers/isdn/gigaset/isocdata.c:		gig_dbg(DEBUG_ISO, "%s: couldn't acquire iso write semaphore",
drivers/isdn/gigaset/isocdata.c:		"%s: acquired iso write semaphore, data[write]=%02x, nbits=%d",
drivers/isdn/gigaset/isocdata.c: * release the write semaphore
drivers/isdn/gigaset/isocdata.c: * must be called with the write semaphore held
drivers/isdn/gigaset/isocdata.c: * must be called with the write semaphore held
drivers/isdn/gigaset/isocdata.c: *		(write semaphore must be held)
drivers/isdn/gigaset/isocdata.c: *		(write semaphore must be held)
drivers/isdn/gigaset/isocdata.c: *	-EAGAIN if write semaphore busy or buffer full
drivers/isdn/gigaset/isocdata.c: *		(write semaphore must be held)
drivers/isdn/gigaset/isocdata.c: *	-EAGAIN if write semaphore busy or buffer full
drivers/isdn/gigaset/gigaset.h: * - writesem is the semaphore for writing to the buffer:
drivers/scsi/gdth.h:#define SEMA0REG        0x0c8a                  /* command semaphore */
drivers/scsi/gdth.h:#define SEMA1REG        0x0c8b                  /* status semaphore */
drivers/scsi/gdth.h:    u8 volatile     Sema0;                  /* command semaphore */
drivers/scsi/gdth.h:        u8 volatile Sema1;                  /* status semaphore */
drivers/scsi/gdth.h:        u8 volatile Sema1;                  /* command semaphore */
drivers/scsi/gdth.h:    u8 volatile     sema0_reg;              /* command semaphore */
drivers/scsi/gdth.h:    u8 volatile     sema1_reg;              /* status semaphore */
drivers/scsi/gdth.h:    u8 volatile     sema0_reg;              /* command semaphore */
drivers/scsi/gdth.h:    u8 volatile     sema1_reg;              /* status semaphore */
drivers/scsi/qlogicpti.h:/* SBUS semaphore register */
drivers/scsi/aha152x.c:	struct completion *done;/* semaphore to block on */
drivers/scsi/sr.c:/* This semaphore is used to mediate the 0->1 reference get in the
drivers/scsi/sr.c: *	scsi_cd_put() helpers which manipulate the semaphore directly
drivers/scsi/qla1280.c:	WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla1280.c:	mailbox[0] = RD_REG_WORD_dmasync(&reg->semaphore);
drivers/scsi/qla1280.c:		WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla2xxx/qla_def.h:	uint16_t semaphore;		/* Semaphore */
drivers/scsi/qla2xxx/qla_def.h:			uint16_t host_semaphore;
drivers/scsi/qla2xxx/qla_init.c:	WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla2xxx/qla_init.c:qla25xx_manipulate_risc_semaphore(scsi_qla_host_t *vha)
drivers/scsi/qla2xxx/qla_init.c:	qla25xx_manipulate_risc_semaphore(vha);
drivers/scsi/qla2xxx/qla_init.c:		    "Unable to acquire semaphore.\n");
drivers/scsi/qla2xxx/qla_init.c:		    "Unable to release semaphore.\n");
drivers/scsi/qla2xxx/qla_nx.c:		/* acquire semaphore3 from PCI HW block */
drivers/scsi/qla2xxx/qla_nx.c:		/* acquire semaphore5 from PCI HW block */
drivers/scsi/qla2xxx/qla_nx.c:		/* acquire semaphore2 from PCI HW block */
drivers/scsi/qla2xxx/qla_isr.c:		if (RD_REG_WORD(&reg->semaphore) & BIT_0) {
drivers/scsi/qla2xxx/qla_isr.c:			WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla2xxx/qla_isr.c:			RD_REG_WORD(&reg->semaphore);
drivers/scsi/qla2xxx/qla_isr.c:			WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla2xxx/qla_isr.c:		WRT_REG_WORD(&reg->isp.semaphore, 0);
drivers/scsi/qla2xxx/qla_dbg.c:					WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla2xxx/qla_dbg.c:				if (RD_REG_WORD(&reg->semaphore) & BIT_0) {
drivers/scsi/qla2xxx/qla_dbg.c:					WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla2xxx/qla_fw.h:/* RISC-RISC semaphore register PCI offet */
drivers/scsi/qla2xxx/qla_fw.h:/* RISC-RISC semaphore/flag register (risc address 0x7016) */
drivers/scsi/qla2xxx/qla_fw.h:/* RISC semaphore timeouts (ms) */
drivers/scsi/qla2xxx/qla_sup.c:		WRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0x1);
drivers/scsi/qla2xxx/qla_sup.c:		RD_REG_WORD(&reg->u.isp2300.host_semaphore);
drivers/scsi/qla2xxx/qla_sup.c:		data = RD_REG_WORD(&reg->u.isp2300.host_semaphore);
drivers/scsi/qla2xxx/qla_sup.c:			WRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0x1);
drivers/scsi/qla2xxx/qla_sup.c:			RD_REG_WORD(&reg->u.isp2300.host_semaphore);
drivers/scsi/qla2xxx/qla_sup.c:			data = RD_REG_WORD(&reg->u.isp2300.host_semaphore);
drivers/scsi/qla2xxx/qla_sup.c:		WRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0);
drivers/scsi/qla2xxx/qla_sup.c:		RD_REG_WORD(&reg->u.isp2300.host_semaphore);
drivers/scsi/qla2xxx/qla_nx2.c:		/* acquire semaphore5 from PCI HW block */
drivers/scsi/gdth.c:    /* if it's the first command, set command semaphore */
drivers/scsi/gdth.c:    /* if it's the first command, set command semaphore */
drivers/scsi/gdth.c:    /* if it's the first command, set command semaphore */
drivers/scsi/gdth.c:            outb(0x00, ha->bmic + SEMA1REG);    /* reset status semaphore */
drivers/scsi/gdth.c:            writeb(0, &dp2_ptr->io.Sema1);     /* reset status semaphore */
drivers/scsi/gdth.c:            writeb(0, &dp6_ptr->io.Sema1);     /* reset status semaphore */
drivers/scsi/aic7xxx/aic79xx.reg:	 * Counting semaphore to prevent new select-outs
drivers/scsi/aic7xxx/aic7xxx_core.c: * to be executed.  We use a counting semaphore to allow the lock
drivers/scsi/st.c: *      scsi_tape_put() helpers which manipulate the semaphore directly
drivers/scsi/isci/phy.c:				 * semaphore state
drivers/scsi/isci/phy.c:			/* got IAF we can now go to the await spinup semaphore state */
drivers/scsi/qla4xxx/ql4_nx.c:		/* acquire semaphore3 from PCI HW block */
drivers/scsi/qla4xxx/ql4_nx.c:		/* acquire semaphore5 from PCI HW block */
drivers/scsi/qla4xxx/ql4_nx.c:		/* acquire semaphore2 from PCI HW block */
drivers/scsi/qla4xxx/ql4_init.c:		/* Reset clears the semaphore, so acquire again */
drivers/scsi/qla4xxx/ql4_dbg.c:		printk(KERN_INFO "0x%02X semaphore	  = 0x%08X\n",
drivers/scsi/qla4xxx/ql4_dbg.c:		    (uint8_t) offsetof(struct isp_reg, u1.isp4022.semaphore),
drivers/scsi/qla4xxx/ql4_dbg.c:		    readw(&ha->reg->u1.isp4022.semaphore));
drivers/scsi/qla4xxx/ql4_def.h:static inline void __iomem* isp_semaphore(struct scsi_qla_host *ha)
drivers/scsi/qla4xxx/ql4_def.h:		&ha->reg->u1.isp4022.semaphore);
drivers/scsi/qla4xxx/ql4_fw.h:			__le32 semaphore;
drivers/scsi/qla4xxx/ql4_nvram.c:		writel((sem_mask | sem_bits), isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nvram.c:		value = readw(isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nvram.c:	writel(sem_mask, isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nvram.c:	readl(isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nvram.c:	writel((sem_mask | sem_bits), isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nvram.c:	value = readw(isp_semaphore(ha));
drivers/scsi/aacraid/commsup.c:#include <linux/semaphore.h>
drivers/scsi/aacraid/dpcsup.c:#include <linux/semaphore.h>
drivers/scsi/aacraid/commctrl.c:#include <linux/semaphore.h>
drivers/scsi/aacraid/aacraid.h:	struct semaphore	wait_sem;	// this is used to wait for the next fib to arrive.
drivers/scsi/aacraid/aacraid.h:	struct semaphore	event_wait;
drivers/scsi/sd.c:/* This semaphore is used to mediate the 0->1 reference get in the
drivers/scsi/sd.c: *	scsi_disk_put() helpers which manipulate the semaphore directly
drivers/scsi/FlashPoint.c:#define  hp_semaphore         0x0C
drivers/scsi/FlashPoint.c:			WR_HARPOON(ioport + hp_semaphore, 0x00);
drivers/scsi/FlashPoint.c:	WR_HARPOON((ioport + hp_semaphore),
drivers/scsi/FlashPoint.c:		   (unsigned char)(RD_HARPOON((ioport + hp_semaphore)) |
drivers/scsi/FlashPoint.c:		WR_HARPOON(ioport + hp_semaphore,
drivers/scsi/FlashPoint.c:			   (RD_HARPOON(ioport + hp_semaphore)
drivers/scsi/FlashPoint.c:	if (RD_HARPOON(ioport + hp_semaphore) & BIOS_IN_USE) {
drivers/scsi/FlashPoint.c:		WR_HARPOON(ioport + hp_semaphore,
drivers/scsi/FlashPoint.c:			   (RD_HARPOON(ioport + hp_semaphore)
drivers/scsi/FlashPoint.c:				WR_HARPOON(ioport + hp_semaphore,
drivers/scsi/FlashPoint.c:					   (RD_HARPOON(ioport + hp_semaphore)
drivers/scsi/FlashPoint.c:		WR_HARPOON(pCurrCard->ioPort + hp_semaphore,
drivers/scsi/FlashPoint.c:			   (RD_HARPOON(pCurrCard->ioPort + hp_semaphore) &
drivers/scsi/dpt/osd_util.h:/* Mutually exclusive semaphore functions */
drivers/scsi/dpt/osd_util.h:  /* Create a named semaphore */
drivers/scsi/dpt/osd_util.h:  /* Create a mutually exlusive semaphore */
drivers/scsi/dpt/osd_util.h:	/* create an event semaphore */
drivers/scsi/dpt/osd_util.h:	/* create a named event semaphore */
drivers/scsi/dpt/osd_util.h:  /* Destroy the specified mutually exclusive semaphore object */
drivers/scsi/dpt/osd_util.h:  /* Request access to the specified mutually exclusive semaphore */
drivers/scsi/dpt/osd_util.h:  /* Release access to the specified mutually exclusive semaphore */
drivers/scsi/dpt/osd_defs.h:  /* Define the mutually exclusive semaphore type */
drivers/scsi/megaraid/megaraid_mbox.c:	// wait for maximum 1 second for poll semaphore
drivers/scsi/megaraid/megaraid_mbox.c:			"megaraid mailbox: could not get poll semaphore\n"));
drivers/scsi/megaraid/megaraid_sas.h:	struct semaphore ioctl_sem;
drivers/scsi/megaraid/megaraid_ioctl.h:#include <linux/semaphore.h>
drivers/scsi/megaraid/megaraid_ioctl.h: * @kioc_semaphore	: so as not to exceed @max_kioc parallel ioctls
drivers/scsi/megaraid/megaraid_ioctl.h:	struct semaphore	kioc_semaphore;
drivers/scsi/megaraid/megaraid_mm.c: * The kioc_semaphore is initialized with number of kioc nodes in the
drivers/scsi/megaraid/megaraid_mm.c:	down(&adp->kioc_semaphore);
drivers/scsi/megaraid/megaraid_mm.c:		up(&adp->kioc_semaphore);
drivers/scsi/megaraid/megaraid_mm.c:	up(&adp->kioc_semaphore);
drivers/scsi/megaraid/megaraid_mm.c:	sema_init(&adapter->kioc_semaphore, lld_adp->max_kioc);
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	/* misc semaphores and spin locks */
drivers/scsi/esas2r/esas2r_flash.c:	if (down_interruptible(&a->nvram_semaphore))
drivers/scsi/esas2r/esas2r_flash.c:	up(&a->nvram_semaphore);
drivers/scsi/esas2r/esas2r_flash.c:		up(&a->nvram_semaphore);
drivers/scsi/esas2r/esas2r_flash.c:	if (down_interruptible(&a->nvram_semaphore))
drivers/scsi/esas2r/esas2r_flash.c:		up(&a->nvram_semaphore);
drivers/scsi/esas2r/esas2r_flash.c:		up(&a->nvram_semaphore);
drivers/scsi/esas2r/esas2r_init.c:	sema_init(&a->fm_api_semaphore, 1);
drivers/scsi/esas2r/esas2r_init.c:	sema_init(&a->fs_api_semaphore, 1);
drivers/scsi/esas2r/esas2r_init.c:	sema_init(&a->nvram_semaphore, 1);
drivers/scsi/esas2r/esas2r_ioctl.c:static DEFINE_SEMAPHORE(buffered_ioctl_semaphore);
drivers/scsi/esas2r/esas2r_ioctl.c:	if (down_interruptible(&a->fm_api_semaphore)) {
drivers/scsi/esas2r/esas2r_ioctl.c:		up(&a->fm_api_semaphore);
drivers/scsi/esas2r/esas2r_ioctl.c:	up(&a->fm_api_semaphore);
drivers/scsi/esas2r/esas2r_ioctl.c:	if (down_interruptible(&buffered_ioctl_semaphore))
drivers/scsi/esas2r/esas2r_ioctl.c:	up(&buffered_ioctl_semaphore);
drivers/scsi/esas2r/esas2r_ioctl.c:			up(&a->nvram_semaphore);
drivers/scsi/esas2r/esas2r_ioctl.c:		if (down_interruptible(&a->fs_api_semaphore)) {
drivers/scsi/esas2r/esas2r_ioctl.c:			up(&a->fs_api_semaphore);
drivers/scsi/esas2r/esas2r_ioctl.c:		up(&a->fs_api_semaphore);
drivers/scsi/esas2r/esas2r.h:	struct semaphore fm_api_semaphore;
drivers/scsi/esas2r/esas2r.h:	struct semaphore fs_api_semaphore;
drivers/scsi/esas2r/esas2r.h:	struct semaphore nvram_semaphore;
drivers/scsi/qlogicpti.c:	/* Set SBUS semaphore. */
drivers/scsi/qlogicpti.c:	/* Clear SBUS semaphore. */
drivers/scsi/qlogicpti.c:	/* Wait for SBUS semaphore to get set. */
drivers/scsi/qlogicpti.c:	/* Release SBUS semaphore. */
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	/* misc semaphores and spin locks */
drivers/scsi/bfa/bfa_ioc.c:	IOCPF_E_SEMLOCKED	= 10,	/*  h/w semaphore is locked	*/
drivers/scsi/bfa/bfa_ioc.c:	BFA_IOCPF_SEMWAIT	= 2,	/*  Waiting for IOC h/w semaphore */
drivers/scsi/bfa/bfa_ioc.c:	 * Spin on init semaphore to serialize.
drivers/scsi/bfa/bfa_ioc.c:	 * Unlock the hw semaphore. Should be here only once per boot.
drivers/scsi/bfa/bfa_ioc.c:	 * unlock init semaphore.
drivers/scsi/bfa/bfa_ioc.c: * Awaiting h/w semaphore to continue with version check.
drivers/scsi/bfa/bfa_ioc.c: * Request for semaphore.
drivers/scsi/bfa/bfa_ioc.c: * Awaiting semaphore for h/w initialzation.
drivers/scsi/bfa/bfa_ioc.c: * Holding hardware semaphore lock.
drivers/scsi/bfa/bfa_ioc.c:	 * First read to the semaphore register will return 0, subsequent reads
drivers/scsi/bfa/bfa_ioc.c:	 *  Hold semaphore to serialize pll init and fwtrc.
drivers/scsi/bfa/bfa_ioc.c:	 *  release semaphore.
drivers/scsi/bfa/bfa_ioc.c:	 *  Hold semaphore to serialize pll init and fwtrc.
drivers/scsi/bfa/bfa_ioc.c:	 *  release semaphore.
drivers/scsi/bfa/bfa_ioc.c:	 *  Hold semaphore so that nobody can access the chip during init.
drivers/scsi/bfa/bfa_ioc.c:	 *  release semaphore.
drivers/scsi/bfa/bfa_ioc.c:#define BFA_PHY_LOCK_STATUS	0x018878        /* phy semaphore status reg */
drivers/scsi/bfa/bfa_ioc_ct.c:	 * IOC semaphore registers and serialization
drivers/scsi/bfa/bfa_ioc_ct.c:	 * IOC semaphore registers and serialization
drivers/scsi/bfa/bfa_ioc_ct.c: * Cleanup hw semaphore and usecnt registers
drivers/scsi/bfa/bfa_ioc_ct.c:	 * semaphore (in bfa_iocpf_sm_semwait()).
drivers/scsi/bfa/bfi_reg.h: * Name semaphore registers based on usage
drivers/scsi/bfa/bfi_reg.h: * CT2 semaphore register locations changed
drivers/scsi/bfa/bfa_ioc_cb.c:	 * IOC semaphore registers and serialization
drivers/scsi/bfa/bfa_ioc_cb.c: * Cleanup hw semaphore and usecnt registers
drivers/scsi/bfa/bfa_defs.h:	BFA_IOC_SEMWAIT		= 3,	/*  Waiting for IOC h/w semaphore */
drivers/scsi/ips.c:/* 4.80.14  - Take all semaphores off stack                                  */
drivers/scsi/ips.c:				   "ips_issue semaphore chk timeout.\n");
drivers/scsi/ips.c:				   "ips_issue semaphore chk timeout.\n");
drivers/scsi/qla1280.h:	uint16_t semaphore;	/* Semaphore */
drivers/scsi/osst.c:/* Handle the write-behind checking (downs the semaphore) */
drivers/scsi/be2iscsi/be_main.c:#include <linux/semaphore.h>
drivers/mfd/dbx500-prcmu-regs.h:/* PRCMU HW semaphore */
drivers/mfd/ucb1x00-ts.c: * (mainly so we can use semaphores in the UCB1200 core code
drivers/mfd/db8500-prcmu.c:	/* Grab the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Release the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Grab the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Release the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Grab the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Release the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Grab the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Release the HW semaphore. */
drivers/acpi/osl.c:#include <linux/semaphore.h>
drivers/acpi/osl.c:acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
drivers/acpi/osl.c:	struct semaphore *sem = NULL;
drivers/acpi/osl.c:	sem = acpi_os_allocate_zeroed(sizeof(struct semaphore));
drivers/acpi/osl.c:	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Creating semaphore[%p|%d].\n",
drivers/acpi/osl.c: * TODO: A better way to delete semaphores?  Linux doesn't have a
drivers/acpi/osl.c: * 'delete_semaphore()' function -- may result in an invalid
drivers/acpi/osl.c:acpi_status acpi_os_delete_semaphore(acpi_handle handle)
drivers/acpi/osl.c:	struct semaphore *sem = (struct semaphore *)handle;
drivers/acpi/osl.c:	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Deleting semaphore[%p].\n", handle));
drivers/acpi/osl.c:acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
drivers/acpi/osl.c:	struct semaphore *sem = (struct semaphore *)handle;
drivers/acpi/osl.c:	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n",
drivers/acpi/osl.c:				  "Failed to acquire semaphore[%p|%d|%d], %s",
drivers/acpi/osl.c:				  "Acquired semaphore[%p|%d|%d]", handle,
drivers/acpi/osl.c:acpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)
drivers/acpi/osl.c:	struct semaphore *sem = (struct semaphore *)handle;
drivers/acpi/osl.c:	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Signaling semaphore[%p|%d]\n", handle,
drivers/acpi/acpica/evgpeutil.c: *              Should be called only when the GPE lists are semaphore locked
drivers/acpi/acpica/evgpeutil.c: *              called only when the GPE lists are semaphore locked and not
drivers/acpi/acpica/exdump.c:	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(event.os_semaphore), "OsSemaphore"}
drivers/acpi/acpica/aclocal.h:#define ACPI_GLOBAL_LOCK                (acpi_semaphore) (-1)
drivers/acpi/acpica/excreate.c:	 * Create the actual OS semaphore, with zero initial units -- meaning
drivers/acpi/acpica/excreate.c:	status = acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0,
drivers/acpi/acpica/excreate.c:					  &obj_desc->event.os_semaphore);
drivers/acpi/acpica/excreate.c:	 * of both object and semaphore if present.)
drivers/acpi/acpica/excreate.c:	 * of both object and semaphore if present.)
drivers/acpi/acpica/nsaccess.c:					/* Create additional counting semaphore for global lock */
drivers/acpi/acpica/nsaccess.c:					    acpi_os_create_semaphore(1, 0,
drivers/acpi/acpica/nsaccess.c:								     &acpi_gbl_global_lock_semaphore);
drivers/acpi/acpica/utdelete.c:			/* Global Lock has extra semaphore */
drivers/acpi/acpica/utdelete.c:			    acpi_os_delete_semaphore
drivers/acpi/acpica/utdelete.c:			    (acpi_gbl_global_lock_semaphore);
drivers/acpi/acpica/utdelete.c:			acpi_gbl_global_lock_semaphore = NULL;
drivers/acpi/acpica/utdelete.c:				  object, object->event.os_semaphore));
drivers/acpi/acpica/utdelete.c:		(void)acpi_os_delete_semaphore(object->event.os_semaphore);
drivers/acpi/acpica/utdelete.c:		object->event.os_semaphore = NULL;
drivers/acpi/acpica/dsmethod.c: *              increments the thread count, and waits at the method semaphore
drivers/acpi/acpica/acinterp.h:acpi_ex_system_wait_semaphore(acpi_semaphore semaphore, u16 timeout);
drivers/acpi/acpica/evgpe.c: *              Should be called only when the GPE lists are semaphore locked
drivers/acpi/acpica/evglock.c:	 * Send a unit to the global lock semaphore. The actual acquisition
drivers/acpi/acpica/evglock.c:	status = acpi_os_signal_semaphore(acpi_gbl_global_lock_semaphore, 1);
drivers/acpi/acpica/evglock.c:		ACPI_ERROR((AE_INFO, "Could not signal Global Lock semaphore"));
drivers/acpi/acpica/evglock.c:		    acpi_ex_system_wait_semaphore
drivers/acpi/acpica/evglock.c:		    (acpi_gbl_global_lock_semaphore, ACPI_WAIT_FOREVER);
drivers/acpi/acpica/utglobal.c:	acpi_gbl_global_lock_semaphore = NULL;
drivers/acpi/acpica/utcopy.c:		status = acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0,
drivers/acpi/acpica/utcopy.c:						  os_semaphore);
drivers/acpi/acpica/acobject.h:	ACPI_OBJECT_COMMON_HEADER acpi_semaphore os_semaphore;	/* Actual OS synchronization object */
drivers/acpi/acpica/acglobal.h: * Global lock semaphore works in conjunction with the actual global lock
drivers/acpi/acpica/acglobal.h:ACPI_GLOBAL(acpi_semaphore, acpi_gbl_global_lock_semaphore);
drivers/acpi/acpica/psxface.c:	/* Init for new method, wait on concurrency semaphore */
drivers/acpi/acpica/exsystem.c: * FUNCTION:    acpi_ex_system_wait_semaphore
drivers/acpi/acpica/exsystem.c: * PARAMETERS:  semaphore       - Semaphore to wait on
drivers/acpi/acpica/exsystem.c: * DESCRIPTION: Implements a semaphore wait with a check to see if the
drivers/acpi/acpica/exsystem.c: *              semaphore is available immediately. If it is not, the
drivers/acpi/acpica/exsystem.c:acpi_status acpi_ex_system_wait_semaphore(acpi_semaphore semaphore, u16 timeout)
drivers/acpi/acpica/exsystem.c:	ACPI_FUNCTION_TRACE(ex_system_wait_semaphore);
drivers/acpi/acpica/exsystem.c:	status = acpi_os_wait_semaphore(semaphore, 1, ACPI_DO_NOT_WAIT);
drivers/acpi/acpica/exsystem.c:		status = acpi_os_wait_semaphore(semaphore, 1, timeout);
drivers/acpi/acpica/exsystem.c:		    acpi_os_signal_semaphore(obj_desc->event.os_semaphore, 1);
drivers/acpi/acpica/exsystem.c:		    acpi_ex_system_wait_semaphore(obj_desc->event.os_semaphore,
drivers/acpi/acpica/exsystem.c:	acpi_semaphore temp_semaphore;
drivers/acpi/acpica/exsystem.c:	 * We are going to simply delete the existing semaphore and
drivers/acpi/acpica/exsystem.c:	    acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0, &temp_semaphore);
drivers/acpi/acpica/exsystem.c:		(void)acpi_os_delete_semaphore(obj_desc->event.os_semaphore);
drivers/acpi/acpica/exsystem.c:		obj_desc->event.os_semaphore = temp_semaphore;
drivers/vfio/vfio.c:	struct rw_semaphore		group_lock;
drivers/hid/hid-core.c:#include <linux/semaphore.h>
drivers/ide/ide-proc.c: *	setting semaphore
drivers/pcmcia/cs_internal.h:extern struct rw_semaphore pcmcia_socket_list_rwsem;
drivers/net/ppp/ppp_async.c:	struct semaphore dead_sem;
drivers/net/ppp/ppp_generic.c:	struct rw_semaphore chan_sem;	/* protects `chan' during chan ioctl */
drivers/net/bonding/bond_main.c: * b. The operation is protected by the RTNL semaphore in the 8021q code,
drivers/net/wimax/i2400m/usb.c: *    as a poor man's semaphore. Ugly, but it works.
drivers/net/irda/sir-dev.h:	struct semaphore	sem;
drivers/net/hamradio/6pack.c:#include <linux/semaphore.h>
drivers/net/hamradio/6pack.c:	struct semaphore	dead_sem;
drivers/net/hamradio/mkiss.c:	struct semaphore	dead_sem;
drivers/net/usb/hso.c:	/* and initialize the semaphore */
drivers/net/usb/hso.c:	/* Initialise the serial table semaphore and table */
drivers/net/caif/caif_spi_slave.c:#include <linux/semaphore.h>
drivers/net/phy/mdio-gpio.c: *  by Laurent Pinchart <laurentp@cse-semaphore.com>
drivers/net/wan/cosa.c:	struct semaphore wsem;
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Sets PHY page required for PHY register access.  Assumes semaphore is
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then reads the PHY register at offset and stores the
drivers/net/ethernet/intel/e1000e/phy.c: *  Release the acquired semaphore before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  in data.  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary.  Then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then reads the PHY register at offset using the
drivers/net/ethernet/intel/e1000e/phy.c: *  Release the acquired semaphore before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary.  Then write the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset using the kumeran interface.  Release any acquired semaphores
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then writes the data to the PHY register at the offset
drivers/net/ethernet/intel/e1000e/phy.c: *  using the kumeran interface.  Release the acquired semaphore before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphore (if necessary) and read/set/write the device control reset
drivers/net/ethernet/intel/e1000e/phy.c: *  reset and release the semaphore (if necessary).
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore already acquired and phy_reg points to a valid memory
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore already acquired and *phy_reg is the contents of the
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore is already acquired.  When page_set==true, assumes
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphore before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then reads the PHY register at offset and stores
drivers/net/ethernet/intel/e1000e/phy.c: *  the retrieved information in data.  Release the acquired semaphore
drivers/net/ethernet/intel/e1000e/phy.c: *  in data.  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/phy.c: *  in data.  Assumes semaphore already acquired and page already set.
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then writes the data to PHY register at the offset.
drivers/net/ethernet/intel/e1000e/phy.c: *  Release the acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Writes the data to PHY register at the offset.  Assumes semaphore
drivers/net/ethernet/intel/e1000e/phy.c: *  Writes the data to PHY register at the offset.  Assumes semaphore
drivers/net/ethernet/intel/e1000e/phy.c: *  in data.  Assumes semaphore already acquired.  Note that the procedure
drivers/net/ethernet/intel/e1000e/netdev.c: * semaphore to read the phy, which we could msleep while
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82571(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82573(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/82571.c:static s32 e1000_get_hw_semaphore_82574(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82574(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/82571.c:		phy->ops.acquire = e1000_get_hw_semaphore_82574;
drivers/net/ethernet/intel/e1000e/82571.c:		phy->ops.release = e1000_put_hw_semaphore_82574;
drivers/net/ethernet/intel/e1000e/82571.c:		nvm->ops.acquire = e1000_get_hw_semaphore_82574;
drivers/net/ethernet/intel/e1000e/82571.c:		nvm->ops.release = e1000_put_hw_semaphore_82574;
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_get_hw_semaphore_82571 - Acquire hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Acquire the HW semaphore to access the PHY or NVM
drivers/net/ethernet/intel/e1000e/82571.c:static s32 e1000_get_hw_semaphore_82571(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c:	 * the inter-port SMBI semaphore, there is old code
drivers/net/ethernet/intel/e1000e/82571.c:	 * we try for the semaphore to interwork with this
drivers/net/ethernet/intel/e1000e/82571.c:	/* Get the SW semaphore */
drivers/net/ethernet/intel/e1000e/82571.c:	/* Get the FW semaphore. */
drivers/net/ethernet/intel/e1000e/82571.c:		/* Release semaphores */
drivers/net/ethernet/intel/e1000e/82571.c:		e1000_put_hw_semaphore_82571(hw);
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_put_hw_semaphore_82571 - Release hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Release hardware semaphore used to access the PHY or NVM
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82571(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_get_hw_semaphore_82573 - Acquire hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Acquire the HW semaphore during reset.
drivers/net/ethernet/intel/e1000e/82571.c:static s32 e1000_get_hw_semaphore_82573(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c:		/* Release semaphores */
drivers/net/ethernet/intel/e1000e/82571.c:		e1000_put_hw_semaphore_82573(hw);
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_put_hw_semaphore_82573 - Release hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Release hardware semaphore used during reset.
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82573(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_get_hw_semaphore_82574 - Acquire hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Acquire the HW semaphore to access the PHY or NVM.
drivers/net/ethernet/intel/e1000e/82571.c:static s32 e1000_get_hw_semaphore_82574(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c:	ret_val = e1000_get_hw_semaphore_82573(hw);
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_put_hw_semaphore_82574 - Release hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Release hardware semaphore used to access the PHY or NVM
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82574(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c:	e1000_put_hw_semaphore_82573(hw);
drivers/net/ethernet/intel/e1000e/82571.c: *  To gain access to the EEPROM, first we must obtain a hardware semaphore.
drivers/net/ethernet/intel/e1000e/82571.c: *  hardware semaphore.
drivers/net/ethernet/intel/e1000e/82571.c:	ret_val = e1000_get_hw_semaphore_82571(hw);
drivers/net/ethernet/intel/e1000e/82571.c:		e1000_put_hw_semaphore_82571(hw);
drivers/net/ethernet/intel/e1000e/82571.c:	e1000_put_hw_semaphore_82571(hw);
drivers/net/ethernet/intel/e1000e/82571.c:		ret_val = e1000_get_hw_semaphore_82573(hw);
drivers/net/ethernet/intel/e1000e/82571.c:		ret_val = e1000_get_hw_semaphore_82574(hw);
drivers/net/ethernet/intel/e1000e/82571.c:		/* Release mutex only if the hw semaphore is acquired */
drivers/net/ethernet/intel/e1000e/82571.c:			e1000_put_hw_semaphore_82573(hw);
drivers/net/ethernet/intel/e1000e/82571.c:		/* Release mutex only if the hw semaphore is acquired */
drivers/net/ethernet/intel/e1000e/82571.c:			e1000_put_hw_semaphore_82574(hw);
drivers/net/ethernet/intel/e1000e/82571.c:	.acquire		= e1000_get_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/82571.c:	.release		= e1000_put_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/82571.c:	.acquire		= e1000_get_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/82571.c:	.release		= e1000_put_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/82571.c:	.acquire		= e1000_get_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/82571.c:	.release		= e1000_put_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  Assumes the sw/fw/hw semaphore is already acquired.
drivers/net/ethernet/intel/e1000e/ich8lan.c:		e_dbg("Failed to acquire the semaphore, FW or HW has it: FWSM=0x%8.8x EXTCNF_CTRL=0x%8.8x)\n",
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Acquire the semaphore to access the Kumeran interface.
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Release the semaphore used to access the Kumeran interface
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Acquire the semaphore to access the EEPROM.
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Release the semaphore used to access the EEPROM.
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  e1000_acquire_swfw_sync_80003es2lan - Acquire SW/FW semaphore
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/e1000e/80003es2lan.c:		if (e1000e_get_hw_semaphore(hw))
drivers/net/ethernet/intel/e1000e/80003es2lan.c:		e1000e_put_hw_semaphore(hw);
drivers/net/ethernet/intel/e1000e/80003es2lan.c:	e1000e_put_hw_semaphore(hw);
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  e1000_release_swfw_sync_80003es2lan - Release SW/FW semaphore
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/e1000e/80003es2lan.c:	while (e1000e_get_hw_semaphore(hw) != 0)
drivers/net/ethernet/intel/e1000e/80003es2lan.c:	e1000e_put_hw_semaphore(hw);
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Acquire semaphore, then read the PHY register at offset
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Release the semaphore before exiting.
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Acquire semaphore, then write the data to PHY register
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  at the offset using the kumeran interface.  Release semaphore
drivers/net/ethernet/intel/e1000e/defines.h:#define E1000_SWSM2_LOCK        0x00000002 /* Secondary driver semaphore bit */
drivers/net/ethernet/intel/e1000e/mac.h:s32 e1000e_get_hw_semaphore(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/mac.h:void e1000e_put_hw_semaphore(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/manage.c: *  Reads the firmware semaphore register and returns true (>0) if
drivers/net/ethernet/intel/e1000e/regs.h:/* Driver-only SW semaphore (not used by BOOT agents) */
drivers/net/ethernet/intel/e1000e/mac.c: *  e1000e_get_hw_semaphore - Acquire hardware semaphore
drivers/net/ethernet/intel/e1000e/mac.c: *  Acquire the HW semaphore to access the PHY or NVM
drivers/net/ethernet/intel/e1000e/mac.c:s32 e1000e_get_hw_semaphore(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/mac.c:	/* Get the SW semaphore */
drivers/net/ethernet/intel/e1000e/mac.c:	/* Get the FW semaphore. */
drivers/net/ethernet/intel/e1000e/mac.c:		/* Release semaphores */
drivers/net/ethernet/intel/e1000e/mac.c:		e1000e_put_hw_semaphore(hw);
drivers/net/ethernet/intel/e1000e/mac.c: *  e1000e_put_hw_semaphore - Release hardware semaphore
drivers/net/ethernet/intel/e1000e/mac.c: *  Release hardware semaphore used to access the PHY or NVM
drivers/net/ethernet/intel/e1000e/mac.c:void e1000e_put_hw_semaphore(struct e1000_hw *hw)
drivers/net/ethernet/intel/i40e/i40e_nvm.c:	hw->nvm.hw_semaphore_timeout = I40E_MS_TO_GTIME(time) + gtime;
drivers/net/ethernet/intel/i40e/i40e_nvm.c:			timeout = hw->nvm.hw_semaphore_timeout;
drivers/net/ethernet/intel/i40e/i40e_nvm.c:				hw->nvm.hw_semaphore_timeout =
drivers/net/ethernet/intel/i40e/i40e_nvm.c:			hw->nvm.hw_semaphore_timeout = 0;
drivers/net/ethernet/intel/i40e/i40e_nvm.c:			hw->nvm.hw_semaphore_wait =
drivers/net/ethernet/intel/i40e/i40e_nvm.c:	 * the synchronization semaphores twice here.
drivers/net/ethernet/intel/i40e/i40e_type.h:	u64 hw_semaphore_timeout; /* 2usec global time (GTIME resolution) */
drivers/net/ethernet/intel/i40e/i40e_type.h:	u64 hw_semaphore_wait;    /* - || - */
drivers/net/ethernet/intel/e1000/e1000_hw.h:	u32 eeprom_semaphore_present;
drivers/net/ethernet/intel/i40evf/i40e_type.h:	u64 hw_semaphore_timeout; /* 2usec global time (GTIME resolution) */
drivers/net/ethernet/intel/i40evf/i40e_type.h:	u64 hw_semaphore_wait;    /* - || - */
drivers/net/ethernet/intel/ixgbe/ixgbe_type.h:	u32                             semaphore_delay;
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		eeprom->semaphore_delay = 10;
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	 * the synchronization semaphores here. Instead use
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		 * the synchronization semaphores twice here.
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		 * take the synchronization semaphores twice here.
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * ixgbe_acquire_swfw_sync_X540 - Acquire SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * @mask: Mask to specify which semaphore to acquire
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * Acquires the SWFW semaphore thought the SW_FW_SYNC register for
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		 * SW NVM semaphore bit is used for access to all
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		if (ixgbe_get_swfw_sync_semaphore(hw))
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:			ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:			ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:			if (ixgbe_get_swfw_sync_semaphore(hw))
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:			ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * ixgbe_release_swfw_sync_X540 - Release SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * @mask: Mask to specify which semaphore to release
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * Releases the SWFW semaphore through the SW_FW_SYNC register
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	ixgbe_get_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * ixgbe_get_nvm_semaphore - Get hardware semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * Sets the hardware semaphores so SW/FW can gain control of shared resources
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw)
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	/* Get SMBI software semaphore between device drivers first */
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		 * set and we have the semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	/* Now get the semaphore between SW/FW through the REGSMP bit */
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		hw_dbg(hw, "Software semaphore SMBI between device drivers not granted.\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * ixgbe_release_nvm_semaphore - Release hardware semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * This function clears hardware semaphore bits.
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw)
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	/* Release both semaphores by writing 0 to the bits REGSMP and SMBI */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		/* PHY config will finish before releasing the semaphore */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		/* Release the semaphore */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		 * Delay obtaining semaphore again to allow FW access,
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		 * semaphore_delay is in ms usleep_range needs us.
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		usleep_range(hw->eeprom.semaphore_delay * 1000,
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:			     hw->eeprom.semaphore_delay * 2000);
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	/* Release the semaphore */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	/* Delay obtaining semaphore again to allow FW access,
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	 * semaphore_delay is in ms usleep_range needs us.
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	usleep_range(hw->eeprom.semaphore_delay * 1000,
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		     hw->eeprom.semaphore_delay * 2000);
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	/* If LESM is on then we need to hold the SW/FW semaphore. */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	/* Free the SW/FW semaphore as we either grabbed it here or
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c: * full pipeline reset.  Note - We must hold the SW/FW semaphore before writing
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c: * to AUTOC, so this function assumes the semaphore is held.
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		/* Need the SW/FW semaphore around AUTOC writes if 82599 and
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		/* Set default semaphore delay to 10ms which is a well
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		eeprom->semaphore_delay = 10;
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	 * We cannot hold synchronization semaphores for too long
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	 * We cannot hold synchronization semaphores for too long
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  ixgbe_get_eeprom_semaphore - Get hardware semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  Sets the hardware semaphores so EEPROM access can occur for bit-bang method
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	/* Get SMBI software semaphore between device drivers first */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * set and we have the semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * above to get the semaphore may have succeeded, and if there
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * was a timeout, we should unconditionally clear the semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		ixgbe_release_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * set and we have the semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	/* Now get the semaphore between SW/FW through the SWESMBI bit */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:			/* Set the SW EEPROM semaphore bit to request access */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:			 * semaphore.
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * Release semaphores and return error if SW EEPROM semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:			hw_dbg(hw, "SWESMBI Software EEPROM semaphore not granted.\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:			ixgbe_release_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		hw_dbg(hw, "Software semaphore SMBI between device drivers not granted.\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  ixgbe_release_eeprom_semaphore - Release hardware semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  This function clears hardware semaphore bits.
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw)
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	/* Release both semaphores by writing 0 to the bits SWESMBI and SMBI */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  ixgbe_release_eeprom - Release EEPROM, release semaphores
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	 * Delay before attempt to obtain semaphore again to allow FW
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	 * access. semaphore_delay is in ms we need us for usleep_range
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	usleep_range(hw->eeprom.semaphore_delay * 1000,
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		     hw->eeprom.semaphore_delay * 2000);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  ixgbe_acquire_swfw_sync - Acquire SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  @mask: Mask to specify which semaphore to acquire
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  Acquires the SWFW semaphore through the GSSR register for the specified
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * SW NVM semaphore bit is used for access to all
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		if (ixgbe_get_eeprom_semaphore(hw))
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:			ixgbe_release_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:			ixgbe_release_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  ixgbe_release_swfw_sync - Release SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  @mask: Mask to specify which semaphore to release
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  Releases the SWFW semaphore through the GSSR register for the specified
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	ixgbe_get_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	ixgbe_release_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.
drivers/net/ethernet/intel/igb/e1000_82575.c:	/* Allow a single clear of the SW semaphore on I210 and newer */
drivers/net/ethernet/intel/igb/e1000_82575.c:		dev_spec->clear_semaphore_once = true;
drivers/net/ethernet/intel/igb/e1000_82575.c: *  Acquire the necessary semaphores for exclusive access to the EEPROM.
drivers/net/ethernet/intel/igb/e1000_82575.c: *  then release the semaphores acquired.
drivers/net/ethernet/intel/igb/e1000_82575.c: *  igb_acquire_swfw_sync_82575 - Acquire SW/FW semaphore
drivers/net/ethernet/intel/igb/e1000_82575.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/igb/e1000_82575.c: *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/igb/e1000_82575.c:		if (igb_get_hw_semaphore(hw)) {
drivers/net/ethernet/intel/igb/e1000_82575.c:		igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_82575.c:	igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_82575.c: *  igb_release_swfw_sync_82575 - Release SW/FW semaphore
drivers/net/ethernet/intel/igb/e1000_82575.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/igb/e1000_82575.c: *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/igb/e1000_82575.c:	while (igb_get_hw_semaphore(hw) != 0)
drivers/net/ethernet/intel/igb/e1000_82575.c:	igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_82575.c:	/* Release semaphore */
drivers/net/ethernet/intel/igb/e1000_hw.h:	bool clear_semaphore_once;
drivers/net/ethernet/intel/igb/e1000_mac.c: *  igb_get_hw_semaphore - Acquire hardware semaphore
drivers/net/ethernet/intel/igb/e1000_mac.c: *  Acquire the HW semaphore to access the PHY or NVM
drivers/net/ethernet/intel/igb/e1000_mac.c:s32 igb_get_hw_semaphore(struct e1000_hw *hw)
drivers/net/ethernet/intel/igb/e1000_mac.c:	/* Get the SW semaphore */
drivers/net/ethernet/intel/igb/e1000_mac.c:	/* Get the FW semaphore. */
drivers/net/ethernet/intel/igb/e1000_mac.c:		/* Release semaphores */
drivers/net/ethernet/intel/igb/e1000_mac.c:		igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_mac.c: *  igb_put_hw_semaphore - Release hardware semaphore
drivers/net/ethernet/intel/igb/e1000_mac.c: *  Release hardware semaphore used to access the PHY or NVM
drivers/net/ethernet/intel/igb/e1000_mac.c:void igb_put_hw_semaphore(struct e1000_hw *hw)
drivers/net/ethernet/intel/igb/e1000_mac.h:s32  igb_get_hw_semaphore(struct e1000_hw *hw);
drivers/net/ethernet/intel/igb/e1000_mac.h:void igb_put_hw_semaphore(struct e1000_hw *hw);
drivers/net/ethernet/intel/igb/e1000_i210.c: * igb_get_hw_semaphore_i210 - Acquire hardware semaphore
drivers/net/ethernet/intel/igb/e1000_i210.c: *  Acquire the HW semaphore to access the PHY or NVM
drivers/net/ethernet/intel/igb/e1000_i210.c:static s32 igb_get_hw_semaphore_i210(struct e1000_hw *hw)
drivers/net/ethernet/intel/igb/e1000_i210.c:	/* Get the SW semaphore */
drivers/net/ethernet/intel/igb/e1000_i210.c:		/* In rare circumstances, the SW semaphore may already be held
drivers/net/ethernet/intel/igb/e1000_i210.c:		 * unintentionally. Clear the semaphore once before giving up.
drivers/net/ethernet/intel/igb/e1000_i210.c:		if (hw->dev_spec._82575.clear_semaphore_once) {
drivers/net/ethernet/intel/igb/e1000_i210.c:			hw->dev_spec._82575.clear_semaphore_once = false;
drivers/net/ethernet/intel/igb/e1000_i210.c:			igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_i210.c:		/* If we do not have the semaphore here, we have to give up. */
drivers/net/ethernet/intel/igb/e1000_i210.c:	/* Get the FW semaphore. */
drivers/net/ethernet/intel/igb/e1000_i210.c:		/* Release semaphores */
drivers/net/ethernet/intel/igb/e1000_i210.c:		igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_i210.c: *  Acquire the necessary semaphores for exclusive access to the EEPROM.
drivers/net/ethernet/intel/igb/e1000_i210.c: *  then release the semaphores acquired.
drivers/net/ethernet/intel/igb/e1000_i210.c: *  igb_acquire_swfw_sync_i210 - Acquire SW/FW semaphore
drivers/net/ethernet/intel/igb/e1000_i210.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/igb/e1000_i210.c: *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/igb/e1000_i210.c:		if (igb_get_hw_semaphore_i210(hw)) {
drivers/net/ethernet/intel/igb/e1000_i210.c:		igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_i210.c:	igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_i210.c: *  igb_release_swfw_sync_i210 - Release SW/FW semaphore
drivers/net/ethernet/intel/igb/e1000_i210.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/igb/e1000_i210.c: *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/igb/e1000_i210.c:	while (igb_get_hw_semaphore_i210(hw))
drivers/net/ethernet/intel/igb/e1000_i210.c:	igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_i210.c: *  Uses necessary synchronization semaphores.
drivers/net/ethernet/intel/igb/e1000_i210.c:	/* We cannot hold synchronization semaphores for too long,
drivers/net/ethernet/intel/igb/e1000_i210.c:	/* We cannot hold synchronization semaphores for too long,
drivers/net/ethernet/intel/igb/e1000_i210.c:		/* Replace the read function with semaphore grabbing with
drivers/net/ethernet/intel/igb/e1000_i210.c:		 * We have semaphore taken already here.
drivers/net/ethernet/intel/igb/e1000_i210.c:		 * semaphores twice here.
drivers/net/ethernet/intel/igb/e1000_phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/igb/e1000_phy.c: *  semaphores before exiting.
drivers/net/ethernet/intel/igb/e1000_phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/igb/e1000_phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/igb/e1000_phy.c: *  semaphore (if necessary) and read/set/write the device control reset
drivers/net/ethernet/intel/igb/e1000_phy.c: *  reset and release the semaphore (if necessary).
drivers/net/ethernet/intel/igb/e1000_phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/igb/e1000_phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/igb/e1000_phy.c: *  Acquires semaphore, if necessary, then reads the data in the PHY register
drivers/net/ethernet/intel/igb/e1000_phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/toshiba/spider_net.c:	/* we don't use semaphores to wait for an SPIDER_NET_GPROPCMPINT
drivers/net/ethernet/toshiba/spider_net.c:		/* we don't use semaphores, as we poll for the completion
drivers/net/ethernet/micrel/ksz884x.c:	struct semaphore proc_sem;
drivers/net/ethernet/ibm/emac/core.c:/* Process ctx, rtnl_lock semaphore */
drivers/net/ethernet/ibm/emac/core.c:/* Process ctx, rtnl_lock semaphore */
drivers/net/ethernet/ibm/emac/core.c:/* Process ctx, rtnl_lock semaphore */
drivers/net/ethernet/ti/davinci_emac.c:#include <linux/semaphore.h>
drivers/net/ethernet/tehuti/tehuti.c: * can have few of them). So all drivers use semaphore register to choose one
drivers/net/ethernet/neterion/vxge/vxge-main.h: * #define VXGE_DEBUG_SEM : debug semaphore
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	IOCPF_E_SEMLOCKED	= 10,   /*!< h/w semaphore is locked	*/
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	BFA_IOCPF_SEMWAIT	= 2,	/*!< Waiting for IOC h/w semaphore */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:/* Awaiting h/w semaphore to continue with version check. */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:/* Request for semaphore. */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:/* Awaiting semaphore for h/w initialzation. */
drivers/net/ethernet/brocade/bna/bfa_ioc.c: * Holding hardware semaphore lock.
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	/* Spin on init semaphore to serialize. */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 * Try to lock and then unlock the semaphore.
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	/* Unlock init semaphore */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 * First read to the semaphore register will return 0, subsequent reads
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 *  Hold semaphore to serialize pll init and fwtrc.
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 * release semaphore
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 *  Hold semaphore so that nobody can access the chip during init.
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 *  release semaphore.
drivers/net/ethernet/brocade/bna/bfa_ioc_ct.c:	 * IOC semaphore registers and serialization
drivers/net/ethernet/brocade/bna/bfa_ioc_ct.c:	 * IOC semaphore registers and serialization
drivers/net/ethernet/brocade/bna/bfa_ioc_ct.c:/* Cleanup hw semaphore and usecnt registers */
drivers/net/ethernet/brocade/bna/bfa_ioc_ct.c:	 * semaphore (in bfa_iocpf_sm_semwait()).
drivers/net/ethernet/brocade/bna/bfi_reg.h: * Name semaphore registers based on usage
drivers/net/ethernet/brocade/bna/bfi_reg.h: * CT2 semaphore register locations changed
drivers/net/ethernet/brocade/bna/bfa_defs.h:	BFA_IOC_SEMWAIT		= 3,	/*!< Waiting for IOC h/w semaphore */
drivers/net/ethernet/nvidia/forcedeth.c:/* The mgmt unit and driver use a semaphore to access the phy during init */
drivers/net/ethernet/nvidia/forcedeth.c:		/* verify that semaphore was acquired */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:#include <linux/semaphore.h>
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:	struct semaphore			stats_sema;
drivers/net/ethernet/qlogic/qla3xxx.h:/* semaphoreReg */
drivers/net/ethernet/qlogic/qla3xxx.h:	u32 semaphoreReg;
drivers/net/ethernet/qlogic/qla3xxx.c:		       &port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/qla3xxx.c:		value = readl(&port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/qla3xxx.c:	writel(sem_mask, &port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/qla3xxx.c:	readl(&port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/qla3xxx.c:	writel((sem_mask | sem_bits), &port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/qla3xxx.c:	value = readl(&port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:	/* Acquire semaphore before accessing CRB */
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:	/* Release semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	PROC_ADDR = 0,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	PROC_DATA = 0x04,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	ICB_RID = 0x1c,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	ICB_L = 0x20,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	ICB_H = 0x24,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	GPIO_1 = 0x68,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	GPIO_2 = 0x6c,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	GPIO_3 = 0x70,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	XGMAC_ADDR = 0x78,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	XGMAC_DATA = 0x7c,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	FLASH_ADDR = 0x88,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	FLASH_DATA = 0x8c,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	MAC_ADDR_IDX = 0xa8,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	MAC_ADDR_DATA = 0xac,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	PRB_MX_ADDR = 0xf8,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	PRB_MX_DATA = 0xfc,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:/* Maximum of 4 functions whose semaphore registeres are
drivers/net/ethernet/qlogic/qlge/qlge.h:	/* semaphore register for all 5 functions */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:/* This hardware semaphore causes exclusive access to
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		/* Another function has the semaphore, so
drivers/net/ethernet/qlogic/qlge/qlge_main.c:			   "Another function has the semaphore, so wait for the port init bit to come ready.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	netif_info(qdev, link, qdev->ndev, "Got xgmac semaphore!.\n");
drivers/net/ethernet/qlogic/qlge/qlge_dbg.c:	/* Get the semaphore registers for all 5 functions */
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c: * Caller must hold PROC_ADDR semaphore.
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	/* Acquire semaphore before accessing CRB */
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	/* Release semaphore */
drivers/net/ethernet/mellanox/mlx4/mlx4.h:#include <linux/semaphore.h>
drivers/net/ethernet/mellanox/mlx4/mlx4.h:	struct semaphore	poll_sem;
drivers/net/ethernet/mellanox/mlx4/mlx4.h:	struct semaphore	event_sem;
drivers/net/ethernet/mellanox/mlx4/reset.c:	/* grab HW semaphore to lock out flash updates */
drivers/net/ethernet/mellanox/mlx4/reset.c:		mlx4_err(dev, "Failed to obtain HW semaphore, aborting\n");
drivers/net/ethernet/mellanox/mlx4/cmd.c:#include <linux/semaphore.h>
drivers/net/ethernet/mellanox/mlx4/mcg.c: * Caller must hold MCG table semaphore.  gid and mgm parameters must
drivers/net/ethernet/mellanox/mlx5/core/cmd.c:	struct semaphore *sem;
drivers/net/ethernet/mellanox/mlx5/core/cmd.c:			struct semaphore *sem;
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:	 * issue an FLR because of a self- deadlock on the device semaphore.
drivers/net/wireless/ath/ath6kl/core.h:	struct semaphore sem;
drivers/net/wireless/ath/ath10k/htc.h:#include <linux/semaphore.h>
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:#include <linux/semaphore.h>
drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c:	struct semaphore tx_seq_lock;	/* protect bus->tx_seq */
drivers/net/wireless/prism54/isl_ioctl.c: * schedule_work(), thus we can as well use sleeping semaphore
drivers/net/wireless/prism54/islpci_dev.h:        struct rw_semaphore mib_sem;
drivers/net/wireless/prism54/islpci_dev.h:	/* The first is accessed under semaphore locking.
drivers/net/wireless/airo.c:	struct semaphore sem;
drivers/net/wireless/iwlwifi/iwl-eeprom-read.c: * The device's EEPROM semaphore prevents conflicts between driver and uCode
drivers/net/wireless/iwlwifi/iwl-eeprom-read.c: * weren't arbitrated by the semaphore.
drivers/net/wireless/iwlwifi/iwl-eeprom-read.c:static int iwl_eeprom_acquire_semaphore(struct iwl_trans *trans)
drivers/net/wireless/iwlwifi/iwl-eeprom-read.c:		/* Request semaphore */
drivers/net/wireless/iwlwifi/iwl-eeprom-read.c:					 "Acquired semaphore after %d tries.\n",
drivers/net/wireless/iwlwifi/iwl-eeprom-read.c:static void iwl_eeprom_release_semaphore(struct iwl_trans *trans)
drivers/net/wireless/iwlwifi/iwl-eeprom-read.c:	ret = iwl_eeprom_acquire_semaphore(trans);
drivers/net/wireless/iwlwifi/iwl-eeprom-read.c:		IWL_ERR(trans, "Failed to acquire EEPROM semaphore.\n");
drivers/net/wireless/iwlwifi/iwl-eeprom-read.c:	iwl_eeprom_release_semaphore(trans);
drivers/net/wireless/iwlwifi/iwl-eeprom-read.c:	iwl_eeprom_release_semaphore(trans);
drivers/net/wireless/ipw2x00/ipw2200.c:	/* TODO: We should use semaphores or locks for access to priv */
drivers/net/wireless/cw1200/scan.h:#include <linux/semaphore.h>
drivers/net/wireless/cw1200/scan.h:	struct semaphore lock;
drivers/net/wireless/mwifiex/scan.c:		dev_err(priv->adapter->dev, "%s: acquire semaphore\n",
drivers/net/wireless/mwifiex/main.h:#include <linux/semaphore.h>
drivers/net/wireless/mwifiex/main.h:	struct semaphore async_sem;
drivers/net/wireless/mwifiex/main.h:	struct semaphore *card_sem;
drivers/net/wireless/mwifiex/main.h:int mwifiex_add_card(void *, struct semaphore *, struct mwifiex_if_ops *, u8);
drivers/net/wireless/mwifiex/main.h:int mwifiex_remove_card(struct mwifiex_adapter *, struct semaphore *);
drivers/net/wireless/mwifiex/usb.c:static struct semaphore add_remove_card_sem;
drivers/net/wireless/mwifiex/usb.c: * This initiates the semaphore and registers the device with
drivers/net/wireless/mwifiex/pcie.c:static struct semaphore add_remove_card_sem;
drivers/net/wireless/mwifiex/pcie.c: * This initiates the semaphore and registers the device with
drivers/net/wireless/mwifiex/main.c:	struct semaphore *sem = adapter->card_sem;
drivers/net/wireless/mwifiex/main.c:mwifiex_add_card(void *card, struct semaphore *sem,
drivers/net/wireless/mwifiex/main.c:int mwifiex_remove_card(struct mwifiex_adapter *adapter, struct semaphore *sem)
drivers/net/wireless/mwifiex/sdio.c:static struct semaphore add_remove_card_sem;
drivers/net/wireless/mwifiex/sdio.c: * This initiates the semaphore and registers the device with
drivers/net/wireless/iwlegacy/4965.c: * The device's EEPROM semaphore prevents conflicts between driver and uCode
drivers/net/wireless/iwlegacy/4965.c: * weren't arbitrated by the semaphore.
drivers/net/wireless/iwlegacy/4965.c:il4965_eeprom_acquire_semaphore(struct il_priv *il)
drivers/net/wireless/iwlegacy/4965.c:		/* Request semaphore */
drivers/net/wireless/iwlegacy/4965.c:il4965_eeprom_release_semaphore(struct il_priv *il)
drivers/net/wireless/iwlegacy/4965.c:	.eeprom_acquire_semaphore = il4965_eeprom_acquire_semaphore,
drivers/net/wireless/iwlegacy/4965.c:	.eeprom_release_semaphore = il4965_eeprom_release_semaphore,
drivers/net/wireless/iwlegacy/4965.h:int il4965_eeprom_acquire_semaphore(struct il_priv *il);
drivers/net/wireless/iwlegacy/4965.h:void il4965_eeprom_release_semaphore(struct il_priv *il);
drivers/net/wireless/iwlegacy/common.h:	int (*eeprom_acquire_semaphore) (struct il_priv *il);
drivers/net/wireless/iwlegacy/common.h:	void (*eeprom_release_semaphore) (struct il_priv *il);
drivers/net/wireless/iwlegacy/common.c:	ret = il->ops->eeprom_acquire_semaphore(il);
drivers/net/wireless/iwlegacy/common.c:		IL_ERR("Failed to acquire EEPROM semaphore.\n");
drivers/net/wireless/iwlegacy/common.c:	il->ops->eeprom_release_semaphore(il);
drivers/net/wireless/iwlegacy/3945.c:il3945_eeprom_acquire_semaphore(struct il_priv *il)
drivers/net/wireless/iwlegacy/3945.c:il3945_eeprom_release_semaphore(struct il_priv *il)
drivers/net/wireless/iwlegacy/3945.c:	.eeprom_acquire_semaphore = il3945_eeprom_acquire_semaphore,
drivers/net/wireless/iwlegacy/3945.c:	.eeprom_release_semaphore = il3945_eeprom_release_semaphore,
drivers/net/wireless/zd1211rw/zd_mac.c:	 * Try very hard to release device beacon semaphore, as otherwise
drivers/net/wireless/zd1211rw/zd_mac.c:	/* semaphore stuck, reset device to avoid fw freeze later */
drivers/s390/block/dcssblk.c:static struct rw_semaphore dcssblk_devices_sem;
drivers/s390/block/dcssblk.c: * device needs to be enqueued before the semaphore is
drivers/block/rsxx/rsxx_priv.h:#include <linux/semaphore.h>
drivers/block/drbd/drbd_int.h: * maybe re-implement using semaphores? */
drivers/block/zram/zram_drv.h:	struct rw_semaphore init_lock;
drivers/block/paride/paride.h:	wait_queue_head_t parq;     /* semaphore for parport sharing */
drivers/block/amiflop.c:/* Hardware semaphore */
drivers/block/amiflop.c:/* returns true when we would get the semaphore */
drivers/block/umem.c:	 * If we find a descriptor without DMA_COMPLETE in the semaphore, then
drivers/block/mtip32xx/mtip32xx.h:	struct semaphore cmd_slot_unal;
drivers/block/rbd.c:	struct rw_semaphore     header_rwsem;
fs/block_dev.c: * If a superblock is found on this device, we take the s_umount semaphore
fs/fat/fat.h:	struct rw_semaphore truncate_lock; /* protect bmap against truncate */
fs/ext2/ext2.h:	struct rw_semaphore xattr_sem;
fs/ext2/inode.c:	 * if the chain has been changed after we grab the semaphore,
fs/xfs/xfs_buf.h:	 * hit to be fully processed. The semaphore straddles the cacheline
fs/xfs/xfs_buf.h:	 * which is the only bit that is touched if we hit the semaphore
fs/xfs/xfs_buf.h:	struct semaphore	b_sema;		/* semaphore for lockables */
fs/xfs/mrlock.h:	struct rw_semaphore	mr_lock;
fs/xfs/xfs_super.c:	 * the rw_semaphore of the VFS superblock is locked
fs/xfs/xfs_linux.h:#include <linux/semaphore.h>
fs/xfs/xfs_log_priv.h:	struct rw_semaphore	xc_ctx_lock ____cacheline_aligned_in_smp;
fs/lockd/svclock.c: * to a file's list of blocked locks through a semaphore. The global
fs/lockd/svclock.c: * then sleep on the file semaphore without disrupting e.g. the nfs client).
fs/lockd/svclock.c:	/* Technically, we should down the file semaphore here. Since we
fs/jfs/jfs_incore.h:	struct rw_semaphore rdwrlock;
fs/jfs/jfs_incore.h:	struct rw_semaphore xattr_sem;
fs/cifs/cifsglob.h:	struct rw_semaphore lock_sem;	/* protect the fields above */
fs/cifs/cifsglob.h: *                  protected by spinlocks or semaphores.
fs/afs/internal.h:	struct rw_semaphore	vl_sem;		/* volume management serialisation semaphore */
fs/afs/internal.h:	struct rw_semaphore	sem;		/* access lock */
fs/afs/internal.h:	struct rw_semaphore	server_sem;	/* lock for accessing current server */
fs/afs/internal.h:extern struct rw_semaphore afs_proc_cells_sem;
fs/gfs2/incore.h:	struct rw_semaphore i_rw_mutex;
fs/gfs2/incore.h:	struct rw_semaphore sd_log_flush_lock;
fs/ext4/ext4.h:	struct rw_semaphore xattr_sem;
fs/ext4/ext4.h:	struct rw_semaphore i_data_sem;
fs/ext4/ext4.h:	struct rw_semaphore alloc_sem;
fs/ext4/mballoc.c: * given some of them can block, we'd have to use something like semaphores
fs/ext4/inode.c:	 * once the inode's allocation semaphore is taken.
fs/ext4/move_extent.c:		 * Up semaphore to avoid following problems:
fs/ceph/mds_client.h:	struct rw_semaphore     snap_rwsem;
fs/nilfs2/the_nilfs.h: * @ns_sem: semaphore for shared states
fs/nilfs2/the_nilfs.h: * @ns_segctor_sem: semaphore protecting log write
fs/nilfs2/the_nilfs.h:	struct rw_semaphore	ns_sem;
fs/nilfs2/the_nilfs.h:	 * constructor must lock a segment semaphore while accessing these
fs/nilfs2/the_nilfs.h:	struct rw_semaphore	ns_segctor_sem;
fs/nilfs2/mdt.h: * @mi_sem: reader/writer semaphore for meta data operations
fs/nilfs2/mdt.h:	struct rw_semaphore	mi_sem;
fs/nilfs2/nilfs.h: * @xattr_sem: semaphore for extended attributes processing
fs/nilfs2/nilfs.h:	struct rw_semaphore xattr_sem;
fs/nilfs2/nilfs.h: * @ti_garbage:	List of inode to be put when releasing semaphore
fs/nilfs2/segment.c: * nilfs_transaction_begin() acquires a reader/writer semaphore, called
fs/nilfs2/segment.c: * the segment semaphore, to make a segment construction and write tasks
fs/nilfs2/segment.c: * deadlock, the semaphore is only acquired or released in the outermost call.
fs/nilfs2/segment.c: * nilfs_transaction_commit() releases the read semaphore which is
fs/nilfs2/segment.c: * semaphore.
fs/nilfs2/segment.c: * Caller must hold the segment semaphore.
fs/nilfs2/bmap.h: * @b_sem: semaphore
fs/nilfs2/bmap.h:	struct rw_semaphore b_sem;
fs/nilfs2/bmap.h:/* Assume that bmap semaphore is locked. */
fs/nilfs2/bmap.h:/* Assume that bmap semaphore is locked. */
fs/nilfs2/bmap.h:/* Assume that bmap semaphore is locked. */
fs/fs-writeback.c: *   completion. Caller need not hold sb s_umount semaphore.
fs/fs-writeback.c: *   Caller need not hold sb s_umount semaphore.
fs/dcache.c: * had better be holding the parent directory semaphore.
fs/fscache/internal.h:extern struct rw_semaphore fscache_addremove_sem;
fs/fscache/cache.c: * - the cache addremove semaphore must be at least read-locked by the caller
fs/nfs/nfs4proc.c: * NOTE: Caller must be holding the sp->so_owner semaphore!
fs/nfs/direct.c: * semaphore and updating the i_size.  The NFS server will set
fs/pipe.c:/* Drop the inode semaphore and wait for a pipe event, atomically */
fs/pipe.c:	/* Reading only -- no need for acquiring the semaphore.  */
fs/9p/v9fs.h:	struct rw_semaphore rename_sem;
fs/reiserfs/stree.c: *  semaphores.
fs/reiserfs/journal.c:#include <linux/semaphore.h>
fs/reiserfs/reiserfs.h:	struct rw_semaphore i_xattr_sem;
fs/reiserfs/reiserfs.h:reiserfs_down_read_safe(struct rw_semaphore *sem, struct super_block *s)
fs/f2fs/f2fs.h:	struct rw_semaphore i_sem;	/* protect fi info */
fs/f2fs/f2fs.h:	struct rw_semaphore io_rwsem;	/* blocking op for bio */
fs/f2fs/f2fs.h:	struct rw_semaphore cp_rwsem;		/* blocking FS operations */
fs/dlm/dlm_internal.h:	struct rw_semaphore	ls_in_recovery;	/* block local requests */
fs/dlm/dlm_internal.h:	struct rw_semaphore	ls_recv_active;	/* block dlm_recv */
fs/dlm/dlm_internal.h:	struct rw_semaphore	ls_root_sem;	/* protect root_list */
fs/dlm/dlm_internal.h: * should do down_write() on the in_recovery rw_semaphore. (doing down_write
fs/dlm/dlm_internal.h: * LSFL_RECOVER_LOCK - dlm_recoverd holds the in_recovery rw_semaphore.
fs/dlm/dlm_internal.h: * rw_semaphore and clears it after it has released the rw_semaphore.
fs/ocfs2/dcache.c: * Call this function with the parent dir semaphore and the parent dir
fs/ocfs2/dcache.c: * The dir semaphore will protect us from having to worry about
fs/ocfs2/journal.c: * WARNING: This will not release any semaphores or disk locks taken
fs/ocfs2/refcounttree.h:	struct rw_semaphore rf_sem;
fs/ocfs2/aops.c:		 * any additional semaphores or cluster locks.
fs/ocfs2/journal.h:	struct rw_semaphore       j_trans_barrier;
fs/ocfs2/inode.h:	struct rw_semaphore		ip_alloc_sem;
fs/ocfs2/inode.h:	struct rw_semaphore		ip_xattr_sem;
fs/ncpfs/ncp_fs_sb.h:	struct rw_semaphore auth_rwsem;
fs/btrfs/volumes.c:#include <linux/semaphore.h>
fs/btrfs/ctree.h:#include <linux/semaphore.h>
fs/btrfs/ctree.h:	struct rw_semaphore groups_sem;
fs/btrfs/ctree.h:	struct rw_semaphore data_rwsem;
fs/btrfs/ctree.h:	struct rw_semaphore commit_root_sem;
fs/btrfs/ctree.h:	struct rw_semaphore cleanup_work_sem;
fs/btrfs/ctree.h:	struct rw_semaphore subvol_sem;
fs/btrfs/ctree.h:	struct semaphore uuid_tree_rescan_sem;
fs/btrfs/extent-tree.c:	 * are still on the list after taking the semaphore
fs/btrfs/disk-io.c:#include <linux/semaphore.h>
fs/udf/udf_i.h:	struct rw_semaphore	i_data_sem;
fs/fuse/fuse_i.h:	/** Read/write semaphore to hold when accessing sb. */
fs/fuse/fuse_i.h:	struct rw_semaphore killsb;
fs/affs/affs.h:	struct semaphore i_link_lock;		/* Protects internal inode access. */
fs/affs/affs.h:	struct semaphore i_ext_lock;		/* Protects internal inode access. */
fs/ext3/ext3.h:	struct rw_semaphore xattr_sem;
fs/ext3/inode.c:	 * if the chain has been changed after we grab the semaphore,
fs/namei.c: * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)
fs/ubifs/ubifs.h:	struct rw_semaphore commit_sem;
fs/ubifs/commit.c: * by holding the commit semaphore down for writing. As few I/O operations as
fs/ubifs/commit.c: * written are merely identified. During commit end, the commit semaphore is no
fs/configfs/dir.c: * the way out.  They assume that the proper semaphores are held, they
fs/configfs/dir.c: * callback.  The subsystem semaphore MUST be held by the caller, and
fs/configfs/dir.c: * do not need the subsystem semaphore.  Holding configfs_dirent_lock helps
fs/configfs/configfs_internal.h:extern struct rw_semaphore configfs_rename_sem;
fs/ntfs/volume.h:	struct rw_semaphore mftbmp_lock; /* Lock for serializing accesses to the
fs/ntfs/volume.h:	struct rw_semaphore lcnbmp_lock; /* Lock for serializing accesses to the
fs/ntfs/super.c: * NOTE: Caller must hold mftbmp_lock rw_semaphore for reading or writing.
fs/ntfs/runlist.h:	struct rw_semaphore lock;
fs/ntfs/aops.h: * a {rw_}semaphore or other means of serialization. A spin lock cannot be
fs/jffs2/README.Locking:This read/write semaphore protects against concurrent access to the
fs/jffs2/README.Locking:This read/write semaphore protects against concurrent access to the
fs/jffs2/README.Locking:In read-only path, write-semaphore is too much exclusion. It's enough
fs/jffs2/README.Locking:by read-semaphore. But you must hold write-semaphore when updating,
fs/jffs2/README.Locking:when updating such a object is necessary under holding read semaphore.
fs/jffs2/README.Locking:For example, do_jffs2_getxattr() holds read-semaphore to scan xref and
fs/jffs2/README.Locking:xdatum at first. But it retries this process with holding write-semaphore
fs/jffs2/README.Locking:after release read-semaphore, if it's necessary to load name/value pair
fs/jffs2/jffs2_fs_sb.h:	struct rw_semaphore wbuf_sem;	/* Protects the write buffer */
fs/jffs2/jffs2_fs_sb.h:	struct rw_semaphore xattr_sem;
fs/jffs2/nodemgmt.c: *	allocation semaphore, to prevent more than one allocation from being
fs/jffs2/nodemgmt.c: *	active at any time. The semaphore is later released by jffs2_commit_allocation()
fs/jffs2/xattr.c: *   is used to initialize semaphore and list_head, and some variables.
fs/jffs2/fs.c:	   generic inode semaphore. */
fs/jffs2/gc.c:	/* OK. Looks safe. And nobody can get us now because we have the semaphore. Move the block */
include/keys/user-type.h: *   - the payload must be read with RCU procedures or with the key semaphore
include/keys/user-type.h: *   - the payload may only be replaced with the key semaphore write-locked
include/video/udlfb.h:	struct semaphore limit_sem;
include/target/target_core_base.h:	struct semaphore	caw_sem;
include/asm-generic/rwsem.h: * R/W semaphores originally for PPC using the stuff in lib/rwsem.c.
include/asm-generic/rwsem.h: * the semaphore definition
include/asm-generic/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline int __down_read_trylock(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline void __down_write_nested(struct rw_semaphore *sem, int subclass)
include/asm-generic/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline int __down_write_trylock(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline void rwsem_atomic_add(long delta, struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline long rwsem_atomic_update(long delta, struct rw_semaphore *sem)
include/rdma/ib_verbs.h:	struct rw_semaphore	mutex;		/* protects .live */
include/sound/core.h:#include <linux/rwsem.h>		/* struct rw_semaphore */
include/sound/core.h:	struct rw_semaphore controls_rwsem;	/* controls list lock */
include/scsi/scsi_transport_spi.h:	struct mutex dv_mutex; /* semaphore to serialise dv */
include/linux/hid.h:#include <linux/semaphore.h>
include/linux/hid.h:	struct semaphore driver_lock;					/* protects the current driver, except during input */
include/linux/hid.h:	struct semaphore driver_input_lock;				/* protects the current driver */
include/linux/cgroup.h:extern struct rw_semaphore css_set_rwsem;
include/linux/eventpoll.h:	 * Fast check to avoid the get/release of the semaphore. Since
include/linux/eventpoll.h:	 * we're doing this outside the semaphore lock, it might return
include/linux/eventpoll.h:	 * to avoid the semaphore lock. False positives simply cannot happen
include/linux/fb.h: * semaphore held, this is the only suitable locking mechanism we have
include/linux/sem.h:/* One sem_array data structure for each set of semaphores in the system. */
include/linux/sem.h:	struct sem		*sem_base;	/* ptr to first semaphore in array */
include/linux/sem.h:	int			sem_nsems;	/* no. of semaphores in array */
include/linux/lockd/lockd.h:	struct rw_semaphore	h_rwsem;	/* Reboot recovery lock */
include/linux/cpufreq.h:	 * The rules for this semaphore:
include/linux/cpufreq.h:	 *   do a down_read on this semaphore.
include/linux/cpufreq.h:	struct rw_semaphore	rwsem;
include/linux/pipe_fs_i.h:/* Drop the inode semaphore and wait for a pipe event, atomically */
include/linux/tty_ldisc.h: * the semaphore definition
include/linux/tty_ldisc.h:struct ld_semaphore {
include/linux/tty_ldisc.h:extern void __init_ldsem(struct ld_semaphore *sem, const char *name,
include/linux/tty_ldisc.h:extern int ldsem_down_read(struct ld_semaphore *sem, long timeout);
include/linux/tty_ldisc.h:extern int ldsem_down_read_trylock(struct ld_semaphore *sem);
include/linux/tty_ldisc.h:extern int ldsem_down_write(struct ld_semaphore *sem, long timeout);
include/linux/tty_ldisc.h:extern int ldsem_down_write_trylock(struct ld_semaphore *sem);
include/linux/tty_ldisc.h:extern void ldsem_up_read(struct ld_semaphore *sem);
include/linux/tty_ldisc.h:extern void ldsem_up_write(struct ld_semaphore *sem);
include/linux/tty_ldisc.h:extern int ldsem_down_read_nested(struct ld_semaphore *sem, int subclass,
include/linux/tty_ldisc.h:extern int ldsem_down_write_nested(struct ld_semaphore *sem, int subclass,
include/linux/nfs_fs.h:	struct rw_semaphore	rwsem;
include/linux/mm.h:extern struct rw_semaphore nommu_region_sem;
include/linux/mm.h:/* These take the mm semaphore themselves */
include/linux/hp_sdc.h:	  struct semaphore *semaphore;	/* Semaphore to sleep on. */
include/linux/hp_sdc.h:#define HP_SDC_ACT_SEMAPHORE    0x20            /* Raise semaphore after */
include/linux/i2o.h:#include <linux/semaphore.h>	/* Needed for MUTEX init macros */
include/linux/i2o.h:	struct semaphore lock;
include/linux/utsname.h:extern struct rw_semaphore uts_sem;
include/linux/rwsem-spinlock.h: * the rw-semaphore definition
include/linux/rwsem-spinlock.h: * - if wait_list is not empty, then there are processes waiting for the semaphore
include/linux/rwsem-spinlock.h:struct rw_semaphore {
include/linux/rwsem-spinlock.h:extern void __down_read(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern int __down_read_trylock(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern void __down_write(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern void __down_write_nested(struct rw_semaphore *sem, int subclass);
include/linux/rwsem-spinlock.h:extern int __down_write_trylock(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern void __up_read(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern void __up_write(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern void __downgrade_write(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern int rwsem_is_locked(struct rw_semaphore *sem);
include/linux/user_namespace.h:	struct rw_semaphore	persistent_keyring_register_sem;
include/linux/ceph/osd_client.h:	struct rw_semaphore    map_sem;
include/linux/mm_types.h:	struct rw_semaphore mmap_sem;
include/linux/sched.h:	struct rw_semaphore group_rwsem;
include/linux/ipc_namespace.h:	struct rw_semaphore rwsem;
include/linux/tty.h:	struct ld_semaphore ldisc_sem;
include/linux/tty.h:	struct rw_semaphore termios_rwsem;
include/linux/syscalls.h:struct semaphore;
include/linux/hil_mlc.h:#include <linux/semaphore.h>
include/linux/hil_mlc.h:	struct semaphore	csem;   /* Raised when loop idle */
include/linux/hil_mlc.h:	struct semaphore	osem;   /* Raised when outpacket dispatched */
include/linux/hil_mlc.h:	struct semaphore	isem;   /* Raised when a packet arrives */
include/linux/mlx5/driver.h:#include <linux/semaphore.h>
include/linux/mlx5/driver.h:	struct semaphore sem;
include/linux/mlx5/driver.h:	struct semaphore pages_sem;
include/linux/usb/hcd.h:extern struct rw_semaphore ehci_cf_port_reset_rwsem;
include/linux/percpu-rwsem.h:struct percpu_rw_semaphore {
include/linux/percpu-rwsem.h:	struct rw_semaphore	rw_sem;
include/linux/percpu-rwsem.h:extern void percpu_down_read(struct percpu_rw_semaphore *);
include/linux/percpu-rwsem.h:extern void percpu_up_read(struct percpu_rw_semaphore *);
include/linux/percpu-rwsem.h:extern void percpu_down_write(struct percpu_rw_semaphore *);
include/linux/percpu-rwsem.h:extern void percpu_up_write(struct percpu_rw_semaphore *);
include/linux/percpu-rwsem.h:extern int __percpu_init_rwsem(struct percpu_rw_semaphore *,
include/linux/percpu-rwsem.h:extern void percpu_free_rwsem(struct percpu_rw_semaphore *);
include/linux/rwsem.h:/* rwsem.h: R/W semaphores, public interface
include/linux/rwsem.h: * Derived from asm-i386/semaphore.h
include/linux/rwsem.h:struct rw_semaphore;
include/linux/rwsem.h:struct rw_semaphore {
include/linux/rwsem.h:extern struct rw_semaphore *rwsem_down_read_failed(struct rw_semaphore *sem);
include/linux/rwsem.h:extern struct rw_semaphore *rwsem_down_write_failed(struct rw_semaphore *sem);
include/linux/rwsem.h:extern struct rw_semaphore *rwsem_wake(struct rw_semaphore *);
include/linux/rwsem.h:extern struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem);
include/linux/rwsem.h:static inline int rwsem_is_locked(struct rw_semaphore *sem)
include/linux/rwsem.h:	struct rw_semaphore name = __RWSEM_INITIALIZER(name)
include/linux/rwsem.h:extern void __init_rwsem(struct rw_semaphore *sem, const char *name,
include/linux/rwsem.h:static inline int rwsem_is_contended(struct rw_semaphore *sem)
include/linux/rwsem.h:extern void down_read(struct rw_semaphore *sem);
include/linux/rwsem.h:extern int down_read_trylock(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void down_write(struct rw_semaphore *sem);
include/linux/rwsem.h:extern int down_write_trylock(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void up_read(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void up_write(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void downgrade_write(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void down_read_nested(struct rw_semaphore *sem, int subclass);
include/linux/rwsem.h:extern void down_write_nested(struct rw_semaphore *sem, int subclass);
include/linux/rwsem.h:extern void _down_write_nest_lock(struct rw_semaphore *sem, struct lockdep_map *nest_lock);
include/linux/rwsem.h:extern void down_read_non_owner(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void up_read_non_owner(struct rw_semaphore *sem);
include/linux/fs.h:#include <linux/semaphore.h>
include/linux/fs.h:	struct rw_semaphore	s_umount;
include/linux/quota.h:	struct rw_semaphore dqptr_sem;		/* serialize ops using quota_info struct, pointers from inode to dquots */
include/linux/security.h: *	@sma contains the semaphore structure
include/linux/security.h: *	deallocate security struct for this semaphore
include/linux/security.h: *	@sma contains the semaphore structure.
include/linux/security.h: *	Check permission when a semaphore is requested through the semget
include/linux/security.h: *	system call.  This hook is only called when returning the semaphore
include/linux/security.h: *	identifier for an existing semaphore, not when a new one must be
include/linux/security.h: *	@sma contains the semaphore structure.
include/linux/security.h: *	Check permission when a semaphore operation specified by @cmd is to be
include/linux/security.h: *	performed on the semaphore @sma.  The @sma may be NULL, e.g. for
include/linux/security.h: *	@sma contains the semaphore structure.  May be NULL.
include/linux/security.h: *	semaphore set @sma.  If the @alter flag is nonzero, the semaphore set
include/linux/security.h: *	@sma contains the semaphore structure.
include/linux/key.h:	struct rw_semaphore	sem;		/* change vs change sem */
include/linux/leds.h:	struct rw_semaphore	 trigger_lock;
include/linux/notifier.h: * They use SRCU (Sleepable Read-Copy Update) instead of rw-semaphores for
include/linux/notifier.h:	struct rw_semaphore rwsem;
include/linux/dmar.h:extern struct rw_semaphore dmar_global_lock;
include/linux/key-type.h:	 * - the key's semaphore will be write-locked by the caller
include/linux/key-type.h:	 * - the key's semaphore will be readlocked by the caller
include/linux/posix-clock.h:	struct rw_semaphore rwsem;
include/linux/semaphore.h: * Please see kernel/semaphore.c for documentation of these functions
include/linux/semaphore.h:struct semaphore {
include/linux/semaphore.h:	struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)
include/linux/semaphore.h:static inline void sema_init(struct semaphore *sem, int val)
include/linux/semaphore.h:	*sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);
include/linux/semaphore.h:	lockdep_init_map(&sem->lock.dep_map, "semaphore->lock", &__key, 0);
include/linux/semaphore.h:extern void down(struct semaphore *sem);
include/linux/semaphore.h:extern int __must_check down_interruptible(struct semaphore *sem);
include/linux/semaphore.h:extern int __must_check down_killable(struct semaphore *sem);
include/linux/semaphore.h:extern int __must_check down_trylock(struct semaphore *sem);
include/linux/semaphore.h:extern int __must_check down_timeout(struct semaphore *sem, long jiffies);
include/linux/semaphore.h:extern void up(struct semaphore *sem);
include/linux/parport.h:#include <linux/semaphore.h>
include/linux/parport.h:	struct semaphore irq;
include/linux/netpoll.h:	struct semaphore dev_lock;
include/linux/mmu_notifier.h: * semaphores. Notifier chains are only changed when all reverse maps and
include/linux/rmap.h:	struct rw_semaphore rwsem;	/* W: modification, R: walking the list */
include/acpi/actypes.h: * Map the OSL Mutex interfaces to binary semaphores.
include/acpi/actypes.h:#define acpi_mutex                      acpi_semaphore
include/acpi/actypes.h:#define acpi_os_create_mutex(out_handle) acpi_os_create_semaphore (1, 1, out_handle)
include/acpi/actypes.h:#define acpi_os_delete_mutex(handle)    (void) acpi_os_delete_semaphore (handle)
include/acpi/actypes.h:#define acpi_os_acquire_mutex(handle,time) acpi_os_wait_semaphore (handle, 1, time)
include/acpi/actypes.h:#define acpi_os_release_mutex(handle)   (void) acpi_os_signal_semaphore (handle, 1)
include/acpi/actypes.h:#ifndef acpi_semaphore
include/acpi/actypes.h:#define acpi_semaphore                  void *
include/acpi/acconfig.h:/* Maximum count for a semaphore object */
include/acpi/platform/acenv.h:/* Type of mutex supported by host. Default is binary semaphores. */
include/acpi/acpiosxf.h:#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_create_semaphore
include/acpi/acpiosxf.h:acpi_os_create_semaphore(u32 max_units,
include/acpi/acpiosxf.h:			 u32 initial_units, acpi_semaphore * out_handle);
include/acpi/acpiosxf.h:#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_delete_semaphore
include/acpi/acpiosxf.h:acpi_status acpi_os_delete_semaphore(acpi_semaphore handle);
include/acpi/acpiosxf.h:#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_wait_semaphore
include/acpi/acpiosxf.h:acpi_os_wait_semaphore(acpi_semaphore handle, u32 units, u16 timeout);
include/acpi/acpiosxf.h:#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_signal_semaphore
include/acpi/acpiosxf.h:acpi_status acpi_os_signal_semaphore(acpi_semaphore handle, u32 units);
include/acpi/acpiosxf.h: * Mutex primitives. May be configured to use semaphores instead via
include/uapi/asm-generic/errno.h:#define	ENAVAIL		119	/* No XENIX semaphores available */
include/uapi/asm-generic/sembuf.h:	unsigned long	sem_nsems;	/* no. of semaphores in array */
include/uapi/linux/sem.h:	struct sem	*sem_base;		/* ptr to first semaphore in array */
include/uapi/linux/sem.h:	unsigned short	sem_nsems;		/* no. of semaphores in array */
include/uapi/linux/sem.h:	unsigned short  sem_num;	/* semaphore index in array */
include/uapi/linux/sem.h:	short		sem_op;		/* semaphore operation */
include/uapi/linux/sem.h:#define SEMMNI  128             /* <= IPCMNI  max # of semaphore identifiers */
include/uapi/linux/sem.h:#define SEMMSL  250             /* <= 8 000 max num of semaphores per id */
include/uapi/linux/sem.h:#define SEMMNS  (SEMMNI*SEMMSL) /* <= INT_MAX max # of semaphores in system */
include/uapi/linux/sem.h:#define SEMVMX  32767           /* <= 32767 semaphore maximum value */
include/uapi/linux/sem.h:#define SEMMAP  SEMMNS          /* # of entries in semaphore map */
include/uapi/linux/sysctl.h: 	KERN_SEM=43,		/* struct: sysv semaphore limits */
include/uapi/linux/capability.h:/* Allow removing semaphores */
include/uapi/linux/capability.h:/* Used instead of CAP_CHOWN to "chown" IPC message queues, semaphores
include/net/sch_generic.h: * root.  This is enforced by holding the RTNL semaphore, which
include/net/sock.h: * mini-semaphore synchronizes multiple users amongst themselves.
ipc/sem.c: * This file implements System V semaphores.
ipc/sem.c: * - multiple semaphore operations that alter the same semaphore in
ipc/sem.c: *     the per-semaphore array structure.
ipc/sem.c: *   Thus: Perfect SMP scaling between independent semaphore arrays.
ipc/sem.c: *         If multiple semaphores in one array are used, then cache line
ipc/sem.c: *         trashing on the semaphore array spinlock will limit the scaling.
ipc/sem.c: * - A woken up task may not even touch the semaphore array anymore, it may
ipc/sem.c: *   wake-up due to a completed semaphore operation is achieved by using an
ipc/sem.c: *   semaphore array, lazily allocated). For backwards compatibility, multiple
ipc/sem.c: *   and per-semaphore list (stored in the array). This allows to achieve FIFO
ipc/sem.c:/* One semaphore structure for each semaphore in the system. */
ipc/sem.c:					/* that alter the semaphore */
ipc/sem.c:					/* that do not alter the semaphore*/
ipc/sem.c:	struct list_head	list_id;	/* per semaphore array list:
ipc/sem.c:	int			semid;		/* semaphore set identifier */
ipc/sem.c:						/* one per semaphore */
ipc/sem.c: *		global or semaphore sem_lock() for read/write
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * It must be called prior to dropping the global semaphore array lock.
ipc/sem.c:	 * Move all pending operation back into the per-semaphore
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * This function merges all per-semaphore queues into the global queue.
ipc/sem.c: * If the request contains only one semaphore operation, and there are
ipc/sem.c: * no complex transactions pending, lock only the semaphore involved.
ipc/sem.c: * Otherwise, lock the entire semaphore array, since we either have
ipc/sem.c: * multiple semaphores in our own semops, or we need to look at
ipc/sem.c: * semaphores from other pending complex operations.
ipc/sem.c:	 * Only one semaphore affected - try to optimize locking.
ipc/sem.c:		 * Acquire the per-semaphore lock.
ipc/sem.c: * newary - Create a new semaphore set
ipc/sem.c: * perform_atomic_semop - Perform (if possible) a semaphore operation
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * The function is called without any locks held, thus the semaphore array
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * @sma: semaphore array.
ipc/sem.c: * @semnum: semaphore that was modified.
ipc/sem.c: * wake_const_ops must be called after a semaphore in a semaphore array
ipc/sem.c: * semaphore.
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * on the actual changes that were performed on the semaphore array.
ipc/sem.c:	/* first: the per-semaphore queues, if known */
ipc/sem.c:		 * No sops means modified semaphores not known.
ipc/sem.c:	 * If one of the modified semaphores got 0,
ipc/sem.c: * @sma: semaphore array.
ipc/sem.c: * @semnum: semaphore that was modified.
ipc/sem.c: * update_queue must be called after a semaphore in a semaphore array
ipc/sem.c: * was modified. If multiple semaphores were modified, update_queue must
ipc/sem.c: * semaphore.
ipc/sem.c:		/* If we are scanning the single sop, per-semaphore list of
ipc/sem.c:		 * one semaphore and that semaphore is 0, then it is not
ipc/sem.c:		 * be in the  per semaphore pending queue, and decrements
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * based on the actual changes that were performed on the semaphore array.
ipc/sem.c:		/* semaphore array uses the global queue - just process it. */
ipc/sem.c:			 * No sops, thus the modified semaphores are not
ipc/sem.c:			 * Check the semaphores that were increased:
ipc/sem.c:			 *   semaphore ops wont be able to run: If the
ipc/sem.c: * check_qop: Test if a queued operation sleeps on the semaphore semnum
ipc/sem.c:	 * semaphores. This violates SUS, therefore it was changed to the
ipc/sem.c:/* The following counts are associated to each semaphore:
ipc/sem.c: * Per definition, a task waits only on the semaphore of the first semop
ipc/sem.c:		/* all task on a per-semaphore list sleep on exactly
ipc/sem.c:		 * that semaphore
ipc/sem.c:/* Free a semaphore set. freeary() is called with sem_ids.rwsem locked
ipc/sem.c: * as a writer and the spinlock for this semaphore set hold. sem_ids.rwsem
ipc/sem.c:	/* Free the existing undo structures for this semaphore set.  */
ipc/sem.c:	/* Remove the semaphore set from the IDR */
ipc/sem.c: * @semid: semaphore array id
ipc/sem.c: * The size of the undo structure depends on the size of the semaphore
ipc/sem.c:	/* step 1: figure out the size of the semaphore array */
ipc/sem.c:	/* step 3: Acquire the lock on semaphore array */
ipc/sem.c: * the requested semaphores.
ipc/sem.c: * The function can be called with or without holding the semaphore spinlock.
ipc/sem.c:	 * only a per-semaphore lock is held and it's OK to proceed with the
ipc/sem.c:		 * overwritten by the previous owner of the semaphore.
ipc/sem.c: * add semadj values to semaphores, free undo structures.
ipc/sem.c: * undo structures are not freed when semaphore arrays are destroyed
ipc/sem.c:			struct sem *semaphore = &sma->sem_base[i];
ipc/sem.c:				semaphore->semval += un->semadj[i];
ipc/sem.c:				 * Range checks of the new semaphore value,
ipc/sem.c:				 * Linux caps the semaphore value, both at 0
ipc/sem.c:				if (semaphore->semval < 0)
ipc/sem.c:					semaphore->semval = 0;
ipc/sem.c:				if (semaphore->semval > SEMVMX)
ipc/sem.c:					semaphore->semval = SEMVMX;
ipc/sem.c:				semaphore->sempid = task_tgid_vnr(current);
ipc/util.c: * The various sysv ipc resources (semaphores, messages and shared
ipc/mqueue.c: * are necessary. The same algorithm is used for sysv semaphores, see
ipc/util.h:		int nsems;	/* for semaphores */
kernel/fork.c:	 * to a new ipc namespace, the semaphore arrays from the old
kernel/taskstats.c:	struct rw_semaphore sem;
kernel/nsproxy.c:	 * to a new ipc namespace, the semaphore arrays from the old
kernel/sched/completion.c: * It differs from semaphores in that their default case is the opposite,
kernel/sched/completion.c: * wait_for_completion default blocks whereas semaphore default non-block. The
kernel/sched/completion.c: * something which isn't entirely natural for semaphores.
kernel/sched/idle.c: * NOTE: no locks or semaphores should be used here
kernel/sched/auto_group.h:	struct rw_semaphore	lock;
kernel/sched/core.c: *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and
kernel/sched/core.c: *		make semaphores SMP safe
kernel/sched/core.c: *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.
kernel/dma.c: * This doesn't really matter now, but it will once we get real semaphores
kernel/printk/printk.c: * keeping track if we have the console semaphore held. It's
kernel/printk/printk.c:	 * semaphore by hand to avoid flushing the buffer. We need to hold the
kernel/printk/printk.c:	 * console semaphore in order to do this test safely.
kernel/printk/printk.c:		 * semaphore.  The release will print out buffers and wake up
kernel/printk/printk.c: * output and call the console drivers.  If we fail to get the semaphore, we
kernel/locking/semaphore.c: * This file implements counting semaphores.
kernel/locking/semaphore.c: * A counting semaphore may be acquired 'n' times before sleeping.
kernel/locking/semaphore.c: * The spinlock controls access to the other members of the semaphore.
kernel/locking/semaphore.c: * parts of the kernel expect to be able to use down() on a semaphore in
kernel/locking/semaphore.c: * semaphore.  If it's zero, there may be tasks waiting on the wait_list.
kernel/locking/semaphore.c:#include <linux/semaphore.h>
kernel/locking/semaphore.c:static noinline void __down(struct semaphore *sem);
kernel/locking/semaphore.c:static noinline int __down_interruptible(struct semaphore *sem);
kernel/locking/semaphore.c:static noinline int __down_killable(struct semaphore *sem);
kernel/locking/semaphore.c:static noinline int __down_timeout(struct semaphore *sem, long jiffies);
kernel/locking/semaphore.c:static noinline void __up(struct semaphore *sem);
kernel/locking/semaphore.c: * down - acquire the semaphore
kernel/locking/semaphore.c: * @sem: the semaphore to be acquired
kernel/locking/semaphore.c: * Acquires the semaphore.  If no more tasks are allowed to acquire the
kernel/locking/semaphore.c: * semaphore, calling this function will put the task to sleep until the
kernel/locking/semaphore.c: * semaphore is released.
kernel/locking/semaphore.c:void down(struct semaphore *sem)
kernel/locking/semaphore.c: * down_interruptible - acquire the semaphore unless interrupted
kernel/locking/semaphore.c: * @sem: the semaphore to be acquired
kernel/locking/semaphore.c: * Attempts to acquire the semaphore.  If no more tasks are allowed to
kernel/locking/semaphore.c: * acquire the semaphore, calling this function will put the task to sleep.
kernel/locking/semaphore.c: * If the semaphore is successfully acquired, this function returns 0.
kernel/locking/semaphore.c:int down_interruptible(struct semaphore *sem)
kernel/locking/semaphore.c: * down_killable - acquire the semaphore unless killed
kernel/locking/semaphore.c: * @sem: the semaphore to be acquired
kernel/locking/semaphore.c: * Attempts to acquire the semaphore.  If no more tasks are allowed to
kernel/locking/semaphore.c: * acquire the semaphore, calling this function will put the task to sleep.
kernel/locking/semaphore.c: * -EINTR.  If the semaphore is successfully acquired, this function returns
kernel/locking/semaphore.c:int down_killable(struct semaphore *sem)
kernel/locking/semaphore.c: * down_trylock - try to acquire the semaphore, without waiting
kernel/locking/semaphore.c: * @sem: the semaphore to be acquired
kernel/locking/semaphore.c: * Try to acquire the semaphore atomically.  Returns 0 if the semaphore has
kernel/locking/semaphore.c: * and the semaphore can be released by any task or interrupt.
kernel/locking/semaphore.c:int down_trylock(struct semaphore *sem)
kernel/locking/semaphore.c: * down_timeout - acquire the semaphore within a specified time
kernel/locking/semaphore.c: * @sem: the semaphore to be acquired
kernel/locking/semaphore.c: * Attempts to acquire the semaphore.  If no more tasks are allowed to
kernel/locking/semaphore.c: * acquire the semaphore, calling this function will put the task to sleep.
kernel/locking/semaphore.c: * If the semaphore is not released within the specified number of jiffies,
kernel/locking/semaphore.c: * this function returns -ETIME.  It returns 0 if the semaphore was acquired.
kernel/locking/semaphore.c:int down_timeout(struct semaphore *sem, long jiffies)
kernel/locking/semaphore.c: * up - release the semaphore
kernel/locking/semaphore.c: * @sem: the semaphore to release
kernel/locking/semaphore.c: * Release the semaphore.  Unlike mutexes, up() may be called from any
kernel/locking/semaphore.c:void up(struct semaphore *sem)
kernel/locking/semaphore.c:struct semaphore_waiter {
kernel/locking/semaphore.c:static inline int __sched __down_common(struct semaphore *sem, long state,
kernel/locking/semaphore.c:	struct semaphore_waiter waiter;
kernel/locking/semaphore.c:static noinline void __sched __down(struct semaphore *sem)
kernel/locking/semaphore.c:static noinline int __sched __down_interruptible(struct semaphore *sem)
kernel/locking/semaphore.c:static noinline int __sched __down_killable(struct semaphore *sem)
kernel/locking/semaphore.c:static noinline int __sched __down_timeout(struct semaphore *sem, long jiffies)
kernel/locking/semaphore.c:static noinline void __sched __up(struct semaphore *sem)
kernel/locking/semaphore.c:	struct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,
kernel/locking/semaphore.c:						struct semaphore_waiter, list);
kernel/locking/rwsem-xadd.c:/* rwsem.c: R/W semaphores: contention handling functions
kernel/locking/rwsem-xadd.c: * Derived from arch/i386/kernel/semaphore.c
kernel/locking/rwsem-xadd.c: * Guide to the rw_semaphore's count field for common values.
kernel/locking/rwsem-xadd.c:void __init_rwsem(struct rw_semaphore *sem, const char *name,
kernel/locking/rwsem-xadd.c:	 * Make sure we are not reinitializing a held semaphore:
kernel/locking/rwsem-xadd.c:static struct rw_semaphore *
kernel/locking/rwsem-xadd.c:__rwsem_do_wake(struct rw_semaphore *sem, enum rwsem_wake_type wake_type)
kernel/locking/rwsem-xadd.c:struct rw_semaphore __sched *rwsem_down_read_failed(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static inline bool rwsem_try_write_lock(long count, struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static inline bool rwsem_can_spin_on_owner(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static inline bool owner_running(struct rw_semaphore *sem,
kernel/locking/rwsem-xadd.c:bool rwsem_spin_on_owner(struct rw_semaphore *sem, struct task_struct *owner)
kernel/locking/rwsem-xadd.c:static bool rwsem_optimistic_spin(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static bool rwsem_optimistic_spin(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:struct rw_semaphore __sched *rwsem_down_write_failed(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c: * handle waking up a waiter on the semaphore
kernel/locking/rwsem-xadd.c:struct rw_semaphore *rwsem_wake(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem)
kernel/locking/Makefile:obj-y += mutex.o semaphore.o rwsem.o mcs_spinlock.o
kernel/locking/rwsem-spinlock.c:/* rwsem-spinlock.c: R/W semaphores: contention handling functions for
kernel/locking/rwsem-spinlock.c:int rwsem_is_locked(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c: * initialise the semaphore
kernel/locking/rwsem-spinlock.c:void __init_rwsem(struct rw_semaphore *sem, const char *name,
kernel/locking/rwsem-spinlock.c:	 * Make sure we are not reinitializing a held semaphore:
kernel/locking/rwsem-spinlock.c:static inline struct rw_semaphore *
kernel/locking/rwsem-spinlock.c:__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)
kernel/locking/rwsem-spinlock.c:static inline struct rw_semaphore *
kernel/locking/rwsem-spinlock.c:__rwsem_wake_one_writer(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c: * get a read lock on the semaphore
kernel/locking/rwsem-spinlock.c:void __sched __down_read(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c:	/* we don't need to touch the semaphore struct anymore */
kernel/locking/rwsem-spinlock.c:int __down_read_trylock(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c: * get a write lock on the semaphore
kernel/locking/rwsem-spinlock.c:void __sched __down_write_nested(struct rw_semaphore *sem, int subclass)
kernel/locking/rwsem-spinlock.c:void __sched __down_write(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c:int __down_write_trylock(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c: * release a read lock on the semaphore
kernel/locking/rwsem-spinlock.c:void __up_read(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c: * release a write lock on the semaphore
kernel/locking/rwsem-spinlock.c:void __up_write(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c:void __downgrade_write(struct rw_semaphore *sem)
kernel/locking/percpu-rwsem.c:int __percpu_init_rwsem(struct percpu_rw_semaphore *brw,
kernel/locking/percpu-rwsem.c:	/* ->rw_sem represents the whole percpu_rw_semaphore for lockdep */
kernel/locking/percpu-rwsem.c:void percpu_free_rwsem(struct percpu_rw_semaphore *brw)
kernel/locking/percpu-rwsem.c: * If this helper fails the callers rely on the normal rw_semaphore and
kernel/locking/percpu-rwsem.c:static bool update_fast_ctr(struct percpu_rw_semaphore *brw, unsigned int val)
kernel/locking/percpu-rwsem.c:void percpu_down_read(struct percpu_rw_semaphore *brw)
kernel/locking/percpu-rwsem.c:void percpu_up_read(struct percpu_rw_semaphore *brw)
kernel/locking/percpu-rwsem.c:static int clear_fast_ctr(struct percpu_rw_semaphore *brw)
kernel/locking/percpu-rwsem.c:void percpu_down_write(struct percpu_rw_semaphore *brw)
kernel/locking/percpu-rwsem.c:void percpu_up_write(struct percpu_rw_semaphore *brw)
kernel/locking/mutex.c: * about this when converting semaphore users to mutexes.
kernel/locking/rwsem.c:/* kernel/rwsem.c: R/W semaphores, public implementation
kernel/locking/rwsem.c: * Derived from asm-i386/semaphore.h
kernel/locking/rwsem.c:static inline void rwsem_set_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.c:static inline void rwsem_clear_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.c:static inline void rwsem_set_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.c:static inline void rwsem_clear_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void __sched down_read(struct rw_semaphore *sem)
kernel/locking/rwsem.c:int down_read_trylock(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void __sched down_write(struct rw_semaphore *sem)
kernel/locking/rwsem.c:int down_write_trylock(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void up_read(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void up_write(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void downgrade_write(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void down_read_nested(struct rw_semaphore *sem, int subclass)
kernel/locking/rwsem.c:void _down_write_nest_lock(struct rw_semaphore *sem, struct lockdep_map *nest)
kernel/locking/rwsem.c:void down_read_non_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void down_write_nested(struct rw_semaphore *sem, int subclass)
kernel/locking/rwsem.c:void up_read_non_owner(struct rw_semaphore *sem)
kernel/events/uprobes.c:static struct percpu_rw_semaphore dup_mmap_sem;
kernel/events/uprobes.c:	struct rw_semaphore	register_rwsem;
kernel/events/uprobes.c:	struct rw_semaphore	consumer_rwsem;
kernel/trace/trace_output.h:extern struct rw_semaphore trace_event_sem;
lib/locking-selftest.c: * mutexes and rw-semaphores.
lib/locking-selftest.c:	struct mutex *mutex, struct rw_semaphore *rwsem)\
mm/memory.c: *  Note: this is only safe if the mm semaphore is held when called.
mm/memory.c: * By the time we get here, we already hold the mm semaphore
mm/mmap.c: * Called with the mm semaphore held.
mm/mmap.c: * Called with the mm semaphore held.
mm/oom_kill.c:	 * oom killed thread cannot exit because it requires the semaphore and
mm/mincore.c: * all the arguments, we hold the mmap semaphore: we should
mm/mempolicy.c: * and mempolicy.  May also be called holding the mmap_semaphore for write.
mm/nommu.c: * - the caller must hold the region semaphore for writing, which this releases
net/dns_resolver/dns_key.c: * - the key's semaphore is read-locked
net/core/link_watch.c:/* Must be called with the rtnl semaphore held */
net/core/dev.c: * semaphore.
net/core/dev.c: * Writers must hold the rtnl semaphore while they loop through the
net/core/dev.c: * protect against pure readers; the rtnl semaphore provides the
net/core/dev.c: * semaphore held.
net/core/dev.c: *	Find an interface by name. Must be called under RTNL semaphore
net/core/dev.c: *	about locking. The caller must hold either the RTNL semaphore
net/core/dev.c: *	number.  The caller must hold the rtnl semaphore or the
net/core/dev.c: *	Callers must hold the rtnl semaphore. You may want
net/core/dev.c: *	This is a wrapper around register_netdevice that takes the rtnl semaphore
net/core/dev.c: * 2) Since we run with the RTNL semaphore not held, we can sleep
net/core/dev.c: *	Callers must hold the rtnl semaphore.  You may want
net/core/dev.c: *	the rtnl semaphore.  In general you want to use this and not
net/core/dev.c: *	Callers must hold the rtnl semaphore.
net/core/dev.c: *       to take the rtnl semaphore.
net/netfilter/ipvs/ip_vs_ctl.c:/* semaphore for IPVS sockopts. And, [gs]etsockopt may sleep. */
net/netfilter/ipvs/ip_vs_pe.c:/* semaphore for IPVS PEs. */
net/netfilter/ipvs/ip_vs_sched.c:/* semaphore for schedulers */
net/ipv4/ipmr.c: * Note that the changes are semaphored via rtnl_lock.
net/ipv4/devinet.c:/* Called only from RTNL semaphored context. No locks. */
net/ipv4/devinet.c:/* Called only under RTNL semaphore */
net/socket.c: *	   i.e. under semaphore.
net/irda/irqueue.c: *		  global semaphore.
net/sched/sch_api.c:			/* We dropped the RTNL semaphore in order to
net/sched/act_api.c:		/* We dropped the RTNL semaphore in order to
net/sched/cls_api.c:				/* We dropped the RTNL semaphore in order to
net/rds/ib.h:extern struct rw_semaphore rds_ib_devices_lock;
net/9p/trans_rdma.c:#include <linux/semaphore.h>
net/9p/trans_rdma.c:	struct semaphore sq_sem;
net/9p/trans_rdma.c:	struct semaphore rq_sem;
net/rxrpc/ar-internal.h:	struct rw_semaphore	defrag_sem;	/* control re-enablement of IP DF bit */
net/appletalk/ddp.c:	 * Fixme: Raise/Lower a routing change semaphore for these
net/ipv6/ip6mr.c:   Note that the changes are semaphored via rtnl_lock.
scripts/checkpatch.pl:# check for semaphores initialized locked
security/keys/key.c: * called with the target keyring's semaphore writelocked.  The target key's
security/keys/key.c: * semaphore need not be locked as instantiation is serialised by
security/keys/keyctl.c:			/* read the data with the semaphore held (since we
security/keys/big_key.c: * - the key's semaphore is read-locked
security/keys/user_defined.c: * - the key's semaphore is write-locked
security/keys/user_defined.c: * - the key's semaphore is read-locked
security/keys/request_key_auth.c: * - the key's semaphore is read-locked
security/keys/keyring.c: * The keyring's semaphore is read-locked by the caller.  This prevents someone
security/keys/keyring.c: * caller must also hold a lock on the keyring semaphore.
security/keys/keyring.c: * This function will write-lock the keyring's semaphore and will consume some
security/keys/keyring.c: * This function will write-lock the keyring's semaphore.
security/keys/gc.c:	 * destroy its payload with its semaphore held.
security/keys/process_keys.c:/* Session keyring create vs join semaphore */
security/keys/process_keys.c:/* User keyring creation semaphore */
security/keys/process_keys.c: * Named session keyrings are joined with a semaphore held to prevent the
security/smack/smack_lsm.c: * smack_sem_semop - Smack checks of semaphore operations
sound/core/seq/seq_ports.h:	struct rw_semaphore list_mutex;
sound/pci/pcxhr/pcxhr_core.c:	/* reset semaphore */
sound/pci/intel8x0m.c:#define   ICH_MD3		0x00020000	/* modem power down semaphore */
sound/pci/intel8x0m.c:#define   ICH_AD3		0x00010000	/* audio power down semaphore */
sound/pci/intel8x0m.c:#define ICH_REG_ACC_SEMA		0x44	/* byte - codec write semaphore */
sound/pci/intel8x0m.c:#define   ICH_CAS		0x01		/* codec access semaphore */
sound/pci/intel8x0m.c:static int snd_intel8x0m_codec_semaphore(struct intel8x0m *chip, unsigned int codec)
sound/pci/intel8x0m.c:	/* Anyone holding a semaphore for 1 msec should be shot... */
sound/pci/intel8x0m.c:	 * reset the semaphore. So even if you don't get the semaphore, still
sound/pci/intel8x0m.c:	 * continue the access. We don't need the semaphore anyway. */
sound/pci/intel8x0m.c:		"codec_semaphore: semaphore is not ready [0x%x][0x%x]\n",
sound/pci/intel8x0m.c:	iagetword(chip, 0);	/* clear semaphore flag */
sound/pci/intel8x0m.c:	/* I don't care about the semaphore */
sound/pci/intel8x0m.c:	if (snd_intel8x0m_codec_semaphore(chip, ac97->num) < 0) {
sound/pci/intel8x0m.c:				"codec_write %d: semaphore is not ready for register 0x%x\n",
sound/pci/intel8x0m.c:	if (snd_intel8x0m_codec_semaphore(chip, ac97->num) < 0) {
sound/pci/intel8x0m.c:				"codec_read %d: semaphore is not ready for register 0x%x\n",
sound/pci/intel8x0m.c:		iagetword(chip, 0); /* clear semaphore */
sound/pci/intel8x0m.c:	iagetword(chip, 0);	/* clear semaphore flag */
sound/pci/intel8x0.c:static bool buggy_semaphore;
sound/pci/intel8x0.c:module_param(buggy_semaphore, bool, 0444);
sound/pci/intel8x0.c:MODULE_PARM_DESC(buggy_semaphore, "Enable workaround for hardwares with problematic codec semaphores.");
sound/pci/intel8x0.c:#define   ICH_MD3		0x00020000	/* modem power down semaphore */
sound/pci/intel8x0.c:#define   ICH_AD3		0x00010000	/* audio power down semaphore */
sound/pci/intel8x0.c:#define ICH_REG_ACC_SEMA		0x34	/* byte - codec write semaphore */
sound/pci/intel8x0.c:#define   ICH_CAS		0x01		/* codec access semaphore */
sound/pci/intel8x0.c:	unsigned buggy_semaphore: 1;	/* workaround for buggy codec semaphore */
sound/pci/intel8x0.c:static int snd_intel8x0_codec_semaphore(struct intel8x0 *chip, unsigned int codec)
sound/pci/intel8x0.c:	if (chip->buggy_semaphore)
sound/pci/intel8x0.c:	/* Anyone holding a semaphore for 1 msec should be shot... */
sound/pci/intel8x0.c:	 * reset the semaphore. So even if you don't get the semaphore, still
sound/pci/intel8x0.c:	 * continue the access. We don't need the semaphore anyway. */
sound/pci/intel8x0.c:		"codec_semaphore: semaphore is not ready [0x%x][0x%x]\n",
sound/pci/intel8x0.c:	iagetword(chip, 0);	/* clear semaphore flag */
sound/pci/intel8x0.c:	/* I don't care about the semaphore */
sound/pci/intel8x0.c:	if (snd_intel8x0_codec_semaphore(chip, ac97->num) < 0) {
sound/pci/intel8x0.c:				"codec_write %d: semaphore is not ready for register 0x%x\n",
sound/pci/intel8x0.c:	if (snd_intel8x0_codec_semaphore(chip, ac97->num) < 0) {
sound/pci/intel8x0.c:				"codec_read %d: semaphore is not ready for register 0x%x\n",
sound/pci/intel8x0.c:	if (snd_intel8x0_codec_semaphore(chip, codec) >= 0) {
sound/pci/intel8x0.c:static int snd_intel8x0_ali_codec_semaphore(struct intel8x0 *chip)
sound/pci/intel8x0.c:	if (chip->buggy_semaphore)
sound/pci/intel8x0.c:		dev_warn(chip->card->dev, "ali_codec_semaphore timeout\n");
sound/pci/intel8x0.c:	if (snd_intel8x0_ali_codec_semaphore(chip))
sound/pci/intel8x0.c:	if (snd_intel8x0_ali_codec_semaphore(chip))
sound/pci/intel8x0.c:		iagetword(chip, 0);	/* clear semaphore flag */
sound/pci/intel8x0.c:	chip->buggy_semaphore = buggy_semaphore;
sound/pci/korg1212/korg1212.c:                // the semaphore in case someone is waiting for this.
sound/pci/sis7019.c:	 * semaphore)
sound/pci/sis7019.c:	/* Get the AC97 semaphore -- software first, so we don't spin
sound/pci/sis7019.c:	 * pounding out IO reads on the hardware semaphore...
sound/pci/sis7019.c:	/* Get the AC-link semaphore, and reset the codecs
sound/pci/sis7019.c:	/* Command complete, we can let go of the semaphore now.
sound/oss/dmasound/dmasound_core.c: * semaphores.
sound/usb/usbaudio.h:	struct rw_semaphore shutdown_rwsem;
sound/usb/midi.c:	struct rw_semaphore disc_rwsem;
tools/perf/builtin-lock.c:#include <semaphore.h>
tools/perf/builtin-sched.c:#include <semaphore.h>
tools/perf/builtin-kvm.c:#include <semaphore.h>
usr/include/asm-generic/errno.h:#define	ENAVAIL		119	/* No XENIX semaphores available */
usr/include/asm-generic/sembuf.h:	unsigned long	sem_nsems;	/* no. of semaphores in array */
usr/include/linux/sem.h:	struct sem	*sem_base;		/* ptr to first semaphore in array */
usr/include/linux/sem.h:	unsigned short	sem_nsems;		/* no. of semaphores in array */
usr/include/linux/sem.h:	unsigned short  sem_num;	/* semaphore index in array */
usr/include/linux/sem.h:	short		sem_op;		/* semaphore operation */
usr/include/linux/sem.h:#define SEMMNI  128             /* <= IPCMNI  max # of semaphore identifiers */
usr/include/linux/sem.h:#define SEMMSL  250             /* <= 8 000 max num of semaphores per id */
usr/include/linux/sem.h:#define SEMMNS  (SEMMNI*SEMMSL) /* <= INT_MAX max # of semaphores in system */
usr/include/linux/sem.h:#define SEMVMX  32767           /* <= 32767 semaphore maximum value */
usr/include/linux/sem.h:#define SEMMAP  SEMMNS          /* # of entries in semaphore map */
usr/include/linux/sysctl.h: 	KERN_SEM=43,		/* struct: sysv semaphore limits */
usr/include/linux/capability.h:/* Allow removing semaphores */
usr/include/linux/capability.h:/* Used instead of CAP_CHOWN to "chown" IPC message queues, semaphores
usr/include/asm/sembuf.h:	__kernel_ulong_t sem_nsems;	/* no. of semaphores in array */
