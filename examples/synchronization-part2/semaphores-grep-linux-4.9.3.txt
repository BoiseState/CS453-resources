arch/sparc/include/uapi/asm/errno.h:#define	ENAVAIL		119	/* No XENIX semaphores available */
arch/sparc/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/sparc/kernel/process_32.c:	/* do_fork() grabs the parent semaphore, we must release it
arch/sparc/mm/srmmu.c: * hammer, but a semaphore like system to make sure we only have N TLB
arch/sparc/mm/fault_32.c:bad_area_nosemaphore:
arch/sparc/mm/fault_32.c:				goto bad_area_nosemaphore;
arch/sparc/mm/fault_32.c:			goto bad_area_nosemaphore;
arch/microblaze/include/uapi/asm/unistd.h:#define __NR_semtimedop		325 /* ok - semaphore group */
arch/microblaze/kernel/sys_microblaze.c:#include <linux/semaphore.h>
arch/microblaze/mm/fault.c:			goto bad_area_nosemaphore;
arch/microblaze/mm/fault.c:			goto bad_area_nosemaphore;
arch/microblaze/mm/fault.c:bad_area_nosemaphore:
arch/tile/include/asm/mmu.h:	 * Written under the mmap_sem semaphore; read without the
arch/tile/include/asm/mmu.h:	 * semaphore but atomically, but it is conservatively set.
arch/tile/mm/pgtable.c: * We only _try_ to acquire the mmap_sem semaphore; if we can't acquire it,
arch/tile/mm/fault.c:		 * Don't take the mm semaphore here. If we fixup a prefetch
arch/tile/mm/fault.c:		goto bad_area_nosemaphore;
arch/tile/mm/fault.c:		goto bad_area_nosemaphore;
arch/tile/mm/fault.c:			goto bad_area_nosemaphore;
arch/tile/mm/fault.c:bad_area_nosemaphore:
arch/nios2/mm/fault.c:			goto bad_area_nosemaphore;
arch/nios2/mm/fault.c:		goto bad_area_nosemaphore;
arch/nios2/mm/fault.c:		goto bad_area_nosemaphore;
arch/nios2/mm/fault.c:			goto bad_area_nosemaphore;
arch/nios2/mm/fault.c:bad_area_nosemaphore:
arch/parisc/include/uapi/asm/errno.h:#define	ENAVAIL		179	/* No XENIX semaphores available */
arch/parisc/include/uapi/asm/sembuf.h:	unsigned long 	sem_nsems;		/* no. of semaphores in array */
arch/parisc/include/asm/ldcw.h:   for the semaphore.  */
arch/parisc/kernel/entry.S:	 * semaphore held). If the translation doesn't exist, we can't
arch/parisc/mm/init.c:	    BUG_ON(recycle_inuse);  /* FIXME: Use a semaphore/wait queue here */
arch/parisc/mm/fault.c:			 * Check for LDCWX and LDCWS (semaphore instructions).
arch/arc/Kconfig:	  hardware semaphores, shared memory,....
arch/arc/mm/fault.c:			goto bad_area_nosemaphore;
arch/arc/mm/fault.c:bad_area_nosemaphore:
arch/powerpc/platforms/pseries/iommu.c:		 * read-write semaphore of the notifier chain. So
arch/powerpc/platforms/powernv/opal-async.c:#include <linux/semaphore.h>
arch/powerpc/platforms/powernv/opal-async.c:static struct semaphore opal_async_sem;
arch/powerpc/sysdev/ppc4xx_hsta_msi.c:#include <linux/semaphore.h>
arch/powerpc/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;	/* no. of semaphores in array */
arch/powerpc/include/asm/pmac_pfunc.h: * Note that irq_enable & irq_disable are called within a semaphore held
arch/powerpc/kernel/eeh_event.c:#include <linux/semaphore.h>
arch/powerpc/kernel/eeh_event.c:static struct semaphore eeh_eventlist_sem;
arch/powerpc/kernel/eeh_event.c:	/* Initialize semaphore */
arch/powerpc/mm/fault.c:		 * If we have retry set, the mmap semaphore will have
arch/powerpc/mm/fault.c:			goto bad_area_nosemaphore;
arch/powerpc/mm/fault.c:bad_area_nosemaphore:
arch/alpha/include/uapi/asm/errno.h:#define	ENAVAIL		119	/* No XENIX semaphores available */
arch/alpha/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/alpha/include/asm/rwsem.h: * Based on asm-alpha/semaphore.h and asm-i386/rwsem.h
arch/alpha/include/asm/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline int __down_read_trylock(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline long ___down_write(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline int __down_write_killable(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline int __down_write_trylock(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
arch/alpha/include/asm/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
arch/arm/lib/uaccess_with_memcpy.c:	/* the mmap semaphore is taken only if not in an atomic context */
arch/arm/mach-omap2/control.c:	u32 sdrc_module_semaphore;
arch/arm/mach-omap2/control.c:	scratchpad_contents.sdrc_module_semaphore = 0x0;
arch/arm/mach-vexpress/spc.c:#include <linux/semaphore.h>
arch/arm/mach-vexpress/spc.c:	struct semaphore sem;
arch/s390/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/s390/include/asm/kvm_host.h:	struct rw_semaphore maps_lock;
arch/s390/include/asm/rwsem.h: *  Based on asm-alpha/semaphore.h and asm-i386/rwsem.h
arch/s390/include/asm/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline int __down_read_trylock(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline long ___down_write(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline int __down_write_killable(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline int __down_write_trylock(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
arch/s390/include/asm/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
arch/score/mm/fault.c:		goto bad_area_nosemaphore;
arch/score/mm/fault.c:bad_area_nosemaphore:
arch/mips/cavium-octeon/flash_setup.c:#include <linux/semaphore.h>
arch/mips/include/uapi/asm/errno.h:#define ENAVAIL		138	/* No XENIX semaphores available */
arch/mips/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/mips/include/asm/sgi/mc.h:	volatile u32 syssembit;		/* Uni-bit system semaphore */
arch/mips/include/asm/octeon/octeon.h:extern struct semaphore octeon_bootbus_sem;
arch/mips/mm/fault.c:		goto bad_area_nosemaphore;
arch/mips/mm/fault.c:bad_area_nosemaphore:
arch/sh/mm/fault.c:__bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
arch/sh/mm/fault.c:bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
arch/sh/mm/fault.c:	__bad_area_nosemaphore(regs, error_code, address, SEGV_MAPERR);
arch/sh/mm/fault.c:	__bad_area_nosemaphore(regs, error_code, address, si_code);
arch/sh/mm/fault.c:		bad_area_nosemaphore(regs, error_code, address);
arch/sh/mm/fault.c:		bad_area_nosemaphore(regs, error_code, address);
arch/frv/include/uapi/asm/sembuf.h:	unsigned long		sem_nsems;	/* no. of semaphores in array */
arch/metag/mm/fault.c:				goto bad_area_nosemaphore;
arch/metag/mm/fault.c:			goto bad_area_nosemaphore;
arch/metag/mm/fault.c:			goto bad_area_nosemaphore;
arch/metag/mm/fault.c:			goto bad_area_nosemaphore;
arch/metag/mm/fault.c:bad_area_nosemaphore:
arch/xtensa/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/m68k/atari/stdma.c:static int stdma_locked;			/* the semaphore */
arch/um/kernel/trap.c:		goto out_nosemaphore;
arch/um/kernel/trap.c:			goto out_nosemaphore;
arch/um/kernel/trap.c:out_nosemaphore:
arch/um/kernel/trap.c:		goto out_nosemaphore;
arch/um/drivers/mmapper_kern.c:	 * called when the mm semaphore is held
arch/um/drivers/chan_user.c:	 * kernel semaphores. We don't use SysV semaphores because they are
arch/um/drivers/port_kern.c:		 * the semaphore regardless of whether it got a successful
arch/um/drivers/xterm_kern.c:	/* This is a locked semaphore... */
arch/m32r/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/m32r/include/asm/spinlock.h: * Changed to use the same technique as rw semaphores.  See
arch/m32r/include/asm/spinlock.h: * semaphore.h for details.  -ben
arch/m32r/mm/fault.c:		goto bad_area_nosemaphore;
arch/m32r/mm/fault.c:			goto bad_area_nosemaphore;
arch/m32r/mm/fault.c:bad_area_nosemaphore:
arch/avr32/include/uapi/asm/sembuf.h:        unsigned long   sem_nsems;              /* no. of semaphores in array */
arch/x86/lib/rwsem.S: * x86 semaphore implementation.
arch/x86/lib/rwsem.S: * rw semaphores implemented November 1999 by Benjamin LaHaise <bcrl@kvack.org>
arch/x86/lib/rwsem.S: * The semaphore operations have a special calling sequence that
arch/x86/lib/rwsem.S: * there is contention on the semaphore.
arch/x86/lib/rwsem.S: * %eax contains the semaphore pointer on entry. Save the C-clobbered
arch/x86/lib/rwsem.S: * will always return the semaphore pointer in %rax (which
arch/x86/include/uapi/asm/sembuf.h:	__kernel_ulong_t sem_nsems;	/* no. of semaphores in array */
arch/x86/include/asm/rwsem.h:/* rwsem.h: R/W semaphores implemented using XADD/CMPXCHG for i486+
arch/x86/include/asm/rwsem.h: * Derived from asm-x86/semaphore.h
arch/x86/include/asm/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline bool __down_read_trylock(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:	struct rw_semaphore* ret;			\
arch/x86/include/asm/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline int __down_write_killable(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline bool __down_write_trylock(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
arch/x86/include/asm/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
arch/x86/mm/fault.c:__bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
arch/x86/mm/fault.c:bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
arch/x86/mm/fault.c:	__bad_area_nosemaphore(regs, error_code, address, vma, SEGV_MAPERR);
arch/x86/mm/fault.c:	__bad_area_nosemaphore(regs, error_code, address, vma, si_code);
arch/x86/mm/fault.c:			bad_area_nosemaphore(regs, error_code, address, vma);
arch/x86/mm/fault.c:		 * Don't take the mm semaphore here. If we fixup a prefetch
arch/x86/mm/fault.c:		bad_area_nosemaphore(regs, error_code, address, NULL);
arch/x86/mm/fault.c:		bad_area_nosemaphore(regs, error_code, address, NULL);
arch/x86/mm/fault.c:		bad_area_nosemaphore(regs, error_code, address, NULL);
arch/x86/mm/fault.c:			bad_area_nosemaphore(regs, error_code, address, NULL);
arch/mn10300/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/mn10300/include/asm/rwlock.h: * Helpers used by both rw spinlocks and rw semaphores.
arch/mn10300/include/asm/rwlock.h: * Based in part on code from semaphore.h and
arch/cris/arch-v32/drivers/cryptocop.c:	/* Acquire the mm page semaphore. */
arch/cris/mm/fault.c: bad_area_nosemaphore:
arch/cris/mm/fault.c:			goto bad_area_nosemaphore;
arch/openrisc/kernel/or32_ksyms.c:#include <linux/semaphore.h>
arch/openrisc/mm/fault.c:bad_area_nosemaphore:
arch/openrisc/mm/fault.c:			goto bad_area_nosemaphore;
arch/ia64/include/uapi/asm/sembuf.h:	unsigned long	sem_nsems;		/* no. of semaphores in array */
arch/ia64/include/asm/rwsem.h: * R/W semaphores for ia64
arch/ia64/include/asm/rwsem.h:__down_read (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:___down_write (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__down_write (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__down_write_killable (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__up_read (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__up_write (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__down_read_trylock (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__down_write_trylock (struct rw_semaphore *sem)
arch/ia64/include/asm/rwsem.h:__downgrade_write (struct rw_semaphore *sem)
arch/ia64/kernel/salinfo.c: *   Replace the counting semaphore with a mutex and a test if the cpumask is non-empty.
arch/ia64/kernel/salinfo.c:#include <linux/semaphore.h>
arch/ia64/kernel/unaligned.c:			/* oops, really a semaphore op (cmpxchg, etc) */
arch/ia64/kernel/unaligned.c:			/* oops, really a semaphore op (cmpxchg, etc) */
arch/ia64/kernel/unaligned.c:			/* oops, really a semaphore op (cmpxchg, etc) */
arch/ia64/kernel/perfmon.c:		 * init restart semaphore to locked
arch/ia64/kernel/perfmon.c:	/* can only be applied to current task, need to have the mm semaphore held when called */
arch/ia64/kernel/perfmon.c:	 * if blocking, then post the semaphore is PFM_CTX_MASKED, i.e.
arch/ia64/mm/tlb.c: * Implement "spinaphores" ... like counting semaphores, but they
arch/ia64/mm/fault.c:	 * is no vma for region 5 addr's anyway, so skip getting the semaphore
CREDITS:D: shm fs, SYSV semaphores, af_unix
crypto/internal.h:extern struct rw_semaphore crypto_alg_sem;
Documentation/devices.txt:		179 = /dev/xsvc		High-speed shared-mem/semaphore service
Documentation/serial/tty.txt:			termios semaphore so allowed to sleep. Serialized
Documentation/serial/tty.txt:			itself by a semaphore. May sleep.
Documentation/serial/driver:There are two locks.  A per-port spinlock, and an overall semaphore.
Documentation/serial/driver:The port_sem semaphore is used to protect against ports being added/
Documentation/serial/driver:semaphore has been the 'mutex' member of the tty_port struct, and
Documentation/kprobes.txt:non-recursive and can never relinquish the CPU (e.g., via a semaphore
Documentation/kprobes.txt:a semaphore).
Documentation/sysctl/kernel.txt:object: message, semaphore or shared memory respectively.
Documentation/DocBook/filesystems.tmpl:were semaphores and include them in your semaphore ordering rules to prevent
Documentation/DocBook/kernel-locking.tmpl:      <type>rwlock_t</type> and <structname>struct rw_semaphore</structname>.
Documentation/DocBook/writing-an-alsa-driver.tmpl:      or semaphores.  In general, if a race condition can happen
Documentation/DocBook/writing-an-alsa-driver.tmpl:      should use mutexes or semaphores instead.
Documentation/networking/netdevices.txt:	Synchronization: rtnl_lock() semaphore.
Documentation/networking/netdevices.txt:	Synchronization: rtnl_lock() semaphore.
Documentation/networking/netdevices.txt:	Synchronization: rtnl_lock() semaphore.
Documentation/PCI/pci-error-recovery.txt:to complete; it can take semaphores, schedule, etc... everything but
Documentation/PCI/pci-error-recovery.txt:>>> *not* schedule or semaphore in this routine; the current powerpc
Documentation/sound/alsa/ALSA-Configuration.txt:    buggy_semaphore - Enable workaround for hardware with buggy
Documentation/sound/alsa/ALSA-Configuration.txt:		    semaphores (e.g. on some ASUS laptops)
Documentation/ko_KR/memory-barriers.txt:	struct rw_semaphore {
Documentation/devicetree/bindings/power/renesas,sysc-rmobile.txt:	   semaphore.
Documentation/percpu-rw-semaphore.txt:Percpu rw semaphores
Documentation/percpu-rw-semaphore.txt:Percpu rw semaphores is a new read-write semaphore design that is
Documentation/percpu-rw-semaphore.txt:The problem with traditional read-write semaphores is that when multiple
Documentation/percpu-rw-semaphore.txt:cores take the lock for reading, the cache line containing the semaphore
Documentation/percpu-rw-semaphore.txt:The lock is declared with "struct percpu_rw_semaphore" type.
Documentation/security/Smack.txt:IPC objects, message queues, semaphore sets, and memory segments exist in flat
Documentation/security/keys.txt: (2) The key's semaphore.
Documentation/security/keys.txt:     The semaphore could be used to govern access to the payload and to control
Documentation/security/keys.txt:     RCU must be used when the semaphore isn't already held; if the semaphore
Documentation/security/keys.txt:     semaphore must still be used to serialise modifications to the key. The
Documentation/security/keys.txt:     payload just dereferenced if the key's semaphore is not held.
Documentation/security/keys.txt:     before a key is created (add key) or the key semaphore is taken (update or
Documentation/security/keys.txt:     The key will have its semaphore write-locked before this method is called,
Documentation/security/keys.txt:     data upon a key being revoked.  The caller will have the key semaphore
Documentation/security/keys.txt:     a deadlock against the key semaphore.
Documentation/security/keys.txt:     This method will be called with the key's semaphore read-locked. This will
Documentation/00-INDEX:percpu-rw-semaphore.txt
Documentation/00-INDEX:	- RCU based read-write semaphore optimized for locking for reading
Documentation/scsi/ChangeLog.1992-1997:    option for no-multi lun scan.  Add semaphore for possible problems
Documentation/scsi/ChangeLog.1992-1997:    * sr.h: Add needs_sector_size semaphore.
Documentation/scsi/ChangeLog.1992-1997:    * scsi.c: Add lockable semaphore for removable devices that can have
Documentation/scsi/ChangeLog.1992-1997:    to lock door for devices that do not have lockable semaphore set.
Documentation/scsi/ChangeLog.ips:        4.80.14  - Take all semaphores off stack                    
Documentation/scsi/ChangeLog.lpfc:	  waiting on a semaphore and "modprobe -r lpfc" is not always
Documentation/scsi/ChangeLog.lpfc:	  semaphore for the interruptable sleep.
Documentation/scsi/ChangeLog.sym53c8xx_2:	  semaphore in order to behave synchronously as required by the eh 
Documentation/locking/mutex-design.txt:behave similarly to binary semaphores, and were introduced in 2006[1]
Documentation/locking/mutex-design.txt:number of workloads. Note that this technique is also used for rw-semaphores.
Documentation/locking/mutex-design.txt:as large as 'struct semaphore' (24 bytes) and tied, along with rwsems,
Documentation/locking/locktorture.txt:		     o "rwsem_lock": read/write down() and up() semaphore pairs.
Documentation/infiniband/core_locking.txt:  semaphores that could cause deadlock if a consumer calls back into
Documentation/RCU/Design/Requirements/Requirements.html:For example, the translation between a user-level SystemV semaphore
Documentation/RCU/Design/Requirements/Requirements.html:but it is absolutely forbidden to update a semaphore that has just been
Documentation/RCU/checklist.txt:	Therefore, SRCU should be used in preference to rw_semaphore
Documentation/RCU/rcuref.txt:reader/writer spinlocks or semaphores are straightforward:
Documentation/RCU/arrayRCU.txt:to map from semaphore, message-queue, and shared-memory IDs to the data
Documentation/RCU/arrayRCU.txt:ids->sem semaphore.
Documentation/RCU/whatisRCU.txt:o	Use some solid scheme (such as locks or semaphores) to
Documentation/namespaces/compatibility-list.txt:   object inside the kernel. E.g. semaphore with IPCID or
Documentation/usb/power-management.txt:autoresume -- the device semaphore (udev->dev.sem) will be held when a
Documentation/usb/power-management.txt:critical section).  Holding the device semaphore will block all
Documentation/memory-barriers.txt: (*) semaphores
Documentation/memory-barriers.txt: (*) R/W semaphores
Documentation/memory-barriers.txt:Locks and semaphores may not provide any guarantee of ordering on UP compiled
Documentation/memory-barriers.txt:Consider, for example, the R/W semaphore slow path.  Here a waiting process is
Documentation/memory-barriers.txt:queued on the semaphore, by virtue of it having a piece of its stack linked to
Documentation/memory-barriers.txt:the semaphore's list of waiting processes:
Documentation/memory-barriers.txt:	struct rw_semaphore {
Documentation/memory-barriers.txt: (3) clear the task pointer to tell the waiter it has been given the semaphore;
Documentation/memory-barriers.txt:Once it has queued itself and dropped the semaphore lock, the waiter does not
Documentation/memory-barriers.txt:This could be dealt with using the semaphore lock, but then the down_xxx()
Documentation/filesystems/coda.txt:  object in NT and a semaphore in Windows 95.
Documentation/filesystems/vfs.txt:	This method is called with the directory inode semaphore held
Documentation/filesystems/xfs-delayed-logging-design.txt:time will tell if using a read-write semaphore for exclusion will limit
Documentation/filesystems/cifs/CHANGES:creation and file open to such servers.  Fix semaphore conflict which causes 
Documentation/filesystems/fuse.txt: |    [acquire inode semaphore        |
Documentation/filesystems/fuse.txt: |                                    |    [acquire inode semaphore
Documentation/kernel-docs.txt:      :Keywords: locks, locking, spinlock, semaphore, atomic, race
Documentation/ia64/err_inject.txt:	/* clear old semaphore */
Documentation/ia64/err_inject.txt:	/* get one semaphore */
Documentation/ia64/err_inject.txt:		printf("Please remove semaphore with key=0x%lx, then run the tool.\n",
Documentation/ia64/err_inject.txt:	/* initialize the semaphore to 1: */
Documentation/ia64/err_inject.txt:	/* Create semaphore: If one_lock, one semaphore for all processors.
Documentation/ia64/err_inject.txt:	   Otherwise, one semaphore for each processor. */
Documentation/ia64/err_inject.txt:			printf("Can not create semaphore...exit\n");
Documentation/ia64/err_inject.txt:			printf("Can not create semaphore for cpu%d...exit\n",i);
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:  deadlocked on a semaphore or something similar.  In this case, when
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:       #5  0x1006a744 in __down (sem=0x507d241c) at semaphore.c:71
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:       #6  0x1006aa10 in __down_failed () at semaphore.c:157
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:       #5  0x1006a744 in __down (sem=0x507d241c) at semaphore.c:71
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:       #6  0x1006aa10 in __down_failed () at semaphore.c:157
drivers/mmc/card/queue.h:	struct semaphore	thread_sem;
drivers/leds/leds-bd2802.c:	struct rw_semaphore		rwsem;
drivers/leds/leds.h:extern struct rw_semaphore leds_list_lock;
drivers/video/fbdev/omap2/omapfb/omapfb.h:	struct rw_semaphore lock;
drivers/video/fbdev/omap2/omapfb/dss/rfbi.c:#include <linux/semaphore.h>
drivers/video/fbdev/omap2/omapfb/dss/rfbi.c:	struct semaphore bus_lock;
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:#include <linux/semaphore.h>
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	struct semaphore bus_lock;
drivers/video/fbdev/matrox/matroxfb_base.h:	struct rw_semaphore	lock;
drivers/video/fbdev/matrox/matroxfb_base.h:	struct rw_semaphore	lock;
drivers/video/fbdev/omap/hwa742.c:	struct semaphore	req_sema;
drivers/video/fbdev/core/fbmem.c: *	It must be called with the console semaphore held
drivers/video/fbdev/smscufx.c:	struct semaphore limit_sem;
drivers/video/fbdev/aty/radeonfb.h: * by a semaphore (currently the console semaphore) so that no conflict
drivers/pcmcia/cs_internal.h:extern struct rw_semaphore pcmcia_socket_list_rwsem;
drivers/hwspinlock/u8500_hsem.c: * Implements u8500 semaphore handling for protocol 1, no interrupts.
drivers/hwspinlock/u8500_hsem.c:#define U8500_MAX_SEMAPHORE		32	/* a total of 32 semaphore */
drivers/hwspinlock/u8500_hsem.c:	 * if equal, we have the semaphore, otherwise
drivers/tty/serial/ioc4_serial.c:	 * Getting interrupted here is okay.  It'll just v() our semaphore, and
drivers/tty/serial/serial_core.c: * uart_shutdown are serialised by the per-port semaphore.
drivers/tty/serial/serial_core.c:	 * This semaphore protects port->count.  It is also
drivers/tty/serial/serial_core.c:	 * port configuration semaphore to make sure that a
drivers/tty/serial/serial_core.c:	 * Take the per-port semaphore.  This prevents count from
drivers/tty/tty_ldsem.c: * Ldisc rw semaphore
drivers/tty/tty_ldsem.c: * The ldisc semaphore is semantically a rw_semaphore but which enforces
drivers/tty/tty_ldsem.c: *   1) Upper half of semaphore count is a wait count (differs from rwsem
drivers/tty/tty_ldsem.c:static inline long ldsem_atomic_update(long delta, struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:void __init_ldsem(struct ld_semaphore *sem, const char *name,
drivers/tty/tty_ldsem.c:	 * Make sure we are not reinitializing a held semaphore:
drivers/tty/tty_ldsem.c:static void __ldsem_wake_readers(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static inline int writer_trylock(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static void __ldsem_wake_writer(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static void __ldsem_wake(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static void ldsem_wake(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:static struct ld_semaphore __sched *
drivers/tty/tty_ldsem.c:down_read_failed(struct ld_semaphore *sem, long count, long timeout)
drivers/tty/tty_ldsem.c:static struct ld_semaphore __sched *
drivers/tty/tty_ldsem.c:down_write_failed(struct ld_semaphore *sem, long count, long timeout)
drivers/tty/tty_ldsem.c:static int __ldsem_down_read_nested(struct ld_semaphore *sem,
drivers/tty/tty_ldsem.c:static int __ldsem_down_write_nested(struct ld_semaphore *sem,
drivers/tty/tty_ldsem.c:int __sched ldsem_down_read(struct ld_semaphore *sem, long timeout)
drivers/tty/tty_ldsem.c:int ldsem_down_read_trylock(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:int __sched ldsem_down_write(struct ld_semaphore *sem, long timeout)
drivers/tty/tty_ldsem.c:int ldsem_down_write_trylock(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:void ldsem_up_read(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:void ldsem_up_write(struct ld_semaphore *sem)
drivers/tty/tty_ldsem.c:int ldsem_down_read_nested(struct ld_semaphore *sem, int subclass, long timeout)
drivers/tty/tty_ldsem.c:int ldsem_down_write_nested(struct ld_semaphore *sem, int subclass,
drivers/tty/vt/vt_ioctl.c: * semaphore.
drivers/tty/vt/vt.c: *	Caller must hold the console semaphore. Takes the termios rwsem and
drivers/tty/vt/vc_screen.c:		/* Finally, release the console semaphore while we push
drivers/tty/vt/vc_screen.c:		 * AKPM: Even though it's a semaphore, we should drop it because
drivers/tty/tty_mutex.c:#include <linux/semaphore.h>
drivers/tty/rocket.c: * rp_write() and rp_write_char() functions use a per port semaphore to protect against
drivers/hid/hid-core.c:#include <linux/semaphore.h>
drivers/misc/genwqe/card_base.h:#include <linux/semaphore.h>
drivers/misc/mei/mei_dev.h:	struct rw_semaphore me_clients_rwsem;
drivers/misc/cxl/flash.c:#include <linux/semaphore.h>
drivers/misc/cxl/flash.c:static struct semaphore sem;
drivers/misc/cxl/flash.c:	/* Allows one process to open the device by using a semaphore */
drivers/misc/cxl/cxl.h:#include <linux/semaphore.h>
drivers/misc/sgi-gru/grutables.h:	struct rw_semaphore	bs_kgts_sema;		/* lock for kgts */
drivers/watchdog/sc1200wdt.c:#include <linux/semaphore.h>
drivers/ide/ide-proc.c: *	setting semaphore
drivers/s390/block/dcssblk.c:static struct rw_semaphore dcssblk_devices_sem;
drivers/s390/block/dcssblk.c: * device needs to be enqueued before the semaphore is
drivers/parport/ieee1284.c:		   semaphore. */
drivers/pci/hotplug/ibmphp_hpc.c:#include <linux/semaphore.h>
drivers/pci/hotplug/ibmphp_hpc.c:static struct semaphore semOperations;	// lock all operations and
drivers/pci/hotplug/ibmphp_hpc.c:static struct semaphore sem_exit;	// make sure polling thread goes away
drivers/pci/hotplug/ibmphp_hpc.c:* Action:  initialize semaphores and variables
drivers/pci/hotplug/ibmphp_hpc.c:		/* give up the hardware semaphore */
drivers/pci/host/pci-hyperv.c:#include <linux/semaphore.h>
drivers/pci/host/pci-hyperv.c:	struct semaphore enum_sem;
drivers/pci/pci.h:extern struct rw_semaphore pci_bus_sem;
drivers/i2c/busses/i2c-nomadik.c: * semaphore set in the kernel i2c_transfer() function.
drivers/i2c/busses/Kconfig:	bool "Intel Baytrail I2C semaphore support"
drivers/i2c/busses/i2c-designware-baytrail.c: * Intel BayTrail PMIC I2C bus semaphore implementaion
drivers/i2c/busses/i2c-designware-baytrail.c:		dev_err(dev, "iosf failed to read punit semaphore\n");
drivers/i2c/busses/i2c-designware-baytrail.c:static void reset_semaphore(struct device *dev)
drivers/i2c/busses/i2c-designware-baytrail.c:		dev_err(dev, "iosf failed to reset punit semaphore during read\n");
drivers/i2c/busses/i2c-designware-baytrail.c:		dev_err(dev, "iosf failed to reset punit semaphore during write\n");
drivers/i2c/busses/i2c-designware-baytrail.c:	/* host driver writes to side band semaphore register */
drivers/i2c/busses/i2c-designware-baytrail.c:		dev_err(dev->dev, "iosf punit semaphore request failed\n");
drivers/i2c/busses/i2c-designware-baytrail.c:	/* host driver waits for bit 0 to be set in semaphore register */
drivers/i2c/busses/i2c-designware-baytrail.c:			dev_dbg(dev->dev, "punit semaphore acquired after %ums\n",
drivers/i2c/busses/i2c-designware-baytrail.c:	dev_err(dev->dev, "punit semaphore timed out, resetting\n");
drivers/i2c/busses/i2c-designware-baytrail.c:	reset_semaphore(dev->dev);
drivers/i2c/busses/i2c-designware-baytrail.c:		dev_err(dev->dev, "iosf failed to read punit semaphore\n");
drivers/i2c/busses/i2c-designware-baytrail.c:	reset_semaphore(dev->dev);
drivers/i2c/busses/i2c-designware-baytrail.c:	dev_dbg(dev->dev, "punit semaphore held for %ums\n",
drivers/i2c/i2c-core.h:extern struct rw_semaphore	__i2c_board_lock;
drivers/staging/android/ashmem.c:	 * semaphore and will be waiting for ashmem_mutex, there by leading to
drivers/staging/android/ion/ion_priv.h:	struct rw_semaphore lock;
drivers/staging/olpc_dcon/olpc_dcon.c:		 * messing with semaphores.
drivers/staging/comedi/comedidev.h: * @attach_lock: &struct rw_semaphore used to guard against the COMEDI device
drivers/staging/comedi/comedidev.h:	struct rw_semaphore attach_lock;
drivers/staging/comedi/drivers/vmk80xx.c:	struct semaphore limit_sem;
drivers/staging/comedi/drivers/s626.h:						 * semaphores.
drivers/staging/comedi/drivers/s626.h:						 * RPS semaphore 0
drivers/staging/comedi/drivers/s626.h:						 * RPS semaphore 1
drivers/staging/comedi/drivers/s626.h:						 * RPS semaphore 2
drivers/staging/lustre/lustre/mdc/mdc_reint.c:/* mdc_setattr does its own semaphore handling */
drivers/staging/lustre/lustre/llite/file.c:	struct rw_semaphore	ioc_sem;
drivers/staging/lustre/lustre/llite/llite_internal.h:			 * struct rw_semaphore {
drivers/staging/lustre/lustre/llite/llite_internal.h:			struct rw_semaphore		lli_trunc_sem;
drivers/staging/lustre/lustre/llite/llite_internal.h:			struct rw_semaphore		lli_glimpse_sem;
drivers/staging/lustre/lustre/llite/llite_internal.h:	struct rw_semaphore		lli_xattrs_list_rwsem;
drivers/staging/lustre/lustre/include/lustre/lustre_errno.h:#define LUSTRE_ENAVAIL		119	/* No XENIX semaphores available */
drivers/staging/lustre/lustre/include/obd.h:	struct rw_semaphore  cl_sem;
drivers/staging/lustre/lustre/include/obd.h:	struct rw_semaphore op_rw_sem;     /* to protect ost_pool use */
drivers/staging/lustre/lustre/include/obd.h:	struct rw_semaphore     lov_notify_lock;
drivers/staging/lustre/lustre/include/obd.h:	/* a spinlock is OK for what we do now, may need a semaphore later */
drivers/staging/lustre/lustre/include/obd.h:	struct rw_semaphore	obd_observer_link_sem;
drivers/staging/lustre/lustre/include/obd_class.h:struct rw_semaphore;
drivers/staging/lustre/lustre/include/obd_class.h:	struct rw_semaphore	rsi_sem;
drivers/staging/lustre/lustre/include/lustre_log.h:	struct rw_semaphore	 lgh_lock;
drivers/staging/lustre/lustre/lov/lov_cl_internal.h: * happens, lov_object::lo_type_guard semaphore is taken in exclusive mode,
drivers/staging/lustre/lustre/lov/lov_cl_internal.h: * constructed. All object methods take said semaphore in the shared mode,
drivers/staging/lustre/lustre/lov/lov_cl_internal.h:	 * This semaphore is taken in shared mode by all object methods, and
drivers/staging/lustre/lustre/lov/lov_cl_internal.h:	struct rw_semaphore	lo_type_guard;
drivers/staging/lustre/lustre/mgc/mgc_request.c:	 * semaphore to make the check non-racy.
drivers/staging/dgnc/dgnc_tty.c:	 * control access to it with a semaphore.  If we are paging, we
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:#include <linux/semaphore.h>
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore *event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore remove_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore bulk_remove_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore quota_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore connect;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore trigger_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore recycle_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore sync_trigger_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore sync_release_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore slot_available_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore slot_remove_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore data_quota_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h:	struct semaphore event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_2835_arm.c:static struct semaphore g_free_fragments_sema;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_killable.h:#include <linux/semaphore.h>
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_killable.h:static inline int __must_check down_interruptible_killable(struct semaphore *sem)
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:#include <linux/semaphore.h>
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	struct semaphore insert_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	struct semaphore remove_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	struct semaphore close_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	struct semaphore insert_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	struct semaphore remove_event;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.h:#include <linux/semaphore.h>
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_util.h:#include <linux/semaphore.h>
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_util.h:	struct semaphore pop;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_util.h:	struct semaphore push;
drivers/staging/vc04_services/interface/vchi/message_drivers/message.h:#include <linux/semaphore.h>
drivers/staging/vc04_services/interface/vchi/message_drivers/message.h:   struct semaphore   sem;
drivers/staging/vc04_services/interface/vchi/message_drivers/message.h:   struct semaphore *blocking;
drivers/staging/vc04_services/interface/vchi/connections/connection.h:#include <linux/semaphore.h>
drivers/staging/vc04_services/interface/vchi/connections/connection.h:   struct semaphore             sem;
drivers/staging/rtl8192u/ieee80211/ieee80211.h:#include <linux/semaphore.h>
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:	 * on the semaphore
drivers/staging/rtl8712/rtl871x_cmd.c:#include <linux/semaphore.h>
drivers/staging/rtl8712/osdep_service.h:#include <linux/semaphore.h>
drivers/staging/rtl8712/rtl871x_event.h:#include <linux/semaphore.h>
drivers/staging/rtl8712/rtl871x_security.c:#include <linux/semaphore.h>
drivers/staging/rtl8712/rtl871x_ioctl_linux.c:#include <linux/semaphore.h>
drivers/staging/rtl8712/rtl8712_cmd.c:#include <linux/semaphore.h>
drivers/staging/speakup/main.c:/* Allocation concurrency is protected by the console semaphore */
drivers/atm/ambassador.c:  use a semaphore.
drivers/atm/ambassador.c:      // semaphore for txer/rxer modifications - we cannot use a
drivers/isdn/gigaset/isocdata.c: * acquire the write semaphore
drivers/isdn/gigaset/isocdata.c:		gig_dbg(DEBUG_ISO, "%s: couldn't acquire iso write semaphore",
drivers/isdn/gigaset/isocdata.c:		"%s: acquired iso write semaphore, data[write]=%02x, nbits=%d",
drivers/isdn/gigaset/isocdata.c: * release the write semaphore
drivers/isdn/gigaset/isocdata.c: * must be called with the write semaphore held
drivers/isdn/gigaset/isocdata.c: * must be called with the write semaphore held
drivers/isdn/gigaset/isocdata.c: *		(write semaphore must be held)
drivers/isdn/gigaset/isocdata.c: *		(write semaphore must be held)
drivers/isdn/gigaset/isocdata.c: *	-EAGAIN if write semaphore busy or buffer full
drivers/isdn/gigaset/isocdata.c: *		(write semaphore must be held)
drivers/isdn/gigaset/isocdata.c: *	-EAGAIN if write semaphore busy or buffer full
drivers/isdn/gigaset/gigaset.h: * - writesem is the semaphore for writing to the buffer:
drivers/isdn/i4l/isdn_net.c: * This might sleep and must be called with the isdn semaphore down.
drivers/isdn/i4l/isdn_common.c: * to be dangerous and for debugging purpose only). The inode semaphore
drivers/isdn/i4l/isdn_common.c: * to be dangerous and for debugging purpose only). The inode semaphore
drivers/isdn/i4l/isdn_common.c: * are serialized by means of a semaphore.
drivers/uwb/umc-bus.c:	 * it tries to retake the dev->parent semaphore.
drivers/uwb/whc-rc.c: * When we up the command semaphore, everybody possibly held trying to
drivers/base/dd.c: * Should somehow figure out how to use a semaphore, not an atomic variable...
drivers/nvme/target/nvmet.h:extern struct rw_semaphore nvmet_config_sem;
drivers/nvme/target/core.c: * This read/write semaphore is used to synchronize access to configuration
drivers/nvme/target/core.c: * The full list of resources to protected by this semaphore is:
drivers/net/irda/sir-dev.h:	struct semaphore	sem;
drivers/net/hamradio/6pack.c:#include <linux/semaphore.h>
drivers/net/hamradio/6pack.c:	struct semaphore	dead_sem;
drivers/net/hamradio/mkiss.c:	struct semaphore	dead_sem;
drivers/net/wireless/st/cw1200/scan.h:#include <linux/semaphore.h>
drivers/net/wireless/st/cw1200/scan.h:	struct semaphore lock;
drivers/net/wireless/intersil/prism54/isl_ioctl.c: * schedule_work(), thus we can as well use sleeping semaphore
drivers/net/wireless/intersil/prism54/islpci_dev.h:        struct rw_semaphore mib_sem;
drivers/net/wireless/intersil/prism54/islpci_dev.h:	/* The first is accessed under semaphore locking.
drivers/net/wireless/intel/iwlwifi/pcie/trans.c:	 * Check the RSA semaphore is accessible.
drivers/net/wireless/intel/iwlwifi/pcie/trans.c:	 * If the HW isn't locked and the rsa semaphore isn't accessible,
drivers/net/wireless/intel/iwlwifi/pcie/trans.c:			       "can't access the RSA semaphore it is write protected\n");
drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c: * The device's EEPROM semaphore prevents conflicts between driver and uCode
drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c: * weren't arbitrated by the semaphore.
drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c:static int iwl_eeprom_acquire_semaphore(struct iwl_trans *trans)
drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c:		/* Request semaphore */
drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c:					 "Acquired semaphore after %d tries.\n",
drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c:static void iwl_eeprom_release_semaphore(struct iwl_trans *trans)
drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c:	ret = iwl_eeprom_acquire_semaphore(trans);
drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c:		IWL_ERR(trans, "Failed to acquire EEPROM semaphore.\n");
drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c:	iwl_eeprom_release_semaphore(trans);
drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c:	iwl_eeprom_release_semaphore(trans);
drivers/net/wireless/intel/ipw2x00/ipw2200.c:	/* TODO: We should use semaphores or locks for access to priv */
drivers/net/wireless/intel/iwlegacy/4965.h:int il4965_eeprom_acquire_semaphore(struct il_priv *il);
drivers/net/wireless/intel/iwlegacy/4965.h:void il4965_eeprom_release_semaphore(struct il_priv *il);
drivers/net/wireless/intel/iwlegacy/common.c:	ret = il->ops->eeprom_acquire_semaphore(il);
drivers/net/wireless/intel/iwlegacy/common.c:		IL_ERR("Failed to acquire EEPROM semaphore.\n");
drivers/net/wireless/intel/iwlegacy/common.c:	il->ops->eeprom_release_semaphore(il);
drivers/net/wireless/intel/iwlegacy/common.h:	int (*eeprom_acquire_semaphore) (struct il_priv *il);
drivers/net/wireless/intel/iwlegacy/common.h:	void (*eeprom_release_semaphore) (struct il_priv *il);
drivers/net/wireless/intel/iwlegacy/4965.c: * The device's EEPROM semaphore prevents conflicts between driver and uCode
drivers/net/wireless/intel/iwlegacy/4965.c: * weren't arbitrated by the semaphore.
drivers/net/wireless/intel/iwlegacy/4965.c:il4965_eeprom_acquire_semaphore(struct il_priv *il)
drivers/net/wireless/intel/iwlegacy/4965.c:		/* Request semaphore */
drivers/net/wireless/intel/iwlegacy/4965.c:il4965_eeprom_release_semaphore(struct il_priv *il)
drivers/net/wireless/intel/iwlegacy/4965.c:	.eeprom_acquire_semaphore = il4965_eeprom_acquire_semaphore,
drivers/net/wireless/intel/iwlegacy/4965.c:	.eeprom_release_semaphore = il4965_eeprom_release_semaphore,
drivers/net/wireless/intel/iwlegacy/3945.c:il3945_eeprom_acquire_semaphore(struct il_priv *il)
drivers/net/wireless/intel/iwlegacy/3945.c:il3945_eeprom_release_semaphore(struct il_priv *il)
drivers/net/wireless/intel/iwlegacy/3945.c:	.eeprom_acquire_semaphore = il3945_eeprom_acquire_semaphore,
drivers/net/wireless/intel/iwlegacy/3945.c:	.eeprom_release_semaphore = il3945_eeprom_release_semaphore,
drivers/net/wireless/marvell/mwifiex/sdio.c:static struct semaphore add_remove_card_sem;
drivers/net/wireless/marvell/mwifiex/sdio.c: * This initiates the semaphore and registers the device with
drivers/net/wireless/marvell/mwifiex/scan.c:			    "%s: acquire semaphore fail\n",
drivers/net/wireless/marvell/mwifiex/usb.c:static struct semaphore add_remove_card_sem;
drivers/net/wireless/marvell/mwifiex/usb.c: * This initiates the semaphore and registers the device with
drivers/net/wireless/marvell/mwifiex/main.h:#include <linux/semaphore.h>
drivers/net/wireless/marvell/mwifiex/main.h:	struct semaphore async_sem;
drivers/net/wireless/marvell/mwifiex/main.h:	struct semaphore *card_sem;
drivers/net/wireless/marvell/mwifiex/main.h:int mwifiex_add_card(void *, struct semaphore *, struct mwifiex_if_ops *, u8);
drivers/net/wireless/marvell/mwifiex/main.h:int mwifiex_remove_card(struct mwifiex_adapter *, struct semaphore *);
drivers/net/wireless/marvell/mwifiex/pcie.c:static struct semaphore add_remove_card_sem;
drivers/net/wireless/marvell/mwifiex/pcie.c: * This initiates the semaphore and registers the device with
drivers/net/wireless/marvell/mwifiex/main.c:	struct semaphore *sem = adapter->card_sem;
drivers/net/wireless/marvell/mwifiex/main.c:mwifiex_shutdown_sw(struct mwifiex_adapter *adapter, struct semaphore *sem)
drivers/net/wireless/marvell/mwifiex/main.c:mwifiex_reinit_sw(struct mwifiex_adapter *adapter, struct semaphore *sem,
drivers/net/wireless/marvell/mwifiex/main.c:mwifiex_add_card(void *card, struct semaphore *sem,
drivers/net/wireless/marvell/mwifiex/main.c:int mwifiex_remove_card(struct mwifiex_adapter *adapter, struct semaphore *sem)
drivers/net/wireless/ath/ath6kl/core.h:	struct semaphore sem;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c:#include <linux/semaphore.h>
drivers/net/wireless/cisco/airo.c:	struct semaphore sem;
drivers/net/wireless/zydas/zd1211rw/zd_mac.c:	 * Try very hard to release device beacon semaphore, as otherwise
drivers/net/wireless/zydas/zd1211rw/zd_mac.c:	/* semaphore stuck, reset device to avoid fw freeze later */
drivers/net/ppp/ppp_async.c:	struct semaphore dead_sem;
drivers/net/ppp/ppp_generic.c:	struct rw_semaphore chan_sem;	/* protects `chan' during chan ioctl */
drivers/net/wimax/i2400m/usb.c: *    as a poor man's semaphore. Ugly, but it works.
drivers/net/bonding/bond_main.c: * b. The operation is protected by the RTNL semaphore in the 8021q code,
drivers/net/phy/mdio-gpio.c: *  by Laurent Pinchart <laurentp@cse-semaphore.com>
drivers/net/wan/cosa.c:	struct semaphore wsem;
drivers/net/ethernet/intel/i40evf/i40e_type.h:	u64 hw_semaphore_timeout; /* usec global time (GTIME resolution) */
drivers/net/ethernet/intel/igb/e1000_i210.c: * igb_get_hw_semaphore_i210 - Acquire hardware semaphore
drivers/net/ethernet/intel/igb/e1000_i210.c: *  Acquire the HW semaphore to access the PHY or NVM
drivers/net/ethernet/intel/igb/e1000_i210.c:static s32 igb_get_hw_semaphore_i210(struct e1000_hw *hw)
drivers/net/ethernet/intel/igb/e1000_i210.c:	/* Get the SW semaphore */
drivers/net/ethernet/intel/igb/e1000_i210.c:		/* In rare circumstances, the SW semaphore may already be held
drivers/net/ethernet/intel/igb/e1000_i210.c:		 * unintentionally. Clear the semaphore once before giving up.
drivers/net/ethernet/intel/igb/e1000_i210.c:		if (hw->dev_spec._82575.clear_semaphore_once) {
drivers/net/ethernet/intel/igb/e1000_i210.c:			hw->dev_spec._82575.clear_semaphore_once = false;
drivers/net/ethernet/intel/igb/e1000_i210.c:			igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_i210.c:		/* If we do not have the semaphore here, we have to give up. */
drivers/net/ethernet/intel/igb/e1000_i210.c:	/* Get the FW semaphore. */
drivers/net/ethernet/intel/igb/e1000_i210.c:		/* Release semaphores */
drivers/net/ethernet/intel/igb/e1000_i210.c:		igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_i210.c: *  Acquire the necessary semaphores for exclusive access to the EEPROM.
drivers/net/ethernet/intel/igb/e1000_i210.c: *  then release the semaphores acquired.
drivers/net/ethernet/intel/igb/e1000_i210.c: *  igb_acquire_swfw_sync_i210 - Acquire SW/FW semaphore
drivers/net/ethernet/intel/igb/e1000_i210.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/igb/e1000_i210.c: *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/igb/e1000_i210.c:		if (igb_get_hw_semaphore_i210(hw)) {
drivers/net/ethernet/intel/igb/e1000_i210.c:		igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_i210.c:	igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_i210.c: *  igb_release_swfw_sync_i210 - Release SW/FW semaphore
drivers/net/ethernet/intel/igb/e1000_i210.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/igb/e1000_i210.c: *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/igb/e1000_i210.c:	while (igb_get_hw_semaphore_i210(hw))
drivers/net/ethernet/intel/igb/e1000_i210.c:	igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_i210.c: *  Uses necessary synchronization semaphores.
drivers/net/ethernet/intel/igb/e1000_i210.c:	/* We cannot hold synchronization semaphores for too long,
drivers/net/ethernet/intel/igb/e1000_i210.c:	/* We cannot hold synchronization semaphores for too long,
drivers/net/ethernet/intel/igb/e1000_i210.c:		/* Replace the read function with semaphore grabbing with
drivers/net/ethernet/intel/igb/e1000_i210.c:		 * We have semaphore taken already here.
drivers/net/ethernet/intel/igb/e1000_i210.c:		 * semaphores twice here.
drivers/net/ethernet/intel/igb/e1000_mac.c: *  igb_get_hw_semaphore - Acquire hardware semaphore
drivers/net/ethernet/intel/igb/e1000_mac.c: *  Acquire the HW semaphore to access the PHY or NVM
drivers/net/ethernet/intel/igb/e1000_mac.c:s32 igb_get_hw_semaphore(struct e1000_hw *hw)
drivers/net/ethernet/intel/igb/e1000_mac.c:	/* Get the SW semaphore */
drivers/net/ethernet/intel/igb/e1000_mac.c:	/* Get the FW semaphore. */
drivers/net/ethernet/intel/igb/e1000_mac.c:		/* Release semaphores */
drivers/net/ethernet/intel/igb/e1000_mac.c:		igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_mac.c: *  igb_put_hw_semaphore - Release hardware semaphore
drivers/net/ethernet/intel/igb/e1000_mac.c: *  Release hardware semaphore used to access the PHY or NVM
drivers/net/ethernet/intel/igb/e1000_mac.c:void igb_put_hw_semaphore(struct e1000_hw *hw)
drivers/net/ethernet/intel/igb/e1000_hw.h:	bool clear_semaphore_once;
drivers/net/ethernet/intel/igb/e1000_mac.h:s32  igb_get_hw_semaphore(struct e1000_hw *hw);
drivers/net/ethernet/intel/igb/e1000_mac.h:void igb_put_hw_semaphore(struct e1000_hw *hw);
drivers/net/ethernet/intel/igb/e1000_phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/igb/e1000_phy.c: *  semaphores before exiting.
drivers/net/ethernet/intel/igb/e1000_phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/igb/e1000_phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/igb/e1000_phy.c: *  semaphore (if necessary) and read/set/write the device control reset
drivers/net/ethernet/intel/igb/e1000_phy.c: *  reset and release the semaphore (if necessary).
drivers/net/ethernet/intel/igb/e1000_82575.c:	/* Allow a single clear of the SW semaphore on I210 and newer */
drivers/net/ethernet/intel/igb/e1000_82575.c:		dev_spec->clear_semaphore_once = true;
drivers/net/ethernet/intel/igb/e1000_82575.c: *  Acquire the necessary semaphores for exclusive access to the EEPROM.
drivers/net/ethernet/intel/igb/e1000_82575.c: *  then release the semaphores acquired.
drivers/net/ethernet/intel/igb/e1000_82575.c: *  igb_acquire_swfw_sync_82575 - Acquire SW/FW semaphore
drivers/net/ethernet/intel/igb/e1000_82575.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/igb/e1000_82575.c: *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/igb/e1000_82575.c:		if (igb_get_hw_semaphore(hw)) {
drivers/net/ethernet/intel/igb/e1000_82575.c:		igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_82575.c:	igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_82575.c: *  igb_release_swfw_sync_82575 - Release SW/FW semaphore
drivers/net/ethernet/intel/igb/e1000_82575.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/igb/e1000_82575.c: *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/igb/e1000_82575.c:	while (igb_get_hw_semaphore(hw) != 0)
drivers/net/ethernet/intel/igb/e1000_82575.c:	igb_put_hw_semaphore(hw);
drivers/net/ethernet/intel/igb/e1000_82575.c:	/* Release semaphore */
drivers/net/ethernet/intel/e1000/e1000_hw.h:	u32 eeprom_semaphore_present;
drivers/net/ethernet/intel/e1000e/manage.c: *  Reads the firmware semaphore register and returns true (>0) if
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  Assumes the sw/fw/hw semaphore is already acquired.
drivers/net/ethernet/intel/e1000e/ich8lan.c:		e_dbg("Failed to acquire the semaphore, FW or HW has it: FWSM=0x%8.8x EXTCNF_CTRL=0x%8.8x)\n",
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/mac.c: *  e1000e_get_hw_semaphore - Acquire hardware semaphore
drivers/net/ethernet/intel/e1000e/mac.c: *  Acquire the HW semaphore to access the PHY or NVM
drivers/net/ethernet/intel/e1000e/mac.c:s32 e1000e_get_hw_semaphore(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/mac.c:	/* Get the SW semaphore */
drivers/net/ethernet/intel/e1000e/mac.c:	/* Get the FW semaphore. */
drivers/net/ethernet/intel/e1000e/mac.c:		/* Release semaphores */
drivers/net/ethernet/intel/e1000e/mac.c:		e1000e_put_hw_semaphore(hw);
drivers/net/ethernet/intel/e1000e/mac.c: *  e1000e_put_hw_semaphore - Release hardware semaphore
drivers/net/ethernet/intel/e1000e/mac.c: *  Release hardware semaphore used to access the PHY or NVM
drivers/net/ethernet/intel/e1000e/mac.c:void e1000e_put_hw_semaphore(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/defines.h:#define E1000_SWSM2_LOCK        0x00000002 /* Secondary driver semaphore bit */
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Acquire the semaphore to access the Kumeran interface.
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Release the semaphore used to access the Kumeran interface
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Acquire the semaphore to access the EEPROM.
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Release the semaphore used to access the EEPROM.
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  e1000_acquire_swfw_sync_80003es2lan - Acquire SW/FW semaphore
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/e1000e/80003es2lan.c:		if (e1000e_get_hw_semaphore(hw))
drivers/net/ethernet/intel/e1000e/80003es2lan.c:		e1000e_put_hw_semaphore(hw);
drivers/net/ethernet/intel/e1000e/80003es2lan.c:	e1000e_put_hw_semaphore(hw);
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  e1000_release_swfw_sync_80003es2lan - Release SW/FW semaphore
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  @mask: specifies which semaphore to acquire
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask
drivers/net/ethernet/intel/e1000e/80003es2lan.c:	while (e1000e_get_hw_semaphore(hw) != 0)
drivers/net/ethernet/intel/e1000e/80003es2lan.c:	e1000e_put_hw_semaphore(hw);
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Acquire semaphore, then read the PHY register at offset
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Release the semaphore before exiting.
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  Acquire semaphore, then write the data to PHY register
drivers/net/ethernet/intel/e1000e/80003es2lan.c: *  at the offset using the kumeran interface.  Release semaphore
drivers/net/ethernet/intel/e1000e/mac.h:s32 e1000e_get_hw_semaphore(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/mac.h:void e1000e_put_hw_semaphore(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/netdev.c: * semaphore to read the phy, which we could msleep while
drivers/net/ethernet/intel/e1000e/regs.h:/* Driver-only SW semaphore (not used by BOOT agents) */
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82571(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82573(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/82571.c:static s32 e1000_get_hw_semaphore_82574(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82574(struct e1000_hw *hw);
drivers/net/ethernet/intel/e1000e/82571.c:		phy->ops.acquire = e1000_get_hw_semaphore_82574;
drivers/net/ethernet/intel/e1000e/82571.c:		phy->ops.release = e1000_put_hw_semaphore_82574;
drivers/net/ethernet/intel/e1000e/82571.c:		nvm->ops.acquire = e1000_get_hw_semaphore_82574;
drivers/net/ethernet/intel/e1000e/82571.c:		nvm->ops.release = e1000_put_hw_semaphore_82574;
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_get_hw_semaphore_82571 - Acquire hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Acquire the HW semaphore to access the PHY or NVM
drivers/net/ethernet/intel/e1000e/82571.c:static s32 e1000_get_hw_semaphore_82571(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c:	 * the inter-port SMBI semaphore, there is old code
drivers/net/ethernet/intel/e1000e/82571.c:	 * we try for the semaphore to interwork with this
drivers/net/ethernet/intel/e1000e/82571.c:	/* Get the SW semaphore */
drivers/net/ethernet/intel/e1000e/82571.c:	/* Get the FW semaphore. */
drivers/net/ethernet/intel/e1000e/82571.c:		/* Release semaphores */
drivers/net/ethernet/intel/e1000e/82571.c:		e1000_put_hw_semaphore_82571(hw);
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_put_hw_semaphore_82571 - Release hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Release hardware semaphore used to access the PHY or NVM
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82571(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_get_hw_semaphore_82573 - Acquire hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Acquire the HW semaphore during reset.
drivers/net/ethernet/intel/e1000e/82571.c:static s32 e1000_get_hw_semaphore_82573(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c:		/* Release semaphores */
drivers/net/ethernet/intel/e1000e/82571.c:		e1000_put_hw_semaphore_82573(hw);
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_put_hw_semaphore_82573 - Release hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Release hardware semaphore used during reset.
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82573(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_get_hw_semaphore_82574 - Acquire hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Acquire the HW semaphore to access the PHY or NVM.
drivers/net/ethernet/intel/e1000e/82571.c:static s32 e1000_get_hw_semaphore_82574(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c:	ret_val = e1000_get_hw_semaphore_82573(hw);
drivers/net/ethernet/intel/e1000e/82571.c: *  e1000_put_hw_semaphore_82574 - Release hardware semaphore
drivers/net/ethernet/intel/e1000e/82571.c: *  Release hardware semaphore used to access the PHY or NVM
drivers/net/ethernet/intel/e1000e/82571.c:static void e1000_put_hw_semaphore_82574(struct e1000_hw *hw)
drivers/net/ethernet/intel/e1000e/82571.c:	e1000_put_hw_semaphore_82573(hw);
drivers/net/ethernet/intel/e1000e/82571.c: *  To gain access to the EEPROM, first we must obtain a hardware semaphore.
drivers/net/ethernet/intel/e1000e/82571.c: *  hardware semaphore.
drivers/net/ethernet/intel/e1000e/82571.c:	ret_val = e1000_get_hw_semaphore_82571(hw);
drivers/net/ethernet/intel/e1000e/82571.c:		e1000_put_hw_semaphore_82571(hw);
drivers/net/ethernet/intel/e1000e/82571.c:	e1000_put_hw_semaphore_82571(hw);
drivers/net/ethernet/intel/e1000e/82571.c:		ret_val = e1000_get_hw_semaphore_82573(hw);
drivers/net/ethernet/intel/e1000e/82571.c:		ret_val = e1000_get_hw_semaphore_82574(hw);
drivers/net/ethernet/intel/e1000e/82571.c:		/* Release mutex only if the hw semaphore is acquired */
drivers/net/ethernet/intel/e1000e/82571.c:			e1000_put_hw_semaphore_82573(hw);
drivers/net/ethernet/intel/e1000e/82571.c:		/* Release mutex only if the hw semaphore is acquired */
drivers/net/ethernet/intel/e1000e/82571.c:			e1000_put_hw_semaphore_82574(hw);
drivers/net/ethernet/intel/e1000e/82571.c:	.acquire		= e1000_get_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/82571.c:	.release		= e1000_put_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/82571.c:	.acquire		= e1000_get_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/82571.c:	.release		= e1000_put_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/82571.c:	.acquire		= e1000_get_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/82571.c:	.release		= e1000_put_hw_semaphore_82571,
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Sets PHY page required for PHY register access.  Assumes semaphore is
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then reads the PHY register at offset and stores the
drivers/net/ethernet/intel/e1000e/phy.c: *  Release the acquired semaphore before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  in data.  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary.  Then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then reads the PHY register at offset using the
drivers/net/ethernet/intel/e1000e/phy.c: *  Release the acquired semaphore before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary.  Then write the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset using the kumeran interface.  Release any acquired semaphores
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then writes the data to the PHY register at the offset
drivers/net/ethernet/intel/e1000e/phy.c: *  using the kumeran interface.  Release the acquired semaphore before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphore (if necessary) and read/set/write the device control reset
drivers/net/ethernet/intel/e1000e/phy.c: *  reset and release the semaphore (if necessary).
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore already acquired and phy_reg points to a valid memory
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore already acquired and *phy_reg is the contents of the
drivers/net/ethernet/intel/e1000e/phy.c: *  Assumes semaphore is already acquired.  When page_set==true, assumes
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then reads the PHY register at offset
drivers/net/ethernet/intel/e1000e/phy.c: *  semaphore before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then reads the PHY register at offset and stores
drivers/net/ethernet/intel/e1000e/phy.c: *  the retrieved information in data.  Release the acquired semaphore
drivers/net/ethernet/intel/e1000e/phy.c: *  in data.  Assumes semaphore already acquired.
drivers/net/ethernet/intel/e1000e/phy.c: *  in data.  Assumes semaphore already acquired and page already set.
drivers/net/ethernet/intel/e1000e/phy.c: *  @locked: semaphore has already been acquired or not
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore, if necessary, then writes the data to PHY register
drivers/net/ethernet/intel/e1000e/phy.c: *  at the offset.  Release any acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Acquires semaphore then writes the data to PHY register at the offset.
drivers/net/ethernet/intel/e1000e/phy.c: *  Release the acquired semaphores before exiting.
drivers/net/ethernet/intel/e1000e/phy.c: *  Writes the data to PHY register at the offset.  Assumes semaphore
drivers/net/ethernet/intel/e1000e/phy.c: *  Writes the data to PHY register at the offset.  Assumes semaphore
drivers/net/ethernet/intel/e1000e/phy.c: *  in data.  Assumes semaphore already acquired.  Note that the procedure
drivers/net/ethernet/intel/i40e/i40e_type.h:	u64 hw_semaphore_timeout; /* usec global time (GTIME resolution) */
drivers/net/ethernet/intel/i40e/i40e_nvm.c:	hw->nvm.hw_semaphore_timeout = I40E_MS_TO_GTIME(time_left) + gtime;
drivers/net/ethernet/intel/i40e/i40e_nvm.c:				hw->nvm.hw_semaphore_timeout =
drivers/net/ethernet/intel/i40e/i40e_nvm.c:			hw->nvm.hw_semaphore_timeout = 0;
drivers/net/ethernet/intel/i40e/i40e_nvm.c:	 * the synchronization semaphores twice here.
drivers/net/ethernet/intel/i40e/i40e_nvm.c:	 * than the default 3 minute timeout on the write semaphore.  If
drivers/net/ethernet/intel/i40e/i40e_nvm.c:	 * so here we try to reacquire the semaphore then retry the write.
drivers/net/ethernet/intel/i40e/i40e_nvm.c:		if (gtime >= hw->nvm.hw_semaphore_timeout) {
drivers/net/ethernet/intel/i40e/i40e_nvm.c:				   "NVMUPD: write semaphore expired (%d >= %lld), retrying\n",
drivers/net/ethernet/intel/i40e/i40e_nvm.c:				   gtime, hw->nvm.hw_semaphore_timeout);
drivers/net/ethernet/intel/i40e/i40e_nvm.c:					   "NVMUPD: write semaphore reacquire failed aq_err = %d\n",
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		/* PHY config will finish before releasing the semaphore */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		/* Release the semaphore */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		 * Delay obtaining semaphore again to allow FW access,
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		 * semaphore_delay is in ms usleep_range needs us.
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		usleep_range(hw->eeprom.semaphore_delay * 1000,
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:			     hw->eeprom.semaphore_delay * 2000);
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	/* Release the semaphore */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	/* Delay obtaining semaphore again to allow FW access,
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	 * semaphore_delay is in ms usleep_range needs us.
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	usleep_range(hw->eeprom.semaphore_delay * 1000,
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:		     hw->eeprom.semaphore_delay * 2000);
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	/* If LESM is on then we need to hold the SW/FW semaphore. */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	/* Free the SW/FW semaphore as we either grabbed it here or
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c: * full pipeline reset.  Note - We must hold the SW/FW semaphore before writing
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c: * to AUTOC, so this function assumes the semaphore is held.
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		/* Need the SW/FW semaphore around AUTOC writes if 82599 and
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		/* Set default semaphore delay to 10ms which is a well
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		eeprom->semaphore_delay = 10;
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	 * We cannot hold synchronization semaphores for too long
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	 * We cannot hold synchronization semaphores for too long
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  ixgbe_get_eeprom_semaphore - Get hardware semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  Sets the hardware semaphores so EEPROM access can occur for bit-bang method
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	/* Get SMBI software semaphore between device drivers first */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * set and we have the semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * above to get the semaphore may have succeeded, and if there
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * was a timeout, we should unconditionally clear the semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		ixgbe_release_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * set and we have the semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:			hw_dbg(hw, "Software semaphore SMBI between device drivers not granted.\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	/* Now get the semaphore between SW/FW through the SWESMBI bit */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		/* Set the SW EEPROM semaphore bit to request access */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * semaphore.
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	/* Release semaphores and return error if SW EEPROM semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		hw_dbg(hw, "SWESMBI Software EEPROM semaphore not granted.\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		ixgbe_release_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  ixgbe_release_eeprom_semaphore - Release hardware semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  This function clears hardware semaphore bits.
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw)
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	/* Release both semaphores by writing 0 to the bits SWESMBI and SMBI */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  ixgbe_release_eeprom - Release EEPROM, release semaphores
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	 * Delay before attempt to obtain semaphore again to allow FW
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	 * access. semaphore_delay is in ms we need us for usleep_range
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	usleep_range(hw->eeprom.semaphore_delay * 1000,
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		     hw->eeprom.semaphore_delay * 2000);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  ixgbe_acquire_swfw_sync - Acquire SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  @mask: Mask to specify which semaphore to acquire
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  Acquires the SWFW semaphore through the GSSR register for the specified
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * SW NVM semaphore bit is used for access to all
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		if (ixgbe_get_eeprom_semaphore(hw))
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:			ixgbe_release_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:			ixgbe_release_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  ixgbe_release_swfw_sync - Release SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  @mask: Mask to specify which semaphore to release
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  Releases the SWFW semaphore through the GSSR register for the specified
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	ixgbe_get_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	ixgbe_release_eeprom_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	/* Take management host interface semaphore */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	/* Make sure the SWFW semaphore is in a valid state */
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * This function assumes that the caller has acquired the proper semaphore.
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:	u32 swfw_mask = hw->phy.phy_semaphore_mask;
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:			hw_err(hw, "semaphore failed with %d\n", status);
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:			hw_err(hw, "semaphore failed with %d\n", status);
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:	/* Reset takes so long, temporarily release semaphore in case the
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:		hw_err(hw, "semaphore failed with %d", status);
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:	msleep(hw->eeprom.semaphore_delay);
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:			hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY1_SM;
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:			hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:		hw->phy.phy_semaphore_mask = IXGBE_GSSR_SHARED_I2C_SM;
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:			hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY1_SM;
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:			hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:		eeprom->semaphore_delay = 10;
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: *  command assuming that the semaphore is already obtained.
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:	/* Take semaphore for the entire operation. */
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:		hw_dbg(hw, "EEPROM read buffer - semaphore failed\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:		hw_dbg(hw, "write ee hostif failed to get semaphore");
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:	/* Take semaphore for the entire operation. */
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:		hw_dbg(hw, "EEPROM write buffer - semaphore failed\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:		phy->phy_semaphore_mask = IXGBE_GSSR_SHARED_I2C_SM;
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * ixgbe_acquire_swfw_sync_X550em - Acquire SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * @mask: Mask to specify which semaphore to acquire
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * Acquires the SWFW semaphore and sets the I2C MUX
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * ixgbe_release_swfw_sync_X550em - Release SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * @mask: Mask to specify which semaphore to release
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * Releases the SWFW semaphore and sets the I2C MUX
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * ixgbe_acquire_swfw_sync_x550em_a - Acquire SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * @mask: Mask to specify which semaphore to acquire
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * Acquires the SWFW semaphore and get the shared PHY token as needed
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * ixgbe_release_swfw_sync_x550em_a - Release SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * @mask: Mask to specify which semaphore to release
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * Release the SWFW semaphore and puts the shared PHY token as needed
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:	u32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:	u32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c: *  @lock: true if to take and release semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:	u32 swfw_mask = hw->phy.phy_semaphore_mask;
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c: *  @lock: true if to take and release semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:	u32 swfw_mask = hw->phy.phy_semaphore_mask;
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:	if (!hw->phy.phy_semaphore_mask) {
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:			hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY1_SM;
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:			hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:	u32 gssr = hw->phy.phy_semaphore_mask;
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:	u32 gssr = hw->phy.phy_semaphore_mask;
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c: *  @lock: true if to take and release semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:	u32 swfw_mask = hw->phy.phy_semaphore_mask;
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c: *  @lock: true if to take and release semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:	u32 swfw_mask = hw->phy.phy_semaphore_mask;
drivers/net/ethernet/intel/ixgbe/ixgbe_type.h:	u32                             semaphore_delay;
drivers/net/ethernet/intel/ixgbe/ixgbe_type.h:	u32				phy_semaphore_mask;
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		eeprom->semaphore_delay = 10;
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	 * the synchronization semaphores here. Instead use
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	 * the synchronization semaphores twice here.
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	 * take the synchronization semaphores twice here.
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * ixgbe_acquire_swfw_sync_X540 - Acquire SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * @mask: Mask to specify which semaphore to acquire
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * Acquires the SWFW semaphore thought the SW_FW_SYNC register for
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		/* SW NVM semaphore bit is used for access to all
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		if (ixgbe_get_swfw_sync_semaphore(hw))
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:			ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	/* Failed to get SW only semaphore */
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		hw_dbg(hw, "Failed to get SW only semaphore\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	if (ixgbe_get_swfw_sync_semaphore(hw))
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * ixgbe_release_swfw_sync_X540 - Release SWFW semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * @mask: Mask to specify which semaphore to release
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * Releases the SWFW semaphore through the SW_FW_SYNC register
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	ixgbe_get_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * ixgbe_get_swfw_sync_semaphore - Get hardware semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * Sets the hardware semaphores so SW/FW can gain control of shared resources
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw)
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	/* Get SMBI software semaphore between device drivers first */
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		 * set and we have the semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:		       "Software semaphore SMBI between device drivers not granted.\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	/* Now get the semaphore between SW/FW through the REGSMP bit */
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	/* Release semaphores and return error if SW NVM semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	hw_dbg(hw, "REGSMP Software NVM semaphore not granted\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * ixgbe_release_nvm_semaphore - Release hardware semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: * This function clears hardware semaphore bits.
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw)
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	/* Release both semaphores by writing 0 to the bits REGSMP and SMBI */
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: *  ixgbe_init_swfw_sync_X540 - Release hardware semaphore
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: *  This function reset hardware semaphore bits for a semaphore that may
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	/* First try to grab the semaphore but we don't need to bother
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	ixgbe_get_swfw_sync_semaphore(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c:	ixgbe_release_swfw_sync_semaphore(hw);
drivers/net/ethernet/micrel/ksz884x.c:	struct semaphore proc_sem;
drivers/net/ethernet/ibm/emac/core.c:/* Process ctx, rtnl_lock semaphore */
drivers/net/ethernet/ibm/emac/core.c:/* Process ctx, rtnl_lock semaphore */
drivers/net/ethernet/ibm/emac/core.c:/* Process ctx, rtnl_lock semaphore */
drivers/net/ethernet/tehuti/tehuti.c: * can have few of them). So all drivers use semaphore register to choose one
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:	/* Acquire semaphore before accessing CRB */
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:	/* Release semaphore */
drivers/net/ethernet/qlogic/qla3xxx.h:/* semaphoreReg */
drivers/net/ethernet/qlogic/qla3xxx.h:	u32 semaphoreReg;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	/* Acquire semaphore before accessing CRB */
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	/* Release semaphore */
drivers/net/ethernet/qlogic/qlge/qlge_dbg.c:	/* Get the semaphore registers for all 5 functions */
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c: * Caller must hold PROC_ADDR semaphore.
drivers/net/ethernet/qlogic/qlge/qlge.h:	PROC_ADDR = 0,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	PROC_DATA = 0x04,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	ICB_RID = 0x1c,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	ICB_L = 0x20,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	ICB_H = 0x24,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	GPIO_1 = 0x68,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	GPIO_2 = 0x6c,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	GPIO_3 = 0x70,		/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	XGMAC_ADDR = 0x78,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	XGMAC_DATA = 0x7c,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	FLASH_ADDR = 0x88,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	FLASH_DATA = 0x8c,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	MAC_ADDR_IDX = 0xa8,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	MAC_ADDR_DATA = 0xac,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	PRB_MX_ADDR = 0xf8,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:	PRB_MX_DATA = 0xfc,	/* Use semaphore */
drivers/net/ethernet/qlogic/qlge/qlge.h:/* Maximum of 4 functions whose semaphore registeres are
drivers/net/ethernet/qlogic/qlge/qlge.h:	/* semaphore register for all 5 functions */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:/* This hardware semaphore causes exclusive access to
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		/* Another function has the semaphore, so
drivers/net/ethernet/qlogic/qlge/qlge_main.c:			   "Another function has the semaphore, so wait for the port init bit to come ready.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	netif_info(qdev, link, qdev->ndev, "Got xgmac semaphore!.\n");
drivers/net/ethernet/qlogic/qla3xxx.c:		       &port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/qla3xxx.c:		value = readl(&port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/qla3xxx.c:	writel(sem_mask, &port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/qla3xxx.c:	readl(&port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/qla3xxx.c:	writel((sem_mask | sem_bits), &port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/qlogic/qla3xxx.c:	value = readl(&port_regs->CommonRegs.semaphoreReg);
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:	 * issue an FLR because of a self- deadlock on the device semaphore.
drivers/net/ethernet/nvidia/forcedeth.c:/* The mgmt unit and driver use a semaphore to access the phy during init */
drivers/net/ethernet/nvidia/forcedeth.c:		/* verify that semaphore was acquired */
drivers/net/ethernet/neterion/vxge/vxge-main.h: * #define VXGE_DEBUG_SEM : debug semaphore
drivers/net/ethernet/brocade/bna/bfi_reg.h: * Name semaphore registers based on usage
drivers/net/ethernet/brocade/bna/bfi_reg.h: * CT2 semaphore register locations changed
drivers/net/ethernet/brocade/bna/bfa_defs.h:	BFA_IOC_SEMWAIT		= 3,	/*!< Waiting for IOC h/w semaphore */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	IOCPF_E_SEMLOCKED	= 10,   /*!< h/w semaphore is locked	*/
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	BFA_IOCPF_SEMWAIT	= 2,	/*!< Waiting for IOC h/w semaphore */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:/* Awaiting h/w semaphore to continue with version check. */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:/* Request for semaphore. */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:/* Awaiting semaphore for h/w initialzation. */
drivers/net/ethernet/brocade/bna/bfa_ioc.c: * Holding hardware semaphore lock.
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	/* Spin on init semaphore to serialize. */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 * Try to lock and then unlock the semaphore.
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	/* Unlock init semaphore */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 * First read to the semaphore register will return 0, subsequent reads
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 *  Hold semaphore to serialize pll init and fwtrc.
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 * release semaphore
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 *  Hold semaphore so that nobody can access the chip during init.
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 *  release semaphore.
drivers/net/ethernet/brocade/bna/bfa_ioc_ct.c:	 * IOC semaphore registers and serialization
drivers/net/ethernet/brocade/bna/bfa_ioc_ct.c:	 * IOC semaphore registers and serialization
drivers/net/ethernet/brocade/bna/bfa_ioc_ct.c:/* Cleanup hw semaphore and usecnt registers */
drivers/net/ethernet/brocade/bna/bfa_ioc_ct.c:	 * semaphore (in bfa_iocpf_sm_semwait()).
drivers/net/ethernet/toshiba/spider_net.c:	/* we don't use semaphores to wait for an SPIDER_NET_GPROPCMPINT
drivers/net/ethernet/toshiba/spider_net.c:		/* we don't use semaphores, as we poll for the completion
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:#include <linux/semaphore.h>
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:	struct semaphore	stats_lock;
drivers/net/ethernet/sfc/net_driver.h: * @filter_sem: Filter table rw_semaphore, for freeing the table
drivers/net/ethernet/sfc/net_driver.h:	struct rw_semaphore filter_sem;
drivers/net/ethernet/sfc/efx.h:static inline bool efx_rwsem_assert_write_locked(struct rw_semaphore *sem)
drivers/net/ethernet/mellanox/mlx5/core/cmd.c:	struct semaphore *sem;
drivers/net/ethernet/mellanox/mlx5/core/cmd.c:			struct semaphore *sem;
drivers/net/ethernet/mellanox/mlx4/mlx4.h:#include <linux/semaphore.h>
drivers/net/ethernet/mellanox/mlx4/mlx4.h:	struct semaphore	poll_sem;
drivers/net/ethernet/mellanox/mlx4/mlx4.h:	struct semaphore	event_sem;
drivers/net/ethernet/mellanox/mlx4/mlx4.h:	struct rw_semaphore	switch_sem;
drivers/net/ethernet/mellanox/mlx4/reset.c:	/* grab HW semaphore to lock out flash updates */
drivers/net/ethernet/mellanox/mlx4/reset.c:		mlx4_err(dev, "Failed to obtain HW semaphore, aborting\n");
drivers/net/ethernet/mellanox/mlx4/cmd.c:#include <linux/semaphore.h>
drivers/net/ethernet/mellanox/mlx4/mcg.c: * Caller must hold MCG table semaphore.  gid and mgm parameters must
drivers/net/ethernet/ti/davinci_emac.c:#include <linux/semaphore.h>
drivers/net/usb/hso.c:	/* and initialize the semaphore */
drivers/net/usb/hso.c:	/* Initialise the serial table semaphore and table */
drivers/net/caif/caif_spi_slave.c:#include <linux/semaphore.h>
drivers/crypto/mxs-dcp.c:	/* Increment the semaphore to start the DMA transfer. */
drivers/crypto/qat/qat_common/adf_cfg.h:	struct rw_semaphore lock;
drivers/crypto/ux500/cryp/cryp_core.c:#include <linux/semaphore.h>
drivers/crypto/ux500/cryp/cryp_core.c: * @device_allocation: A semaphore initialized with number of devices.
drivers/crypto/ux500/cryp/cryp_core.c:	struct semaphore device_allocation;
drivers/crypto/ux500/cryp/cryp_core.c:	 * The down_interruptible part for this semaphore is called in
drivers/crypto/ux500/cryp/cryp_core.c:	 * The down_interruptible part for this semaphore is called in
drivers/crypto/ux500/cryp/cryp_core.c:	/* Initialize the semaphore to 0 devices (locked state) */
drivers/crypto/ux500/hash/hash_core.c: * @device_allocation:	A semaphore initialized with number of devices.
drivers/crypto/ux500/hash/hash_core.c:	struct semaphore	device_allocation;
drivers/crypto/ux500/hash/hash_core.c:	 * The down_interruptible part for this semaphore is called in
drivers/crypto/ux500/hash/hash_core.c:	/* Initialize the semaphore to 0 devices (locked state) */
drivers/scsi/qlogicpti.h:/* SBUS semaphore register */
drivers/scsi/sr.c:/* This semaphore is used to mediate the 0->1 reference get in the
drivers/scsi/sr.c: *	scsi_cd_put() helpers which manipulate the semaphore directly
drivers/scsi/qla1280.h:	uint16_t semaphore;	/* Semaphore */
drivers/scsi/aic7xxx/aic7xxx_core.c: * to be executed.  We use a counting semaphore to allow the lock
drivers/scsi/aic7xxx/aic79xx.reg:	 * Counting semaphore to prevent new select-outs
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	/* misc semaphores and spin locks */
drivers/scsi/qla4xxx/ql4_init.c:		/* Reset clears the semaphore, so acquire again */
drivers/scsi/qla4xxx/ql4_fw.h:			__le32 semaphore;
drivers/scsi/qla4xxx/ql4_def.h:static inline void __iomem* isp_semaphore(struct scsi_qla_host *ha)
drivers/scsi/qla4xxx/ql4_def.h:		&ha->reg->u1.isp4022.semaphore);
drivers/scsi/qla4xxx/ql4_dbg.c:		printk(KERN_INFO "0x%02X semaphore	  = 0x%08X\n",
drivers/scsi/qla4xxx/ql4_dbg.c:		    (uint8_t) offsetof(struct isp_reg, u1.isp4022.semaphore),
drivers/scsi/qla4xxx/ql4_dbg.c:		    readw(&ha->reg->u1.isp4022.semaphore));
drivers/scsi/qla4xxx/ql4_nvram.c:		writel((sem_mask | sem_bits), isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nvram.c:		value = readw(isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nvram.c:	writel(sem_mask, isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nvram.c:	readl(isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nvram.c:	writel((sem_mask | sem_bits), isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nvram.c:	value = readw(isp_semaphore(ha));
drivers/scsi/qla4xxx/ql4_nx.c:		/* acquire semaphore3 from PCI HW block */
drivers/scsi/qla4xxx/ql4_nx.c:		/* acquire semaphore5 from PCI HW block */
drivers/scsi/qla4xxx/ql4_nx.c:		/* acquire semaphore2 from PCI HW block */
drivers/scsi/sd.c:/* This semaphore is used to mediate the 0->1 reference get in the
drivers/scsi/sd.c: *	scsi_disk_put() helpers which manipulate the semaphore directly
drivers/scsi/cxlflash/vlun.c: * semaphore. This will allow the EEH handler to proceed with a recovery while
drivers/scsi/cxlflash/vlun.c: * ioctl read semaphore and check the adapter state in case it changed while
drivers/scsi/cxlflash/superpipe.c: * unmark this thread as an ioctl thread by releasing the ioctl read semaphore.
drivers/scsi/cxlflash/superpipe.c: * semaphore and check the adapter state in case it changed while inside of
drivers/scsi/cxlflash/superpipe.c: * read semaphore. This is temporarily let up across the wait to allow
drivers/scsi/cxlflash/superpipe.c: * semaphore that is used to drain ioctls in recovery scenarios. The
drivers/scsi/cxlflash/superpipe.c: * requires that the ioctl r/w semaphore be dropped and reacquired to
drivers/scsi/cxlflash/superpipe.c: * A read/write semaphore is used to implement a 'drain' of currently
drivers/scsi/cxlflash/superpipe.c: * running ioctls. The read semaphore is taken at the beginning of each
drivers/scsi/cxlflash/superpipe.c: * semaphore should be released and then reacquired in any ioctl execution
drivers/scsi/cxlflash/superpipe.c: * a thread simply needs to acquire the write semaphore.
drivers/scsi/cxlflash/superpipe.c:	/* Hold read semaphore so we can drain if needed */
drivers/scsi/cxlflash/common.h:	struct rw_semaphore ioctl_rwsem;
drivers/scsi/cxlflash/main.c: * Obtain write access to read/write semaphore that wraps ioctl
drivers/scsi/dpt/osd_defs.h:  /* Define the mutually exclusive semaphore type */
drivers/scsi/dpt/osd_util.h:/* Mutually exclusive semaphore functions */
drivers/scsi/dpt/osd_util.h:  /* Create a named semaphore */
drivers/scsi/dpt/osd_util.h:  /* Create a mutually exlusive semaphore */
drivers/scsi/dpt/osd_util.h:	/* create an event semaphore */
drivers/scsi/dpt/osd_util.h:	/* create a named event semaphore */
drivers/scsi/dpt/osd_util.h:  /* Destroy the specified mutually exclusive semaphore object */
drivers/scsi/dpt/osd_util.h:  /* Request access to the specified mutually exclusive semaphore */
drivers/scsi/dpt/osd_util.h:  /* Release access to the specified mutually exclusive semaphore */
drivers/scsi/gdth.h:#define SEMA0REG        0x0c8a                  /* command semaphore */
drivers/scsi/gdth.h:#define SEMA1REG        0x0c8b                  /* status semaphore */
drivers/scsi/gdth.h:    u8 volatile     Sema0;                  /* command semaphore */
drivers/scsi/gdth.h:        u8 volatile Sema1;                  /* status semaphore */
drivers/scsi/gdth.h:        u8 volatile Sema1;                  /* command semaphore */
drivers/scsi/gdth.h:    u8 volatile     sema0_reg;              /* command semaphore */
drivers/scsi/gdth.h:    u8 volatile     sema1_reg;              /* status semaphore */
drivers/scsi/gdth.h:    u8 volatile     sema0_reg;              /* command semaphore */
drivers/scsi/gdth.h:    u8 volatile     sema1_reg;              /* status semaphore */
drivers/scsi/aha152x.c:	struct completion *done;/* semaphore to block on */
drivers/scsi/osst.c:/* Handle the write-behind checking (downs the semaphore) */
drivers/scsi/isci/phy.c:				 * semaphore state
drivers/scsi/isci/phy.c:			/* got IAF we can now go to the await spinup semaphore state */
drivers/scsi/megaraid/megaraid_mm.c: * The kioc_semaphore is initialized with number of kioc nodes in the
drivers/scsi/megaraid/megaraid_mm.c:	down(&adp->kioc_semaphore);
drivers/scsi/megaraid/megaraid_mm.c:		up(&adp->kioc_semaphore);
drivers/scsi/megaraid/megaraid_mm.c:	up(&adp->kioc_semaphore);
drivers/scsi/megaraid/megaraid_mm.c:	sema_init(&adapter->kioc_semaphore, lld_adp->max_kioc);
drivers/scsi/megaraid/megaraid_sas.h:	struct semaphore ioctl_sem;
drivers/scsi/megaraid/megaraid_ioctl.h:#include <linux/semaphore.h>
drivers/scsi/megaraid/megaraid_ioctl.h: * @kioc_semaphore	: so as not to exceed @max_kioc parallel ioctls
drivers/scsi/megaraid/megaraid_ioctl.h:	struct semaphore	kioc_semaphore;
drivers/scsi/megaraid/megaraid_mbox.c:	// wait for maximum 1 second for poll semaphore
drivers/scsi/megaraid/megaraid_mbox.c:			"megaraid mailbox: could not get poll semaphore\n"));
drivers/scsi/smartpqi/smartpqi.h:	struct semaphore sync_request_sem;
drivers/scsi/smartpqi/smartpqi.h:	struct semaphore lun_reset_sem;
drivers/scsi/ips.c:/* 4.80.14  - Take all semaphores off stack                                  */
drivers/scsi/ips.c:				   "ips_issue semaphore chk timeout.\n");
drivers/scsi/ips.c:				   "ips_issue semaphore chk timeout.\n");
drivers/scsi/be2iscsi/be_main.c:#include <linux/semaphore.h>
drivers/scsi/qla2xxx/qla_def.h:	uint16_t semaphore;		/* Semaphore */
drivers/scsi/qla2xxx/qla_def.h:			uint16_t host_semaphore;
drivers/scsi/qla2xxx/qla_fw.h:/* RISC-RISC semaphore register PCI offet */
drivers/scsi/qla2xxx/qla_fw.h:/* RISC-RISC semaphore/flag register (risc address 0x7016) */
drivers/scsi/qla2xxx/qla_fw.h:/* RISC semaphore timeouts (ms) */
drivers/scsi/qla2xxx/qla_nx.c:		/* acquire semaphore3 from PCI HW block */
drivers/scsi/qla2xxx/qla_nx.c:		/* acquire semaphore5 from PCI HW block */
drivers/scsi/qla2xxx/qla_nx.c:		/* acquire semaphore2 from PCI HW block */
drivers/scsi/qla2xxx/qla_isr.c:		if (RD_REG_WORD(&reg->semaphore) & BIT_0) {
drivers/scsi/qla2xxx/qla_isr.c:			WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla2xxx/qla_isr.c:			RD_REG_WORD(&reg->semaphore);
drivers/scsi/qla2xxx/qla_isr.c:			WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla2xxx/qla_isr.c:	WRT_REG_WORD(&reg->isp.semaphore, 0);
drivers/scsi/qla2xxx/qla_sup.c:		WRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0x1);
drivers/scsi/qla2xxx/qla_sup.c:		RD_REG_WORD(&reg->u.isp2300.host_semaphore);
drivers/scsi/qla2xxx/qla_sup.c:		data = RD_REG_WORD(&reg->u.isp2300.host_semaphore);
drivers/scsi/qla2xxx/qla_sup.c:			WRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0x1);
drivers/scsi/qla2xxx/qla_sup.c:			RD_REG_WORD(&reg->u.isp2300.host_semaphore);
drivers/scsi/qla2xxx/qla_sup.c:			data = RD_REG_WORD(&reg->u.isp2300.host_semaphore);
drivers/scsi/qla2xxx/qla_sup.c:		WRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0);
drivers/scsi/qla2xxx/qla_sup.c:		RD_REG_WORD(&reg->u.isp2300.host_semaphore);
drivers/scsi/qla2xxx/qla_init.c:	WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla2xxx/qla_init.c:qla25xx_manipulate_risc_semaphore(scsi_qla_host_t *vha)
drivers/scsi/qla2xxx/qla_init.c:	qla25xx_manipulate_risc_semaphore(vha);
drivers/scsi/qla2xxx/qla_init.c:		    "Unable to acquire semaphore.\n");
drivers/scsi/qla2xxx/qla_init.c:		    "Unable to release semaphore.\n");
drivers/scsi/qla2xxx/qla_nx2.c:		/* acquire semaphore5 from PCI HW block */
drivers/scsi/qla2xxx/qla_dbg.c:					WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla2xxx/qla_dbg.c:				if (RD_REG_WORD(&reg->semaphore) & BIT_0) {
drivers/scsi/qla2xxx/qla_dbg.c:					WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla1280.c:	WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/qla1280.c:	mailbox[0] = RD_REG_WORD_dmasync(&reg->semaphore);
drivers/scsi/qla1280.c:		WRT_REG_WORD(&reg->semaphore, 0);
drivers/scsi/esas2r/esas2r.h:	struct semaphore fm_api_semaphore;
drivers/scsi/esas2r/esas2r.h:	struct semaphore fs_api_semaphore;
drivers/scsi/esas2r/esas2r.h:	struct semaphore nvram_semaphore;
drivers/scsi/esas2r/esas2r_ioctl.c:static DEFINE_SEMAPHORE(buffered_ioctl_semaphore);
drivers/scsi/esas2r/esas2r_ioctl.c:	if (down_interruptible(&a->fm_api_semaphore)) {
drivers/scsi/esas2r/esas2r_ioctl.c:	up(&a->fm_api_semaphore);
drivers/scsi/esas2r/esas2r_ioctl.c:	if (down_interruptible(&buffered_ioctl_semaphore))
drivers/scsi/esas2r/esas2r_ioctl.c:	up(&buffered_ioctl_semaphore);
drivers/scsi/esas2r/esas2r_ioctl.c:		if (down_interruptible(&a->fs_api_semaphore)) {
drivers/scsi/esas2r/esas2r_ioctl.c:			up(&a->fs_api_semaphore);
drivers/scsi/esas2r/esas2r_ioctl.c:		up(&a->fs_api_semaphore);
drivers/scsi/esas2r/esas2r_flash.c:	if (down_interruptible(&a->nvram_semaphore))
drivers/scsi/esas2r/esas2r_flash.c:	up(&a->nvram_semaphore);
drivers/scsi/esas2r/esas2r_flash.c:		up(&a->nvram_semaphore);
drivers/scsi/esas2r/esas2r_flash.c:	if (down_interruptible(&a->nvram_semaphore))
drivers/scsi/esas2r/esas2r_flash.c:		up(&a->nvram_semaphore);
drivers/scsi/esas2r/esas2r_flash.c:		up(&a->nvram_semaphore);
drivers/scsi/esas2r/esas2r_init.c:	sema_init(&a->fm_api_semaphore, 1);
drivers/scsi/esas2r/esas2r_init.c:	sema_init(&a->fs_api_semaphore, 1);
drivers/scsi/esas2r/esas2r_init.c:	sema_init(&a->nvram_semaphore, 1);
drivers/scsi/st.c: *      scsi_tape_put() helpers which manipulate the semaphore directly
drivers/scsi/FlashPoint.c:#define  hp_semaphore         0x0C
drivers/scsi/FlashPoint.c:			WR_HARPOON(ioport + hp_semaphore, 0x00);
drivers/scsi/FlashPoint.c:	WR_HARPOON((ioport + hp_semaphore),
drivers/scsi/FlashPoint.c:		   (unsigned char)(RD_HARPOON((ioport + hp_semaphore)) |
drivers/scsi/FlashPoint.c:		WR_HARPOON(ioport + hp_semaphore,
drivers/scsi/FlashPoint.c:			   (RD_HARPOON(ioport + hp_semaphore)
drivers/scsi/FlashPoint.c:	if (RD_HARPOON(ioport + hp_semaphore) & BIOS_IN_USE) {
drivers/scsi/FlashPoint.c:		WR_HARPOON(ioport + hp_semaphore,
drivers/scsi/FlashPoint.c:			   (RD_HARPOON(ioport + hp_semaphore)
drivers/scsi/FlashPoint.c:				WR_HARPOON(ioport + hp_semaphore,
drivers/scsi/FlashPoint.c:					   (RD_HARPOON(ioport + hp_semaphore)
drivers/scsi/FlashPoint.c:		WR_HARPOON(pCurrCard->ioPort + hp_semaphore,
drivers/scsi/FlashPoint.c:			   (RD_HARPOON(pCurrCard->ioPort + hp_semaphore) &
drivers/scsi/aacraid/dpcsup.c:#include <linux/semaphore.h>
drivers/scsi/aacraid/aacraid.h:	struct semaphore	wait_sem;	// this is used to wait for the next fib to arrive.
drivers/scsi/aacraid/aacraid.h:	struct semaphore	event_wait;
drivers/scsi/aacraid/commsup.c:#include <linux/semaphore.h>
drivers/scsi/aacraid/commctrl.c:#include <linux/semaphore.h>
drivers/scsi/bfa/bfa_ioc_cb.c:	 * IOC semaphore registers and serialization
drivers/scsi/bfa/bfa_ioc_cb.c: * Cleanup hw semaphore and usecnt registers
drivers/scsi/bfa/bfi_reg.h: * Name semaphore registers based on usage
drivers/scsi/bfa/bfi_reg.h: * CT2 semaphore register locations changed
drivers/scsi/bfa/bfa_defs.h:	BFA_IOC_SEMWAIT		= 3,	/*  Waiting for IOC h/w semaphore */
drivers/scsi/bfa/bfa_ioc.c:	IOCPF_E_SEMLOCKED	= 10,	/*  h/w semaphore is locked	*/
drivers/scsi/bfa/bfa_ioc.c:	BFA_IOCPF_SEMWAIT	= 2,	/*  Waiting for IOC h/w semaphore */
drivers/scsi/bfa/bfa_ioc.c:	 * Spin on init semaphore to serialize.
drivers/scsi/bfa/bfa_ioc.c:	 * Unlock the hw semaphore. Should be here only once per boot.
drivers/scsi/bfa/bfa_ioc.c:	 * unlock init semaphore.
drivers/scsi/bfa/bfa_ioc.c: * Awaiting h/w semaphore to continue with version check.
drivers/scsi/bfa/bfa_ioc.c: * Request for semaphore.
drivers/scsi/bfa/bfa_ioc.c: * Awaiting semaphore for h/w initialzation.
drivers/scsi/bfa/bfa_ioc.c: * Holding hardware semaphore lock.
drivers/scsi/bfa/bfa_ioc.c:	 * First read to the semaphore register will return 0, subsequent reads
drivers/scsi/bfa/bfa_ioc.c:	 *  Hold semaphore to serialize pll init and fwtrc.
drivers/scsi/bfa/bfa_ioc.c:	 *  release semaphore.
drivers/scsi/bfa/bfa_ioc.c:	 *  Hold semaphore to serialize pll init and fwtrc.
drivers/scsi/bfa/bfa_ioc.c:	 *  release semaphore.
drivers/scsi/bfa/bfa_ioc.c:	 *  Hold semaphore so that nobody can access the chip during init.
drivers/scsi/bfa/bfa_ioc.c:	 *  release semaphore.
drivers/scsi/bfa/bfa_ioc.c:#define BFA_PHY_LOCK_STATUS	0x018878        /* phy semaphore status reg */
drivers/scsi/bfa/bfa_ioc_ct.c:	 * IOC semaphore registers and serialization
drivers/scsi/bfa/bfa_ioc_ct.c:	 * IOC semaphore registers and serialization
drivers/scsi/bfa/bfa_ioc_ct.c: * Cleanup hw semaphore and usecnt registers
drivers/scsi/bfa/bfa_ioc_ct.c:	 * semaphore (in bfa_iocpf_sm_semwait()).
drivers/scsi/gdth.c:    /* if it's the first command, set command semaphore */
drivers/scsi/gdth.c:    /* if it's the first command, set command semaphore */
drivers/scsi/gdth.c:    /* if it's the first command, set command semaphore */
drivers/scsi/gdth.c:            outb(0x00, ha->bmic + SEMA1REG);    /* reset status semaphore */
drivers/scsi/gdth.c:            writeb(0, &dp2_ptr->io.Sema1);     /* reset status semaphore */
drivers/scsi/gdth.c:            writeb(0, &dp6_ptr->io.Sema1);     /* reset status semaphore */
drivers/scsi/qlogicpti.c:	/* Set SBUS semaphore. */
drivers/scsi/qlogicpti.c:	/* Clear SBUS semaphore. */
drivers/scsi/qlogicpti.c:	/* Wait for SBUS semaphore to get set. */
drivers/scsi/qlogicpti.c:	/* Release SBUS semaphore. */
drivers/vfio/vfio.c:	struct rw_semaphore		group_lock;
drivers/infiniband/hw/mthca/mthca_dev.h:#include <linux/semaphore.h>
drivers/infiniband/hw/mthca/mthca_dev.h:	struct semaphore 	  poll_sem;
drivers/infiniband/hw/mthca/mthca_dev.h:	struct semaphore 	  event_sem;
drivers/infiniband/hw/mthca/mthca_mcg.c: * Caller must hold MCG table semaphore.  gid and mgm parameters must
drivers/infiniband/hw/mlx5/mlx5_ib.h:	struct semaphore	sem;
drivers/infiniband/hw/hns/hns_roce_device.h:	struct semaphore	poll_sem;
drivers/infiniband/hw/hns/hns_roce_device.h:	struct semaphore	event_sem;
drivers/infiniband/core/iwpm_util.h:	struct semaphore    sem;
drivers/infiniband/core/user_mad.c:#include <linux/semaphore.h>
drivers/infiniband/core/user_mad.c:	struct semaphore       sm_sem;
drivers/infiniband/core/umem_odp.c: * Must be called with the ib_ucontext->umem_rwsem semaphore unlocked, since
drivers/infiniband/core/umem_odp.c: * the function takes the semaphore itself. */
drivers/infiniband/core/umem_odp.c:		 * semaphore taken for write. */
drivers/infiniband/core/umem_odp.c:	 * destroyed. We use the umem_rwsem semaphore to synchronize.
drivers/infiniband/core/umem_odp.c:	 * released the semaphore.
drivers/infiniband/ulp/ipoib/ipoib.h:	struct rw_semaphore vlan_rwsem;
drivers/infiniband/ulp/isert/ib_isert.c:#include <linux/semaphore.h>
drivers/infiniband/ulp/isert/ib_isert.h:	struct semaphore	sem;
drivers/message/fusion/mptctl.c: *	mptctl_syscall_down - Down the MPT adapter syscall semaphore.
drivers/dma/mxs-dma.c:#include <linux/semaphore.h>
drivers/dma/mxs-dma.c:	 * we use cyclic DMA with semaphores, that are enhanced in
drivers/dma/mxs-dma.c:	 * into the semaphore counter.
drivers/dma/mxs-dma.c:		 * the semaphore with 2 so we have enough time to add 1 to the
drivers/dma/mxs-dma.c:		 * semaphore if we need to */
drivers/dma/imx-sdma.c:#include <linux/semaphore.h>
drivers/firmware/efi/vars.c: * Returns 0 on success, -EINTR if we can't grab the semaphore,
drivers/firmware/efi/vars.c: * Returns 0 on success, -EINTR if we can't grab the semaphore,
drivers/firmware/efi/runtime-wrappers.c:#include <linux/semaphore.h>
drivers/md/dm-thin-metadata.c:	struct rw_semaphore root_lock;
drivers/md/bcache/bcache.h:	struct semaphore	sb_write_mutex;
drivers/md/bcache/bcache.h:	struct rw_semaphore	writeback_lock;
drivers/md/bcache/bcache.h:	struct semaphore	in_flight;
drivers/md/bcache/bcache.h:	struct semaphore	sb_write_mutex;
drivers/md/bcache/bcache.h:	struct semaphore	moving_in_flight;
drivers/md/bcache/bcache.h:	struct semaphore	uuid_write_mutex;
drivers/md/bcache/btree.h:	struct rw_semaphore	lock;
drivers/md/bcache/btree.h:	struct semaphore	io_mutex;
drivers/md/dm-cache-metadata.c:	struct rw_semaphore root_lock;
drivers/md/dm-region-hash.c:	struct semaphore recovery_count;
drivers/md/persistent-data/dm-block-manager.c: * This is a read/write semaphore with a couple of differences.
drivers/md/dm-snap.c:	struct rw_semaphore lock;
drivers/md/dm-snap.c:static struct rw_semaphore _origins_lock;
drivers/md/dm-thin.c:	struct rw_semaphore lock;
drivers/target/iscsi/iscsi_target.c:	 * up the connection reinstatement semaphore that is being blocked on
drivers/target/iscsi/iscsi_target.c:	 * connection wait rcfr semaphore that is being blocked on
drivers/power/reset/rmobile-reset.c:	/* Let's assume we have acquired the HPB semaphore */
drivers/nfc/st95hf/core.c: * @exchange_lock: semaphore used for signaling the st95hf_remove
drivers/nfc/st95hf/core.c:	struct semaphore exchange_lock;
drivers/nfc/st95hf/core.c:	 * check semaphore, if not down() already, then we don't
drivers/nfc/st95hf/core.c:	 * will be a bug. Note that down() of the semaphore is done
drivers/nfc/st95hf/core.c:	 * semaphore before leaving. Hence when the ISR is called
drivers/nfc/st95hf/core.c:	 * return 1 (indicating semaphore cant be taken and hence no
drivers/nfc/st95hf/core.c:	 * change in semaphore count).
drivers/nfc/st95hf/core.c:	 * If not, then we up() the semaphore and crash on
drivers/nfc/st95hf/core.c:	/* up the semaphore before returning */
drivers/nfc/st95hf/core.c:	/* up the semaphore before returning */
drivers/nfc/st95hf/core.c:	 * down the semaphore to indicate to remove func that an
drivers/nfc/st95hf/core.c:		/* up the semaphore since ISR will never come in this case */
drivers/nfc/st95hf/core.c:		dev_err(&spictx->spidev->dev, "sleep for semaphore interrupted by signal\n");
drivers/media/dvb-frontends/bcm3510.c:/* not needed, we use a semaphore to prevent HAB races */
drivers/media/pci/ngene/ngene.h:	struct semaphore reslock;
drivers/media/pci/ngene/ngene.h:	struct semaphore      cmd_mutex;
drivers/media/pci/ngene/ngene.h:	struct semaphore      stream_mutex;
drivers/media/pci/ngene/ngene.h:	struct semaphore      pll_mutex;
drivers/media/pci/ngene/ngene.h:	struct semaphore      i2c_switch_mutex;
drivers/media/pci/cx18/cx18-scb.h:	u32 semaphores[8];  /* Semaphores */
drivers/media/platform/davinci/vpif_display.c:				 * done and unlock semaphore on it */
drivers/media/radio/radio-si476x.c: * @core_lock: An r/w semaphore to brebvent the deletion of underlying
drivers/media/usb/em28xx/em28xx-dvb.c:	struct semaphore      pll_mutex;
drivers/media/usb/em28xx/em28xx-dvb.c:		/* FIXME: do we need a pll semaphore? */
drivers/media/usb/em28xx/em28xx-dvb.c:		/* FIXME: do we need a pll semaphore? */
drivers/media/firewire/firedtv-ci.c:	/* Do we need a semaphore for this? */
drivers/media/dvb-core/dvb_frontend.c:#include <linux/semaphore.h>
drivers/media/dvb-core/dvb_frontend.c:	struct semaphore sem;
drivers/usb/image/mdc800.c: * a semaphore from a spinlock.
drivers/usb/wusbcore/wa-xfer.c: *     rpipe to the endpoint is done under the wa->rpipe_sem semaphore
drivers/usb/chipidea/udc.c:	/* clear setup token semaphores */
drivers/usb/host/xhci-pci.c:	 * BIOS/OS semaphore is written, but we all know we can't trust BIOS
drivers/usb/host/pci-quirks.c:#define EHCI_USBLEGSUP_BIOS	(1 << 16)	/* BIOS semaphore */
drivers/usb/host/pci-quirks.c:#define EHCI_USBLEGSUP_OS	(1 << 24)	/* OS semaphore */
drivers/usb/host/pci-quirks.c:	 * The HASEE E200 hangs when the semaphore is set (bugzilla #77021).
drivers/usb/host/pci-quirks.c:		/* some systems get upset if this semaphore is
drivers/usb/misc/usblcd.c:	struct semaphore	limit_sem;		/* to stop writes at
drivers/usb/misc/ftdi-elan.c:	struct semaphore sw_lock;
drivers/usb/misc/sisusbvga/sisusb_con.c:	 * the disconnect semaphore; we can't
drivers/usb/misc/sisusbvga/sisusb_con.c:	 * and while disconnect and lock semaphores
drivers/usb/misc/cytherm.c:#define BRIGHTNESS_SEM 0x2b /* RAM location for brightness semaphore */
drivers/usb/early/ehci-dbgp.c:#define EHCI_USBLEGSUP_BIOS	(1 << 16)	/* BIOS semaphore */
drivers/usb/usb-skeleton.c:	struct semaphore	limit_sem;		/* limiting the number of writes in progress */
drivers/usb/gadget/function/f_mass_storage.c:	struct rw_semaphore	filesem;
drivers/usb/gadget/function/f_mass_storage.c:	struct rw_semaphore	*filesem = dev_get_drvdata(dev);
drivers/usb/gadget/function/f_mass_storage.c:	struct rw_semaphore	*filesem = dev_get_drvdata(dev);
drivers/usb/gadget/function/f_mass_storage.c:	struct rw_semaphore	*filesem = dev_get_drvdata(dev);
drivers/usb/gadget/function/storage_common.c:ssize_t fsg_show_file(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/function/storage_common.c:ssize_t fsg_store_ro(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/function/storage_common.c:ssize_t fsg_store_file(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/function/storage_common.c:ssize_t fsg_store_cdrom(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/function/storage_common.h:ssize_t fsg_show_file(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/function/storage_common.h:ssize_t fsg_store_ro(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/function/storage_common.h:ssize_t fsg_store_file(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/function/storage_common.h:ssize_t fsg_store_cdrom(struct fsg_lun *curlun, struct rw_semaphore *filesem,
drivers/usb/gadget/udc/mv_udc_core.c:			/* start with setting the semaphores */
drivers/usb/gadget/udc/mv_udc_core.c:			 * Reread the ATDTW semaphore bit to check if it is
drivers/usb/gadget/udc/mv_udc_core.c:		/* Clear the semaphore */
drivers/usb/gadget/udc/mv_udc_core.c:	/* Clear all the setup token semaphores */
drivers/usb/gadget/udc/fsl_udc_core.c:	/* Clear all the setup token semaphores */
drivers/usb/core/urb.c: *       semaphores), or
drivers/usb/core/usb.c: * USB devices and interfaces are locked using the semaphore in their
drivers/usb/core/hub.c: * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */
drivers/usb/core/hub.c: * without having to wait for any semaphores to be released.  As a result,
drivers/usb/isp1760/isp1760-hcd.c:	 * the semaphore while doing so.
drivers/firewire/core.h:extern struct rw_semaphore fw_device_rwsem;
drivers/mtd/ubi/ubi.h:	struct rw_semaphore mutex;
drivers/mtd/ubi/ubi.h:	struct rw_semaphore fm_eba_sem;
drivers/mtd/ubi/ubi.h:	struct rw_semaphore fm_protect;
drivers/mtd/ubi/ubi.h:	struct rw_semaphore work_sem;
drivers/acpi/cppc_acpi.c:	struct rw_semaphore pcc_lock;
drivers/acpi/acpica/acinterp.h:acpi_ex_system_wait_semaphore(acpi_semaphore semaphore, u16 timeout);
drivers/acpi/acpica/evglock.c:	 * Send a unit to the global lock semaphore. The actual acquisition
drivers/acpi/acpica/evglock.c:	status = acpi_os_signal_semaphore(acpi_gbl_global_lock_semaphore, 1);
drivers/acpi/acpica/evglock.c:		ACPI_ERROR((AE_INFO, "Could not signal Global Lock semaphore"));
drivers/acpi/acpica/evglock.c:		    acpi_ex_system_wait_semaphore
drivers/acpi/acpica/evglock.c:		    (acpi_gbl_global_lock_semaphore, ACPI_WAIT_FOREVER);
drivers/acpi/acpica/utinit.c:	acpi_gbl_global_lock_semaphore = NULL;
drivers/acpi/acpica/dsmethod.c: *              increments the thread count, and waits at the method semaphore
drivers/acpi/acpica/evgpeutil.c: *              called only when the GPE lists are semaphore locked and not
drivers/acpi/acpica/dbinput.c:		 * re-creating the semaphores!
drivers/acpi/acpica/dbexec.c:	(void)acpi_os_wait_semaphore(info->info_gate, 1, ACPI_WAIT_FOREVER);
drivers/acpi/acpica/dbexec.c:	(void)acpi_os_signal_semaphore(info->info_gate, 1);
drivers/acpi/acpica/dbexec.c:	(void)acpi_os_wait_semaphore(info->thread_complete_gate,
drivers/acpi/acpica/dbexec.c:	(void)acpi_os_signal_semaphore(info->thread_complete_gate, 1);
drivers/acpi/acpica/dbexec.c:		status = acpi_os_signal_semaphore(info->main_thread_gate, 1);
drivers/acpi/acpica/dbexec.c:			    ("Could not signal debugger thread sync semaphore, %s\n",
drivers/acpi/acpica/dbexec.c:	 * Create the semaphore for synchronization of
drivers/acpi/acpica/dbexec.c:	status = acpi_os_create_semaphore(1, 0, &main_thread_gate);
drivers/acpi/acpica/dbexec.c:		acpi_os_printf("Could not create semaphore for "
drivers/acpi/acpica/dbexec.c:	 * Create the semaphore for synchronization
drivers/acpi/acpica/dbexec.c:	status = acpi_os_create_semaphore(1, 1, &thread_complete_gate);
drivers/acpi/acpica/dbexec.c:		acpi_os_printf("Could not create semaphore for "
drivers/acpi/acpica/dbexec.c:		(void)acpi_os_delete_semaphore(main_thread_gate);
drivers/acpi/acpica/dbexec.c:	status = acpi_os_create_semaphore(1, 1, &info_gate);
drivers/acpi/acpica/dbexec.c:		acpi_os_printf("Could not create semaphore for "
drivers/acpi/acpica/dbexec.c:		(void)acpi_os_delete_semaphore(thread_complete_gate);
drivers/acpi/acpica/dbexec.c:		(void)acpi_os_delete_semaphore(main_thread_gate);
drivers/acpi/acpica/dbexec.c:		(void)acpi_os_delete_semaphore(main_thread_gate);
drivers/acpi/acpica/dbexec.c:		(void)acpi_os_delete_semaphore(thread_complete_gate);
drivers/acpi/acpica/dbexec.c:		(void)acpi_os_delete_semaphore(info_gate);
drivers/acpi/acpica/dbexec.c:	(void)acpi_os_wait_semaphore(main_thread_gate, 1, ACPI_WAIT_FOREVER);
drivers/acpi/acpica/dbexec.c:	(void)acpi_os_delete_semaphore(main_thread_gate);
drivers/acpi/acpica/dbexec.c:	(void)acpi_os_delete_semaphore(thread_complete_gate);
drivers/acpi/acpica/dbexec.c:	(void)acpi_os_delete_semaphore(info_gate);
drivers/acpi/acpica/acobject.h:	ACPI_OBJECT_COMMON_HEADER acpi_semaphore os_semaphore;	/* Actual OS synchronization object */
drivers/acpi/acpica/utdelete.c:			/* Global Lock has extra semaphore */
drivers/acpi/acpica/utdelete.c:			    acpi_os_delete_semaphore
drivers/acpi/acpica/utdelete.c:			    (acpi_gbl_global_lock_semaphore);
drivers/acpi/acpica/utdelete.c:			acpi_gbl_global_lock_semaphore = NULL;
drivers/acpi/acpica/utdelete.c:				  object, object->event.os_semaphore));
drivers/acpi/acpica/utdelete.c:		(void)acpi_os_delete_semaphore(object->event.os_semaphore);
drivers/acpi/acpica/utdelete.c:		object->event.os_semaphore = NULL;
drivers/acpi/acpica/evgpe.c: *              Should be called only when the GPE lists are semaphore locked
drivers/acpi/acpica/nsaccess.c:					/* Create additional counting semaphore for global lock */
drivers/acpi/acpica/nsaccess.c:					    acpi_os_create_semaphore(1, 0,
drivers/acpi/acpica/nsaccess.c:								     &acpi_gbl_global_lock_semaphore);
drivers/acpi/acpica/exdump.c:	{ACPI_EXD_POINTER, ACPI_EXD_OFFSET(event.os_semaphore), "OsSemaphore"}
drivers/acpi/acpica/excreate.c:	 * Create the actual OS semaphore, with zero initial units -- meaning
drivers/acpi/acpica/excreate.c:	status = acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0,
drivers/acpi/acpica/excreate.c:					  &obj_desc->event.os_semaphore);
drivers/acpi/acpica/excreate.c:	 * of both object and semaphore if present.)
drivers/acpi/acpica/excreate.c:	 * of both object and semaphore if present.)
drivers/acpi/acpica/aclocal.h:#define ACPI_GLOBAL_LOCK                (acpi_semaphore) (-1)
drivers/acpi/acpica/utcopy.c:		status = acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0,
drivers/acpi/acpica/utcopy.c:						  os_semaphore);
drivers/acpi/acpica/exsystem.c: * FUNCTION:    acpi_ex_system_wait_semaphore
drivers/acpi/acpica/exsystem.c: * PARAMETERS:  semaphore       - Semaphore to wait on
drivers/acpi/acpica/exsystem.c: * DESCRIPTION: Implements a semaphore wait with a check to see if the
drivers/acpi/acpica/exsystem.c: *              semaphore is available immediately. If it is not, the
drivers/acpi/acpica/exsystem.c:acpi_status acpi_ex_system_wait_semaphore(acpi_semaphore semaphore, u16 timeout)
drivers/acpi/acpica/exsystem.c:	ACPI_FUNCTION_TRACE(ex_system_wait_semaphore);
drivers/acpi/acpica/exsystem.c:	status = acpi_os_wait_semaphore(semaphore, 1, ACPI_DO_NOT_WAIT);
drivers/acpi/acpica/exsystem.c:		status = acpi_os_wait_semaphore(semaphore, 1, timeout);
drivers/acpi/acpica/exsystem.c:		    acpi_os_signal_semaphore(obj_desc->event.os_semaphore, 1);
drivers/acpi/acpica/exsystem.c:		    acpi_ex_system_wait_semaphore(obj_desc->event.os_semaphore,
drivers/acpi/acpica/exsystem.c:	acpi_semaphore temp_semaphore;
drivers/acpi/acpica/exsystem.c:	 * We are going to simply delete the existing semaphore and
drivers/acpi/acpica/exsystem.c:	    acpi_os_create_semaphore(ACPI_NO_UNIT_LIMIT, 0, &temp_semaphore);
drivers/acpi/acpica/exsystem.c:		(void)acpi_os_delete_semaphore(obj_desc->event.os_semaphore);
drivers/acpi/acpica/exsystem.c:		obj_desc->event.os_semaphore = temp_semaphore;
drivers/acpi/acpica/acglobal.h: * Global lock semaphore works in conjunction with the actual global lock
drivers/acpi/acpica/acglobal.h:ACPI_GLOBAL(acpi_semaphore, acpi_gbl_global_lock_semaphore);
drivers/acpi/acpica/psxface.c:	/* Init for new method, wait on concurrency semaphore */
drivers/acpi/osl.c:#include <linux/semaphore.h>
drivers/acpi/osl.c:acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
drivers/acpi/osl.c:	struct semaphore *sem = NULL;
drivers/acpi/osl.c:	sem = acpi_os_allocate_zeroed(sizeof(struct semaphore));
drivers/acpi/osl.c:	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Creating semaphore[%p|%d].\n",
drivers/acpi/osl.c: * TODO: A better way to delete semaphores?  Linux doesn't have a
drivers/acpi/osl.c: * 'delete_semaphore()' function -- may result in an invalid
drivers/acpi/osl.c:acpi_status acpi_os_delete_semaphore(acpi_handle handle)
drivers/acpi/osl.c:	struct semaphore *sem = (struct semaphore *)handle;
drivers/acpi/osl.c:	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Deleting semaphore[%p].\n", handle));
drivers/acpi/osl.c:acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
drivers/acpi/osl.c:	struct semaphore *sem = (struct semaphore *)handle;
drivers/acpi/osl.c:	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n",
drivers/acpi/osl.c:				  "Failed to acquire semaphore[%p|%d|%d], %s",
drivers/acpi/osl.c:				  "Acquired semaphore[%p|%d|%d]", handle,
drivers/acpi/osl.c:acpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)
drivers/acpi/osl.c:	struct semaphore *sem = (struct semaphore *)handle;
drivers/acpi/osl.c:	ACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Signaling semaphore[%p|%d]\n", handle,
drivers/xen/xenbus/xenbus_xs.c:	struct rw_semaphore watch_mutex;
drivers/xen/xen-pciback/pciback_ops.c: * use of semaphores). This function is intended to be called from a work
drivers/char/tpm/tpm.h:	struct rw_semaphore ops_sem;
drivers/char/ipmi/ipmi_watchdog.c: * The semaphore is claimed when the set_timeout is sent and freed
drivers/char/snsc.h:#include <linux/semaphore.h>
drivers/char/snsc.h:	struct semaphore sd_rbs;	/* semaphore for read buffer */
drivers/char/snsc.h:	struct semaphore sd_wbs;	/* semaphore for write buffer */
drivers/input/serio/hp_sdc_mlc.c:#include <linux/semaphore.h>
drivers/input/serio/hp_sdc_mlc.c:	/* Try to down the semaphore */
drivers/input/serio/hp_sdc_mlc.c:	/* Try to down the semaphores -- they should be up. */
drivers/input/serio/hp_sdc_mlc.c:		if (priv->trans.act.semaphore != &mlc->csem)
drivers/input/serio/hp_sdc_mlc.c:	priv->trans.act.semaphore = &mlc->csem;
drivers/input/serio/hp_sdc_mlc.c:	priv->trans.act.semaphore = &mlc->osem;
drivers/input/serio/hp_sdc_mlc.c:	/* Try to down the semaphore -- it should be up. */
drivers/input/serio/hp_sdc_mlc.c:	priv->trans.act.semaphore = &mlc->osem;
drivers/input/serio/hp_sdc_mlc.c:	priv->trans.act.semaphore = &mlc->osem;
drivers/input/serio/hp_sdc_mlc.c:	hp_sdc_mlc_priv.trans.act.semaphore = &mlc->osem;
drivers/input/serio/hp_sdc.c:#include <linux/semaphore.h>
drivers/input/serio/hp_sdc.c:			if (curr->act.semaphore)
drivers/input/serio/hp_sdc.c:				up(curr->act.semaphore);
drivers/input/serio/hp_sdc.c:				if (curr->act.semaphore)
drivers/input/serio/hp_sdc.c:					up(curr->act.semaphore);
drivers/input/serio/hp_sdc.c:		up(curr->act.semaphore);
drivers/input/serio/hp_sdc.c:	struct semaphore s_sync;
drivers/input/serio/hp_sdc.c:	t_sync.act.semaphore = &s_sync;
drivers/input/serio/hp_sdc.c:	struct semaphore tq_init_sem;
drivers/input/serio/hp_sdc.c:	tq_init.act.semaphore	= &tq_init_sem;
drivers/input/serio/hil_mlc.c: *	termination or packet match, at which point a semaphore must
drivers/input/touchscreen/ucb1400_ts.c: * access completion and uses semaphores for access control to the
drivers/input/misc/hp_sdc_rtc.c:#include <linux/semaphore.h>
drivers/input/misc/hp_sdc_rtc.c:static struct semaphore i8042tregs;
drivers/input/misc/hp_sdc_rtc.c:	struct semaphore tsem;
drivers/input/misc/hp_sdc_rtc.c:	t.act.semaphore =	&tsem;
drivers/input/misc/hp_sdc_rtc.c:	t.act.semaphore =	&i8042tregs;
drivers/input/mouse/psmouse-base.c: * sysfs). We could use a per-device semaphore but since there
drivers/input/mouse/psmouse-base.c: * rarely more than one PS/2 mouse connected and since semaphore
drivers/mfd/ucb1x00-ts.c: * (mainly so we can use semaphores in the UCB1200 core code
drivers/mfd/db8500-prcmu.c:	/* Grab the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Release the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Grab the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Release the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Grab the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Release the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Grab the HW semaphore. */
drivers/mfd/db8500-prcmu.c:	/* Release the HW semaphore. */
drivers/mfd/dbx500-prcmu-regs.h:/* PRCMU HW semaphore */
drivers/gpu/drm/i915/i915_params.h:	int semaphores;
drivers/gpu/drm/i915/i915_gem_context.c:		i915.semaphores ?
drivers/gpu/drm/i915/i915_gpu_error.c:			   ee->semaphore_mboxes[0],
drivers/gpu/drm/i915/i915_gpu_error.c:			   ee->semaphore_seqno[0]);
drivers/gpu/drm/i915/i915_gpu_error.c:			   ee->semaphore_mboxes[1],
drivers/gpu/drm/i915/i915_gpu_error.c:			   ee->semaphore_seqno[1]);
drivers/gpu/drm/i915/i915_gpu_error.c:				   ee->semaphore_mboxes[2],
drivers/gpu/drm/i915/i915_gpu_error.c:				   ee->semaphore_seqno[2]);
drivers/gpu/drm/i915/i915_gpu_error.c:	if ((obj = error->semaphore)) {
drivers/gpu/drm/i915/i915_gpu_error.c:	i915_error_object_free(error->semaphore);
drivers/gpu/drm/i915/i915_gpu_error.c:static void gen8_record_semaphore_state(struct drm_i915_error_state *error,
drivers/gpu/drm/i915/i915_gpu_error.c:	if (!error->semaphore)
drivers/gpu/drm/i915/i915_gpu_error.c:		tmp = error->semaphore->pages[0];
drivers/gpu/drm/i915/i915_gpu_error.c:		ee->semaphore_mboxes[idx] = tmp[signal_offset];
drivers/gpu/drm/i915/i915_gpu_error.c:		ee->semaphore_seqno[idx] = engine->semaphore.sync_seqno[idx];
drivers/gpu/drm/i915/i915_gpu_error.c:static void gen6_record_semaphore_state(struct intel_engine_cs *engine,
drivers/gpu/drm/i915/i915_gpu_error.c:	ee->semaphore_mboxes[0] = I915_READ(RING_SYNC_0(engine->mmio_base));
drivers/gpu/drm/i915/i915_gpu_error.c:	ee->semaphore_mboxes[1] = I915_READ(RING_SYNC_1(engine->mmio_base));
drivers/gpu/drm/i915/i915_gpu_error.c:	ee->semaphore_seqno[0] = engine->semaphore.sync_seqno[0];
drivers/gpu/drm/i915/i915_gpu_error.c:	ee->semaphore_seqno[1] = engine->semaphore.sync_seqno[1];
drivers/gpu/drm/i915/i915_gpu_error.c:		ee->semaphore_mboxes[2] =
drivers/gpu/drm/i915/i915_gpu_error.c:		ee->semaphore_seqno[2] = engine->semaphore.sync_seqno[2];
drivers/gpu/drm/i915/i915_gpu_error.c:			gen8_record_semaphore_state(error, engine, ee);
drivers/gpu/drm/i915/i915_gpu_error.c:			gen6_record_semaphore_state(engine, ee);
drivers/gpu/drm/i915/i915_gpu_error.c:	error->semaphore =
drivers/gpu/drm/i915/i915_gpu_error.c:		i915_error_object_create(dev_priv, dev_priv->semaphore);
drivers/gpu/drm/i915/i915_irq.c:ipehr_is_semaphore_wait(struct intel_engine_cs *engine, u32 ipehr)
drivers/gpu/drm/i915/i915_irq.c:semaphore_wait_to_signaller_ring(struct intel_engine_cs *engine, u32 ipehr,
drivers/gpu/drm/i915/i915_irq.c:			if (offset == signaller->semaphore.signal_ggtt[engine->hw_id])
drivers/gpu/drm/i915/i915_irq.c:			if (sync_bits == signaller->semaphore.mbox.wait[engine->hw_id])
drivers/gpu/drm/i915/i915_irq.c:semaphore_waits_for(struct intel_engine_cs *engine, u32 *seqno)
drivers/gpu/drm/i915/i915_irq.c:	if (!ipehr_is_semaphore_wait(engine, ipehr))
drivers/gpu/drm/i915/i915_irq.c:	 * or 4 dwords depending on the semaphore wait command size.
drivers/gpu/drm/i915/i915_irq.c:	 * point at at batch, and semaphores are always emitted into the
drivers/gpu/drm/i915/i915_irq.c:	return semaphore_wait_to_signaller_ring(engine, ipehr, offset);
drivers/gpu/drm/i915/i915_irq.c:static int semaphore_passed(struct intel_engine_cs *engine)
drivers/gpu/drm/i915/i915_irq.c:	signaller = semaphore_waits_for(engine, &seqno);
drivers/gpu/drm/i915/i915_irq.c:	    semaphore_passed(signaller) < 0)
drivers/gpu/drm/i915/i915_irq.c:static void semaphore_clear_deadlocks(struct drm_i915_private *dev_priv)
drivers/gpu/drm/i915/i915_irq.c:		switch (semaphore_passed(engine)) {
drivers/gpu/drm/i915/i915_irq.c:					  "Kicking stuck semaphore on %s",
drivers/gpu/drm/i915/i915_irq.c:		semaphore_clear_deadlocks(dev_priv);
drivers/gpu/drm/i915/i915_drv.h:	struct drm_i915_error_object *semaphore;
drivers/gpu/drm/i915/i915_drv.h:		u32 semaphore_seqno[I915_NUM_ENGINES - 1];
drivers/gpu/drm/i915/i915_drv.h:		u32 semaphore_mboxes[I915_NUM_ENGINES - 1];
drivers/gpu/drm/i915/i915_drv.h:	struct i915_vma *semaphore;
drivers/gpu/drm/i915/i915_drv.h:bool intel_sanitize_semaphores(struct drm_i915_private *dev_priv, int value);
drivers/gpu/drm/i915/intel_lrc.c:	/* TODO: WaDisableLiteRestore when we start using semaphore
drivers/gpu/drm/i915/i915_debugfs.c:static int i915_semaphore_status(struct seq_file *m, void *unused)
drivers/gpu/drm/i915/i915_debugfs.c:	if (!i915.semaphores) {
drivers/gpu/drm/i915/i915_debugfs.c:		page = i915_gem_object_get_page(dev_priv->semaphore->obj, 0);
drivers/gpu/drm/i915/i915_debugfs.c:					   I915_READ(engine->semaphore.mbox.signal[j]));
drivers/gpu/drm/i915/i915_debugfs.c:				   engine->semaphore.sync_seqno[j]);
drivers/gpu/drm/i915/i915_debugfs.c:	{"i915_semaphore_status", i915_semaphore_status, 0},
drivers/gpu/drm/i915/i915_gem.c:bool intel_sanitize_semaphores(struct drm_i915_private *dev_priv, int value)
drivers/gpu/drm/i915/i915_gem.c:	/* TODO: make semaphores and Execlists play nicely together */
drivers/gpu/drm/i915/i915_gem.c:	/* Enable semaphores on SNB when IO remapping is off */
drivers/gpu/drm/i915/i915_params.c:	.semaphores = -1,
drivers/gpu/drm/i915/i915_params.c:module_param_named_unsafe(semaphores, i915.semaphores, int, 0400);
drivers/gpu/drm/i915/i915_params.c:MODULE_PARM_DESC(semaphores,
drivers/gpu/drm/i915/i915_params.c:	"Use semaphores for inter-ring sync "
drivers/gpu/drm/i915/intel_engine_cs.c:	/* Our semaphore implementation is strictly monotonic (i.e. we proceed
drivers/gpu/drm/i915/intel_engine_cs.c:	 * so long as the semaphore value in the register/page is greater
drivers/gpu/drm/i915/intel_engine_cs.c:	 * so long as we reset the tracking semaphore value to 0, it will
drivers/gpu/drm/i915/intel_engine_cs.c:	 * the semaphore value, then when the seqno moves backwards all
drivers/gpu/drm/i915/intel_engine_cs.c:	if (dev_priv->semaphore) {
drivers/gpu/drm/i915/intel_engine_cs.c:		struct page *page = i915_vma_first_page(dev_priv->semaphore);
drivers/gpu/drm/i915/intel_engine_cs.c:		void *semaphores;
drivers/gpu/drm/i915/intel_engine_cs.c:		semaphores = kmap(page);
drivers/gpu/drm/i915/intel_engine_cs.c:		memset(semaphores + GEN8_SEMAPHORE_OFFSET(engine->id, 0),
drivers/gpu/drm/i915/intel_engine_cs.c:		       0, I915_NUM_ENGINES * gen8_semaphore_seqno_size);
drivers/gpu/drm/i915/intel_engine_cs.c:		drm_clflush_virt_range(semaphores + GEN8_SEMAPHORE_OFFSET(engine->id, 0),
drivers/gpu/drm/i915/intel_engine_cs.c:				       I915_NUM_ENGINES * gen8_semaphore_seqno_size);
drivers/gpu/drm/i915/intel_engine_cs.c:	memset(engine->semaphore.sync_seqno, 0,
drivers/gpu/drm/i915/intel_engine_cs.c:	       sizeof(engine->semaphore.sync_seqno));
drivers/gpu/drm/i915/i915_gem_request.c:	if (from->fence.seqno <= from->engine->semaphore.sync_seqno[idx])
drivers/gpu/drm/i915/i915_gem_request.c:	if (!i915.semaphores) {
drivers/gpu/drm/i915/i915_gem_request.c:		ret = to->engine->semaphore.sync_to(to, from);
drivers/gpu/drm/i915/i915_gem_request.c:	from->engine->semaphore.sync_seqno[idx] = from->fence.seqno;
drivers/gpu/drm/i915/intel_ringbuffer.c:	i915_vma_unpin_and_release(&dev_priv->semaphore);
drivers/gpu/drm/i915/intel_ringbuffer.c:		u64 gtt_offset = req->engine->semaphore.signal_ggtt[id];
drivers/gpu/drm/i915/intel_ringbuffer.c:		u64 gtt_offset = req->engine->semaphore.signal_ggtt[id];
drivers/gpu/drm/i915/intel_ringbuffer.c:		mbox_reg = req->engine->semaphore.mbox.signal[engine->hw_id];
drivers/gpu/drm/i915/intel_ringbuffer.c: * gen6_sema_emit_request - Update the semaphore mailbox registers
drivers/gpu/drm/i915/intel_ringbuffer.c: * This acts like a signal in the canonical semaphore.
drivers/gpu/drm/i915/intel_ringbuffer.c:	ret = req->engine->semaphore.signal(req);
drivers/gpu/drm/i915/intel_ringbuffer.c:	if (engine->semaphore.signal) {
drivers/gpu/drm/i915/intel_ringbuffer.c:		ret = engine->semaphore.signal(req);
drivers/gpu/drm/i915/intel_ringbuffer.c:	/* When the !RCS engines idle waiting upon a semaphore, they lose their
drivers/gpu/drm/i915/intel_ringbuffer.c:	u32 wait_mbox = signal->engine->semaphore.mbox.wait[req->engine->hw_id];
drivers/gpu/drm/i915/intel_ringbuffer.c:	memset(engine->semaphore.sync_seqno, 0,
drivers/gpu/drm/i915/intel_ringbuffer.c:	       sizeof(engine->semaphore.sync_seqno));
drivers/gpu/drm/i915/intel_ringbuffer.c:static void intel_ring_init_semaphores(struct drm_i915_private *dev_priv,
drivers/gpu/drm/i915/intel_ringbuffer.c:	if (!i915.semaphores)
drivers/gpu/drm/i915/intel_ringbuffer.c:	if (INTEL_GEN(dev_priv) >= 8 && !dev_priv->semaphore) {
drivers/gpu/drm/i915/intel_ringbuffer.c:		dev_priv->semaphore = vma;
drivers/gpu/drm/i915/intel_ringbuffer.c:		u32 offset = i915_ggtt_offset(dev_priv->semaphore);
drivers/gpu/drm/i915/intel_ringbuffer.c:		engine->semaphore.sync_to = gen8_ring_sync_to;
drivers/gpu/drm/i915/intel_ringbuffer.c:		engine->semaphore.signal = gen8_xcs_signal;
drivers/gpu/drm/i915/intel_ringbuffer.c:			engine->semaphore.signal_ggtt[i] = ring_offset;
drivers/gpu/drm/i915/intel_ringbuffer.c:		engine->semaphore.sync_to = gen6_ring_sync_to;
drivers/gpu/drm/i915/intel_ringbuffer.c:		engine->semaphore.signal = gen6_signal;
drivers/gpu/drm/i915/intel_ringbuffer.c:		 * The current semaphore is only applied on pre-gen8
drivers/gpu/drm/i915/intel_ringbuffer.c:		 * platform. So the semaphore between RCS and VCS2 is
drivers/gpu/drm/i915/intel_ringbuffer.c:			engine->semaphore.mbox.wait[i] = wait_mbox;
drivers/gpu/drm/i915/intel_ringbuffer.c:			engine->semaphore.mbox.signal[i] = mbox_reg;
drivers/gpu/drm/i915/intel_ringbuffer.c:	DRM_DEBUG_DRIVER("Failed to allocate space for semaphores, disabling\n");
drivers/gpu/drm/i915/intel_ringbuffer.c:	i915.semaphores = 0;
drivers/gpu/drm/i915/intel_ringbuffer.c:	intel_ring_init_semaphores(dev_priv, engine);
drivers/gpu/drm/i915/intel_ringbuffer.c:	if (i915.semaphores)
drivers/gpu/drm/i915/intel_ringbuffer.c:		if (i915.semaphores)
drivers/gpu/drm/i915/intel_ringbuffer.c:			engine->semaphore.signal = gen8_rcs_signal;
drivers/gpu/drm/i915/i915_drv.c:		value = i915.semaphores;
drivers/gpu/drm/i915/i915_drv.c:	i915.semaphores = intel_sanitize_semaphores(dev_priv, i915.semaphores);
drivers/gpu/drm/i915/i915_drv.c:	DRM_DEBUG_DRIVER("use GPU sempahores? %s\n", yesno(i915.semaphores));
drivers/gpu/drm/i915/intel_ringbuffer.h:#define gen8_semaphore_seqno_size sizeof(uint64_t)
drivers/gpu/drm/i915/intel_ringbuffer.h:	(((__from) * I915_NUM_ENGINES  + (__to)) * gen8_semaphore_seqno_size)
drivers/gpu/drm/i915/intel_ringbuffer.h:	(dev_priv->semaphore->node.start + \
drivers/gpu/drm/i915/intel_ringbuffer.h:	(dev_priv->semaphore->node.start + \
drivers/gpu/drm/i915/intel_ringbuffer.h:	} semaphore;
drivers/gpu/drm/i915/i915_mm.c: *  Note: this is only safe if the mm semaphore is held when called.
drivers/gpu/drm/udl/udl_drv.h:	struct semaphore limit_sem;
drivers/gpu/drm/amd/amdgpu/amdgpu.h: * like the indirect buffer or semaphore, which both have their
drivers/gpu/drm/etnaviv/etnaviv_buffer.c:	 * 2 semaphore stall + 1 event + 1 wait + 1 link.
drivers/gpu/drm/vc4/vc4_drv.h:	struct semaphore async_modeset;
drivers/gpu/drm/vc4/vc4_drv.h:	bool found_increment_semaphore_packet;
drivers/gpu/drm/vc4/vc4_crtc.c: * modeset semaphore on the pipe, and queue the address update for
drivers/gpu/drm/vc4/vc4_crtc.c:	 * modeset prep sees the state that will be present when the semaphore
drivers/gpu/drm/vc4/vc4_validate.c:validate_increment_semaphore(VALIDATE_ARGS)
drivers/gpu/drm/vc4/vc4_validate.c:	exec->found_increment_semaphore_packet = true;
drivers/gpu/drm/vc4/vc4_validate.c:			  validate_increment_semaphore),
drivers/gpu/drm/vc4/vc4_validate.c:	 * semaphore is used to trigger the render CL to start up, and the
drivers/gpu/drm/vc4/vc4_validate.c:	 * semaphore increment.
drivers/gpu/drm/vc4/vc4_validate.c:	if (!exec->found_increment_semaphore_packet || !exec->found_flush) {
drivers/gpu/drm/gma500/mmu.h:	struct rw_semaphore sem;
drivers/gpu/drm/gma500/gtt.h:	struct rw_semaphore sem;
drivers/gpu/drm/gma500/mmu.c:	   since we have the semaphore in write mode. */
drivers/gpu/drm/omapdrm/dss/rfbi.c:#include <linux/semaphore.h>
drivers/gpu/drm/omapdrm/dss/rfbi.c:	struct semaphore bus_lock;
drivers/gpu/drm/omapdrm/dss/dsi.c:#include <linux/semaphore.h>
drivers/gpu/drm/omapdrm/dss/dsi.c:	struct semaphore bus_lock;
drivers/gpu/drm/nouveau/nv84_fence.c:	/* map display semaphore buffers into channel's vm */
drivers/gpu/drm/nouveau/nv50_fence.c:	/* dma objects for display sync channel semaphore blocks */
drivers/gpu/drm/nouveau/nv50_display.c:	/* small shared memory area we use for notifiers and semaphores */
drivers/gpu/drm/radeon/radeon_semaphore.c:int radeon_semaphore_create(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_semaphore.c:			    struct radeon_semaphore **semaphore)
drivers/gpu/drm/radeon/radeon_semaphore.c:	*semaphore = kmalloc(sizeof(struct radeon_semaphore), GFP_KERNEL);
drivers/gpu/drm/radeon/radeon_semaphore.c:	if (*semaphore == NULL) {
drivers/gpu/drm/radeon/radeon_semaphore.c:			     &(*semaphore)->sa_bo, 8, 8);
drivers/gpu/drm/radeon/radeon_semaphore.c:		kfree(*semaphore);
drivers/gpu/drm/radeon/radeon_semaphore.c:		*semaphore = NULL;
drivers/gpu/drm/radeon/radeon_semaphore.c:	(*semaphore)->waiters = 0;
drivers/gpu/drm/radeon/radeon_semaphore.c:	(*semaphore)->gpu_addr = radeon_sa_bo_gpu_addr((*semaphore)->sa_bo);
drivers/gpu/drm/radeon/radeon_semaphore.c:	*((uint64_t *)radeon_sa_bo_cpu_addr((*semaphore)->sa_bo)) = 0;
drivers/gpu/drm/radeon/radeon_semaphore.c:bool radeon_semaphore_emit_signal(struct radeon_device *rdev, int ridx,
drivers/gpu/drm/radeon/radeon_semaphore.c:				  struct radeon_semaphore *semaphore)
drivers/gpu/drm/radeon/radeon_semaphore.c:	trace_radeon_semaphore_signale(ridx, semaphore);
drivers/gpu/drm/radeon/radeon_semaphore.c:	if (radeon_semaphore_ring_emit(rdev, ridx, ring, semaphore, false)) {
drivers/gpu/drm/radeon/radeon_semaphore.c:		--semaphore->waiters;
drivers/gpu/drm/radeon/radeon_semaphore.c:		ring->last_semaphore_signal_addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/radeon_semaphore.c:bool radeon_semaphore_emit_wait(struct radeon_device *rdev, int ridx,
drivers/gpu/drm/radeon/radeon_semaphore.c:				struct radeon_semaphore *semaphore)
drivers/gpu/drm/radeon/radeon_semaphore.c:	trace_radeon_semaphore_wait(ridx, semaphore);
drivers/gpu/drm/radeon/radeon_semaphore.c:	if (radeon_semaphore_ring_emit(rdev, ridx, ring, semaphore, true)) {
drivers/gpu/drm/radeon/radeon_semaphore.c:		++semaphore->waiters;
drivers/gpu/drm/radeon/radeon_semaphore.c:		ring->last_semaphore_wait_addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/radeon_semaphore.c:void radeon_semaphore_free(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_semaphore.c:			   struct radeon_semaphore **semaphore,
drivers/gpu/drm/radeon/radeon_semaphore.c:	if (semaphore == NULL || *semaphore == NULL) {
drivers/gpu/drm/radeon/radeon_semaphore.c:	if ((*semaphore)->waiters > 0) {
drivers/gpu/drm/radeon/radeon_semaphore.c:		dev_err(rdev->dev, "semaphore %p has more waiters than signalers,"
drivers/gpu/drm/radeon/radeon_semaphore.c:			" hardware lockup imminent!\n", *semaphore);
drivers/gpu/drm/radeon/radeon_semaphore.c:	radeon_sa_bo_free(rdev, &(*semaphore)->sa_bo, fence);
drivers/gpu/drm/radeon/radeon_semaphore.c:	kfree(*semaphore);
drivers/gpu/drm/radeon/radeon_semaphore.c:	*semaphore = NULL;
drivers/gpu/drm/radeon/radeon_asic.h:bool r100_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			      struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool r600_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			      struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool r600_dma_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:				  struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool cik_sdma_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:				  struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool cik_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool uvd_v1_0_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool uvd_v2_2_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_asic.h:bool uvd_v3_1_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_asic.h:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/uvd_v3_1.c: * uvd_v3_1_semaphore_emit - emit semaphore command
drivers/gpu/drm/radeon/uvd_v3_1.c: * @semaphore: semaphore to emit commands for
drivers/gpu/drm/radeon/uvd_v3_1.c: * Emit a semaphore command (either wait or signal) to the UVD ring.
drivers/gpu/drm/radeon/uvd_v3_1.c:bool uvd_v3_1_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/uvd_v3_1.c:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/uvd_v3_1.c:	uint64_t addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/r600_dma.c: * r600_dma_semaphore_ring_emit - emit a semaphore on the dma ring
drivers/gpu/drm/radeon/r600_dma.c: * @semaphore: radeon semaphore object
drivers/gpu/drm/radeon/r600_dma.c: * @emit_wait: wait or signal semaphore
drivers/gpu/drm/radeon/r600_dma.c: * Add a DMA semaphore packet to the ring wait on or signal
drivers/gpu/drm/radeon/r600_dma.c:bool r600_dma_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/r600_dma.c:				  struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/r600_dma.c:	u64 addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/uvd_v1_0.c: * uvd_v1_0_semaphore_emit - emit semaphore command
drivers/gpu/drm/radeon/uvd_v1_0.c: * @semaphore: semaphore to emit commands for
drivers/gpu/drm/radeon/uvd_v1_0.c: * Emit a semaphore command (either wait or signal) to the UVD ring.
drivers/gpu/drm/radeon/uvd_v1_0.c:bool uvd_v1_0_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/uvd_v1_0.c:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/uvd_v1_0.c:	/* disable semaphores for UVD V1 hardware */
drivers/gpu/drm/radeon/radeon_sync.c:		sync->semaphores[i] = NULL;
drivers/gpu/drm/radeon/radeon_sync.c: * radeon_sync_fence - use the semaphore to sync to a fence
drivers/gpu/drm/radeon/radeon_sync.c: * Sync to the fence using the semaphore objects
drivers/gpu/drm/radeon/radeon_sync.c: * radeon_sync_resv - use the semaphores to sync to a reservation object
drivers/gpu/drm/radeon/radeon_sync.c: * Sync to the fence using the semaphore objects
drivers/gpu/drm/radeon/radeon_sync.c:		struct radeon_semaphore *semaphore;
drivers/gpu/drm/radeon/radeon_sync.c:		r = radeon_semaphore_create(rdev, &semaphore);
drivers/gpu/drm/radeon/radeon_sync.c:		sync->semaphores[count++] = semaphore;
drivers/gpu/drm/radeon/radeon_sync.c:		/* emit the signal semaphore */
drivers/gpu/drm/radeon/radeon_sync.c:		if (!radeon_semaphore_emit_signal(rdev, i, semaphore)) {
drivers/gpu/drm/radeon/radeon_sync.c:		if (!radeon_semaphore_emit_wait(rdev, ring, semaphore)) {
drivers/gpu/drm/radeon/radeon_sync.c: * Free the sync object by freeing all semaphores in it.
drivers/gpu/drm/radeon/radeon_sync.c:		radeon_semaphore_free(rdev, &sync->semaphores[i], fence);
drivers/gpu/drm/radeon/radeon_test.c:	struct radeon_semaphore *semaphore = NULL;
drivers/gpu/drm/radeon/radeon_test.c:	r = radeon_semaphore_create(rdev, &semaphore);
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Failed to create semaphore\n");
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_wait(rdev, ringA->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_wait(rdev, ringA->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Fence 1 signaled without waiting for semaphore.\n");
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_signal(rdev, ringB->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Fence 2 signaled without waiting for semaphore.\n");
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_signal(rdev, ringB->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_free(rdev, &semaphore, NULL);
drivers/gpu/drm/radeon/radeon_test.c:	struct radeon_semaphore *semaphore = NULL;
drivers/gpu/drm/radeon/radeon_test.c:	r = radeon_semaphore_create(rdev, &semaphore);
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Failed to create semaphore\n");
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_wait(rdev, ringA->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_wait(rdev, ringB->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Fence A signaled without waiting for semaphore.\n");
drivers/gpu/drm/radeon/radeon_test.c:		DRM_ERROR("Fence B signaled without waiting for semaphore.\n");
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_signal(rdev, ringC->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_emit_signal(rdev, ringC->idx, semaphore);
drivers/gpu/drm/radeon/radeon_test.c:	radeon_semaphore_free(rdev, &semaphore, NULL);
drivers/gpu/drm/radeon/radeon_ring.c:	seq_printf(m, "last semaphore signal addr : 0x%016llx\n",
drivers/gpu/drm/radeon/radeon_ring.c:		   ring->last_semaphore_signal_addr);
drivers/gpu/drm/radeon/radeon_ring.c:	seq_printf(m, "last semaphore wait addr   : 0x%016llx\n",
drivers/gpu/drm/radeon/radeon_ring.c:		   ring->last_semaphore_wait_addr);
drivers/gpu/drm/radeon/cik_sdma.c: * cik_sdma_semaphore_ring_emit - emit a semaphore on the dma ring
drivers/gpu/drm/radeon/cik_sdma.c: * @semaphore: radeon semaphore object
drivers/gpu/drm/radeon/cik_sdma.c: * @emit_wait: wait or signal semaphore
drivers/gpu/drm/radeon/cik_sdma.c: * Add a DMA semaphore packet to the ring wait on or signal
drivers/gpu/drm/radeon/cik_sdma.c:bool cik_sdma_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/cik_sdma.c:				  struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/cik_sdma.c:	u64 addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/Makefile:	atombios_encoders.o radeon_semaphore.o radeon_sa.o atombios_i2c.o si.o \
drivers/gpu/drm/radeon/r600.c: * CP fences/semaphores
drivers/gpu/drm/radeon/r600.c: * r600_semaphore_ring_emit - emit a semaphore on the CP ring
drivers/gpu/drm/radeon/r600.c: * @semaphore: radeon semaphore object
drivers/gpu/drm/radeon/r600.c: * Emits a semaphore signal/wait packet to the CP ring and prevents the PFP
drivers/gpu/drm/radeon/r600.c: * from running ahead of semaphore waits.
drivers/gpu/drm/radeon/r600.c:bool r600_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/r600.c:			      struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/r600.c:	uint64_t addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/r600.c:		/* Prevent the PFP from running ahead of the semaphore wait */
drivers/gpu/drm/radeon/uvd_v2_2.c: * uvd_v2_2_semaphore_emit - emit semaphore command
drivers/gpu/drm/radeon/uvd_v2_2.c: * @semaphore: semaphore to emit commands for
drivers/gpu/drm/radeon/uvd_v2_2.c: * Emit a semaphore command (either wait or signal) to the UVD ring.
drivers/gpu/drm/radeon/uvd_v2_2.c:bool uvd_v2_2_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/uvd_v2_2.c:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/uvd_v2_2.c:	uint64_t addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/radeon_trace.h:DECLARE_EVENT_CLASS(radeon_semaphore_request,
drivers/gpu/drm/radeon/radeon_trace.h:	    TP_PROTO(int ring, struct radeon_semaphore *sem),
drivers/gpu/drm/radeon/radeon_trace.h:DEFINE_EVENT(radeon_semaphore_request, radeon_semaphore_signale,
drivers/gpu/drm/radeon/radeon_trace.h:	    TP_PROTO(int ring, struct radeon_semaphore *sem),
drivers/gpu/drm/radeon/radeon_trace.h:DEFINE_EVENT(radeon_semaphore_request, radeon_semaphore_wait,
drivers/gpu/drm/radeon/radeon_trace.h:	    TP_PROTO(int ring, struct radeon_semaphore *sem),
drivers/gpu/drm/radeon/cik.c: * cik_semaphore_ring_emit - emit a semaphore on the CP ring
drivers/gpu/drm/radeon/cik.c: * @semaphore: radeon semaphore object
drivers/gpu/drm/radeon/cik.c: * Emits a semaphore signal/wait packet to the CP ring and prevents the PFP
drivers/gpu/drm/radeon/cik.c: * from running ahead of semaphore waits.
drivers/gpu/drm/radeon/cik.c:bool cik_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/cik.c:			     struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/cik.c:	uint64_t addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/cik.c:		/* Prevent the PFP from running ahead of the semaphore wait */
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r100_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r100_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r100_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_dma_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &uvd_v1_0_semaphore_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &uvd_v2_2_semaphore_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_dma_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_dma_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &uvd_v3_1_semaphore_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &radeon_vce_semaphore_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &r600_dma_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &cik_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &cik_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &cik_sdma_semaphore_ring_emit,
drivers/gpu/drm/radeon/radeon_asic.c:	.emit_semaphore = &radeon_vce_semaphore_emit,
drivers/gpu/drm/radeon/r100.c:bool r100_semaphore_ring_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/r100.c:			      struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/r100.c:	/* Unused on older asics, since we don't have semaphores or multiple rings */
drivers/gpu/drm/radeon/radeon_fence.c: * radeon_fence_need_sync - do we need a semaphore
drivers/gpu/drm/radeon/radeon_fence.c: * (all asics).  If so, we need to emit a semaphore.
drivers/gpu/drm/radeon/radeon_vce.c: * radeon_vce_semaphore_emit - emit a semaphore command
drivers/gpu/drm/radeon/radeon_vce.c: * @semaphore: address of semaphore
drivers/gpu/drm/radeon/radeon_vce.c:bool radeon_vce_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon_vce.c:			       struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon_vce.c:	uint64_t addr = semaphore->gpu_addr;
drivers/gpu/drm/radeon/radeon.h: * like the indirect buffer or semaphore, which both have their
drivers/gpu/drm/radeon/radeon.h:struct radeon_semaphore {
drivers/gpu/drm/radeon/radeon.h:int radeon_semaphore_create(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon.h:			    struct radeon_semaphore **semaphore);
drivers/gpu/drm/radeon/radeon.h:bool radeon_semaphore_emit_signal(struct radeon_device *rdev, int ring,
drivers/gpu/drm/radeon/radeon.h:				  struct radeon_semaphore *semaphore);
drivers/gpu/drm/radeon/radeon.h:bool radeon_semaphore_emit_wait(struct radeon_device *rdev, int ring,
drivers/gpu/drm/radeon/radeon.h:				struct radeon_semaphore *semaphore);
drivers/gpu/drm/radeon/radeon.h:void radeon_semaphore_free(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon.h:			   struct radeon_semaphore **semaphore,
drivers/gpu/drm/radeon/radeon.h:	struct radeon_semaphore *semaphores[RADEON_NUM_SYNCS];
drivers/gpu/drm/radeon/radeon.h:	u64			last_semaphore_signal_addr;
drivers/gpu/drm/radeon/radeon.h:	u64			last_semaphore_wait_addr;
drivers/gpu/drm/radeon/radeon.h:	struct rw_semaphore	mclk_lock;
drivers/gpu/drm/radeon/radeon.h:bool radeon_vce_semaphore_emit(struct radeon_device *rdev,
drivers/gpu/drm/radeon/radeon.h:			       struct radeon_semaphore *semaphore,
drivers/gpu/drm/radeon/radeon.h:	bool (*emit_semaphore)(struct radeon_device *rdev, struct radeon_ring *cp,
drivers/gpu/drm/radeon/radeon.h:			       struct radeon_semaphore *semaphore, bool emit_wait);
drivers/gpu/drm/radeon/radeon.h:	struct rw_semaphore		exclusive_lock;
drivers/gpu/drm/radeon/radeon.h:#define radeon_semaphore_ring_emit(rdev, r, cp, semaphore, emit_wait) (rdev)->asic->ring[(r)]->emit_semaphore((rdev), (cp), (semaphore), (emit_wait))
drivers/gpu/drm/vmwgfx/vmwgfx_drv.h:	struct rw_semaphore rwsem;
drivers/gpu/host1x/cdma.h:#include <linux/semaphore.h>
drivers/gpu/host1x/cdma.h:	struct semaphore sem;		/* signalled when event occurs */
drivers/block/umem.c:	 * If we find a descriptor without DMA_COMPLETE in the semaphore, then
drivers/block/paride/paride.h:	wait_queue_head_t parq;     /* semaphore for parport sharing */
drivers/block/zram/zram_drv.h:	struct rw_semaphore init_lock;
drivers/block/amiflop.c:/* Hardware semaphore */
drivers/block/amiflop.c:/* returns true when we would get the semaphore */
drivers/block/rbd.c:	struct rw_semaphore	lock_rwsem;
drivers/block/rbd.c:	struct rw_semaphore     header_rwsem;
drivers/block/mtip32xx/mtip32xx.h:	struct semaphore cmd_slot_unal;
drivers/block/rsxx/rsxx_priv.h:#include <linux/semaphore.h>
drivers/block/drbd/drbd_int.h: * maybe re-implement using semaphores? */
fs/pipe.c:/* Drop the inode semaphore and wait for a pipe event, atomically */
fs/pipe.c:	/* Reading only -- no need for acquiring the semaphore.  */
fs/btrfs/extent-tree.c:	 * on the groups' semaphore is held and decremented after releasing
fs/btrfs/extent-tree.c:	 * the read access on that semaphore and creating the ordered extent.
fs/btrfs/extent-tree.c:	 * are still on the list after taking the semaphore
fs/btrfs/ctree.h:#include <linux/semaphore.h>
fs/btrfs/ctree.h:	struct rw_semaphore groups_sem;
fs/btrfs/ctree.h:	struct rw_semaphore data_rwsem;
fs/btrfs/ctree.h:	 * on the space_info's groups_sem semaphore.
fs/btrfs/ctree.h:	struct rw_semaphore commit_root_sem;
fs/btrfs/ctree.h:	struct rw_semaphore cleanup_work_sem;
fs/btrfs/ctree.h:	struct rw_semaphore subvol_sem;
fs/btrfs/ctree.h:	struct semaphore uuid_tree_rescan_sem;
fs/btrfs/btrfs_inode.h:	 * access on this semaphore for creating an extent map and its
fs/btrfs/btrfs_inode.h:	 * access on this semaphore before it collects ordered extents and
fs/btrfs/btrfs_inode.h:	struct rw_semaphore dio_sem;
fs/btrfs/disk-io.c:#include <linux/semaphore.h>
fs/btrfs/volumes.c:#include <linux/semaphore.h>
fs/9p/v9fs.h:	struct rw_semaphore rename_sem;
fs/jffs2/README.Locking:This read/write semaphore protects against concurrent access to the
fs/jffs2/README.Locking:This read/write semaphore protects against concurrent access to the
fs/jffs2/README.Locking:In read-only path, write-semaphore is too much exclusion. It's enough
fs/jffs2/README.Locking:by read-semaphore. But you must hold write-semaphore when updating,
fs/jffs2/README.Locking:when updating such a object is necessary under holding read semaphore.
fs/jffs2/README.Locking:For example, do_jffs2_getxattr() holds read-semaphore to scan xref and
fs/jffs2/README.Locking:xdatum at first. But it retries this process with holding write-semaphore
fs/jffs2/README.Locking:after release read-semaphore, if it's necessary to load name/value pair
fs/jffs2/gc.c:	/* OK. Looks safe. And nobody can get us now because we have the semaphore. Move the block */
fs/jffs2/fs.c:	   generic inode semaphore. */
fs/jffs2/xattr.c: *   is used to initialize semaphore and list_head, and some variables.
fs/jffs2/nodemgmt.c: *	allocation semaphore, to prevent more than one allocation from being
fs/jffs2/nodemgmt.c: *	active at any time. The semaphore is later released by jffs2_commit_allocation()
fs/jffs2/jffs2_fs_sb.h:	struct rw_semaphore wbuf_sem;	/* Protects the write buffer */
fs/jffs2/jffs2_fs_sb.h:	struct rw_semaphore xattr_sem;
fs/ext4/move_extent.c:		 * Up semaphore to avoid following problems:
fs/ext4/mballoc.c: * given some of them can block, we'd have to use something like semaphores
fs/ext4/ext4.h:	struct rw_semaphore xattr_sem;
fs/ext4/ext4.h:	struct rw_semaphore i_data_sem;
fs/ext4/ext4.h:	struct rw_semaphore i_mmap_sem;
fs/ext4/ext4.h:	struct percpu_rw_semaphore s_journal_flag_rwsem;
fs/ext4/ext4.h:	struct rw_semaphore alloc_sem;
fs/dlm/dlm_internal.h:	struct rw_semaphore	ls_in_recovery;	/* block local requests */
fs/dlm/dlm_internal.h:	struct rw_semaphore	ls_recv_active;	/* block dlm_recv */
fs/dlm/dlm_internal.h:	struct rw_semaphore	ls_root_sem;	/* protect root_list */
fs/dlm/dlm_internal.h: * should do down_write() on the in_recovery rw_semaphore. (doing down_write
fs/dlm/dlm_internal.h: * LSFL_RECOVER_LOCK - dlm_recoverd holds the in_recovery rw_semaphore.
fs/dlm/dlm_internal.h: * rw_semaphore and clears it after it has released the rw_semaphore.
fs/gfs2/incore.h:	struct rw_semaphore i_rw_mutex;
fs/gfs2/incore.h:	struct rw_semaphore sd_log_flush_lock;
fs/ceph/mds_client.h:	struct rw_semaphore     snap_rwsem;
fs/ceph/mds_client.h:	struct rw_semaphore     pool_perm_rwsem;
fs/udf/udf_i.h:	struct rw_semaphore	i_data_sem;
fs/nilfs2/mdt.h: * @mi_sem: reader/writer semaphore for meta data operations
fs/nilfs2/mdt.h:	struct rw_semaphore	mi_sem;
fs/nilfs2/segment.c: * nilfs_transaction_begin() acquires a reader/writer semaphore, called
fs/nilfs2/segment.c: * the segment semaphore, to make a segment construction and write tasks
fs/nilfs2/segment.c: * deadlock, the semaphore is only acquired or released in the outermost call.
fs/nilfs2/segment.c: * nilfs_transaction_commit() releases the read semaphore which is
fs/nilfs2/segment.c: * semaphore.
fs/nilfs2/segment.c: * Caller must hold the segment semaphore.
fs/nilfs2/bmap.h: * @b_sem: semaphore
fs/nilfs2/bmap.h:	struct rw_semaphore b_sem;
fs/nilfs2/bmap.h:/* Assume that bmap semaphore is locked. */
fs/nilfs2/bmap.h:/* Assume that bmap semaphore is locked. */
fs/nilfs2/bmap.h:/* Assume that bmap semaphore is locked. */
fs/nilfs2/the_nilfs.h: * @ns_sem: semaphore for shared states
fs/nilfs2/the_nilfs.h: * @ns_segctor_sem: semaphore protecting log write
fs/nilfs2/the_nilfs.h:	struct rw_semaphore	ns_sem;
fs/nilfs2/the_nilfs.h:	struct rw_semaphore	ns_segctor_sem;
fs/nilfs2/nilfs.h: * @xattr_sem: semaphore for extended attributes processing
fs/nilfs2/nilfs.h:	struct rw_semaphore xattr_sem;
fs/ntfs/volume.h:	struct rw_semaphore mftbmp_lock; /* Lock for serializing accesses to the
fs/ntfs/volume.h:	struct rw_semaphore lcnbmp_lock; /* Lock for serializing accesses to the
fs/ntfs/runlist.h:	struct rw_semaphore lock;
fs/ntfs/aops.h: * a {rw_}semaphore or other means of serialization. A spin lock cannot be
fs/ntfs/super.c: * NOTE: Caller must hold mftbmp_lock rw_semaphore for reading or writing.
fs/reiserfs/stree.c: *  semaphores.
fs/reiserfs/reiserfs.h:	struct rw_semaphore i_xattr_sem;
fs/reiserfs/reiserfs.h:reiserfs_down_read_safe(struct rw_semaphore *sem, struct super_block *s)
fs/reiserfs/journal.c:#include <linux/semaphore.h>
fs/dcache.c:	struct rw_semaphore *m2 = NULL;
fs/orangefs/super.c:	 * We want to clear everything except for rw_semaphore and the
fs/orangefs/orangefs-kernel.h:	 * reader/writer semaphore on the orangefs_inode_s structure.
fs/orangefs/orangefs-kernel.h:	struct rw_semaphore xattr_sem;
fs/ext2/inode.c:	 * if the chain has been changed after we grab the semaphore,
fs/ext2/ext2.h:	struct rw_semaphore xattr_sem;
fs/ext2/ext2.h:	struct rw_semaphore dax_sem;
fs/ubifs/commit.c: * by holding the commit semaphore down for writing. As few I/O operations as
fs/ubifs/commit.c: * written are merely identified. During commit end, the commit semaphore is no
fs/ubifs/ubifs.h:	struct rw_semaphore commit_sem;
fs/affs/affs.h:	struct semaphore i_link_lock;		/* Protects internal inode access. */
fs/affs/affs.h:	struct semaphore i_ext_lock;		/* Protects internal inode access. */
fs/fs-writeback.c: *   Caller need not hold sb s_umount semaphore.
fs/xfs/mrlock.h:	struct rw_semaphore	mr_lock;
fs/xfs/xfs_log_priv.h:	struct rw_semaphore	xc_ctx_lock ____cacheline_aligned_in_smp;
fs/xfs/xfs_linux.h:#include <linux/semaphore.h>
fs/xfs/xfs_buf.h:	 * hit to be fully processed. The semaphore straddles the cacheline
fs/xfs/xfs_buf.h:	 * which is the only bit that is touched if we hit the semaphore
fs/xfs/xfs_buf.h:	struct semaphore	b_sema;		/* semaphore for lockables */
fs/afs/internal.h:	struct rw_semaphore	vl_sem;		/* volume management serialisation semaphore */
fs/afs/internal.h:	struct rw_semaphore	sem;		/* access lock */
fs/afs/internal.h:	struct rw_semaphore	server_sem;	/* lock for accessing current server */
fs/afs/internal.h:extern struct rw_semaphore afs_proc_cells_sem;
fs/fat/fat.h:	struct rw_semaphore truncate_lock; /* protect bmap against truncate */
fs/namei.c: * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)
fs/block_dev.c: * If a superblock is found on this device, we take the s_umount semaphore
fs/f2fs/segment.h:	struct rw_semaphore journal_rwsem;	/* protect journal area */
fs/f2fs/f2fs.h:	struct rw_semaphore i_sem;	/* protect fi info */
fs/f2fs/f2fs.h:	struct rw_semaphore dio_rwsem[2];/* avoid racing between dio and gc */
fs/f2fs/f2fs.h:	struct rw_semaphore nat_tree_lock;	/* protect nat_tree_lock */
fs/f2fs/f2fs.h:	struct rw_semaphore io_rwsem;	/* blocking op for bio */
fs/f2fs/f2fs.h:	struct rw_semaphore cp_rwsem;		/* blocking FS operations */
fs/f2fs/f2fs.h:	struct rw_semaphore node_write;		/* locking node writes */
fs/f2fs/f2fs.h:	struct rw_semaphore extent_tree_lock;	/* locking extent radix tree */
fs/cifs/cifsglob.h:	struct rw_semaphore lock_sem;	/* protect the fields above */
fs/cifs/cifsglob.h: *                  protected by spinlocks or semaphores.
fs/ocfs2/refcounttree.h:	struct rw_semaphore rf_sem;
fs/ocfs2/inode.h:	struct rw_semaphore		ip_alloc_sem;
fs/ocfs2/inode.h:	struct rw_semaphore		ip_xattr_sem;
fs/ocfs2/aops.c:		 * any additional semaphores or cluster locks.
fs/ocfs2/journal.h:	struct rw_semaphore       j_trans_barrier;
fs/ocfs2/dcache.c: * Call this function with the parent dir semaphore and the parent dir
fs/ocfs2/dcache.c: * The dir semaphore will protect us from having to worry about
fs/ocfs2/journal.c: * WARNING: This will not release any semaphores or disk locks taken
fs/fscache/cache.c: * - the cache addremove semaphore must be at least read-locked by the caller
fs/fscache/internal.h:extern struct rw_semaphore fscache_addremove_sem;
fs/jfs/jfs_incore.h:	struct rw_semaphore rdwrlock;
fs/jfs/jfs_incore.h:	struct rw_semaphore xattr_sem;
fs/lockd/svclock.c: * to a file's list of blocked locks through a semaphore. The global
fs/lockd/svclock.c: * then sleep on the file semaphore without disrupting e.g. the nfs client).
fs/lockd/svclock.c:	/* Technically, we should down the file semaphore here. Since we
fs/ncpfs/ncp_fs_sb.h:	struct rw_semaphore auth_rwsem;
fs/nfs/direct.c: * semaphore and updating the i_size.  The NFS server will set
fs/nfs/nfs4proc.c: * NOTE: Caller must be holding the sp->so_owner semaphore!
fs/configfs/dir.c: * the way out.  They assume that the proper semaphores are held, they
fs/configfs/dir.c: * callback.  The subsystem semaphore MUST be held by the caller, and
fs/configfs/dir.c: * do not need the subsystem semaphore.  Holding configfs_dirent_lock helps
fs/configfs/configfs_internal.h:extern struct rw_semaphore configfs_rename_sem;
fs/fuse/fuse_i.h:	/** Read/write semaphore to hold when accessing sb. */
fs/fuse/fuse_i.h:	struct rw_semaphore killsb;
include/asm-generic/rwsem.h: * R/W semaphores originally for PPC using the stuff in lib/rwsem.c.
include/asm-generic/rwsem.h: * the semaphore definition
include/asm-generic/rwsem.h:static inline void __down_read(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline int __down_read_trylock(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline void __down_write(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline int __down_write_killable(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline int __down_write_trylock(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline void __up_read(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline void __up_write(struct rw_semaphore *sem)
include/asm-generic/rwsem.h:static inline void __downgrade_write(struct rw_semaphore *sem)
include/video/udlfb.h:	struct semaphore limit_sem;
include/sound/core.h:#include <linux/rwsem.h>		/* struct rw_semaphore */
include/sound/core.h:	struct rw_semaphore controls_rwsem;	/* controls list lock */
include/uapi/asm-generic/errno.h:#define	ENAVAIL		119	/* No XENIX semaphores available */
include/uapi/asm-generic/sembuf.h:	unsigned long	sem_nsems;	/* no. of semaphores in array */
include/uapi/linux/sem.h:	struct sem	*sem_base;		/* ptr to first semaphore in array */
include/uapi/linux/sem.h:	unsigned short	sem_nsems;		/* no. of semaphores in array */
include/uapi/linux/sem.h:	unsigned short  sem_num;	/* semaphore index in array */
include/uapi/linux/sem.h:	short		sem_op;		/* semaphore operation */
include/uapi/linux/sem.h:#define SEMMNI  32000           /* <= IPCMNI  max # of semaphore identifiers */
include/uapi/linux/sem.h:#define SEMMSL  32000           /* <= INT_MAX max num of semaphores per id */
include/uapi/linux/sem.h:#define SEMMNS  (SEMMNI*SEMMSL) /* <= INT_MAX max # of semaphores in system */
include/uapi/linux/sem.h:#define SEMVMX  32767           /* <= 32767 semaphore maximum value */
include/uapi/linux/sem.h:#define SEMMAP  SEMMNS          /* # of entries in semaphore map */
include/uapi/linux/capability.h:/* Allow removing semaphores */
include/uapi/linux/capability.h:/* Used instead of CAP_CHOWN to "chown" IPC message queues, semaphores
include/uapi/linux/sysctl.h: 	KERN_SEM=43,		/* struct: sysv semaphore limits */
include/keys/user-type.h: *   - the payload must be read with RCU procedures or with the key semaphore
include/keys/user-type.h: *   - the payload may only be replaced with the key semaphore write-locked
include/rdma/ib_verbs.h:	struct rw_semaphore	umem_rwsem;
include/rdma/ib_verbs.h:	struct rw_semaphore	mutex;		/* protects .live */
include/rdma/ib_verbs.h:	 * spinlock and the lists_rwsem read-write semaphore */
include/rdma/ib_umem_odp.h:	 * and the ucontext umem_mutex semaphore locked for read).
include/net/sch_generic.h: * root.  This is enforced by holding the RTNL semaphore, which
include/net/sock.h: * mini-semaphore synchronizes multiple users amongst themselves.
include/scsi/scsi_transport_spi.h:	struct mutex dv_mutex; /* semaphore to serialise dv */
include/target/target_core_base.h:	struct semaphore	caw_sem;
include/target/iscsi/iscsi_target_core.h:	struct semaphore	np_login_sem;
include/linux/percpu-rwsem.h:struct percpu_rw_semaphore {
include/linux/percpu-rwsem.h:	struct rw_semaphore	rw_sem;
include/linux/percpu-rwsem.h:static struct percpu_rw_semaphore name = {				\
include/linux/percpu-rwsem.h:extern int __percpu_down_read(struct percpu_rw_semaphore *, int);
include/linux/percpu-rwsem.h:extern void __percpu_up_read(struct percpu_rw_semaphore *);
include/linux/percpu-rwsem.h:static inline void percpu_down_read_preempt_disable(struct percpu_rw_semaphore *sem)
include/linux/percpu-rwsem.h:static inline void percpu_down_read(struct percpu_rw_semaphore *sem)
include/linux/percpu-rwsem.h:static inline int percpu_down_read_trylock(struct percpu_rw_semaphore *sem)
include/linux/percpu-rwsem.h:static inline void percpu_up_read_preempt_enable(struct percpu_rw_semaphore *sem)
include/linux/percpu-rwsem.h:static inline void percpu_up_read(struct percpu_rw_semaphore *sem)
include/linux/percpu-rwsem.h:extern void percpu_down_write(struct percpu_rw_semaphore *);
include/linux/percpu-rwsem.h:extern void percpu_up_write(struct percpu_rw_semaphore *);
include/linux/percpu-rwsem.h:extern int __percpu_init_rwsem(struct percpu_rw_semaphore *,
include/linux/percpu-rwsem.h:extern void percpu_free_rwsem(struct percpu_rw_semaphore *);
include/linux/percpu-rwsem.h:static inline void percpu_rwsem_release(struct percpu_rw_semaphore *sem,
include/linux/percpu-rwsem.h:static inline void percpu_rwsem_acquire(struct percpu_rw_semaphore *sem,
include/linux/cpufreq.h:	 * The rules for this semaphore:
include/linux/cpufreq.h:	 *   do a down_read on this semaphore.
include/linux/cpufreq.h:	struct rw_semaphore	rwsem;
include/linux/fb.h: * semaphore held, this is the only suitable locking mechanism we have
include/linux/key.h:	struct rw_semaphore	sem;		/* change vs change sem */
include/linux/sem.h:/* One sem_array data structure for each set of semaphores in the system. */
include/linux/sem.h:	struct sem		*sem_base;	/* ptr to first semaphore in array */
include/linux/sem.h:	int			sem_nsems;	/* no. of semaphores in array */
include/linux/cgroup-defs.h:extern struct percpu_rw_semaphore cgroup_threadgroup_rwsem;
include/linux/cgroup-defs.h: * synchronize against threadgroup changes using a percpu_rw_semaphore.
include/linux/lsm_hooks.h: *	@sma contains the semaphore structure
include/linux/lsm_hooks.h: *	deallocate security struct for this semaphore
include/linux/lsm_hooks.h: *	@sma contains the semaphore structure.
include/linux/lsm_hooks.h: *	Check permission when a semaphore is requested through the semget
include/linux/lsm_hooks.h: *	system call.  This hook is only called when returning the semaphore
include/linux/lsm_hooks.h: *	identifier for an existing semaphore, not when a new one must be
include/linux/lsm_hooks.h: *	@sma contains the semaphore structure.
include/linux/lsm_hooks.h: *	Check permission when a semaphore operation specified by @cmd is to be
include/linux/lsm_hooks.h: *	performed on the semaphore @sma.  The @sma may be NULL, e.g. for
include/linux/lsm_hooks.h: *	@sma contains the semaphore structure.  May be NULL.
include/linux/lsm_hooks.h: *	semaphore set @sma.  If the @alter flag is nonzero, the semaphore set
include/linux/lsm_hooks.h: *	@sma contains the semaphore structure.
include/linux/ceph/osd_client.h:	struct rw_semaphore    lock;
include/linux/key-type.h:	 * - the key's semaphore will be write-locked by the caller
include/linux/key-type.h:	 * - the key's semaphore will be readlocked by the caller
include/linux/semaphore.h: * Please see kernel/semaphore.c for documentation of these functions
include/linux/semaphore.h:struct semaphore {
include/linux/semaphore.h:	struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)
include/linux/semaphore.h:static inline void sema_init(struct semaphore *sem, int val)
include/linux/semaphore.h:	*sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);
include/linux/semaphore.h:	lockdep_init_map(&sem->lock.dep_map, "semaphore->lock", &__key, 0);
include/linux/semaphore.h:extern void down(struct semaphore *sem);
include/linux/semaphore.h:extern int __must_check down_interruptible(struct semaphore *sem);
include/linux/semaphore.h:extern int __must_check down_killable(struct semaphore *sem);
include/linux/semaphore.h:extern int __must_check down_trylock(struct semaphore *sem);
include/linux/semaphore.h:extern int __must_check down_timeout(struct semaphore *sem, long jiffies);
include/linux/semaphore.h:extern void up(struct semaphore *sem);
include/linux/mm_types.h:	struct rw_semaphore mmap_sem;
include/linux/notifier.h: * They use SRCU (Sleepable Read-Copy Update) instead of rw-semaphores for
include/linux/notifier.h:	struct rw_semaphore rwsem;
include/linux/fs.h:#include <linux/semaphore.h>
include/linux/fs.h:	struct rw_semaphore	i_mmap_rwsem;	/* protect tree, count, list */
include/linux/fs.h:	struct rw_semaphore	i_rwsem;
include/linux/fs.h:	struct percpu_rw_semaphore	rw_sem[SB_FREEZE_LEVELS];
include/linux/fs.h:	struct rw_semaphore	s_umount;
include/linux/utsname.h:extern struct rw_semaphore uts_sem;
include/linux/netpoll.h:	struct semaphore dev_lock;
include/linux/posix-clock.h:	struct rw_semaphore rwsem;
include/linux/mlx5/driver.h:#include <linux/semaphore.h>
include/linux/mlx5/driver.h:	struct semaphore sem;
include/linux/mlx5/driver.h:	struct semaphore pages_sem;
include/linux/dmar.h:extern struct rw_semaphore dmar_global_lock;
include/linux/rmap.h:	struct rw_semaphore rwsem;	/* W: modification, R: walking the list */
include/linux/mmu_notifier.h: * semaphores. Notifier chains are only changed when all reverse maps and
include/linux/leds.h:	struct rw_semaphore	 trigger_lock;
include/linux/rwsem.h:/* rwsem.h: R/W semaphores, public interface
include/linux/rwsem.h: * Derived from asm-i386/semaphore.h
include/linux/rwsem.h:struct rw_semaphore;
include/linux/rwsem.h:struct rw_semaphore {
include/linux/rwsem.h:extern struct rw_semaphore *rwsem_down_read_failed(struct rw_semaphore *sem);
include/linux/rwsem.h:extern struct rw_semaphore *rwsem_down_write_failed(struct rw_semaphore *sem);
include/linux/rwsem.h:extern struct rw_semaphore *rwsem_down_write_failed_killable(struct rw_semaphore *sem);
include/linux/rwsem.h:extern struct rw_semaphore *rwsem_wake(struct rw_semaphore *);
include/linux/rwsem.h:extern struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem);
include/linux/rwsem.h:static inline int rwsem_is_locked(struct rw_semaphore *sem)
include/linux/rwsem.h:	struct rw_semaphore name = __RWSEM_INITIALIZER(name)
include/linux/rwsem.h:extern void __init_rwsem(struct rw_semaphore *sem, const char *name,
include/linux/rwsem.h:static inline int rwsem_is_contended(struct rw_semaphore *sem)
include/linux/rwsem.h:extern void down_read(struct rw_semaphore *sem);
include/linux/rwsem.h:extern int down_read_trylock(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void down_write(struct rw_semaphore *sem);
include/linux/rwsem.h:extern int __must_check down_write_killable(struct rw_semaphore *sem);
include/linux/rwsem.h:extern int down_write_trylock(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void up_read(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void up_write(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void downgrade_write(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void down_read_nested(struct rw_semaphore *sem, int subclass);
include/linux/rwsem.h:extern void down_write_nested(struct rw_semaphore *sem, int subclass);
include/linux/rwsem.h:extern int down_write_killable_nested(struct rw_semaphore *sem, int subclass);
include/linux/rwsem.h:extern void _down_write_nest_lock(struct rw_semaphore *sem, struct lockdep_map *nest_lock);
include/linux/rwsem.h:extern void down_read_non_owner(struct rw_semaphore *sem);
include/linux/rwsem.h:extern void up_read_non_owner(struct rw_semaphore *sem);
include/linux/nfs_fs.h:	struct rw_semaphore	rmdir_sem;
include/linux/nfs_fs.h:	struct rw_semaphore	rwsem;
include/linux/rwsem-spinlock.h: * the rw-semaphore definition
include/linux/rwsem-spinlock.h: * - if wait_list is not empty, then there are processes waiting for the semaphore
include/linux/rwsem-spinlock.h:struct rw_semaphore {
include/linux/rwsem-spinlock.h:extern void __down_read(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern int __down_read_trylock(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern void __down_write(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern int __must_check __down_write_killable(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern int __down_write_trylock(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern void __up_read(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern void __up_write(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern void __downgrade_write(struct rw_semaphore *sem);
include/linux/rwsem-spinlock.h:extern int rwsem_is_locked(struct rw_semaphore *sem);
include/linux/hp_sdc.h:	  struct semaphore *semaphore;	/* Semaphore to sleep on. */
include/linux/hp_sdc.h:#define HP_SDC_ACT_SEMAPHORE    0x20            /* Raise semaphore after */
include/linux/mm.h:extern struct rw_semaphore nommu_region_sem;
include/linux/mm.h:/* These take the mm semaphore themselves */
include/linux/parport.h:#include <linux/semaphore.h>
include/linux/parport.h:	struct semaphore irq;
include/linux/tty.h:	struct ld_semaphore ldisc_sem;
include/linux/tty.h:	struct rw_semaphore termios_rwsem;
include/linux/ipc_namespace.h:	struct rw_semaphore rwsem;
include/linux/user_namespace.h:	struct rw_semaphore	persistent_keyring_register_sem;
include/linux/syscalls.h:struct semaphore;
include/linux/eventpoll.h:	 * Fast check to avoid the get/release of the semaphore. Since
include/linux/eventpoll.h:	 * we're doing this outside the semaphore lock, it might return
include/linux/eventpoll.h:	 * to avoid the semaphore lock. False positives simply cannot happen
include/linux/usb/hcd.h:extern struct rw_semaphore ehci_cf_port_reset_rwsem;
include/linux/pipe_fs_i.h:/* Drop the inode semaphore and wait for a pipe event, atomically */
include/linux/hid.h:#include <linux/semaphore.h>
include/linux/hid.h:	struct semaphore driver_lock;					/* protects the current driver, except during input */
include/linux/hid.h:	struct semaphore driver_input_lock;				/* protects the current driver */
include/linux/tty_ldisc.h: * the semaphore definition
include/linux/tty_ldisc.h:struct ld_semaphore {
include/linux/tty_ldisc.h:extern void __init_ldsem(struct ld_semaphore *sem, const char *name,
include/linux/tty_ldisc.h:extern int ldsem_down_read(struct ld_semaphore *sem, long timeout);
include/linux/tty_ldisc.h:extern int ldsem_down_read_trylock(struct ld_semaphore *sem);
include/linux/tty_ldisc.h:extern int ldsem_down_write(struct ld_semaphore *sem, long timeout);
include/linux/tty_ldisc.h:extern int ldsem_down_write_trylock(struct ld_semaphore *sem);
include/linux/tty_ldisc.h:extern void ldsem_up_read(struct ld_semaphore *sem);
include/linux/tty_ldisc.h:extern void ldsem_up_write(struct ld_semaphore *sem);
include/linux/tty_ldisc.h:extern int ldsem_down_read_nested(struct ld_semaphore *sem, int subclass,
include/linux/tty_ldisc.h:extern int ldsem_down_write_nested(struct ld_semaphore *sem, int subclass,
include/linux/lockd/lockd.h:	struct rw_semaphore	h_rwsem;	/* Reboot recovery lock */
include/linux/hil_mlc.h:#include <linux/semaphore.h>
include/linux/hil_mlc.h:	struct semaphore	csem;   /* Raised when loop idle */
include/linux/hil_mlc.h:	struct semaphore	osem;   /* Raised when outpacket dispatched */
include/linux/hil_mlc.h:	struct semaphore	isem;   /* Raised when a packet arrives */
include/acpi/acconfig.h:/* Maximum count for a semaphore object */
include/acpi/acpiosxf.h:#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_create_semaphore
include/acpi/acpiosxf.h:acpi_os_create_semaphore(u32 max_units,
include/acpi/acpiosxf.h:			 u32 initial_units, acpi_semaphore * out_handle);
include/acpi/acpiosxf.h:#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_delete_semaphore
include/acpi/acpiosxf.h:acpi_status acpi_os_delete_semaphore(acpi_semaphore handle);
include/acpi/acpiosxf.h:#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_wait_semaphore
include/acpi/acpiosxf.h:acpi_os_wait_semaphore(acpi_semaphore handle, u32 units, u16 timeout);
include/acpi/acpiosxf.h:#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_signal_semaphore
include/acpi/acpiosxf.h:acpi_status acpi_os_signal_semaphore(acpi_semaphore handle, u32 units);
include/acpi/acpiosxf.h: * Mutex primitives. May be configured to use semaphores instead via
include/acpi/actypes.h: * Map the OSL Mutex interfaces to binary semaphores.
include/acpi/actypes.h:#define acpi_mutex                      acpi_semaphore
include/acpi/actypes.h:#define acpi_os_create_mutex(out_handle) acpi_os_create_semaphore (1, 1, out_handle)
include/acpi/actypes.h:#define acpi_os_delete_mutex(handle)    (void) acpi_os_delete_semaphore (handle)
include/acpi/actypes.h:#define acpi_os_acquire_mutex(handle,time) acpi_os_wait_semaphore (handle, 1, time)
include/acpi/actypes.h:#define acpi_os_release_mutex(handle)   (void) acpi_os_signal_semaphore (handle, 1)
include/acpi/actypes.h:#ifndef acpi_semaphore
include/acpi/actypes.h:#define acpi_semaphore                  void *
include/acpi/platform/acenv.h:/* Type of mutex supported by host. Default is binary semaphores. */
ipc/util.h:		int nsems;	/* for semaphores */
ipc/sem.c: * This file implements System V semaphores.
ipc/sem.c: * - multiple semaphore operations that alter the same semaphore in
ipc/sem.c: *     the per-semaphore array structure.
ipc/sem.c: *   Thus: Perfect SMP scaling between independent semaphore arrays.
ipc/sem.c: *         If multiple semaphores in one array are used, then cache line
ipc/sem.c: *         trashing on the semaphore array spinlock will limit the scaling.
ipc/sem.c: * - A woken up task may not even touch the semaphore array anymore, it may
ipc/sem.c: *   wake-up due to a completed semaphore operation is achieved by using an
ipc/sem.c: *   semaphore array, lazily allocated). For backwards compatibility, multiple
ipc/sem.c: *   and per-semaphore list (stored in the array). This allows to achieve FIFO
ipc/sem.c:/* One semaphore structure for each semaphore in the system. */
ipc/sem.c:	 * PID of the process that last modified the semaphore. For
ipc/sem.c:					/* that alter the semaphore */
ipc/sem.c:					/* that do not alter the semaphore*/
ipc/sem.c:	struct list_head	list_id;	/* per semaphore array list:
ipc/sem.c:	int			semid;		/* semaphore set identifier */
ipc/sem.c:						/* one per semaphore */
ipc/sem.c: * b) global or semaphore sem_lock() for read/write:
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * It must be called prior to dropping the global semaphore array lock.
ipc/sem.c:	 * Move all pending operation back into the per-semaphore
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * This function merges all per-semaphore queues into the global queue.
ipc/sem.c: * If the request contains only one semaphore operation, and there are
ipc/sem.c: * no complex transactions pending, lock only the semaphore involved.
ipc/sem.c: * Otherwise, lock the entire semaphore array, since we either have
ipc/sem.c: * multiple semaphores in our own semops, or we need to look at
ipc/sem.c: * semaphores from other pending complex operations.
ipc/sem.c:	 * Only one semaphore affected - try to optimize locking.
ipc/sem.c:		 * Acquire the per-semaphore lock.
ipc/sem.c: * newary - Create a new semaphore set
ipc/sem.c: * perform_atomic_semop - Perform (if possible) a semaphore operation
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * The function is called without any locks held, thus the semaphore array
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * @sma: semaphore array.
ipc/sem.c: * @semnum: semaphore that was modified.
ipc/sem.c: * wake_const_ops must be called after a semaphore in a semaphore array
ipc/sem.c: * semaphore.
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * on the actual changes that were performed on the semaphore array.
ipc/sem.c:	/* first: the per-semaphore queues, if known */
ipc/sem.c:		 * No sops means modified semaphores not known.
ipc/sem.c:	 * If one of the modified semaphores got 0,
ipc/sem.c: * @sma: semaphore array.
ipc/sem.c: * @semnum: semaphore that was modified.
ipc/sem.c: * update_queue must be called after a semaphore in a semaphore array
ipc/sem.c: * was modified. If multiple semaphores were modified, update_queue must
ipc/sem.c: * semaphore.
ipc/sem.c:		/* If we are scanning the single sop, per-semaphore list of
ipc/sem.c:		 * one semaphore and that semaphore is 0, then it is not
ipc/sem.c:		 * be in the  per semaphore pending queue, and decrements
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * @sma: semaphore array
ipc/sem.c: * based on the actual changes that were performed on the semaphore array.
ipc/sem.c:		/* semaphore array uses the global queue - just process it. */
ipc/sem.c:			 * No sops, thus the modified semaphores are not
ipc/sem.c:			 * Check the semaphores that were increased:
ipc/sem.c:			 *   semaphore ops wont be able to run: If the
ipc/sem.c: * check_qop: Test if a queued operation sleeps on the semaphore semnum
ipc/sem.c:	 * semaphores. This violates SUS, therefore it was changed to the
ipc/sem.c:/* The following counts are associated to each semaphore:
ipc/sem.c: * Per definition, a task waits only on the semaphore of the first semop
ipc/sem.c:		/* all task on a per-semaphore list sleep on exactly
ipc/sem.c:		 * that semaphore
ipc/sem.c:/* Free a semaphore set. freeary() is called with sem_ids.rwsem locked
ipc/sem.c: * as a writer and the spinlock for this semaphore set hold. sem_ids.rwsem
ipc/sem.c:	/* Free the existing undo structures for this semaphore set.  */
ipc/sem.c:	/* Remove the semaphore set from the IDR */
ipc/sem.c: * @semid: semaphore array id
ipc/sem.c: * The size of the undo structure depends on the size of the semaphore
ipc/sem.c:	/* step 1: figure out the size of the semaphore array */
ipc/sem.c:	/* step 3: Acquire the lock on semaphore array */
ipc/sem.c: * the requested semaphores.
ipc/sem.c: * The function can be called with or without holding the semaphore spinlock.
ipc/sem.c:	 * only a per-semaphore lock is held and it's OK to proceed with the
ipc/sem.c:		 * overwritten by the previous owner of the semaphore.
ipc/sem.c: * add semadj values to semaphores, free undo structures.
ipc/sem.c: * undo structures are not freed when semaphore arrays are destroyed
ipc/sem.c:			struct sem *semaphore = &sma->sem_base[i];
ipc/sem.c:				semaphore->semval += un->semadj[i];
ipc/sem.c:				 * Range checks of the new semaphore value,
ipc/sem.c:				 * Linux caps the semaphore value, both at 0
ipc/sem.c:				if (semaphore->semval < 0)
ipc/sem.c:					semaphore->semval = 0;
ipc/sem.c:				if (semaphore->semval > SEMVMX)
ipc/sem.c:					semaphore->semval = SEMVMX;
ipc/sem.c:				semaphore->sempid = task_tgid_vnr(current);
ipc/util.c: * The various sysv ipc resources (semaphores, messages and shared
kernel/dma.c: * This doesn't really matter now, but it will once we get real semaphores
kernel/nsproxy.c:	 * to a new ipc namespace, the semaphore arrays from the old
kernel/trace/trace_output.h:extern struct rw_semaphore trace_event_sem;
kernel/events/uprobes.c:static struct percpu_rw_semaphore dup_mmap_sem;
kernel/events/uprobes.c:	struct rw_semaphore	register_rwsem;
kernel/events/uprobes.c:	struct rw_semaphore	consumer_rwsem;
kernel/locking/mutex.c: * about this when converting semaphore users to mutexes.
kernel/locking/percpu-rwsem.c:int __percpu_init_rwsem(struct percpu_rw_semaphore *sem,
kernel/locking/percpu-rwsem.c:	/* ->rw_sem represents the whole percpu_rw_semaphore for lockdep */
kernel/locking/percpu-rwsem.c:void percpu_free_rwsem(struct percpu_rw_semaphore *sem)
kernel/locking/percpu-rwsem.c:int __percpu_down_read(struct percpu_rw_semaphore *sem, int try)
kernel/locking/percpu-rwsem.c:void __percpu_up_read(struct percpu_rw_semaphore *sem)
kernel/locking/percpu-rwsem.c:static bool readers_active_check(struct percpu_rw_semaphore *sem)
kernel/locking/percpu-rwsem.c:void percpu_down_write(struct percpu_rw_semaphore *sem)
kernel/locking/percpu-rwsem.c:void percpu_up_write(struct percpu_rw_semaphore *sem)
kernel/locking/Makefile:obj-y += mutex.o semaphore.o rwsem.o percpu-rwsem.o
kernel/locking/rwsem.c:/* kernel/rwsem.c: R/W semaphores, public implementation
kernel/locking/rwsem.c: * Derived from asm-i386/semaphore.h
kernel/locking/rwsem.c:void __sched down_read(struct rw_semaphore *sem)
kernel/locking/rwsem.c:int down_read_trylock(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void __sched down_write(struct rw_semaphore *sem)
kernel/locking/rwsem.c:int __sched down_write_killable(struct rw_semaphore *sem)
kernel/locking/rwsem.c:int down_write_trylock(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void up_read(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void up_write(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void downgrade_write(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void down_read_nested(struct rw_semaphore *sem, int subclass)
kernel/locking/rwsem.c:void _down_write_nest_lock(struct rw_semaphore *sem, struct lockdep_map *nest)
kernel/locking/rwsem.c:void down_read_non_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.c:void down_write_nested(struct rw_semaphore *sem, int subclass)
kernel/locking/rwsem.c:int __sched down_write_killable_nested(struct rw_semaphore *sem, int subclass)
kernel/locking/rwsem.c:void up_read_non_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.h: * The owner field of the rw_semaphore structure will be set to
kernel/locking/rwsem.h:static inline void rwsem_set_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.h:static inline void rwsem_clear_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.h:static inline void rwsem_set_reader_owned(struct rw_semaphore *sem)
kernel/locking/rwsem.h:static inline void rwsem_set_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.h:static inline void rwsem_clear_owner(struct rw_semaphore *sem)
kernel/locking/rwsem.h:static inline void rwsem_set_reader_owned(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:/* rwsem.c: R/W semaphores: contention handling functions
kernel/locking/rwsem-xadd.c: * Derived from arch/i386/kernel/semaphore.c
kernel/locking/rwsem-xadd.c: * Guide to the rw_semaphore's count field for common values.
kernel/locking/rwsem-xadd.c:void __init_rwsem(struct rw_semaphore *sem, const char *name,
kernel/locking/rwsem-xadd.c:	 * Make sure we are not reinitializing a held semaphore:
kernel/locking/rwsem-xadd.c:static void __rwsem_mark_wake(struct rw_semaphore *sem,
kernel/locking/rwsem-xadd.c:struct rw_semaphore __sched *rwsem_down_read_failed(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static inline bool rwsem_try_write_lock(long count, struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static inline bool rwsem_try_write_lock_unqueued(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static inline bool rwsem_can_spin_on_owner(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static noinline bool rwsem_spin_on_owner(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static bool rwsem_optimistic_spin(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static inline bool rwsem_has_spinner(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static bool rwsem_optimistic_spin(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static inline bool rwsem_has_spinner(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:static inline struct rw_semaphore *
kernel/locking/rwsem-xadd.c:__rwsem_down_write_failed_common(struct rw_semaphore *sem, int state)
kernel/locking/rwsem-xadd.c:	struct rw_semaphore *ret = sem;
kernel/locking/rwsem-xadd.c:__visible struct rw_semaphore * __sched
kernel/locking/rwsem-xadd.c:rwsem_down_write_failed(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:__visible struct rw_semaphore * __sched
kernel/locking/rwsem-xadd.c:rwsem_down_write_failed_killable(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c: * handle waking up a waiter on the semaphore
kernel/locking/rwsem-xadd.c:struct rw_semaphore *rwsem_wake(struct rw_semaphore *sem)
kernel/locking/rwsem-xadd.c:struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem)
kernel/locking/locktorture.c:static struct percpu_rw_semaphore pcpu_rwsem;
kernel/locking/rwsem-spinlock.c:/* rwsem-spinlock.c: R/W semaphores: contention handling functions for
kernel/locking/rwsem-spinlock.c:int rwsem_is_locked(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c: * initialise the semaphore
kernel/locking/rwsem-spinlock.c:void __init_rwsem(struct rw_semaphore *sem, const char *name,
kernel/locking/rwsem-spinlock.c:	 * Make sure we are not reinitializing a held semaphore:
kernel/locking/rwsem-spinlock.c:static inline struct rw_semaphore *
kernel/locking/rwsem-spinlock.c:__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)
kernel/locking/rwsem-spinlock.c:static inline struct rw_semaphore *
kernel/locking/rwsem-spinlock.c:__rwsem_wake_one_writer(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c: * get a read lock on the semaphore
kernel/locking/rwsem-spinlock.c:void __sched __down_read(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c:	/* we don't need to touch the semaphore struct anymore */
kernel/locking/rwsem-spinlock.c:int __down_read_trylock(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c: * get a write lock on the semaphore
kernel/locking/rwsem-spinlock.c:int __sched __down_write_common(struct rw_semaphore *sem, int state)
kernel/locking/rwsem-spinlock.c:void __sched __down_write(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c:int __sched __down_write_killable(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c:int __down_write_trylock(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c: * release a read lock on the semaphore
kernel/locking/rwsem-spinlock.c:void __up_read(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c: * release a write lock on the semaphore
kernel/locking/rwsem-spinlock.c:void __up_write(struct rw_semaphore *sem)
kernel/locking/rwsem-spinlock.c:void __downgrade_write(struct rw_semaphore *sem)
kernel/locking/semaphore.c: * This file implements counting semaphores.
kernel/locking/semaphore.c: * A counting semaphore may be acquired 'n' times before sleeping.
kernel/locking/semaphore.c: * The spinlock controls access to the other members of the semaphore.
kernel/locking/semaphore.c: * parts of the kernel expect to be able to use down() on a semaphore in
kernel/locking/semaphore.c: * semaphore.  If it's zero, there may be tasks waiting on the wait_list.
kernel/locking/semaphore.c:#include <linux/semaphore.h>
kernel/locking/semaphore.c:static noinline void __down(struct semaphore *sem);
kernel/locking/semaphore.c:static noinline int __down_interruptible(struct semaphore *sem);
kernel/locking/semaphore.c:static noinline int __down_killable(struct semaphore *sem);
kernel/locking/semaphore.c:static noinline int __down_timeout(struct semaphore *sem, long timeout);
kernel/locking/semaphore.c:static noinline void __up(struct semaphore *sem);
kernel/locking/semaphore.c: * down - acquire the semaphore
kernel/locking/semaphore.c: * @sem: the semaphore to be acquired
kernel/locking/semaphore.c: * Acquires the semaphore.  If no more tasks are allowed to acquire the
kernel/locking/semaphore.c: * semaphore, calling this function will put the task to sleep until the
kernel/locking/semaphore.c: * semaphore is released.
kernel/locking/semaphore.c:void down(struct semaphore *sem)
kernel/locking/semaphore.c: * down_interruptible - acquire the semaphore unless interrupted
kernel/locking/semaphore.c: * @sem: the semaphore to be acquired
kernel/locking/semaphore.c: * Attempts to acquire the semaphore.  If no more tasks are allowed to
kernel/locking/semaphore.c: * acquire the semaphore, calling this function will put the task to sleep.
kernel/locking/semaphore.c: * If the semaphore is successfully acquired, this function returns 0.
kernel/locking/semaphore.c:int down_interruptible(struct semaphore *sem)
kernel/locking/semaphore.c: * down_killable - acquire the semaphore unless killed
kernel/locking/semaphore.c: * @sem: the semaphore to be acquired
kernel/locking/semaphore.c: * Attempts to acquire the semaphore.  If no more tasks are allowed to
kernel/locking/semaphore.c: * acquire the semaphore, calling this function will put the task to sleep.
kernel/locking/semaphore.c: * -EINTR.  If the semaphore is successfully acquired, this function returns
kernel/locking/semaphore.c:int down_killable(struct semaphore *sem)
kernel/locking/semaphore.c: * down_trylock - try to acquire the semaphore, without waiting
kernel/locking/semaphore.c: * @sem: the semaphore to be acquired
kernel/locking/semaphore.c: * Try to acquire the semaphore atomically.  Returns 0 if the semaphore has
kernel/locking/semaphore.c: * and the semaphore can be released by any task or interrupt.
kernel/locking/semaphore.c:int down_trylock(struct semaphore *sem)
kernel/locking/semaphore.c: * down_timeout - acquire the semaphore within a specified time
kernel/locking/semaphore.c: * @sem: the semaphore to be acquired
kernel/locking/semaphore.c: * Attempts to acquire the semaphore.  If no more tasks are allowed to
kernel/locking/semaphore.c: * acquire the semaphore, calling this function will put the task to sleep.
kernel/locking/semaphore.c: * If the semaphore is not released within the specified number of jiffies,
kernel/locking/semaphore.c: * this function returns -ETIME.  It returns 0 if the semaphore was acquired.
kernel/locking/semaphore.c:int down_timeout(struct semaphore *sem, long timeout)
kernel/locking/semaphore.c: * up - release the semaphore
kernel/locking/semaphore.c: * @sem: the semaphore to release
kernel/locking/semaphore.c: * Release the semaphore.  Unlike mutexes, up() may be called from any
kernel/locking/semaphore.c:void up(struct semaphore *sem)
kernel/locking/semaphore.c:struct semaphore_waiter {
kernel/locking/semaphore.c:static inline int __sched __down_common(struct semaphore *sem, long state,
kernel/locking/semaphore.c:	struct semaphore_waiter waiter;
kernel/locking/semaphore.c:static noinline void __sched __down(struct semaphore *sem)
kernel/locking/semaphore.c:static noinline int __sched __down_interruptible(struct semaphore *sem)
kernel/locking/semaphore.c:static noinline int __sched __down_killable(struct semaphore *sem)
kernel/locking/semaphore.c:static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)
kernel/locking/semaphore.c:static noinline void __sched __up(struct semaphore *sem)
kernel/locking/semaphore.c:	struct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,
kernel/locking/semaphore.c:						struct semaphore_waiter, list);
kernel/cgroup.c:struct percpu_rw_semaphore cgroup_threadgroup_rwsem;
kernel/taskstats.c:	struct rw_semaphore sem;
kernel/fork.c:	 * to a new ipc namespace, the semaphore arrays from the old
kernel/printk/printk.c: * keeping track if we have the console semaphore held. It's
kernel/printk/printk.c:		 * semaphore.  The release will print out buffers and wake up
kernel/printk/printk.c: * output and call the console drivers.  If we fail to get the semaphore, we
kernel/sched/idle.c: * NOTE: no locks or semaphores should be used here
kernel/sched/core.c: *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and
kernel/sched/core.c: *		make semaphores SMP safe
kernel/sched/core.c: *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.
kernel/sched/completion.c: * It differs from semaphores in that their default case is the opposite,
kernel/sched/completion.c: * wait_for_completion default blocks whereas semaphore default non-block. The
kernel/sched/completion.c: * something which isn't entirely natural for semaphores.
kernel/sched/auto_group.h:	struct rw_semaphore	lock;
lib/locking-selftest.c: * mutexes and rw-semaphores.
lib/locking-selftest.c:	struct mutex *mutex, struct rw_semaphore *rwsem)\
lib/test_rhashtable.c:#include <linux/semaphore.h>
lib/test_rhashtable.c:static struct semaphore prestart_sem;
lib/test_rhashtable.c:static struct semaphore startup_sem = __SEMAPHORE_INITIALIZER(startup_sem, 0);
mm/mincore.c: * all the arguments, we hold the mmap semaphore: we should
mm/mmap.c: * Called with the mm semaphore held.
mm/mmap.c: * Called with the mm semaphore held.
mm/memory.c: *  Note: this is only safe if the mm semaphore is held when called.
mm/memory.c: * By the time we get here, we already hold the mm semaphore
mm/memory.c: * By the time we get here, we already hold the mm semaphore
mm/nommu.c: * - the caller must hold the region semaphore for writing, which this releases
mm/mempolicy.c: * and mempolicy.  May also be called holding the mmap_semaphore for write.
mm/oom_kill.c:	 * oom killed thread cannot exit because it requires the semaphore and
net/irda/irqueue.c: *		  global semaphore.
net/9p/trans_rdma.c:#include <linux/semaphore.h>
net/9p/trans_rdma.c:	struct semaphore sq_sem;
net/9p/trans_rdma.c:	struct semaphore rq_sem;
net/ceph/osd_client.c:static inline bool rwsem_is_wrlocked(struct rw_semaphore *sem)
net/ipv4/ipmr.c: * Note that the changes are semaphored via rtnl_lock.
net/ipv4/devinet.c:/* Called only from RTNL semaphored context. No locks. */
net/ipv4/devinet.c:/* Called only under RTNL semaphore */
net/ipv6/ip6mr.c:   Note that the changes are semaphored via rtnl_lock.
net/core/link_watch.c:/* Must be called with the rtnl semaphore held */
net/core/dev.c: * semaphore.
net/core/dev.c: * Writers must hold the rtnl semaphore while they loop through the
net/core/dev.c: * protect against pure readers; the rtnl semaphore provides the
net/core/dev.c: * semaphore held.
net/core/dev.c: *	Find an interface by name. Must be called under RTNL semaphore
net/core/dev.c: *	about locking. The caller must hold either the RTNL semaphore
net/core/dev.c: *	number.  The caller must hold the rtnl semaphore or the
net/core/dev.c: *	Callers must hold the rtnl semaphore. You may want
net/core/dev.c: *	This is a wrapper around register_netdevice that takes the rtnl semaphore
net/core/dev.c: * 2) Since we run with the RTNL semaphore not held, we can sleep
net/core/dev.c: *	Callers must hold the rtnl semaphore.  You may want
net/core/dev.c: *	the rtnl semaphore.  In general you want to use this and not
net/core/dev.c: *	Callers must hold the rtnl semaphore.
net/core/dev.c: *       to take the rtnl semaphore.
net/appletalk/ddp.c:	 * Fixme: Raise/Lower a routing change semaphore for these
net/dns_resolver/dns_key.c: * - the key's semaphore is read-locked
net/socket.c: *	   i.e. under semaphore.
net/rds/ib.h:extern struct rw_semaphore rds_ib_devices_lock;
net/rxrpc/ar-internal.h:	struct rw_semaphore	defrag_sem;	/* control re-enablement of IP DF bit */
net/netfilter/ipvs/ip_vs_sched.c:/* semaphore for schedulers */
net/netfilter/ipvs/ip_vs_pe.c:/* semaphore for IPVS PEs. */
net/netfilter/ipvs/ip_vs_ctl.c:/* semaphore for IPVS sockopts. And, [gs]etsockopt may sleep. */
net/sched/sch_api.c:			/* We dropped the RTNL semaphore in order to
net/sched/act_api.c:		/* We dropped the RTNL semaphore in order to
net/sched/cls_api.c:				/* We dropped the RTNL semaphore in order to
net/batman-adv/types.h: * @sending: sending binary semaphore: 1 if sending, 0 is not
scripts/checkpatch.pl:# check for semaphores initialized locked
security/smack/smack_lsm.c: * smack_sem_semop - Smack checks of semaphore operations
security/keys/keyring.c: * The keyring's semaphore is read-locked by the caller.  This prevents someone
security/keys/keyring.c: * caller must also hold a lock on the keyring semaphore.
security/keys/keyring.c: * This function will write-lock the keyring's semaphore and will consume some
security/keys/keyring.c: * This function will write-lock the keyring's semaphore.
security/keys/keyctl.c:		/* Read the data with the semaphore held (since we might sleep)
security/keys/big_key.c: * - the key's semaphore is read-locked
security/keys/request_key_auth.c: * - the key's semaphore is read-locked
security/keys/process_keys.c:/* Session keyring create vs join semaphore */
security/keys/process_keys.c:/* User keyring creation semaphore */
security/keys/process_keys.c: * Named session keyrings are joined with a semaphore held to prevent the
security/keys/gc.c:	 * destroy its payload with its semaphore held.
security/keys/key.c: * called with the target keyring's semaphore writelocked.  The target key's
security/keys/key.c: * semaphore need not be locked as instantiation is serialised by
security/keys/user_defined.c: * - the key's semaphore is write-locked
security/keys/user_defined.c: * - the key's semaphore is read-locked
sound/pci/intel8x0.c:static bool buggy_semaphore;
sound/pci/intel8x0.c:module_param(buggy_semaphore, bool, 0444);
sound/pci/intel8x0.c:MODULE_PARM_DESC(buggy_semaphore, "Enable workaround for hardwares with problematic codec semaphores.");
sound/pci/intel8x0.c:#define   ICH_MD3		0x00020000	/* modem power down semaphore */
sound/pci/intel8x0.c:#define   ICH_AD3		0x00010000	/* audio power down semaphore */
sound/pci/intel8x0.c:#define ICH_REG_ACC_SEMA		0x34	/* byte - codec write semaphore */
sound/pci/intel8x0.c:#define   ICH_CAS		0x01		/* codec access semaphore */
sound/pci/intel8x0.c:	unsigned buggy_semaphore: 1;	/* workaround for buggy codec semaphore */
sound/pci/intel8x0.c:static int snd_intel8x0_codec_semaphore(struct intel8x0 *chip, unsigned int codec)
sound/pci/intel8x0.c:	if (chip->buggy_semaphore)
sound/pci/intel8x0.c:	/* Anyone holding a semaphore for 1 msec should be shot... */
sound/pci/intel8x0.c:	 * reset the semaphore. So even if you don't get the semaphore, still
sound/pci/intel8x0.c:	 * continue the access. We don't need the semaphore anyway. */
sound/pci/intel8x0.c:		"codec_semaphore: semaphore is not ready [0x%x][0x%x]\n",
sound/pci/intel8x0.c:	iagetword(chip, 0);	/* clear semaphore flag */
sound/pci/intel8x0.c:	/* I don't care about the semaphore */
sound/pci/intel8x0.c:	if (snd_intel8x0_codec_semaphore(chip, ac97->num) < 0) {
sound/pci/intel8x0.c:				"codec_write %d: semaphore is not ready for register 0x%x\n",
sound/pci/intel8x0.c:	if (snd_intel8x0_codec_semaphore(chip, ac97->num) < 0) {
sound/pci/intel8x0.c:				"codec_read %d: semaphore is not ready for register 0x%x\n",
sound/pci/intel8x0.c:	if (snd_intel8x0_codec_semaphore(chip, codec) >= 0) {
sound/pci/intel8x0.c:static int snd_intel8x0_ali_codec_semaphore(struct intel8x0 *chip)
sound/pci/intel8x0.c:	if (chip->buggy_semaphore)
sound/pci/intel8x0.c:		dev_warn(chip->card->dev, "ali_codec_semaphore timeout\n");
sound/pci/intel8x0.c:	if (snd_intel8x0_ali_codec_semaphore(chip))
sound/pci/intel8x0.c:	if (snd_intel8x0_ali_codec_semaphore(chip))
sound/pci/intel8x0.c:		iagetword(chip, 0);	/* clear semaphore flag */
sound/pci/intel8x0.c:	chip->buggy_semaphore = buggy_semaphore;
sound/pci/korg1212/korg1212.c:                // the semaphore in case someone is waiting for this.
sound/pci/sis7019.c:	 * semaphore)
sound/pci/sis7019.c:	/* Get the AC97 semaphore -- software first, so we don't spin
sound/pci/sis7019.c:	 * pounding out IO reads on the hardware semaphore...
sound/pci/sis7019.c:	/* Get the AC-link semaphore, and reset the codecs
sound/pci/sis7019.c:	/* Command complete, we can let go of the semaphore now.
sound/pci/intel8x0m.c:#define   ICH_MD3		0x00020000	/* modem power down semaphore */
sound/pci/intel8x0m.c:#define   ICH_AD3		0x00010000	/* audio power down semaphore */
sound/pci/intel8x0m.c:#define ICH_REG_ACC_SEMA		0x44	/* byte - codec write semaphore */
sound/pci/intel8x0m.c:#define   ICH_CAS		0x01		/* codec access semaphore */
sound/pci/intel8x0m.c:static int snd_intel8x0m_codec_semaphore(struct intel8x0m *chip, unsigned int codec)
sound/pci/intel8x0m.c:	/* Anyone holding a semaphore for 1 msec should be shot... */
sound/pci/intel8x0m.c:	 * reset the semaphore. So even if you don't get the semaphore, still
sound/pci/intel8x0m.c:	 * continue the access. We don't need the semaphore anyway. */
sound/pci/intel8x0m.c:		"codec_semaphore: semaphore is not ready [0x%x][0x%x]\n",
sound/pci/intel8x0m.c:	iagetword(chip, 0);	/* clear semaphore flag */
sound/pci/intel8x0m.c:	/* I don't care about the semaphore */
sound/pci/intel8x0m.c:	if (snd_intel8x0m_codec_semaphore(chip, ac97->num) < 0) {
sound/pci/intel8x0m.c:				"codec_write %d: semaphore is not ready for register 0x%x\n",
sound/pci/intel8x0m.c:	if (snd_intel8x0m_codec_semaphore(chip, ac97->num) < 0) {
sound/pci/intel8x0m.c:				"codec_read %d: semaphore is not ready for register 0x%x\n",
sound/pci/intel8x0m.c:		iagetword(chip, 0); /* clear semaphore */
sound/pci/intel8x0m.c:	iagetword(chip, 0);	/* clear semaphore flag */
sound/pci/pcxhr/pcxhr_core.c:	/* reset semaphore */
sound/soc/codecs/nau8825.h:	struct semaphore xtalk_sem;
sound/soc/codecs/nau8825.c:#include <linux/semaphore.h>
sound/soc/codecs/nau8825.c: * nau8825_sema_acquire - acquire the semaphore of nau88l25
sound/soc/codecs/nau8825.c: * Attempts to acquire the semaphore with number of jiffies. If no more
sound/soc/codecs/nau8825.c: * tasks are allowed to acquire the semaphore, calling this function will
sound/soc/codecs/nau8825.c: * put the task to sleep. If the semaphore is not released within the
sound/soc/codecs/nau8825.c: * Acquires the semaphore without jiffies. If no more tasks are allowed
sound/soc/codecs/nau8825.c: * to acquire the semaphore, calling this function will put the task to
sound/soc/codecs/nau8825.c: * sleep until the semaphore is released.
sound/soc/codecs/nau8825.c: * If the semaphore is not released within the specified number of jiffies,
sound/soc/codecs/nau8825.c: * It returns 0 if the semaphore was acquired successfully.
sound/soc/codecs/nau8825.c: * nau8825_sema_release - release the semaphore of nau88l25
sound/soc/codecs/nau8825.c: * Release the semaphore which may be called from any context and
sound/soc/codecs/nau8825.c: * nau8825_sema_reset - reset the semaphore for nau88l25
sound/soc/codecs/nau8825.c: * Reset the counter of the semaphore. Call this function to restart
sound/core/seq/seq_ports.h:	struct rw_semaphore list_mutex;
sound/core/pcm_native.c:static inline void down_write_nonblock(struct rw_semaphore *lock)
sound/usb/midi.c:	struct rw_semaphore disc_rwsem;
sound/oss/dmasound/dmasound_core.c: * semaphores.
tools/testing/selftests/seccomp/seccomp_bpf.c:#include <semaphore.h>
tools/power/acpi/os_specific/service_layers/osunixxf.c:#include <semaphore.h>
tools/power/acpi/os_specific/service_layers/osunixxf.c: *              not require semaphore synchronization. Full implementations
tools/power/acpi/os_specific/service_layers/osunixxf.c:acpi_os_create_semaphore(u32 max_units,
tools/power/acpi/os_specific/service_layers/osunixxf.c:acpi_status acpi_os_delete_semaphore(acpi_handle handle)
tools/power/acpi/os_specific/service_layers/osunixxf.c:acpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)
tools/power/acpi/os_specific/service_layers/osunixxf.c:acpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)
tools/power/acpi/os_specific/service_layers/osunixxf.c: * FUNCTION:    acpi_os_create_semaphore
tools/power/acpi/os_specific/service_layers/osunixxf.c: * PARAMETERS:  initial_units       - Units to be assigned to the new semaphore
tools/power/acpi/os_specific/service_layers/osunixxf.c: * DESCRIPTION: Create an OS semaphore
tools/power/acpi/os_specific/service_layers/osunixxf.c:acpi_os_create_semaphore(u32 max_units,
tools/power/acpi/os_specific/service_layers/osunixxf.c:		char *semaphore_name = tmpnam(NULL);
tools/power/acpi/os_specific/service_layers/osunixxf.c:		    sem_open(semaphore_name, O_EXCL | O_CREAT, 0755,
tools/power/acpi/os_specific/service_layers/osunixxf.c:		sem_unlink(semaphore_name);	/* This just deletes the name */
tools/power/acpi/os_specific/service_layers/osunixxf.c: * FUNCTION:    acpi_os_delete_semaphore
tools/power/acpi/os_specific/service_layers/osunixxf.c: * PARAMETERS:  handle              - Handle returned by acpi_os_create_semaphore
tools/power/acpi/os_specific/service_layers/osunixxf.c: * DESCRIPTION: Delete an OS semaphore
tools/power/acpi/os_specific/service_layers/osunixxf.c:acpi_status acpi_os_delete_semaphore(acpi_handle handle)
tools/power/acpi/os_specific/service_layers/osunixxf.c: * FUNCTION:    acpi_os_wait_semaphore
tools/power/acpi/os_specific/service_layers/osunixxf.c: * PARAMETERS:  handle              - Handle returned by acpi_os_create_semaphore
tools/power/acpi/os_specific/service_layers/osunixxf.c:acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 msec_timeout)
tools/power/acpi/os_specific/service_layers/osunixxf.c:		 * acquire the semaphore if available otherwise return AE_TIME
tools/power/acpi/os_specific/service_layers/osunixxf.c:				/* Got the semaphore */
tools/power/acpi/os_specific/service_layers/osunixxf.c: * FUNCTION:    acpi_os_signal_semaphore
tools/power/acpi/os_specific/service_layers/osunixxf.c: * PARAMETERS:  handle              - Handle returned by acpi_os_create_semaphore
tools/power/acpi/os_specific/service_layers/osunixxf.c:acpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)
tools/power/acpi/os_specific/service_layers/osunixxf.c: * DESCRIPTION: Map these interfaces to semaphore interfaces
tools/power/acpi/os_specific/service_layers/osunixxf.c:	return (acpi_os_create_semaphore(1, 1, out_handle));
tools/power/acpi/os_specific/service_layers/osunixxf.c:	acpi_os_delete_semaphore(handle);
tools/power/acpi/os_specific/service_layers/osunixxf.c:	acpi_os_wait_semaphore(handle, 1, 0xFFFF);
tools/power/acpi/os_specific/service_layers/osunixxf.c:	acpi_os_signal_semaphore(handle, 1);
tools/perf/builtin-sched.c:#include <semaphore.h>
tools/perf/builtin-lock.c:#include <semaphore.h>
tools/perf/util/symbol.h:	union {				/* location, base and semaphore addrs */
tools/perf/builtin-kvm.c:#include <semaphore.h>
