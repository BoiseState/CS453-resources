arch/sparc/include/asm/vio.h:#include <linux/completion.h>
arch/sparc/include/asm/vio.h:struct vio_completion {
arch/sparc/include/asm/vio.h:	struct completion	com;
arch/sparc/include/asm/vio.h:	struct vio_completion	*cmp;
arch/sparc/include/asm/hypervisor.h: * boundary.  On successful completion, the specified CPU will be in
arch/sparc/include/asm/hypervisor.h: * running state.  On completion, it will be in the stopped state.  It
arch/sparc/include/asm/hypervisor.h: * Upon successful completion, control will be returned to the given
arch/sparc/include/asm/hypervisor.h: * and the completion of the configuration operation.  It should be noted
arch/sparc/include/asm/hypervisor.h: * completion and return HV_EOK, or return an error code.
arch/sparc/include/asm/estate.h: * 3) As the result of store merge completion, writeback, or copyout will
arch/sparc/include/asm/backoff.h: * completion of the compare-and-swap instruction.  Heavily
arch/sparc/kernel/pci_schizo.c:	 * completion register.
arch/sparc/kernel/smp_64.c:	/* Now, poll for completion. */
arch/sparc/kernel/sbus.c:	 * in order to ensure write completion.
arch/sparc/kernel/pci_fire.c:	 * completion register.
arch/sparc/kernel/iommu.c:		/* Ensure completion of previous PIO writes. */
arch/tile/lib/memcpy_64.c:				/* wh64 and wait for tmp7 load completion. */
arch/tile/include/hv/hypervisor.h: *  The completion interrupt message could come directly, or via the downcall
arch/tile/include/hv/hypervisor.h: *         conditions at this time rather than when the completion notification
arch/tile/include/hv/hypervisor.h: *  The completion interrupt message could come directly, or via the downcall
arch/tile/include/hv/hypervisor.h: *         conditions at this time rather than when the completion notification
arch/tile/include/hv/drv_xgbe_intf.h:  uint8_t send_completion   : 1;
arch/tile/include/hv/drv_xgbe_intf.h:/** An LEPP completion ring entry. */
arch/tile/include/hv/drv_xgbe_intf.h:/** The maximum number of completions in an LEPP queue. */
arch/tile/include/hv/drv_xgbe_intf.h:  /** Index of first completion not yet processed by user code.
arch/tile/include/hv/drv_xgbe_intf.h:   *  If this is equal to comp_busy, there are no such completions.
arch/tile/include/hv/drv_xgbe_intf.h:  /** Index of first completion record not yet completed.
arch/tile/include/hv/drv_xgbe_intf.h:   *  If this is equal to comp_tail, there are no such completions.
arch/tile/include/hv/drv_xgbe_intf.h:   *  a command with the 'completion' bit set is finished.
arch/tile/include/hv/drv_xgbe_intf.h:  /** Index of the first empty slot in the completion ring.
arch/tile/include/hv/drv_xgbe_intf.h:   *  can be filled in with completion data.
arch/tile/include/hv/drv_xgbe_intf.h:  /** A ring of user completion data.
arch/tile/include/hv/drv_xgbe_impl.h:  /** Last completion number received for packet_sendv. */
arch/tile/include/hv/drv_xgbe_impl.h:  volatile uint32_t __last_completion_rcv;
arch/tile/include/hv/drv_xgbe_impl.h:  /** Last completion number requested. */
arch/tile/include/hv/drv_xgbe_impl.h:  uint32_t __last_completion_req;
arch/tile/include/hv/drv_xgbe_impl.h:/** Get a completion on this packet.  Only used with multi-segment sends.  */
arch/tile/include/hv/netio_intf.h: *  so it will not be present in the packet upon completion of this routine.
arch/tile/include/hv/netio_intf.h: *  so it will not be present in the packet upon completion of this routine.
arch/tile/include/uapi/arch/chip_tilegx.h:/** Does the chip have post-completion interrupts? */
arch/tile/include/uapi/arch/chip_tilepro.h:/** Does the chip have post-completion interrupts? */
arch/tile/include/gxio/dma_queue.h: * based on pending hardware completions.  Note that some other thread
arch/tile/include/gxio/dma_queue.h: * available, and optionally returning a "completion_slot" suitable for
arch/tile/include/gxio/dma_queue.h:					       bool completion)
arch/tile/include/gxio/dma_queue.h:	if (completion) {
arch/tile/include/gxio/dma_queue.h:		 * A "completion_slot" is a "slot" which can be compared to
arch/tile/include/gxio/dma_queue.h:		 * "slot" into a "completion_slot", we access "hw_complete_count"
arch/tile/include/gxio/dma_queue.h:/* Check whether a particular "completion slot" has completed.
arch/tile/include/gxio/dma_queue.h: * Note that this function requires a "completion slot", and thus
arch/tile/include/gxio/dma_queue.h:					int64_t completion_slot, int update);
arch/tile/include/gxio/mpipe.h: * functions return a 63-bit "completion slot", which is actually a
arch/tile/include/gxio/mpipe.h: * application to check for egress completion by calling
arch/tile/include/gxio/mpipe.h: * bit "slot", instead of a 63-bit "completion slot".
arch/tile/include/gxio/mpipe.h:/* Reserve completion slots for edescs.
arch/tile/include/gxio/mpipe.h: * returns a full 64 bit completion slot, which can be used with
arch/tile/include/gxio/mpipe.h: * @return The first reserved completion slot, or a negative error code.
arch/tile/include/gxio/mpipe.h:/* Reserve completion slots for edescs, if possible.
arch/tile/include/gxio/mpipe.h: * but returns a full 64 bit completion slot, which can be used with
arch/tile/include/gxio/mpipe.h: * @return The first reserved completion slot, or a negative error code.
arch/tile/include/gxio/mpipe.h: * returns a 24 bit slot (instead of a 64 bit completion slot), which
arch/tile/include/gxio/mpipe.h: * returns a 24 bit slot (instead of a 64 bit completion slot), which
arch/tile/include/gxio/mpipe.h: * can handle "slots" as well as "completion slots".
arch/tile/include/gxio/mpipe.h: * Note that this function requires a "completion slot", and thus may
arch/tile/include/gxio/mpipe.h: * @param completion_slot The completion slot used by the edesc.
arch/tile/include/gxio/mpipe.h: * yet, then update any software cache of the hardware completion counter,
arch/tile/include/gxio/mpipe.h:						int64_t completion_slot,
arch/tile/include/gxio/mpipe.h:					    completion_slot, update);
arch/tile/gxio/dma_queue.c:	 * 16 bit completion counter.
arch/tile/gxio/dma_queue.c:	 * Read the 64-bit completion count without touching the cache, so
arch/tile/gxio/dma_queue.c:	 * Calculate the number of completions since we last updated the
arch/tile/gxio/dma_queue.c:	 * We succeeded in advancing the completion count; add back the
arch/tile/gxio/dma_queue.c:				 int64_t completion_slot, int update)
arch/tile/gxio/dma_queue.c:		    completion_slot)
arch/tile/gxio/dma_queue.c:	return ACCESS_ONCE(dma_queue->hw_complete_count) > completion_slot;
arch/blackfin/kernel/reboot.c:	/* Wait for completion of "system" events such as cache line
arch/parisc/kernel/perf_asm.S:	ssm     0,0                     ; dummy op to ensure completion
arch/parisc/kernel/perf_asm.S:	ssm     0,0                     ; dummy op to ensure completion
arch/arc/include/asm/barrier.h: *  - DSYNC provides DMB+completion_of_cache_bpu_maintenance_ops hence not needed
arch/unicore32/lib/copy_template.S: * Abort preamble and completion macros.
arch/unicore32/kernel/head.S: *  r15 = *virtual* address to jump to upon completion
arch/powerpc/platforms/ps3/device-init.c:	struct completion done;
arch/powerpc/platforms/ps3/device-init.c:	init_completion(&dev->done);
arch/powerpc/platforms/cell/spufs/sched.c:#include <linux/completion.h>
arch/powerpc/platforms/cell/spufs/switch.c:	/* Stop SPE execution and wait for completion. */
arch/powerpc/platforms/cell/spufs/switch.c:	/* Initiate isolate exit request and wait for completion. */
arch/powerpc/platforms/powermac/low_i2c.c:#include <linux/completion.h>
arch/powerpc/platforms/powermac/low_i2c.c:	struct completion	complete;
arch/powerpc/platforms/powermac/low_i2c.c:		/* Clear completion */
arch/powerpc/platforms/powermac/low_i2c.c:		reinit_completion(&host->complete);
arch/powerpc/platforms/powermac/low_i2c.c:	/* Wait for completion */
arch/powerpc/platforms/powermac/low_i2c.c:		wait_for_completion(&host->complete);
arch/powerpc/platforms/powermac/low_i2c.c:	init_completion(&host->complete);
arch/powerpc/platforms/powermac/low_i2c.c:	struct completion comp;
arch/powerpc/platforms/powermac/low_i2c.c:	init_completion(&comp);
arch/powerpc/platforms/powermac/low_i2c.c:		reinit_completion(&comp);
arch/powerpc/platforms/powermac/low_i2c.c:		wait_for_completion(&comp);
arch/powerpc/platforms/powermac/low_i2c.c:		reinit_completion(&comp);
arch/powerpc/platforms/powermac/low_i2c.c:		wait_for_completion(&comp);
arch/powerpc/platforms/powermac/low_i2c.c:	struct completion comp;
arch/powerpc/platforms/powermac/low_i2c.c:	init_completion(&comp);
arch/powerpc/platforms/powermac/low_i2c.c:	wait_for_completion(&comp);
arch/powerpc/platforms/powermac/nvram.c:#include <linux/completion.h>
arch/powerpc/platforms/powermac/nvram.c:		complete((struct completion *)req->arg);
arch/powerpc/platforms/powermac/nvram.c:		wait_for_completion(&req_complete);
arch/powerpc/platforms/powermac/nvram.c:		wait_for_completion(&req_complete);
arch/powerpc/platforms/pseries/mobility.c:#include <linux/completion.h>
arch/powerpc/platforms/pseries/suspend.c:	reinit_completion(&suspend_work);
arch/powerpc/platforms/pseries/dlpar.c:	struct completion *hp_completion;
arch/powerpc/platforms/pseries/dlpar.c:	if (hp_work->hp_completion)
arch/powerpc/platforms/pseries/dlpar.c:		complete(hp_work->hp_completion);
arch/powerpc/platforms/pseries/dlpar.c:			 struct completion *hotplug_done, int *rc)
arch/powerpc/platforms/pseries/dlpar.c:		work->hp_completion = hotplug_done;
arch/powerpc/platforms/pseries/dlpar.c:	struct completion hotplug_done;
arch/powerpc/platforms/pseries/dlpar.c:	init_completion(&hotplug_done);
arch/powerpc/platforms/pseries/dlpar.c:	wait_for_completion(&hotplug_done);
arch/powerpc/platforms/pseries/pseries.h:			 struct completion *hotplug_done, int *rc);
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c:		/* Unmask both error and completion irqs */
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c:			bit_fields |= 0x00000100; /* completion irq too */
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c: * On transmit, the dma completion irq triggers before the fifo completion
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c: * triggers.  Handle the dma completion here instead of the LPB FIFO Bestcomm
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c: * task completion irq because everything is not really done until the LPB FIFO
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c: * completion irq triggers.
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c: * For DMA, on receive, the "Fat Lady" is the bestcom completion irq. on
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c: * transmit, the fifo completion irq is the "Fat Lady". The opera (or in this
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c: * 1) PIO mode rx and tx completion irq
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c: * 2) DMA interrupt mode tx completion irq
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c: * Condition 3 requires executing the callback to report completion
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c:		 * Count the DMA as complete only when the FIFO completion
arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c: * mpc52xx_lpbfifo_bcom_poll - Poll for DMA completion
arch/powerpc/platforms/powernv/opal.c:	/* We still try to handle partial completions, though they
arch/powerpc/platforms/powernv/opal.c:	/* Initialise OPAL asynchronous completion interface */
arch/powerpc/platforms/powernv/opal-async.c: * PowerNV OPAL asynchronous completion interfaces
arch/powerpc/platforms/powernv/opal-async.c:				"completion init\n", __func__);
arch/powerpc/platforms/powernv/opal-wrappers.S:OPAL_CALL(opal_check_completion,		OPAL_CHECK_ASYNC_COMPLETION);
arch/powerpc/sysdev/pmi.c:#include <linux/completion.h>
arch/powerpc/sysdev/pmi.c:	struct completion	*completion;
arch/powerpc/sysdev/pmi.c:	if (type & PMI_ACK && !data->completion) {
arch/powerpc/sysdev/pmi.c:	if (data->completion && !(type & PMI_ACK)) {
arch/powerpc/sysdev/pmi.c:		complete(data->completion);
arch/powerpc/sysdev/pmi.c:	DECLARE_COMPLETION_ONSTACK(completion);
arch/powerpc/sysdev/pmi.c:	data->completion = &completion;
arch/powerpc/sysdev/pmi.c:	pr_debug("pmi_send_message: wait for completion\n");
arch/powerpc/sysdev/pmi.c:	wait_for_completion_interruptible_timeout(data->completion,
arch/powerpc/sysdev/pmi.c:	data->completion = NULL;
arch/powerpc/sysdev/fsl_pci.h:	__be32	pex_otb_cpl_tor;	/* 0x.00c - PCIE Outbound completion timeout register */
arch/powerpc/include/asm/rtas.h:	struct completion *complete; /* wait on this until working == 0 */
arch/powerpc/include/asm/icswx.h:struct coprocessor_completion_block {
arch/powerpc/include/asm/icswx.h:	struct coprocessor_completion_block ccb;
arch/powerpc/include/asm/dbdma.h:	__le16 res_count;	/* residual count after completion */
arch/powerpc/include/asm/opal.h:int64_t opal_check_completion(uint64_t buffer, uint64_t size, uint64_t token);
arch/powerpc/include/asm/smu.h: * completion passed in the "misc" argument
arch/powerpc/include/asm/smu.h: * Synchronous helpers. Will spin-wait for completion of a command
arch/powerpc/include/asm/smu.h: * For now, no polling interface is provided so you have to use completion
arch/powerpc/include/asm/ps3stor.h:	struct completion done;
arch/powerpc/kernel/traps.c:		/* Disable instruction completion */
arch/powerpc/kernel/traps.c:		/* Clear the instruction completion event */
arch/powerpc/kernel/vio.c: * Upon completion sizes of the reserve and excess pools are calculated.
arch/powerpc/kernel/rtas.c:#include <linux/completion.h>
arch/powerpc/kernel/rtas.c:	wait_for_completion(&done);
arch/powerpc/kernel/eeh_driver.c:			"the completion of reset\n");
arch/powerpc/kvm/book3s_hv_rmhandlers.S:	 *   2 Passthrough that needs completion in the host
arch/powerpc/kvm/book3s_hv_builtin.c: *	2 Passthrough that needs completion in the host
arch/alpha/Kconfig.debug:	tristate "Kernel FP software completion" if DEBUG_KERNEL && !SMP
arch/alpha/math-emu/math.c:MODULE_DESCRIPTION("FP Software completion module");
arch/alpha/kernel/traps.c:		/* Software-completion summary bit is set, so try to
arch/alpha/kernel/core_t2.c: * lowering IPL during completion processing in pci_read_config_byte()
arch/alpha/kernel/err_marvel.c:		sprintf(message, "Normal completion");
arch/alpha/kernel/err_marvel.c:		printk("%s    Discarded split completion\n", err_print_prefix);
arch/alpha/kernel/err_marvel.c:	 * completion transaction. The symptom is an ERROR_RESPONSE 
arch/arm/lib/copy_template.S: * Abort preamble and completion macros.
arch/arm/boot/dts/keystone-k2l-netcp.dtsi:			tx-completion-queue = <530>;
arch/arm/boot/dts/keystone-k2l-netcp.dtsi:			tx-completion-queue = <531>;
arch/arm/boot/dts/keystone-k2hk-netcp.dtsi:			tx-completion-queue = <8706>;
arch/arm/boot/dts/keystone-k2hk-netcp.dtsi:			tx-completion-queue = <8707>;
arch/arm/boot/dts/keystone-k2e-netcp.dtsi:			tx-completion-queue = <530>;
arch/arm/boot/dts/keystone-k2e-netcp.dtsi:			tx-completion-queue = <531>;
arch/arm/mach-omap2/i2c.c:	 * When waiting for completion of a i2c transfer, we need to
arch/arm/Kconfig:	bool "ARM errata: Interrupted ICIALLUIS may prevent completion of broadcasted operation"
arch/arm/Kconfig:	  completion of a following broadcasted operation if the second
arch/arm/mach-vexpress/spc.c:	struct completion done;
arch/arm/mach-vexpress/spc.c:static int ve_spc_waitforcompletion(int req_type)
arch/arm/mach-vexpress/spc.c:	int ret = wait_for_completion_interruptible_timeout(
arch/arm/mach-vexpress/spc.c:	init_completion(&info->done);
arch/arm/mach-vexpress/spc.c:	ret = ve_spc_waitforcompletion(req_type);
arch/arm/mach-vexpress/spc.c:	init_completion(&info->done);
arch/arm/mach-vexpress/spc.c:	ret = ve_spc_waitforcompletion(SPC_SYS_CFG);
arch/arm/mach-vexpress/spc.c:	init_completion(&info->done);
arch/arm/include/asm/bL_switcher.h:typedef void (*bL_switch_completion_handler)(void *cookie);
arch/arm/include/asm/bL_switcher.h:			 bL_switch_completion_handler completer,
arch/arm/include/asm/smp.h:extern int register_ipi_completion(struct completion *completion, int cpu);
arch/arm/mach-ux500/pm.c:	/* Wait a few cycles for the gic mask completion */
arch/arm/common/bL_switcher.c:	struct completion inbound_alive;
arch/arm/common/bL_switcher.c:	init_completion(&inbound_alive);
arch/arm/common/bL_switcher.c:	ipi_nr = register_ipi_completion(&inbound_alive, this_cpu);
arch/arm/common/bL_switcher.c:	wait_for_completion(&inbound_alive);
arch/arm/common/bL_switcher.c:	struct completion started;
arch/arm/common/bL_switcher.c:	bL_switch_completion_handler completer;
arch/arm/common/bL_switcher.c:	bL_switch_completion_handler completer;
arch/arm/common/bL_switcher.c: *      with completion notification via a callback
arch/arm/common/bL_switcher.c: * @completer: switch completion callback.  if non-NULL,
arch/arm/common/bL_switcher.c: *	@completer(@completer_cookie) will be called on completion of
arch/arm/common/bL_switcher.c:			 bL_switch_completion_handler completer,
arch/arm/common/bL_switcher.c:		init_completion(&t->started);
arch/arm/common/bL_switcher.c:		init_completion(&t->started);
arch/arm/common/bL_switcher.c:			wait_for_completion(&t->started);
arch/arm/mach-bcm/platsmp-brcmstb.c: * cannot use traditionl completion structures or spinlocks as they rely on
arch/arm/kernel/head.S: *  r13 = *virtual* address to jump to upon completion
arch/arm/kernel/head.S: *  r13 = *virtual* address to jump to upon completion
arch/arm/kernel/head.S: * other registers depend on the function called upon completion
arch/arm/kernel/smp.c:#include <linux/completion.h>
arch/arm/kernel/smp.c:		wait_for_completion_timeout(&cpu_running,
arch/arm/kernel/smp.c:	if (!wait_for_completion_timeout(&cpu_died, msecs_to_jiffies(5000))) {
arch/arm/kernel/smp.c:	 * before the completion to ensure that data is safely written out
arch/arm/kernel/smp.c:	 * Ensure that the cache lines associated with that completion are
arch/arm/kernel/smp.c:	 * powering down, to ensure that the completion is visible to the
arch/arm/kernel/smp.c:	S(IPI_COMPLETION, "completion interrupts"),
arch/arm/kernel/smp.c:static DEFINE_PER_CPU(struct completion *, cpu_completion);
arch/arm/kernel/smp.c:int register_ipi_completion(struct completion *completion, int cpu)
arch/arm/kernel/smp.c:	per_cpu(cpu_completion, cpu) = completion;
arch/arm/kernel/smp.c:	complete(per_cpu(cpu_completion, cpu));
arch/arm/mach-davinci/sleep.S:	/* Check for DDR2 clock disable completion; */
arch/arm/mm/cache-l2x0.c:	 * until completion.
arch/arm/mm/cache-uniphier.c:#define    UNIPHIER_SSCOQM_CE			BIT(15)	/* notify completion */
arch/arm/mm/dma-mapping.c: * before transfers and delay cache invalidation until transfer completion.
arch/arm/mm/cache-feroceon-l2.c: * The cache range operations stall the CPU pipeline until completion.
arch/arm/mm/cache-feroceon-l2.c:	 * until completion.
arch/arm/mm/proc-xsc3.S:	sub	pc, \lr, \rd, LSR #32		@ wait for completion and
arch/arm/mm/proc-xscale.S:	mov	\rd, \rd			@ wait for completion
arch/arm/mm/proc-xscale.S:	sub	pc, \lr, \rd, LSR #32		@ wait for completion and
arch/arm/mach-rpc/ecard.c:#include <linux/completion.h>
arch/arm/mach-rpc/ecard.c:	struct completion *complete;
arch/arm/mach-rpc/ecard.c:	DECLARE_COMPLETION_ONSTACK(completion);
arch/arm/mach-rpc/ecard.c:	req->complete = &completion;
arch/arm/mach-rpc/ecard.c:	wait_for_completion(&completion);
arch/arm/mach-ixp4xx/ixp4xx_npe.c:	/* we need this value later to wait for completion of NPE execution
arch/arm64/kernel/smp.c:#include <linux/completion.h>
arch/arm64/kernel/smp.c:		wait_for_completion_timeout(&cpu_running,
arch/arm64/kvm/hyp/tlb.c:	 * We have to ensure completion of the invalidation at Stage-2,
arch/s390/include/asm/qdio.h: *   (only required for use with completion queues)
arch/s390/include/asm/cpacf.h:		"	brc	1,0b\n"	/* handle partial completion */
arch/s390/include/asm/cpacf.h:		"	brc	1,0b\n" /* handle partial completion */
arch/s390/include/asm/cpacf.h:		"	brc	1,0b\n" /* handle partial completion */
arch/s390/include/asm/cpacf.h:		"	brc	1,0b\n" /* handle partial completion */
arch/s390/include/asm/cpacf.h:		"	brc	1,0b\n" /* handle partial completion */
arch/s390/include/asm/cpacf.h:		"	brc	1,0b\n" /* handle partial completion */
arch/s390/include/asm/cpacf.h:		"	brc	1,0b\n" /* handle partial completion */
arch/s390/include/asm/cpacf.h:		"	brc	1,0b\n"	  /* handle partial completion */
arch/s390/include/asm/cpacf.h:		"	brc	1,0b\n" /* handle partial completion */
arch/s390/include/asm/ccwdev.h:/* Allow for i/o completion notification after primary interrupt status. */
arch/s390/mm/fault.c: * Of course we have a lot of additional fun with the completion interrupt (->
arch/s390/mm/fault.c:	 * Get the external interruption subcode & pfault initial/completion
arch/s390/mm/fault.c:			/* Initial interrupt was faster than the completion
arch/s390/mm/fault.c:			 * If the task is not running, ignore the completion
arch/s390/mm/fault.c:			 * completion interrupts. */
arch/s390/mm/fault.c:			/* Initial interrupt arrived before completion
arch/s390/kvm/kvm-s390.c:	kvm_clear_async_pf_completion_queue(vcpu);
arch/s390/kvm/kvm-s390.c:	kvm_clear_async_pf_completion_queue(vcpu);
arch/s390/kvm/kvm-s390.c:	kvm_clear_async_pf_completion_queue(vcpu);
arch/s390/kvm/kvm-s390.c:			kvm_clear_async_pf_completion_queue(vcpu);
arch/s390/kvm/kvm-s390.c:	 * but we still want check_async_completion to cleanup
arch/s390/kvm/kvm-s390.c:	kvm_check_async_pf_completion(vcpu);
arch/s390/kvm/kvm-s390.c:			kvm_clear_async_pf_completion_queue(vcpu);
arch/s390/kvm/interrupt.c:			kvm_clear_async_pf_completion_queue(vcpu);
arch/s390/kvm/sigp.c:			kvm_clear_async_pf_completion_queue(v);
arch/c6x/platforms/dscr.c: * change completion when enabling/disabling a device. Status is
arch/c6x/platforms/cache.c:	/* Wait for completion */
arch/c6x/platforms/cache.c:			/* Wait for previous operation completion */
arch/c6x/platforms/cache.c:		/* Wait for completion */
arch/c6x/platforms/cache.c:		/* Don't wait for completion on last cache operation */
arch/mips/pci/ops-tx4927.c:	/* wait write cycle completion before checking error status */
arch/mips/pci/pcie-octeon.c:	 * Load completion relaxed ordering (NPEI_CTL_PORTn[WAITL_COM]).
arch/mips/pci/pcie-octeon.c:	 * Load completion relaxed ordering (NPEI_CTL_PORTn[WAITL_COM])
arch/mips/include/uapi/asm/siginfo.h:#define SI_ASYNCIO	-2	/* sent by AIO completion */
arch/mips/include/asm/kvm_host.h:	/* Resume PC after MMIO completion */
arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h:	u32	dscr_stat;		/* completion status */
arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h: * meaningful name.  The 'callback' is called during DMA completion
arch/mips/include/asm/barrier.h: * As compared to the completion barrier, the ordering barrier is a
arch/mips/include/asm/barrier.h: *   stype zero always does a completion barrier that affects both loads and
arch/mips/include/asm/barrier.h: *   act the same as stype zero completion barrier. This allows software written
arch/mips/include/asm/barrier.h: *   implementation which only implements the stype zero completion barrier.
arch/mips/include/asm/barrier.h: * - A completion barrier is required, potentially in conjunction with SSNOP (in
arch/mips/include/asm/barrier.h: *   mode changes. For example, a completion barrier is required on some
arch/mips/include/asm/barrier.h: * stype 0 - A completion barrier that affects preceding loads and stores and
arch/mips/include/asm/octeon/cvmx-pow.h: * Waits for a tag switch to complete by polling the completion bit.
arch/mips/include/asm/octeon/cvmx-pow.h: * so completion should not be waited for.
arch/mips/include/asm/octeon/cvmx-pow.h: * so completion should not be waited for.
arch/mips/include/asm/octeon/cvmx-pow.h: * immediately, so completion must not be waited for.  This function does NOT
arch/mips/include/asm/octeon/cvmx-pow.h: * immediately, so completion must not be waited for.  This function does NOT
arch/mips/kernel/smp-cps.c:	if (!wait_for_completion_timeout(&cpu_death_chosen,
arch/mips/kernel/process.c:#include <linux/completion.h>
arch/mips/mm/page.c:	 * reliable way to delay completion detection.
arch/mips/mm/page.c:	 * reliable way to delay completion detection.
arch/sh/include/asm/dma.h:	 * wait_queue used in dma_wait_for_completion.
arch/sh/include/asm/dma.h:extern void dma_wait_for_completion(unsigned int chan);
arch/sh/kernel/hw_breakpoint.c:		 * Reset the condition match flag to denote completion of
arch/sh/kernel/cpu/sh4/sq.c:	/* Wait for completion */
arch/sh/drivers/pci/pcie-sh7786.c:	/* Set the completion timer timeout to the maximum 32ms. */
arch/sh/drivers/dma/dma-api.c:void dma_wait_for_completion(unsigned int chan)
arch/sh/drivers/dma/dma-api.c:EXPORT_SYMBOL(dma_wait_for_completion);
arch/sh/drivers/dma/dma-g2.c:	 * bit 1 - if set, generate a hardware event on transfer completion
arch/sh/drivers/dma/dma-pvr2.c:		dma_wait_for_completion(PVR2_CASCADE_CHAN);
arch/frv/kernel/dma.c:	int			irq;		/* completion IRQ */
arch/frv/kernel/entry.S:	# set CCCR.CC3 to Undefined to abort atomic-modify completion inside the kernel
arch/frv/kernel/entry.S:	# set CCCR.CC3 to Undefined to abort atomic-modify completion inside the kernel
arch/metag/include/asm/metag_mem.h:#define     SYSC_MCMGCTRL_TR31_BIT  0x80000000 /* Trigger 31 on completion */
arch/metag/include/asm/l2cache.h: * Start an initialisation of the L2 cachelines and wait for completion.
arch/metag/include/asm/l2cache.h: * Start a writeback of dirty L2 cachelines and wait for completion.
arch/metag/include/asm/l2cache.h:	 * detect completion, so keep this operation atomic with other threads.
arch/metag/kernel/smp.c:#include <linux/completion.h>
arch/metag/kernel/smp.c:		wait_for_completion_timeout(&cpu_running,
arch/xtensa/kernel/smp.c:		wait_for_completion_timeout(&cpu_running,
arch/m68k/include/asm/dma.h:    MCFDMA_DCR_INT |         /* Enable completion irq */
arch/m68k/include/asm/dma.h:  dmawp[MCFDMA_DIR] |= MCFDMA_DIR_ASCEN;   /* Enable completion interrupts */
arch/m68k/include/asm/mcfdma.h:#define	MCFDMA_DCR_INT	        0x8000		/* Enable completion irq */
arch/m68k/kernel/entry.S: *  6/05/00 RZ:	 addedd writeback completion after return from sighandler
arch/m68k/fpsp040/bugfix.S:| This code is entered only on completion of the handling of an
arch/m68k/fpsp040/bugfix.S:| the code sequence to allow completion.  We will jump to
arch/m68k/fpsp040/bugfix.S:| the code sequence to allow completion.  fpsp_fmt_error causes
arch/m68k/fpsp040/bindec.S:	frestore (%a7)+		|restore frame to fpu for completion
arch/um/drivers/port_kern.c:#include <linux/completion.h>
arch/um/drivers/port_kern.c:	struct completion done;
arch/um/drivers/port_kern.c:	init_completion(&port->done);
arch/um/drivers/port_kern.c:		if (wait_for_completion_interruptible(&port->done))
arch/um/drivers/xterm_kern.c:#include <linux/completion.h>
arch/um/drivers/xterm_kern.c:	struct completion ready;
arch/um/drivers/xterm_kern.c:	init_completion(&data->ready);
arch/um/drivers/xterm_kern.c:	wait_for_completion(&data->ready);
arch/x86/platform/uv/tlb_uv.c: * Wait for completion of a broadcast software ack message
arch/x86/platform/uv/tlb_uv.c:static int uv1_wait_completion(struct bau_desc *bau_desc,
arch/x86/platform/uv/tlb_uv.c:static int uv2_3_wait_completion(struct bau_desc *bau_desc,
arch/x86/platform/uv/tlb_uv.c:static int wait_completion(struct bau_desc *bau_desc, struct bau_control *bcp, long try)
arch/x86/platform/uv/tlb_uv.c:		return uv1_wait_completion(bau_desc, mmr_offset, right_shift, bcp, try);
arch/x86/platform/uv/tlb_uv.c:		return uv2_3_wait_completion(bau_desc, mmr_offset, right_shift, bcp, try);
arch/x86/platform/uv/tlb_uv.c:		int completion_status, int try)
arch/x86/platform/uv/tlb_uv.c:		if ((completion_status == FLUSH_COMPLETE) && (try == 1)) {
arch/x86/platform/uv/tlb_uv.c:	if (completion_status == FLUSH_COMPLETE && try > 1)
arch/x86/platform/uv/tlb_uv.c:	else if (completion_status == FLUSH_GIVEUP) {
arch/x86/platform/uv/tlb_uv.c: * Handle the completion status of a message send.
arch/x86/platform/uv/tlb_uv.c:static void handle_cmplt(int completion_status, struct bau_desc *bau_desc,
arch/x86/platform/uv/tlb_uv.c:	if (completion_status == FLUSH_RETRY_PLUGGED)
arch/x86/platform/uv/tlb_uv.c:	else if (completion_status == FLUSH_RETRY_TIMEOUT)
arch/x86/platform/uv/tlb_uv.c:	int completion_stat = 0;
arch/x86/platform/uv/tlb_uv.c:		completion_stat = wait_completion(bau_desc, bcp, try);
arch/x86/platform/uv/tlb_uv.c:		handle_cmplt(completion_stat, bau_desc, bcp, hmaster, stat);
arch/x86/platform/uv/tlb_uv.c:			completion_stat = FLUSH_GIVEUP;
arch/x86/platform/uv/tlb_uv.c:	} while ((completion_stat == FLUSH_RETRY_PLUGGED) ||
arch/x86/platform/uv/tlb_uv.c:		 (completion_stat == FLUSH_RETRY_TIMEOUT));
arch/x86/platform/uv/tlb_uv.c:	count_max_concurr(completion_stat, bcp, hmaster);
arch/x86/platform/uv/tlb_uv.c:	record_send_stats(time1, time2, bcp, stat, completion_stat, try);
arch/x86/platform/uv/tlb_uv.c:	if (completion_stat == FLUSH_GIVEUP)
arch/x86/math-emu/README:emulate each FPU instruction to completion without interruption.
arch/x86/include/asm/uv/uv_bau.h: * completion statuses for sending a TLB flush message
arch/x86/kernel/kgdb.c:	 * denote completion of processing
arch/x86/kernel/hw_breakpoint.c:		 * Reset the 'i'th TRAP bit in dr6 to denote completion of
arch/x86/kernel/pci-calgary_64.c:static void __init calgary_set_split_completion_timeout(void __iomem *bbar,
arch/x86/kernel/pci-calgary_64.c:	 * Give split completion a longer timeout on bus 1 for aic94xx
arch/x86/kernel/pci-calgary_64.c:		calgary_set_split_completion_timeout(tbl->bbar, busnum,
arch/x86/kernel/hpet.c:	struct completion complete;
arch/x86/kernel/hpet.c:	init_completion(&work.complete);
arch/x86/kernel/hpet.c:	wait_for_completion(&work.complete);
arch/x86/mm/kmmio.c:			 * denote completion of processing
arch/x86/kvm/x86.c:		kvm_clear_async_pf_completion_queue(vcpu);
arch/x86/kvm/x86.c:		kvm_clear_async_pf_completion_queue(vcpu);
arch/x86/kvm/x86.c:		kvm_check_async_pf_completion(vcpu);
arch/x86/kvm/x86.c:	kvm_clear_async_pf_completion_queue(vcpu);
arch/x86/kvm/x86.c:		kvm_clear_async_pf_completion_queue(vcpu);
arch/mn10300/kernel/mn10300-serial.c:	 * run to completion if it was already in progress. If the VDMA IRQ
arch/mn10300/kernel/smp.c: * wait for completion of that function on all CPUs.
arch/cris/arch-v32/drivers/cryptocop.c:				pj->oper->operation_status = -EINTR; /* Job is terminated without completion. */
arch/cris/arch-v32/drivers/cryptocop.c:		pj->oper->operation_status = -EINTR; /* Job is terminated without completion. */
arch/cris/arch-v32/drivers/cryptocop.c:		pj->oper->operation_status = -EINTR; /* Job is terminated without completion. */
arch/cris/arch-v32/drivers/cryptocop.c:		printk(KERN_WARNING "cryptocop_ioctl_process: job not processed at completion\n");
arch/ia64/sn/kernel/sn2/ptc_deadlock.S:	st8.rel [ptc0]=data0		// Write PTC0 & wait for completion.
arch/ia64/include/asm/ptrace.h:   * System call handlers that, upon successful completion, need to return a negative value
arch/ia64/kernel/perfmon.c:#include <linux/completion.h>
arch/ia64/kernel/perfmon.c:	struct completion	ctx_restart_done;  	/* use for blocking notification mode */
arch/ia64/kernel/perfmon.c:		init_completion(&ctx->ctx_restart_done);
arch/ia64/kernel/perfmon.c:		 * task to report completion
arch/ia64/kernel/perfmon.c:		 * is no risk of being notified of completion before
arch/ia64/kernel/perfmon.c:	ret = wait_for_completion_interruptible(&ctx->ctx_restart_done);
arch/ia64/kernel/palinfo.c:	/* will send IPI to other CPU and wait for completion of remote call */
block/cfq-iosched.c:static inline void cfqg_stats_update_completion(struct cfq_group *cfqg,
block/cfq-iosched.c:static inline void cfqg_stats_update_completion(struct cfq_group *cfqg,
block/cfq-iosched.c:	 * got expired immediately after first request completion.
block/cfq-iosched.c:		 * If slice had not expired at the completion of last request
block/cfq-iosched.c:	cfqg_stats_update_completion(cfqq->cfqg, rq_start_time_ns(rq),
block/blk-map.c: *    the I/O completion may have changed rq->bio.
block/blk-softirq.c: * Functions related to softirq rq completions
block/blk-softirq.c:	 * Select completion CPU
block/blk-softirq.c: *     Ends all I/O on a request. It does not handle partial completions,
block/blk-softirq.c: *     unless the driver actually implements this in its completion callback
block/blk-softirq.c: *     through requeueing. The actual completion happens out-of-order,
block/blk-softirq.c: *     through a softirq handler. The user must have registered a completion
block/scsi_ioctl.c:#include <linux/completion.h>
block/bio-integrity.c:	/* Install custom I/O completion handler if read verify is enabled */
block/bio-integrity.c: * bio_integrity_verify_fn - Integrity I/O completion worker
block/bio-integrity.c:	/* Restore original bio completion handler */
block/bio-integrity.c: * bio_integrity_endio - Integrity I/O completion function
block/bio-integrity.c: * Normally I/O completion is done in interrupt context.  However,
block/bio-integrity.c: * in process context.	This function postpones completion
block/blk.h:void blk_account_io_completion(struct request *req, unsigned int bytes);
block/blk.h: * EH timer and IO completion will both attempt to 'grab' the request, make
block/bsg-lib.c: * bsg_job_done - completion routine for bsg requests
block/blk-mq-tag.c:		 * as running the queue may also have found completions.
block/blk-mq.c: *	Ends all I/O on a request. It does not handle partial completions.
block/blk-mq.c: *	The actual completion happens out-of-order, through a IPI handler.
block/blk-mq.c:	 * the request, otherwise we'll ignore the completion event.
block/blk-mq.c:	 * the request is active. But if we race with completion, then
block/blk-mq.c:	 * completion, since the timeout code would not be able to
block/blk-mq.c:	 * one swoop and then wait for the completions so that freezing can
block/bsg.c: * async completion call-back from the block layer, when scsi/ide/whatever
block/blk-flush.c: * completion.
block/blk-flush.c: * complete.  The first completion updates the contained bio but doesn't
block/blk-flush.c:	 * After flush data completion, @rq->bio is %NULL but we need to
block/blk-flush.c: * completion and trigger the next step.
block/blk-flush.c:		 * flush data request completion path.  Restore @rq for
block/blk-flush.c:		 * normal completion and end it.
block/blk-flush.c:	/* account completion of the flush request */
block/blk-flush.c:	 * This function is called from request completion path and calling
block/blk-core.c:#include <linux/completion.h>
block/blk-core.c: * Normally, that accounting is done on IO completion, but that can result
block/blk-core.c: * completion, is delivered asynchronously through the bio->bi_end_io
block/blk-core.c: * completion notification should be signaled.
block/blk-core.c:void blk_account_io_completion(struct request *req, unsigned int bytes)
block/blk-core.c:	 * Account IO completion.  flush_rq isn't accounted as a
block/blk-core.c:	 * normal IO on queueing nor completion.  Accounting the
block/blk-core.c: *     (e.g. request-based dm) so that they can handle partial completion.
block/blk-core.c:	 * and each partial completion should be handled separately.
block/blk-core.c:	 * Reset per-request error on each partial completion.
block/blk-core.c:	blk_account_io_completion(req, nr_bytes);
block/blk-core.c: * completion).  It happens only after all error handling is complete,
block/blk-core.c:		laptop_io_completion(&req->q->backing_dev_info);
block/bio.c: * bio_chain - chain bio completions
block/bio.c:	struct completion event;
block/bio.c:	init_completion(&ret.event);
block/bio.c:	wait_for_completion_io(&ret.event);
block/bio.c: *	call bio_uncopy_user() on io completion.
block/blk-mq.h:	/* incremented at completion time */
block/blk-exec.c: * blk_end_sync_rq - executes a completion event on a request
block/blk-exec.c:	struct completion *waiting = rq->end_io_data;
block/blk-exec.c: * @done:	I/O completion handler
block/blk-exec.c: *    for execution.  Don't wait for completion.
block/blk-exec.c: *    for execution and wait for completion.
block/blk-exec.c:		while (!wait_for_completion_io_timeout(&wait, hang_check * (HZ/2)));
block/blk-exec.c:		wait_for_completion_io(&wait);
block/blk-timeout.c:		 * Check if we raced with end io completion
crypto/algif_hash.c:	struct af_alg_completion completion;
crypto/algif_hash.c:		err = af_alg_wait_for_completion(crypto_ahash_init(&ctx->req),
crypto/algif_hash.c:						&ctx->completion);
crypto/algif_hash.c:		err = af_alg_wait_for_completion(crypto_ahash_update(&ctx->req),
crypto/algif_hash.c:						 &ctx->completion);
crypto/algif_hash.c:		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
crypto/algif_hash.c:						 &ctx->completion);
crypto/algif_hash.c:			err = af_alg_wait_for_completion(err, &ctx->completion);
crypto/algif_hash.c:	err = af_alg_wait_for_completion(err, &ctx->completion);
crypto/algif_hash.c:		err = af_alg_wait_for_completion(
crypto/algif_hash.c:				&ctx->completion);
crypto/algif_hash.c:		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
crypto/algif_hash.c:						 &ctx->completion);
crypto/algif_hash.c:	af_alg_init_completion(&ctx->completion);
crypto/algif_hash.c:				   af_alg_complete, &ctx->completion);
crypto/af_alg.c:int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
crypto/af_alg.c:		wait_for_completion(&completion->completion);
crypto/af_alg.c:		reinit_completion(&completion->completion);
crypto/af_alg.c:		err = completion->err;
crypto/af_alg.c:EXPORT_SYMBOL_GPL(af_alg_wait_for_completion);
crypto/af_alg.c:	struct af_alg_completion *completion = req->data;
crypto/af_alg.c:	completion->err = err;
crypto/af_alg.c:	complete(&completion->completion);
crypto/asymmetric_keys/public_key.c:struct public_key_completion {
crypto/asymmetric_keys/public_key.c:	struct completion completion;
crypto/asymmetric_keys/public_key.c:	struct public_key_completion *compl = req->data;
crypto/asymmetric_keys/public_key.c:	complete(&compl->completion);
crypto/asymmetric_keys/public_key.c:	struct public_key_completion compl;
crypto/asymmetric_keys/public_key.c:	init_completion(&compl.completion);
crypto/asymmetric_keys/public_key.c:		wait_for_completion(&compl.completion);
crypto/api.c:	init_completion(&larval->completion);
crypto/api.c:	complete_all(&larval->completion);
crypto/api.c:	timeout = wait_for_completion_killable_timeout(
crypto/api.c:		&larval->completion, 60 * HZ);
crypto/algapi.c:	complete_all(&test->completion);
crypto/algapi.c:	err = wait_for_completion_killable(&larval->completion);
crypto/mcryptd.c:				crypto_completion_t complete)
crypto/algif_skcipher.c:	struct af_alg_completion completion;
crypto/algif_skcipher.c:		err = af_alg_wait_for_completion(
crypto/algif_skcipher.c:				&ctx->completion);
crypto/algif_skcipher.c:	af_alg_init_completion(&ctx->completion);
crypto/algif_skcipher.c:				      af_alg_complete, &ctx->completion);
crypto/echainiv.c:	crypto_completion_t compl;
crypto/ablkcipher.c: * This is the asynchronous version of blkcipher.c indicating completion
crypto/algif_aead.c:	struct af_alg_completion completion;
crypto/algif_aead.c:	err = af_alg_wait_for_completion(ctx->enc ?
crypto/algif_aead.c:					 &ctx->completion);
crypto/algif_aead.c:	af_alg_init_completion(&ctx->completion);
crypto/algif_aead.c:				  af_alg_complete, &ctx->completion);
crypto/seqiv.c:	crypto_completion_t compl;
crypto/seqiv.c:	crypto_completion_t compl;
crypto/drbg.c:	complete(&drbg->ctr_completion);
crypto/drbg.c:			ret = wait_for_completion_interruptible(
crypto/drbg.c:				&drbg->ctr_completion);
crypto/drbg.c:				reinit_completion(&drbg->ctr_completion);
crypto/drbg.c:		init_completion(&drbg->ctr_completion);
crypto/gcm.c:#include <linux/completion.h>
crypto/gcm.c:	struct completion completion;
crypto/gcm.c:	complete(&result->completion);
crypto/gcm.c:	init_completion(&data->result.completion);
crypto/gcm.c:		err = wait_for_completion_interruptible(
crypto/gcm.c:			&data->result.completion);
crypto/gcm.c:			   crypto_completion_t compl,
crypto/gcm.c:			   crypto_completion_t compl, u32 flags)
crypto/ahash.c: * completion via a callback.
crypto/ahash.c:	crypto_completion_t complete;
crypto/ahash.c:static int ahash_save_req(struct ahash_request *req, crypto_completion_t cplt)
crypto/ahash.c:	 *   .base.complete = ADJUSTED[pointer to completion function]
crypto/async_tx/async_pq.c: * @submit: submission/completion modifiers
crypto/async_tx/async_pq.c: * @submit: submission / completion modifiers
crypto/async_tx/async_raid6_recov.c: * @submit: submission/completion modifiers
crypto/async_tx/async_raid6_recov.c: * @submit: submission/completion modifiers
crypto/async_tx/async_memcpy.c: * @submit: submission / completion modifiers
crypto/async_tx/raid6test.c:	struct completion *cmp = param;
crypto/async_tx/raid6test.c:	struct completion cmp;
crypto/async_tx/raid6test.c:	init_completion(&cmp);
crypto/async_tx/raid6test.c:	if (wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000)) == 0)
crypto/async_tx/raid6test.c:	struct completion cmp;
crypto/async_tx/raid6test.c:	init_completion(&cmp);
crypto/async_tx/raid6test.c:	if (wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000)) == 0) {
crypto/async_tx/async_tx.c:	 * otherwise poll for completion
crypto/async_tx/async_tx.c: * @submit: submission and completion parameters
crypto/async_tx/async_tx.c:		 * otherwise poll for completion
crypto/async_tx/async_xor.c: * @submit: submission / completion modifiers
crypto/async_tx/async_xor.c: * @submit: submission / completion modifiers
crypto/cryptd.c:	crypto_completion_t complete;
crypto/cryptd.c:	crypto_completion_t complete;
crypto/cryptd.c:	crypto_completion_t complete;
crypto/cryptd.c:				    crypto_completion_t compl)
crypto/cryptd.c:				crypto_completion_t compl)
crypto/cryptd.c:	crypto_completion_t compl;
crypto/cryptd.c:				    crypto_completion_t compl)
crypto/internal.h:#include <linux/completion.h>
crypto/internal.h:	struct completion completion;
crypto/tcrypt.c:	struct completion completion;
crypto/tcrypt.c:	complete(&res->completion);
crypto/tcrypt.c:		ret = wait_for_completion_interruptible(&tr->completion);
crypto/tcrypt.c:		reinit_completion(&tr->completion);
crypto/tcrypt.c:	init_completion(&result.completion);
crypto/tcrypt.c:		wait_for_completion(&tr->completion);
crypto/tcrypt.c:		reinit_completion(&tr->completion);
crypto/tcrypt.c:		init_completion(&data[i].tresult.completion);
crypto/tcrypt.c:			complete(&data[k].tresult.completion);
crypto/tcrypt.c:			wait_for_completion(&tr->completion);
crypto/tcrypt.c:	init_completion(&tresult.completion);
crypto/tcrypt.c:		wait_for_completion(&tr->completion);
crypto/tcrypt.c:		reinit_completion(&tr->completion);
crypto/tcrypt.c:	init_completion(&tresult.completion);
crypto/algboss.c:#include <linux/completion.h>
crypto/algboss.c:	complete_all(&param->larval->completion);
crypto/algboss.c:	wait_for_completion_interruptible(&larval->completion);
crypto/testmgr.c:	struct completion completion;
crypto/testmgr.c:	complete(&res->completion);
crypto/testmgr.c:		wait_for_completion(&tr->completion);
crypto/testmgr.c:		reinit_completion(&tr->completion);
crypto/testmgr.c:	init_completion(&tresult.completion);
crypto/testmgr.c:			wait_for_completion(&tresult.completion);
crypto/testmgr.c:			reinit_completion(&tresult.completion);
crypto/testmgr.c:	init_completion(&result.completion);
crypto/testmgr.c:			wait_for_completion(&result.completion);
crypto/testmgr.c:			reinit_completion(&result.completion);
crypto/testmgr.c:			wait_for_completion(&result.completion);
crypto/testmgr.c:			reinit_completion(&result.completion);
crypto/testmgr.c:	init_completion(&result.completion);
crypto/testmgr.c:			wait_for_completion(&result.completion);
crypto/testmgr.c:			reinit_completion(&result.completion);
crypto/testmgr.c:			wait_for_completion(&result.completion);
crypto/testmgr.c:			reinit_completion(&result.completion);
crypto/testmgr.c:	init_completion(&result.completion);
crypto/testmgr.c:	init_completion(&result.completion);
crypto/testmgr.c:	init_completion(&result.completion);
Documentation/blockdev/cciss.txt:with simple mode, each command completion requires an interrupt, while with
Documentation/blockdev/cciss.txt:possible to have multiple command completions indicated by a single
Documentation/blockdev/README.DAC960:logical and physical drives and the rebuild completion:
Documentation/blockdev/README.DAC960:logical and physical drives and the rebuild completion:
Documentation/blockdev/drbd/disk-states-8.dot:	Consistent -> Failed           [ label = "io completion error" ]
Documentation/blockdev/drbd/disk-states-8.dot:	Outdated   -> Failed           [ label = "io completion error" ]
Documentation/blockdev/drbd/disk-states-8.dot:	UpToDate   -> Failed           [ label = "io completion error" ]
Documentation/blockdev/drbd/disk-states-8.dot:	Inconsistent -> Failed         [ label = "io completion error" ]
Documentation/mmc/mmc-async-req.txt:for completion of that request and starts the new one and returns. It
Documentation/dmaengine/dmatest.txt:To wait for test completion userpace can poll 'run' until it is false, or use
Documentation/dmaengine/dmatest.txt:or status.  A test thread also emits a summary line at completion listing the
Documentation/dmaengine/client.txt:	Although the async_tx API specifies that completion callback
Documentation/dmaengine/client.txt:   On completion of each DMA operation, the next in queue is started and
Documentation/dmaengine/client.txt:   completion callback routine for notification, if set.
Documentation/dmaengine/client.txt:   completion of a specific DMA transaction.
Documentation/dmaengine/pxa_dma.txt:  d) Transfers completion updater
Documentation/dmaengine/pxa_dma.txt:     transfer being completed into the physical channel's completion mark.
Documentation/dmaengine/pxa_dma.txt:  e) Transfers completion, irq and tasklet
Documentation/dmaengine/provider.txt:      it can resubmit the transfer right after its completion.
Documentation/accounting/delay-accounting.txt:b) completion of synchronous block I/O initiated by the task
Documentation/DocBook/libata.tmpl:	completion.  One is via qc->complete_fn() callback and the
Documentation/DocBook/libata.tmpl:	other is completion qc->waiting.  qc->complete_fn() callback
Documentation/DocBook/libata.tmpl:	midlayer's completion notification function pointer is stored
Documentation/DocBook/libata.tmpl:	qc->complete_fn() callback is used for completion
Documentation/DocBook/libata.tmpl:	   completion.
Documentation/DocBook/libata.tmpl:	cases - timeout and ATAPI error completion.  This function
Documentation/DocBook/libata.tmpl:	half-completion is to use the qc as place holder to make EH
Documentation/DocBook/libata.tmpl:	DRQ on command completion.
Documentation/DocBook/libata.tmpl:	&amp;&amp; ERR during command execution and on completion.
Documentation/DocBook/libata.tmpl:	   <term>ABRT error during data transfer or on completion</term>
Documentation/DocBook/libata.tmpl:	   amount of transferred data on error completion is
Documentation/DocBook/libata.tmpl:	Controller-specific error completion with error information
Documentation/DocBook/libata.tmpl:        <title>Late completion</title>
Documentation/DocBook/writing_usb_driver.tmpl:     usb_fill_bulk_urb function, we point the urb's completion callback to call our
Documentation/DocBook/writing_usb_driver.tmpl:     urb completion callback functions. We call the usb_bulk_msg function,
Documentation/DocBook/usb.tmpl:    in the form of an URB, and the URB's completion callback
Documentation/DocBook/deviceiobook.tmpl:	only a few will indicate or depend on DMA completion.
Documentation/DocBook/crypto-API.tmpl:     cipher operation but it does not signal its completion. Before
Documentation/DocBook/crypto-API.tmpl:     completion of the cipher operation. Furthermore, the caller
Documentation/DocBook/crypto-API.tmpl:	struct completion completion;
Documentation/DocBook/crypto-API.tmpl:	complete(&amp;result-&gt;completion);
Documentation/DocBook/crypto-API.tmpl:		rc = wait_for_completion_interruptible(
Documentation/DocBook/crypto-API.tmpl:			&amp;sk-&gt;result.completion);
Documentation/DocBook/crypto-API.tmpl:			reinit_completion(&amp;sk-&gt;result.completion);
Documentation/DocBook/crypto-API.tmpl:	init_completion(&amp;sk-&gt;result.completion);
Documentation/DocBook/crypto-API.tmpl:	init_completion(&amp;sk.result.completion);
Documentation/IPMI.txt:here) or the response.  Note that the completion code of a response is
Documentation/driver-model/binding.txt:Upon the successful completion of probe, the device is registered with
Documentation/powerpc/eeh-pci-error-recovery.txt:connectivity due to a poorly seated card), and PCI-X split-completion
Documentation/powerpc/cxlflash.txt:    completion events. This file descriptor is intentionally installed by
Documentation/networking/ena.txt:- Create I/O completion queue
Documentation/networking/ena.txt:- Destroy I/O completion queue
Documentation/networking/ena.txt:SQ correspondingly). Each SQ has a completion queue (CQ) associated
Documentation/networking/ena.txt:- Cache miss rate on completion is reduced, particularly for data
Documentation/networking/ena.txt:  out-of-order TX completions.
Documentation/networking/ena.txt:- When the ENA device finishes sending the packet, a completion
Documentation/networking/ena.txt:  completion descriptors generated by the ENA, with a single
Documentation/networking/ena.txt:  completion descriptor per completed packet.
Documentation/networking/ena.txt:  * req_id is retrieved from the completion descriptor. The tx_info of
Documentation/networking/ena.txt:  * The function stops when the completion descriptors are completed or
Documentation/networking/filter.txt:Interaction in bpf_dbg happens through a shell that also has auto-completion
Documentation/networking/scaling.txt:exclusively to a subset of CPUs, where the transmit completions for
Documentation/networking/scaling.txt:transmit queue). Secondly, cache miss rate on transmit completion is
Documentation/networking/scaling.txt:with the CPU that processes transmit completions for that queue
Documentation/networking/driver.txt:   be aborted. If necessary, poll or wait for completion of 
Documentation/networking/cxgb.txt:      can provide stale data via split completion cycles to a PCI-X card that
Documentation/networking/rxrpc.txt: (*) An call may be aborted by either end at any time up to its completion.
Documentation/networking/rds.txt:    looks at write completions
Documentation/networking/rds.txt:  prior to outgoing hash completion in rds_sendmsg() when the transport
Documentation/networking/altera_tse.txt:completion in the context of the interrupt handling chain by recycling
Documentation/networking/altera_tse.txt:completions until no more receive completions are available.
Documentation/PCI/pci.txt:call this "Write Posting" because the write completion is "posted" to
Documentation/PCI/pci-error-recovery.txt:will be platform-dependent. Upon completion of slot reset, the
Documentation/hid/intel-ish-hid.txt:Optionally the caller can register handler to get notification of completion.
Documentation/ide/ide-tape.txt:to the request-list of the block device, and waits for their completion.
Documentation/driver-api/basics.rst:.. kernel-doc:: include/linux/completion.h
Documentation/s390/cds.txt:they are presenting I/O completion a unified way : I/O interruptions. Every
Documentation/s390/cds.txt:      0 - successful completion or request successfully initiated
Documentation/s390/cds.txt:interrupt will be presented to indicate I/O completion as the I/O request was
Documentation/s390/cds.txt:never started, even though ccw_device_start() returned with successful completion.
Documentation/s390/cds.txt:successful completion for all overlapping ccw_device_start() requests that have
Documentation/s390/cds.txt:-ENOTCONN  - there is no I/O request pending for completion 
Documentation/s390/Debugging390.txt:1) command completion works just like bash 
Documentation/mailbox.txt:	struct completion c;
Documentation/mailbox.txt:	init_completion(&dc_async->c);
Documentation/mailbox.txt:	wait_for_completion(&dc_async->c);
Documentation/devicetree/bindings/memory-controllers/mvebu-devbus.txt:                        drive the AD bus after the completion of a device read.
Documentation/devicetree/bindings/cpufreq/cpufreq-exynos5440.txt:- interrupts: Interrupt to know the completion of cpu frequency change.
Documentation/devicetree/bindings/arm/idle-states.txt:	to completion up to IDLE before anything else can happen.
Documentation/devicetree/bindings/net/keystone-netcp.txt:- tx-completion-queue:	the navigator queue number where the descriptors are
Documentation/devicetree/bindings/net/keystone-netcp.txt:			recycled after Tx DMA completion.
Documentation/devicetree/bindings/net/keystone-netcp.txt:			tx-completion-queue = <8706>;
Documentation/devicetree/bindings/net/keystone-netcp.txt:			tx-completion-queue = <8707>;
Documentation/devicetree/bindings/net/apm-xgene-enet.txt:  - Second is the Tx completion interrupt.
Documentation/devicetree/bindings/scsi/hisilicon-sas.txt:  - queue-count : number of delivery and completion queues in the controller
Documentation/devicetree/bindings/scsi/hisilicon-sas.txt:  - interrupts : For v1 hw: Interrupts for phys, completion queues, and fatal
Documentation/devicetree/bindings/scsi/hisilicon-sas.txt:		Completion queue interrupts : each completion queue has 1
Documentation/devicetree/bindings/scsi/hisilicon-sas.txt:		For v2 hw: Interrupts for phys, Sata, and completion queues;
Documentation/devicetree/bindings/scsi/hisilicon-sas.txt:		Completion queue interrupts : each completion queue has 1
Documentation/devicetree/bindings/infiniband/hisilicon-hns-roce.txt:- interrupts: should contain 32 completion event irq,1 async event irq
Documentation/devicetree/bindings/dma/apm-xgene-dma.txt:  are completion interrupts for each DMA channels.
Documentation/devicetree/bindings/dma/ti-edma.txt:              1. Transfer completion interrupt.
Documentation/devicetree/bindings/spi/spi_pl022.txt:- pl022,autosuspend-delay : delay in ms following transfer completion before
Documentation/devicetree/bindings/mailbox/hisilicon,hi6220-mailbox.txt:			completion.
Documentation/device-mapper/kcopyd.txt:to one or more other block-devices, with an asynchronous completion
Documentation/device-mapper/kcopyd.txt:completion callback routine, and a pointer to some context data for the copy.
Documentation/device-mapper/kcopyd.txt:When the copy completes, kcopyd will call the user's completion routine,
Documentation/device-mapper/dm-io.txt:Callers of the asynchronous I/O services must include the name of a completion
Documentation/device-mapper/log-writes.txt:We log things in order of completion once we are sure the write is no longer in
Documentation/device-mapper/thin-provisioning.txt:completion may have already been acknowledged to upper IO layers
Documentation/cgroup-v1/blkio-controller.txt:	- Total amount of time between request dispatch and request completion
Documentation/scheduler/completion.txt:completions - wait for completion handling
Documentation/scheduler/completion.txt:to have reached a point or a specific state, completions can provide a
Documentation/scheduler/completion.txt:look into using one of the wait_for_completion*() calls instead. The
Documentation/scheduler/completion.txt:advantage of using completions is clear intent of the code, but also more
Documentation/scheduler/completion.txt:struct completion that tells the waiting threads of execution if they
Documentation/scheduler/completion.txt:As completions are scheduling related, the code is found in
Documentation/scheduler/completion.txt:kernel/sched/completion.c - for details on completion design and
Documentation/scheduler/completion.txt:implementation see completions-design.txt
Documentation/scheduler/completion.txt:There are three parts to using completions, the initialization of the
Documentation/scheduler/completion.txt:struct completion, the waiting part through a call to one of the variants of
Documentation/scheduler/completion.txt:wait_for_completion() and the signaling side through a call to complete()
Documentation/scheduler/completion.txt:state of completions.
Documentation/scheduler/completion.txt:To use completions one needs to include <linux/completion.h> and
Documentation/scheduler/completion.txt:create a variable of type struct completion. The structure used for
Documentation/scheduler/completion.txt:handling of completions is:
Documentation/scheduler/completion.txt:	struct completion {
Documentation/scheduler/completion.txt:	wait_for_completion(&early_console_added);
Documentation/scheduler/completion.txt:Initializing completions:
Documentation/scheduler/completion.txt:Initialization of dynamically allocated completions, often embedded in
Documentation/scheduler/completion.txt:	void init_completion(&done);
Documentation/scheduler/completion.txt:The re-initialization function, reinit_completion(), simply resets the
Documentation/scheduler/completion.txt:wait queue. Calling init_completion() twice on the same completion object is
Documentation/scheduler/completion.txt:enqueued tasks could get "lost" - use reinit_completion() in that case.
Documentation/scheduler/completion.txt:happy. Note also that one needs to make *sure* the completion passed to
Documentation/scheduler/completion.txt:Using on-stack completions for code that calls any of the _timeout or
Documentation/scheduler/completion.txt:additional synchronization to prevent the on-stack completion object in
Documentation/scheduler/completion.txt:allocated completions when intending to use the _interruptible/_killable
Documentation/scheduler/completion.txt:or _timeout variants of wait_for_completion().
Documentation/scheduler/completion.txt:Waiting for completions:
Documentation/scheduler/completion.txt:calls wait_for_completion() on the initialized completion structure.
Documentation/scheduler/completion.txt:	struct completion setup_done;
Documentation/scheduler/completion.txt:	init_completion(&setup_done);
Documentation/scheduler/completion.txt:	wait_for_completion(&setup_done);         complete(setup_done)
Documentation/scheduler/completion.txt:This is not implying any temporal order on wait_for_completion() and the
Documentation/scheduler/completion.txt:to wait_for_completion() then the waiting side simply will continue
Documentation/scheduler/completion.txt:completion is signaled by complete().
Documentation/scheduler/completion.txt:Note that wait_for_completion() is calling spin_lock_irq()/spin_unlock_irq(),
Documentation/scheduler/completion.txt:wait_for_completion():
Documentation/scheduler/completion.txt:	void wait_for_completion(struct completion *done):
Documentation/scheduler/completion.txt:uninterruptible. wait_for_completion() and its variants are only safe
Documentation/scheduler/completion.txt:try_wait_for_completion() below for handling completion in atomic/interrupt
Documentation/scheduler/completion.txt:As all variants of wait_for_completion() can (obviously) block for a long
Documentation/scheduler/completion.txt:if (!wait_for_completion_interruptible_timeout(...)) would execute the same
Documentation/scheduler/completion.txt:code path for successful completion and for the interrupted case - which is
Documentation/scheduler/completion.txt:	int wait_for_completion_interruptible(struct completion *done)
Documentation/scheduler/completion.txt:	unsigned long wait_for_completion_timeout(struct completion *done,
Documentation/scheduler/completion.txt:	long wait_for_completion_interruptible_timeout(
Documentation/scheduler/completion.txt:		struct completion *done, unsigned long timeout)
Documentation/scheduler/completion.txt:otherwise it returns 0 if the completion timed out or the remaining time in
Documentation/scheduler/completion.txt:jiffies if completion occurred.
Documentation/scheduler/completion.txt:else 0 if completion was achieved.  There is a _timeout variant as well:
Documentation/scheduler/completion.txt:	long wait_for_completion_killable(struct completion *done)
Documentation/scheduler/completion.txt:	long wait_for_completion_killable_timeout(struct completion *done,
Documentation/scheduler/completion.txt:The _io variants wait_for_completion_io() behave the same as the non-_io
Documentation/scheduler/completion.txt:	void wait_for_completion_io(struct completion *done)
Documentation/scheduler/completion.txt:	unsigned long wait_for_completion_io_timeout(struct completion *done
Documentation/scheduler/completion.txt:Signaling completions:
Documentation/scheduler/completion.txt:	void complete(struct completion *done)
Documentation/scheduler/completion.txt:	void complete_all(struct completion *done)
Documentation/scheduler/completion.txt:The signaling will work as expected even if completions are signaled before
Documentation/scheduler/completion.txt:(decrementing) the done element of struct completion. Waiting threads
Documentation/scheduler/completion.txt:particular struct completion at any time - serialized through the wait
Documentation/scheduler/completion.txt:Signaling completion from hard-irq context is fine as it will appropriately
Documentation/scheduler/completion.txt:try_wait_for_completion()/completion_done():
Documentation/scheduler/completion.txt:The try_wait_for_completion() function will not put the thread on the wait
Documentation/scheduler/completion.txt:else it consumes one posted completion and returns true.
Documentation/scheduler/completion.txt:	bool try_wait_for_completion(struct completion *done)
Documentation/scheduler/completion.txt:Finally, to check the state of a completion without changing it in any way, 
Documentation/scheduler/completion.txt:call completion_done(), which returns false if there are no posted
Documentation/scheduler/completion.txt:completions that were not yet consumed by waiters (implying that there are
Documentation/scheduler/completion.txt:	bool completion_done(struct completion *done)
Documentation/scheduler/completion.txt:Both try_wait_for_completion() and completion_done() are safe to be called in
Documentation/security/keys.txt:    construction.  To wait for construction completion, the following should be
Documentation/memory-hotplug.txt: - Notification completion of remove works by OS to firmware.
Documentation/crypto/async-tx-api.txt:There are two methods for an application to learn about the completion
Documentation/crypto/async-tx-api.txt:   it polls for the completion of the operation.  It handles dependency
Documentation/crypto/async-tx-api.txt:2/ Specify a completion callback.  The callback routine runs in tasklet
Documentation/crypto/async-tx-api.txt:   completion interrupt/callback at the end of the chain.
Documentation/crypto/async-tx-api.txt:	struct completion *cmp = param;
Documentation/crypto/async-tx-api.txt:	struct completion cmp;
Documentation/crypto/async-tx-api.txt:	init_completion(&cmp);
Documentation/crypto/async-tx-api.txt:	wait_for_completion(&cmp);
Documentation/scsi/scsi_mid_low_api.txt:   queuecommand - queue scsi command, invoke 'done' on completion
Documentation/scsi/scsi_mid_low_api.txt: *      queuecommand - queue scsi command, invoke scp->scsi_done on completion
Documentation/scsi/scsi_mid_low_api.txt:with the completion of a SCSI command" when a status of CHECK CONDITION
Documentation/scsi/ncr53c8xx.txt:The profiling information is updated upon completion of SCSI commands.
Documentation/scsi/ncr53c8xx.txt:	(time from SCSI status get to command completion call)
Documentation/scsi/ncr53c8xx.txt:and delay data transfers or status/completions, and (b) may just waste 
Documentation/scsi/hpsa.txt:mode, each command completion requires an interrupt, while with "performant mode"
Documentation/scsi/hpsa.txt:command completions indicated by a single interrupt.
Documentation/scsi/ChangeLog.megaraid:	> sd 0:1:0:0: Notifying upper driver of completion (result 0)
Documentation/scsi/ChangeLog.sym53c8xx:	  handler is called for command completion, then clears INTF, scans 
Documentation/scsi/ChangeLog.lpfc:	  find command in both TX and TX completion queues.  Return ERROR
Documentation/scsi/ChangeLog.lpfc:	  completion path.
Documentation/scsi/ChangeLog.lpfc:	  function into two routines to match the fast and slow completion
Documentation/scsi/ChangeLog.lpfc:	  semantics - ELS completions worked for the wrong reasons.  Also
Documentation/scsi/ChangeLog.lpfc:	* Defined default mailbox completion routine and removed code in
Documentation/scsi/ChangeLog.lpfc:	* Abort handler will try to wait for abort completion before
Documentation/scsi/ChangeLog.lpfc:	  returning.  Fixes some panics in iocb completion code path.
Documentation/scsi/ChangeLog.lpfc:	* Ignore more unexpected completions in lpfc_nportdisc.c.
Documentation/scsi/ChangeLog.lpfc:	  I/O completion path a little more, especially taking care of
Documentation/scsi/ChangeLog.lpfc:	  submission and completion path a little.
Documentation/scsi/ChangeLog.lpfc:	* In some of the els completion routines, after calling
Documentation/scsi/ChangeLog.lpfc:	* Correct Iocbq completion routine for 2.6 kernel case
Documentation/scsi/hptiop.txt:register 0. An outbound message with the same value indicates the completion
Documentation/scsi/hptiop.txt:with the same value indicates the completion of message.
Documentation/scsi/osd.txt:   layer and wait for its completion.  The request can be executed
Documentation/scsi/scsi_eh.txt:discussion.  The latter is used for completion and EH lists and unless
Documentation/scsi/scsi_eh.txt: For all non-EH commands, scsi_done() is the completion callback.  It
Documentation/scsi/scsi_eh.txt:	scsi_io_completion() to finish the I/O.
Documentation/scsi/scsi_eh.txt:	scsi_io_completion() then notifies the block layer on
Documentation/scsi/scsi_eh.txt:	handler raced with normal completion.
Documentation/scsi/scsi_eh.txt: 2. If the host supports asynchronous completion (as indicated by the
Documentation/scsi/scsi_eh.txt:    completions and SCSI_EH_CANCEL_CMD for timeouts.
Documentation/scsi/scsi_eh.txt:active as long as lower layers are concerned and completion could
Documentation/scsi/scsi_eh.txt:occur at any time.  Of course, all such completions are ignored as the
Documentation/scsi/scsi_eh.txt: 1. Error completion / time out
Documentation/scsi/scsi_eh.txt:On completion, the handler should have made lower layers forget about
Documentation/scsi/scsi_eh.txt: - On completion, each failed sdev must have forgotten about all
Documentation/scsi/scsi_eh.txt: - On completion, each failed sdev must be ready for new commands or
Documentation/scsi/ChangeLog.megaraid_sas:    1. Removed un-needed completion_lock spinlock calls.
Documentation/scsi/ChangeLog.megaraid_sas:	(reduced interrupt operation).  In this mode, IO completion
Documentation/scsi/ChangeLog.megaraid_sas:	driver schedules for cmd completion if there are pending cmds
Documentation/scsi/ChangeLog.megaraid_sas:	to prevent IO completion processing from being delayed
Documentation/scsi/ChangeLog.megaraid_sas:routine for max 3 minutes for all pending command completion. Now driver will
Documentation/scsi/ChangeLog.megaraid_sas:call completion routine every 5 seconds from the reset routine instead of
Documentation/scsi/ChangeLog.megaraid_sas:waiting for depending on cmd completion from isr path.
Documentation/scsi/ChangeLog.megaraid_sas:iv.	Tasklet added for cmd completion
Documentation/trace/ftrace.txt:  8)     1824      16   wait_for_completion+0x1d/0x1f
Documentation/w1/w1.netlink:If command requires reply (like read command) it is sent on command completion.
Documentation/w1/masters/ds2490:  show a successful completion, but the ds2490 status register would
Documentation/infiniband/core_locking.txt:  simultaneously.  However, the ordering of the work completion
Documentation/infiniband/core_locking.txt:  allowed for a low-level driver to call a consumer's completion event
Documentation/infiniband/core_locking.txt:  completion event handlers for the same CQ are not called
Documentation/infiniband/core_locking.txt:  The context in which completion event and asynchronous event
Documentation/infiniband/ipoib.txt:  IPoIB doesn't use events for TX completion signaling so only RX
Documentation/RCU/Design/Requirements/Requirements.html:RCU's grace-period guarantee allows updaters to wait for the completion
Documentation/RCU/Design/Requirements/Requirements.html:contain anything that waits, directly or indirectly, on completion of
Documentation/RCU/Design/Requirements/Requirements.html:But what if the updater must wait for the completion of code to be
Documentation/RCU/Design/Requirements/Requirements.html:completion of grace-period processing.
Documentation/RCU/Design/Data-Structures/Data-Structures.html:The CPU detects the completion of an RCU grace period by noticing
Documentation/RCU/whatisRCU.txt:	the data element, in order to wait for the completion of all
Documentation/RCU/whatisRCU.txt:	function that will be invoked after the completion of all RCU
Documentation/RCU/whatisRCU.txt:"toy" implementation would restore the affinity upon completion rather
Documentation/RCU/rcubarrier.txt: 6   init_completion(&rcu_barrier_completion);
Documentation/RCU/rcubarrier.txt: 9   wait_for_completion(&rcu_barrier_completion);
Documentation/RCU/rcubarrier.txt:global completion and counters at a time, which are initialized on lines
Documentation/RCU/rcubarrier.txt:before on_each_cpu() returns. Line 9 then waits for the completion.
Documentation/RCU/rcubarrier.txt:rcu_barrier_cpu_count variable and finalizes the completion when it
Documentation/RCU/rcubarrier.txt: 4 complete(&rcu_barrier_completion);
Documentation/ioctl/hdio.txt:	  written back into in_flags on completion.
Documentation/ioctl/hdio.txt:	  effect other than modifying in_flags on completion.
Documentation/ABI/stable/sysfs-driver-ib_srp:		  MSI-X completion vector of the first RDMA channel. Some
Documentation/ABI/stable/sysfs-driver-ib_srp:		  spread the SRP completion workload over multiple CPU's.
Documentation/ABI/stable/firewire-cdev:		outbound asynchronous transaction completion or isochronous
Documentation/ABI/stable/firewire-cdev:		buffer completion, and unsolicited events such as bus resets,
Documentation/target/tcmu-design.txt:- TCMU_MAILBOX_FLAG_CAP_OOOC: indicates out-of-order completion is
Documentation/target/tcmu-design.txt:capable of handling out-of-order completions. In this case, userspace can
Documentation/spi/spi-summary:completion callbacks.  There are also some simple synchronous wrappers
Documentation/spi/spi-summary:    issued in any context (irq handler, task, etc) and completion
Documentation/power/devices.txt:be able to treat DMA completion as a wakeup event (sometimes DMA can stay
Documentation/power/runtime_pm.txt:	foo_io_completion(struct foo_priv *foo, void *req)
Documentation/power/runtime_pm.txt:The important point is that after foo_io_completion() asks for an autosuspend,
Documentation/power/freezing-of-tasks.txt:on another.  For example, if kernel thread A waits for a completion (in the
Documentation/DMA-attributes.txt:ready and available in memory.  The DMA of the "completion indication"
Documentation/DMA-attributes.txt:could race with data DMA.  Mapping the memory used for completion
Documentation/nfc/nfc-hci.txt:HCI command, setup a local wait queue on stack, and wait_event() for completion.
Documentation/nfc/nfc-hci.txt:waiting command execution. Response processing involves invoking the completion
Documentation/nfc/nfc-hci.txt:The completion callback will then wake the syscall context.
Documentation/nfc/nfc-hci.txt:connection, the error is reported through the connect completion.
Documentation/vm/numa_memory_policy.txt:on completion of the policy installation.
Documentation/intel_txt.txt:executed between system reset through the completion of the kernel
Documentation/media/uapi/v4l/dmabuf.rst:buffer at any time between the completion of the DMA and this ioctl. The
Documentation/media/uapi/v4l/userp.rst:memory pages at any time between the completion of the DMA and this
Documentation/media/uapi/dvb/examples.rst:		     printf("completion event\\n");
Documentation/media/v4l-drivers/soc-camera.rst:updates these fields upon successful completion of a .s_fmt() call, but if these
Documentation/usb/usbmon.txt:  completion where the received data is sparse in the buffer, the length of
Documentation/usb/error-codes.txt:USB device drivers may only test urb status values in completion handlers.
Documentation/usb/dwc3.txt:  - dwc3_send_gadget_ep_cmd() will sleep in wait_for_completion_timeout()
Documentation/usb/dwc3.txt:      for command completion.
Documentation/usb/power-management.txt:	such as an URB's completion handler, but when they return the
Documentation/usb/power-management.txt:the I/O request routine and the URB completion handler; it should
Documentation/usb/anchors.txt:an URB is finished by (successful) completion. Thus disassociation
Documentation/usb/ehci.txt:to receive interrupts from the EHCI controller indicating completion
Documentation/usb/ehci.txt:I/O completion and the driver issuing the next request will take longer
Documentation/usb/WUSB-Design-overview.txt:completion. [Note: The bandwidth reservation work is in progress and
Documentation/usb/callbacks.txt:structure and through the completion handler of URBs a driver submits.
Documentation/usb/callbacks.txt:completion callback can be found in Documentation/usb/URB.txt.
Documentation/usb/URB.txt:- Each URB has a completion handler, which is called after the action
Documentation/usb/URB.txt:  context-pointer for passing information to the completion handler.
Documentation/usb/URB.txt:  data to an endpoint while your driver handles completion of another.
Documentation/usb/URB.txt:// (IN) all urbs need completion routines
Documentation/usb/URB.txt:	void *context;                  // context for completion routine
Documentation/usb/URB.txt:	void (*complete)(struct urb *); // pointer to completion routine
Documentation/usb/URB.txt:// (OUT) status after each completion
Documentation/usb/URB.txt:returned to you in a completion callback.  It will automatically be
Documentation/usb/URB.txt:the desired transfer length, the completion  handler, and its context. 
Documentation/usb/URB.txt:look at that value except in your completion callback.
Documentation/usb/URB.txt:For isochronous endpoints, your completion handlers should (re)submit
Documentation/usb/URB.txt:returns; you must still wait for the completion handler to be called.
Documentation/usb/URB.txt:until after the URB has been returned and the completion handler
Documentation/usb/URB.txt:that if the completion handler or anyone else tries to resubmit it
Documentation/usb/URB.txt:time, and the completion handler may free the URB.  If this happens
Documentation/usb/URB.txt:completion handler, the handler must not take any lock that is held
Documentation/usb/URB.txt:by the completion handler.
Documentation/usb/URB.txt:1.7. What about the completion handler?
Documentation/usb/URB.txt:I.e., it gets the URB that caused the completion call. In the completion
Documentation/usb/URB.txt:information to the completion handler.
Documentation/usb/URB.txt:have transferred successfully before the completion was called.
Documentation/usb/URB.txt:In the current kernel, completion handlers run with local interrupts
Documentation/usb/URB.txt:local IRQs are always disabled inside completion handlers.
Documentation/usb/URB.txt:After completion, actual_length contains the actual transferred length and 
Documentation/usb/URB.txt:earlier, if you always keep at least one URB queued and your completion
Documentation/usb/URB.txt:restarted when they complete.  They end when the completion handler is
Documentation/usb/URB.txt:your completion handler must resubmit it.
Documentation/timers/hrtimers.txt:  evil to guarantee the processing of actual timeout completions
Documentation/timers/hrtimers.txt:  (because most of the timeouts are deleted before completion), which
Documentation/hwmon/lm90:transaction completion, effectively doubling the register cache refresh time.
Documentation/rapidio/rapidio.txt:each agent waits for enumeration completion by the host for the configured wait
Documentation/rapidio/mport_cdev.txt:- Check/Wait for completion of asynchronous DMA data transfer
Documentation/rapidio/mport_cdev.txt:- 'dma_timeout' - DMA transfer completion timeout (in msec, default value 3000).
Documentation/rapidio/mport_cdev.txt:        This parameter set a maximum completion wait time for SYNC mode DMA
Documentation/memory-barriers.txt:     memory barrier will be _complete_ by the completion of a memory barrier
Documentation/fb/fbcon.txt:garbled display, but the system still boots to completion.  If you are
Documentation/filesystems/Locking:completion.
Documentation/filesystems/Locking:I/O against them.  They come unlocked upon I/O completion.
Documentation/filesystems/Locking:page, write I/O can be submitted and the write I/O completion handler must run
Documentation/filesystems/Locking:call this method upon the IO completion.
Documentation/filesystems/caching/object.txt:     At the completion of lookup, FS-Cache will let the netfs go ahead with
Documentation/filesystems/caching/object.txt:     At the completion of creation, FS-Cache will start processing write
Documentation/filesystems/caching/fscache.txt:     invoked to indicate completion.  The I/O may be either synchronous or
Documentation/filesystems/caching/fscache.txt:		wcr=N	Number of rlq reqs waited on completion of creation
Documentation/filesystems/caching/fscache.txt:		wt=N	Number of alloc reqs that waited on lookup completion
Documentation/filesystems/caching/fscache.txt:		wt=N	Number of retr reqs that waited on lookup completion
Documentation/filesystems/caching/operations.txt:backend for completion.
Documentation/filesystems/caching/netfs-api.txt: (8) A pair of functions to manage contexts for the completion callback
Documentation/filesystems/caching/netfs-api.txt:     to the I/O completion callback function.  To ensure this context remains
Documentation/filesystems/caching/netfs-api.txt:     valid until after the I/O completion is called, two functions may be
Documentation/filesystems/caching/backend-api.txt:     retrieval routine could be enqueued upon the completion of a disk read.
Documentation/filesystems/caching/backend-api.txt: (*) Invoke the retrieval I/O completion function:
Documentation/filesystems/caching/backend-api.txt: (*) Record operation completion:
Documentation/filesystems/caching/backend-api.txt:     This is called to record the completion of an operation.  This deducts
Documentation/filesystems/caching/backend-api.txt:     completion to go off and start fetching data from the netfs server as it's
Documentation/filesystems/autofs4-mount-control.txt:request back to the daemon and waits for completion.
Documentation/filesystems/gfs2-uevents.txt:The other CHANGE uevent is used to inform of the completion
Documentation/filesystems/xfs-self-describing-metadata.txt:that it should see, and the IO completion process verifies that the metadata
Documentation/filesystems/xfs-delayed-logging-design.txt:completion, after which they are unpinned and can be written to disk. An object
Documentation/filesystems/xfs-delayed-logging-design.txt:checkpoint completion.
Documentation/filesystems/xfs-delayed-logging-design.txt:checkpoint from initiation to checkpoint completion. A new context is initiated
Documentation/filesystems/xfs-delayed-logging-design.txt:completion callback. Log IO completion will call that callback, which can then
Documentation/filesystems/xfs-delayed-logging-design.txt:every checkpoint transaction completion. Unfortunately, if this space is not
Documentation/filesystems/xfs-delayed-logging-design.txt:as there is a 1:1 relationship with transaction commit and log item completion.
Documentation/filesystems/xfs-delayed-logging-design.txt:completion relationship. Every time an object is relogged in the CIL it goes
Documentation/filesystems/xfs-delayed-logging-design.txt:through the commit process without a corresponding completion being registered.
Documentation/filesystems/xfs-delayed-logging-design.txt:log item completion. The result of this is that pinning and unpinning of the
Documentation/filesystems/xfs-delayed-logging-design.txt:on transaction completion" model.
Documentation/filesystems/xfs-delayed-logging-design.txt:insertion into the CIL, unpin on checkpoint completion". In other words, the
Documentation/filesystems/xfs-delayed-logging-design.txt:ensure completion of checkpoints.
Documentation/filesystems/xfs-delayed-logging-design.txt:(obtained through completion of a commit record write) while log force
Documentation/filesystems/xfs-delayed-logging-design.txt:	7. Transaction completion
Documentation/filesystems/xfs-delayed-logging-design.txt:	<item IO completion>
Documentation/filesystems/xfs-delayed-logging-design.txt:	8. Checkpoint completion
Documentation/filesystems/xfs-delayed-logging-design.txt:	<item IO completion>
Documentation/filesystems/xfs-delayed-logging-design.txt:committing of the log items to the log itself and the completion processing.
Documentation/filesystems/cifs/CHANGES:copies caused by writepages page i/o completion bug.
Documentation/filesystems/xfs.txt:	completion when there are persistent errors, and it may prevent the
Documentation/filesystems/xfs.txt:	there is a successful completion of the operation.
Documentation/xillybus.txt:partial completion is allowed.
Documentation/gpu/drm-mm.rst:command completion and fence synchronization, and memory migration. See
Documentation/block/data-integrity.txt:    to be verified upon completion.
Documentation/block/data-integrity.txt:      Upon completion of a READ operation, the attached pages will
Documentation/block/data-integrity.txt:      integrity upon completion.
Documentation/block/queue-sysfs.txt:If this option is '1', the block layer will migrate request completions to the
Documentation/block/queue-sysfs.txt:For storage configurations that need to maximize distribution of completion
Documentation/block/queue-sysfs.txt:processing setting this option to '2' forces the completion to run on the
Documentation/block/writeback_cache_control.txt:write back caches.  That means the devices signal I/O completion to the
Documentation/block/writeback_cache_control.txt:filesystem and will make sure that I/O completion for this request is only
Documentation/block/request.txt:struct completion *waiting	D	Can be used by driver to get signalled
Documentation/block/request.txt:					on request completion
Documentation/block/null_blk.txt:All of them have a completion queue for each core in the system.
Documentation/block/null_blk.txt:  The completion mode used for completing IOs to the block-layer.
Documentation/block/null_blk.txt:  2: Timer: Waits a specific period (completion_nsec) for each IO before
Documentation/block/null_blk.txt:     completion.
Documentation/block/null_blk.txt:completion_nsec=[ns]: Default: 10.000ns
Documentation/block/null_blk.txt:  Combined with irqmode=2 (timer). The time each completion event must wait.
Documentation/block/cfq-iosched.txt:on same queue after completion of a request. In this process CFQ will not
Documentation/block/cfq-iosched.txt:sequential reads (next read will come on only after completion of previous
Documentation/block/cfq-iosched.txt:    roughly after 1 second. If after completion of REQ_NOIDLE request we
Documentation/block/biodoc.txt:    3.2.1 Traversing segments and completion units in a request
Documentation/block/biodoc.txt:    3.2.3 I/O completion
Documentation/block/biodoc.txt:data read has to be copied to the original buffer on i/o completion, so a
Documentation/block/biodoc.txt:performing the copy, and special care may be needed in the completion path
Documentation/block/biodoc.txt:wait for completion. Alternatively, sometimes the caller might just
Documentation/block/biodoc.txt:completion. Alternatively one could directly use the request->buffer field to
Documentation/block/biodoc.txt:end_request or end_that_request_first completion interfaces.
Documentation/block/biodoc.txt: completion of partial transfers. The driver has to modify these fields 
Documentation/block/biodoc.txt:    different sources or i/o units requiring individual completion (e.g. for
Documentation/block/biodoc.txt:  avoids reallocs and makes independent completions easier to handle.
Documentation/block/biodoc.txt:bi_end_io() i/o callback gets called on i/o completion of the entire bio.
Documentation/block/biodoc.txt:be one of the many segments in the current bio (i.e i/o completion unit).
Documentation/block/biodoc.txt:i/o is issued (since the bio may otherwise get freed in case i/o completion
Documentation/block/biodoc.txt:3.2.1 Traversing segments and completion units in a request
Documentation/block/biodoc.txt:I/O completion callbacks are per-bio rather than per-segment, so drivers
Documentation/block/biodoc.txt:that traverse bio chains on completion need to keep that in mind. Drivers
Documentation/block/biodoc.txt:which don't make a distinction between segments and completion units would
Documentation/block/biodoc.txt:3.2.3 I/O completion
Documentation/block/biodoc.txt:completion (and setting things up so the rest of the i/o or the next
Documentation/block/biodoc.txt:is crossed on completion of a transfer. (The end*request* functions should
Documentation/block/biodoc.txt:completion of the request to the block layer. This means ending tag
Documentation/block/biodoc.txt:  and passed on in some way to the endio completion routine.
Documentation/block/biodoc.txt:the queue gets explicitly unplugged as part of waiting for completion on that
Documentation/iostats.txt:    This field is incremented at each I/O start, I/O completion, I/O
Documentation/iostats.txt:    I/O completion time and the backlog that may be accumulating.
Documentation/iostats.txt:of queuing for partitions, and at completion for whole disks.  This is
Documentation/virtual/kvm/devices/s390_flic.txt:    async page faults are done. This is necessary to trigger a completion interrupt
Documentation/virtual/kvm/s390-diag.txt:Upon completion of the DIAGNOSE instruction, general register 2 contains
Documentation/virtual/kvm/s390-diag.txt:    After completion of the DIAGNOSE call, general register 2 may contain
Documentation/virtual/kvm/api.txt:where KVM queues elapsed i8254 ticks and monitors completion of interrupt from
drivers/clk/renesas/clk-rcar-gen2.c:	 * clock change completion.
drivers/pnp/pnpbios/core.c:#include <linux/completion.h>
drivers/pnp/pnpbios/core.c:static struct completion unload_sem;
drivers/pnp/pnpbios/core.c:	init_completion(&unload_sem);
drivers/pnp/pnpbios/bioscalls.c:#include <linux/completion.h>
drivers/mmc/card/block.c: * partial completions.
drivers/mmc/host/mxs-mmc.c:#include <linux/completion.h>
drivers/mmc/host/vub300.c:	struct completion command_complete;
drivers/mmc/host/vub300.c:	struct completion irqpoll_complete;
drivers/mmc/host/vub300.c:{				/* urb completion handler - hardirq */
drivers/mmc/host/vub300.c:{				/* urb completion handler - hardirq */
drivers/mmc/host/vub300.c:	init_completion(&vub300->irqpoll_complete);
drivers/mmc/host/vub300.c:	commretval = wait_for_completion_timeout(&vub300->irqpoll_complete,
drivers/mmc/host/vub300.c:{				/* urb completion handler - hardirq */
drivers/mmc/host/vub300.c:{				/* urb completion handler - hardirq */
drivers/mmc/host/vub300.c:			 * the urb completion handler will call
drivers/mmc/host/vub300.c:			 * our completion handler
drivers/mmc/host/vub300.c:static void vub300_usb_bulk_msg_completion(struct urb *urb)
drivers/mmc/host/vub300.c:{				/* urb completion handler - hardirq */
drivers/mmc/host/vub300.c:	complete((struct completion *)urb->context);
drivers/mmc/host/vub300.c:	struct completion done;
drivers/mmc/host/vub300.c:			  vub300_usb_bulk_msg_completion, NULL);
drivers/mmc/host/vub300.c:	init_completion(&done);
drivers/mmc/host/vub300.c:	if (!wait_for_completion_timeout
drivers/mmc/host/vub300.c:		wait_for_completion_timeout(&vub300->command_complete,
drivers/mmc/host/vub300.c:		init_completion(&vub300->command_complete);
drivers/mmc/host/sunxi-mmc.c:#define SDXC_IDMAC_DES0_DIC	BIT(1)  /* disable interrupt on completion */
drivers/mmc/host/wmt-sdmmc.c:	struct completion cmdcomp;
drivers/mmc/host/wmt-sdmmc.c:	struct completion datacomp;
drivers/mmc/host/wmt-sdmmc.c:	struct completion *comp_cmd;
drivers/mmc/host/wmt-sdmmc.c:	struct completion *comp_dma;
drivers/mmc/host/wmt-sdmmc.c:			init_completion(priv->comp_cmd);
drivers/mmc/host/wmt-sdmmc.c:		if (completion_done(priv->comp_cmd)) {
drivers/mmc/host/wmt-sdmmc.c:			if (completion_done(priv->comp_dma))
drivers/mmc/host/wmt-sdmmc.c:		/* completion is now handled in the regular_isr() */
drivers/mmc/host/wmt-sdmmc.c:		init_completion(priv->comp_cmd);
drivers/mmc/host/wmt-sdmmc.c:		init_completion(priv->comp_dma);
drivers/mmc/host/usdhi6rol0.c:	if (WARN(!mrq || !mrq->data, "%s: NULL data in DMA completion for %p!\n",
drivers/mmc/host/usdhi6rol0.c:	/* We have to get a command completion interrupt with DMA too */
drivers/mmc/host/mmci.c:	/* Check if we need to wait for busy completion. */
drivers/mmc/host/mmci.c:	/* Enable busy completion if needed and supported. */
drivers/mmc/host/mmci.c:	/* At busy completion, mask the IRQ and complete the request. */
drivers/mmc/host/mmci.c: * Handle completion of command and data transfers.
drivers/mmc/host/mmci.c:		 * edges while monitoring DAT0 for busy completion.
drivers/mmc/host/mmci.c:		/* Don't poll for busy completion in irq context. */
drivers/mmc/host/omap.c:		/* Send clock cycles, poll completion */
drivers/mmc/host/s3cmci.c: *   host->complete_request	is the completion-object the driver waits for
drivers/mmc/host/toshsd.c:	/* Command completion */
drivers/mmc/host/toshsd.c:	/* Data transfer completion */
drivers/mmc/host/tmio_mmc_pio.c:	/* Command completion */
drivers/mmc/host/tmio_mmc_pio.c:	/* Data transfer completion */
drivers/mmc/host/sh_mmcif.c: * initialises the hardware, installs a timeout handler to handle completion
drivers/mmc/host/sh_mmcif.c: * thread, a DMA completion callback, if DMA is used, a timeout work, and
drivers/mmc/host/sh_mmcif.c: * processing completion, the MMC core is informed and the request processing is
drivers/mmc/host/sh_mmcif.c:#include <linux/completion.h>
drivers/mmc/host/sh_mmcif.c:	struct completion	dma_complete;
drivers/mmc/host/sh_mmcif.c:	if (WARN(!mrq || !mrq->data, "%s: NULL data in DMA completion!\n",
drivers/mmc/host/sh_mmcif.c:	init_completion(&host->dma_complete);
drivers/mmc/host/sh_mmcif.c:	time = wait_for_completion_interruptible_timeout(&host->dma_complete,
drivers/mmc/host/sh_mmcif.c:			"Error IRQ while waiting for DMA completion!\n");
drivers/mmc/host/sh_mmcif.c:			"wait_for_completion_...() error %ld!\n", time);
drivers/mmc/host/sdricoh_cs.c:	/* wait for command completion */
drivers/mmc/host/omap_hsmmc.c: * Notify the core about command completion
drivers/mmc/host/davinci_mmc.c:		/* Send clock cycles, poll completion */
drivers/mmc/host/atmel-mci.c: * @cmd_status: Snapshot of SR taken upon completion of the current
drivers/mmc/host/atmel-mci.c: * @data_status: Snapshot of SR taken upon completion of the current
drivers/mmc/host/atmel-mci.c:		 * completion callback" rule of the dma engine
drivers/mmc/host/moxart-mmc.c:	struct completion		dma_complete;
drivers/mmc/host/moxart-mmc.c:	struct completion		pio_complete;
drivers/mmc/host/moxart-mmc.c:	dma_time = wait_for_completion_interruptible_timeout(
drivers/mmc/host/moxart-mmc.c:	init_completion(&host->dma_complete);
drivers/mmc/host/moxart-mmc.c:	init_completion(&host->pio_complete);
drivers/mmc/host/moxart-mmc.c:			pio_time = wait_for_completion_interruptible_timeout(
drivers/mmc/host/sdhci.c:		 * on successful completion (so no Auto-CMD12).
drivers/mmc/core/mmc_ops.c:	 * to detect busy completion.
drivers/mmc/core/sd_ops.c: 			       completion
drivers/mmc/core/core.c:#include <linux/completion.h>
drivers/mmc/core/core.c:	if (mrq->cap_cmd_during_tfr && !completion_done(&mrq->cmd_completion))
drivers/mmc/core/core.c:		complete_all(&mrq->cmd_completion);
drivers/mmc/core/core.c:		 * cmd_completion, so ensure it is reinitialised.
drivers/mmc/core/core.c:		reinit_completion(&mrq->cmd_completion);
drivers/mmc/core/core.c:	complete(&mrq->completion);
drivers/mmc/core/core.c:	if (ongoing_mrq && !completion_done(&ongoing_mrq->cmd_completion))
drivers/mmc/core/core.c:		wait_for_completion(&ongoing_mrq->cmd_completion);
drivers/mmc/core/core.c:	init_completion(&mrq->cmd_completion);
drivers/mmc/core/core.c:	init_completion(&mrq->completion);
drivers/mmc/core/core.c:	init_completion(&mrq->cmd_completion);
drivers/mmc/core/core.c:		complete(&mrq->completion);
drivers/mmc/core/core.c:		wait_for_completion(&mrq->completion);
drivers/mmc/core/core.c:		return completion_done(&mrq->completion);
drivers/mmc/core/core.c: *	If there is on ongoing async request wait for completion
drivers/mmc/core/core.c: *	mmc_wait_for_req - start a request and wait for completion
drivers/mmc/core/core.c: *	mmc_wait_for_cmd - start a command and wait for completion
drivers/rtc/rtc-wm831x.c:#include <linux/completion.h>
drivers/rtc/rtc-wm8350.c:#include <linux/completion.h>
drivers/rtc/rtc-imxdi.c: * LP (Low Power) domain and set the WCF upon completion. Writes to the
drivers/rtc/rtc-imxdi.c: * on the write completion.
drivers/rtc/rtc-as3722.c:#include <linux/completion.h>
drivers/rtc/rtc-at91rm9200.c:#include <linux/completion.h>
drivers/rtc/rtc-at91rm9200.c:	wait_for_completion(&at91_rtc_upd_rdy);
drivers/rtc/rtc-at91rm9200.c:	wait_for_completion(&at91_rtc_updated);	/* wait for ACKUPD interrupt */
drivers/rtc/rtc-at91rm9200.c:	 * completion.
drivers/rtc/rtc-hid-sensor-time.c:	struct completion comp_last_time;
drivers/rtc/rtc-hid-sensor-time.c:	reinit_completion(&time_state->comp_last_time);
drivers/rtc/rtc-hid-sensor-time.c:	ret = wait_for_completion_killable_timeout(
drivers/rtc/rtc-hid-sensor-time.c:	init_completion(&time_state->comp_last_time);
drivers/rtc/rtc-bfin.c:#include <linux/completion.h>
drivers/rtc/rtc-bfin.c:		wait_for_completion_timeout(&bfin_write_complete, HZ * 5);
drivers/video/fbdev/omap2/omapfb/displays/encoder-tpd12s015.c:#include <linux/completion.h>
drivers/video/fbdev/omap2/omapfb/omapfb-main.c:	/* FIXME: wait till completion of pending events */
drivers/video/fbdev/omap2/omapfb/dss/venc.c:#include <linux/completion.h>
drivers/video/fbdev/omap2/omapfb/dss/apply.c:static DECLARE_COMPLETION(extra_updated_completion);
drivers/video/fbdev/omap2/omapfb/dss/apply.c:	init_completion(&extra_updated_completion);
drivers/video/fbdev/omap2/omapfb/dss/apply.c:	r = wait_for_completion_timeout(&extra_updated_completion, t);
drivers/video/fbdev/omap2/omapfb/dss/apply.c:		complete_all(&extra_updated_completion);
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:	struct completion *compl = data;
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:	if (!wait_for_completion_timeout(&framedone_compl,
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:	struct completion *compl = data;
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:	if (!wait_for_completion_timeout(&vsync_compl, msecs_to_jiffies(100)))
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:		 * wait_for_completion.
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:		if (!wait_for_completion_timeout(&framedone_compl,
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:	complete((struct completion *)data);
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:	r = omap_dispc_register_isr(dispc_irq_wait_handler, &completion,
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:	time_left = wait_for_completion_interruptible_timeout(&completion,
drivers/video/fbdev/omap2/omapfb/dss/dispc-compat.c:	omap_dispc_unregister_isr(dispc_irq_wait_handler, &completion, irqmask);
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	struct completion *completion;
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:static void dsi_completion_handler(void *data, u32 mask)
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	complete((struct completion *)data);
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:		complete(vp_data->completion);
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:		.completion = &completion
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	/* Wait for completion only if TE_EN/TE_START is still set */
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:		if (wait_for_completion_timeout(&completion,
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:		complete(l4_data->completion);
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:		.completion = &completion
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	/* Wait for completion only if TX_FIFO_NOT_EMPTY is still set */
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:		if (wait_for_completion_timeout(&completion,
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	r = dsi_register_isr_vc(dsidev, channel, dsi_completion_handler,
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:			&completion, DSI_VC_IRQ_BTA);
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	r = dsi_register_isr(dsidev, dsi_completion_handler, &completion,
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	if (wait_for_completion_timeout(&completion,
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	dsi_unregister_isr(dsidev, dsi_completion_handler, &completion,
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	dsi_unregister_isr_vc(dsidev, channel, dsi_completion_handler,
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:			&completion, DSI_VC_IRQ_BTA);
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	r = dsi_register_isr_cio(dsidev, dsi_completion_handler, &completion,
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	if (wait_for_completion_timeout(&completion,
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	dsi_unregister_isr_cio(dsidev, dsi_completion_handler, &completion,
drivers/video/fbdev/omap2/omapfb/dss/dsi.c:	dsi_unregister_isr_cio(dsidev, dsi_completion_handler, &completion,
drivers/video/fbdev/pxafb.c:#include <linux/completion.h>
drivers/video/fbdev/pxafb.c:	if (wait_for_completion_timeout(&ofb->branch_done, 1 * HZ) == 0)
drivers/video/fbdev/pxafb.c:	if (wait_for_completion_timeout(&ofb->branch_done, 1 * HZ) == 0)
drivers/video/fbdev/pxafb.c:	init_completion(&ofb->branch_done);
drivers/video/fbdev/pxafb.c:	if (wait_for_completion_timeout(&fbi->command_done, HZ/2) == 0) {
drivers/video/fbdev/pxafb.c:	init_completion(&fbi->command_done);
drivers/video/fbdev/pxafb.c:	init_completion(&fbi->refresh_done);
drivers/video/fbdev/pxafb.c:		wait_for_completion_timeout(&fbi->refresh_done,
drivers/video/fbdev/pxafb.c:	wait_for_completion_timeout(&fbi->disable_done, msecs_to_jiffies(200));
drivers/video/fbdev/pxafb.c:	init_completion(&fbi->disable_done);
drivers/video/fbdev/sh7760fb.c:#include <linux/completion.h>
drivers/video/fbdev/sh7760fb.c:	struct completion vsync;	/* vsync irq event */
drivers/video/fbdev/sh7760fb.c:	struct completion *c = data;
drivers/video/fbdev/da8xx-fb.c:		/* Disable PL completion interrupt */
drivers/video/fbdev/da8xx-fb.c:		/* Disable PL completion inerrupt */
drivers/video/fbdev/da8xx-fb.c:	 * user immediately after a frame completion which is all that is
drivers/video/fbdev/omap/lcdc.c:	struct completion	last_frame_complete;
drivers/video/fbdev/omap/lcdc.c:	struct completion	palette_load_complete;
drivers/video/fbdev/omap/lcdc.c:	init_completion(&lcdc.last_frame_complete);
drivers/video/fbdev/omap/lcdc.c:	if (!wait_for_completion_timeout(&lcdc.last_frame_complete,
drivers/video/fbdev/omap/lcdc.c:	init_completion(&lcdc.palette_load_complete);
drivers/video/fbdev/omap/lcdc.c:	if (!wait_for_completion_timeout(&lcdc.palette_load_complete,
drivers/video/fbdev/omap/hwa742.c:		struct completion	*sync;
drivers/video/fbdev/omap/hwa742.c:	struct completion comp;
drivers/video/fbdev/omap/hwa742.c:	init_completion(&comp);
drivers/video/fbdev/omap/hwa742.c:	wait_for_completion(&comp);
drivers/video/fbdev/omap/omapfb_main.c:	/* FIXME: wait till completion of pending events */
drivers/video/fbdev/via/via-core.c:static DECLARE_COMPLETION(viafb_dma_completion);
drivers/video/fbdev/via/via-core.c: * The completion IRQ handler.
drivers/video/fbdev/via/via-core.c:		complete(&viafb_dma_completion);
drivers/video/fbdev/via/via-core.c:	init_completion(&viafb_dma_completion);
drivers/video/fbdev/via/via-core.c:	wait_for_completion_interruptible(&viafb_dma_completion);
drivers/video/fbdev/via/via-core.c:	init_completion(&viafb_dma_completion);
drivers/video/fbdev/via/via-core.c:	wait_for_completion_timeout(&viafb_dma_completion, 1);
drivers/video/fbdev/udlfb.c:static void dlfb_urb_completion(struct urb *urb);
drivers/video/fbdev/udlfb.c:		dlfb_urb_completion(urb);
drivers/video/fbdev/udlfb.c:		dlfb_urb_completion(urb);
drivers/video/fbdev/udlfb.c:static void dlfb_urb_completion(struct urb *urb)
drivers/video/fbdev/udlfb.c:			buf, size, dlfb_urb_completion, unode);
drivers/video/fbdev/udlfb.c:		dlfb_urb_completion(urb); /* because no one else will */
drivers/video/fbdev/pxafb.h:	struct completion	branch_done;
drivers/video/fbdev/pxafb.h:	struct completion	disable_done;
drivers/video/fbdev/pxafb.h:	struct completion	command_done;
drivers/video/fbdev/pxafb.h:	struct completion	refresh_done;
drivers/video/fbdev/smscufx.c:static void ufx_urb_completion(struct urb *urb);
drivers/video/fbdev/smscufx.c:static void ufx_urb_completion(struct urb *urb)
drivers/video/fbdev/smscufx.c:			buf, size, ufx_urb_completion, unode);
drivers/video/fbdev/smscufx.c:		ufx_urb_completion(urb); /* because no one else will */
drivers/video/fbdev/hyperv_fb.c:#include <linux/completion.h>
drivers/video/fbdev/hyperv_fb.c:	struct completion wait;
drivers/video/fbdev/hyperv_fb.c:	t = wait_for_completion_timeout(&par->wait, VSP_TIMEOUT);
drivers/video/fbdev/hyperv_fb.c:	t = wait_for_completion_timeout(&par->wait, VSP_TIMEOUT);
drivers/video/fbdev/hyperv_fb.c:	init_completion(&par->wait);
drivers/video/fbdev/sh_mobile_lcdcfb.h:#include <linux/completion.h>
drivers/video/fbdev/sh_mobile_lcdcfb.h:	struct completion vsync_completion;
drivers/video/fbdev/uvesafb.c:#include <linux/completion.h>
drivers/video/fbdev/uvesafb.c:	init_completion(task->done);
drivers/video/fbdev/uvesafb.c:		err = !wait_for_completion_timeout(task->done,
drivers/video/fbdev/uvesafb.c:	struct completion *cpl = task->done;
drivers/video/fbdev/mx3fb.c:	struct completion		flip_cmpl;
drivers/video/fbdev/mx3fb.c:	init_completion(&mx3_fbi->flip_cmpl);
drivers/video/fbdev/mx3fb.c:	ret = wait_for_completion_timeout(&mx3_fbi->flip_cmpl, HZ / 10);
drivers/video/fbdev/mx3fb.c:	init_completion(&mx3fbi->flip_cmpl);
drivers/video/fbdev/sh_mobile_lcdcfb.c:			complete(&ch->vsync_completion);
drivers/video/fbdev/sh_mobile_lcdcfb.c:	ret = wait_for_completion_interruptible_timeout(&ch->vsync_completion,
drivers/video/fbdev/sh_mobile_lcdcfb.c:		init_completion(&ch->vsync_completion);
drivers/video/fbdev/pvr2fb.c:		dma_wait_for_completion(pvr2dma);
drivers/video/fbdev/pvr2fb.c:		dma_wait_for_completion(pvr2dma);
drivers/lightnvm/rrpc.c:	struct completion *waiting = bio->bi_private;
drivers/lightnvm/rrpc.c:		wait_for_completion_io(&wait);
drivers/lightnvm/rrpc.c:		reinit_completion(&wait);
drivers/lightnvm/rrpc.c:		wait_for_completion_io(&wait);
drivers/lightnvm/core.c:	struct completion *waiting = rqd->wait;
drivers/lightnvm/core.c:		while (!wait_for_completion_io_timeout(&wait,
drivers/lightnvm/core.c:		wait_for_completion_io(&wait);
drivers/parisc/lba_pci.c:** guarantee non-postable completion semantics - not avoid X4107.
drivers/pcmcia/cs.c:	init_completion(&socket->socket_released);
drivers/pcmcia/cs.c:	init_completion(&socket->thread_done);
drivers/pcmcia/cs.c:	wait_for_completion(&socket->thread_done);
drivers/pcmcia/cs.c:	wait_for_completion(&socket->socket_released);
drivers/pcmcia/cs.c:static struct completion pcmcia_unload;
drivers/pcmcia/cs.c:	init_completion(&pcmcia_unload);
drivers/pcmcia/cs.c:	wait_for_completion(&pcmcia_unload);
drivers/hv/vmbus_drv.c:#include <linux/completion.h>
drivers/hv/vmbus_drv.c:static struct completion probe_event;
drivers/hv/vmbus_drv.c:	init_completion(&probe_event);
drivers/hv/vmbus_drv.c:	t = wait_for_completion_timeout(&probe_event, 5*HZ);
drivers/hv/connection.c:	init_completion(&msginfo->waitevent);
drivers/hv/connection.c:	wait_for_completion(&msginfo->waitevent);
drivers/hv/channel_mgmt.c:#include <linux/completion.h>
drivers/hv/channel_mgmt.c:		if (completion_done(&vmbus_connection.unload_event))
drivers/hv/channel_mgmt.c:	init_completion(&vmbus_connection.unload_event);
drivers/hv/channel_mgmt.c:		wait_for_completion(&vmbus_connection.unload_event);
drivers/hv/hv_balloon.c:#include <linux/completion.h>
drivers/hv/hv_balloon.c:	struct completion host_event;
drivers/hv/hv_balloon.c:	struct completion config_event;
drivers/hv/hv_balloon.c:	struct completion  ol_waitevent;
drivers/hv/hv_balloon.c:		init_completion(&dm_device.ol_waitevent);
drivers/hv/hv_balloon.c:			wait_for_completion_timeout(&dm_device.ol_waitevent,
drivers/hv/hv_balloon.c:		wait_for_completion_interruptible_timeout(
drivers/hv/hv_balloon.c:		reinit_completion(&dm_device.config_event);
drivers/hv/hv_balloon.c:	init_completion(&dm_device.host_event);
drivers/hv/hv_balloon.c:	init_completion(&dm_device.config_event);
drivers/hv/hv_balloon.c:	t = wait_for_completion_timeout(&dm_device.host_event, 5*HZ);
drivers/hv/hv_balloon.c:	t = wait_for_completion_timeout(&dm_device.host_event, 5*HZ);
drivers/hv/channel.c:	init_completion(&open_info->waitevent);
drivers/hv/channel.c:	wait_for_completion(&open_info->waitevent);
drivers/hv/channel.c:	init_completion(&msginfo->waitevent);
drivers/hv/channel.c:	wait_for_completion(&msginfo->waitevent);
drivers/hv/channel.c:	init_completion(&info->waitevent);
drivers/hv/channel.c:	wait_for_completion(&info->waitevent);
drivers/hv/hyperv_vmbus.h:	struct completion  unload_event;
drivers/cpuidle/sysfs.c:#include <linux/completion.h>
drivers/cpuidle/sysfs.c:	struct completion kobj_unregister;
drivers/cpuidle/sysfs.c:	struct completion kobj_unregister;
drivers/cpuidle/sysfs.c:	wait_for_completion(&device->kobjs[i]->kobj_unregister);
drivers/cpuidle/sysfs.c:		init_completion(&kobj->kobj_unregister);
drivers/cpuidle/sysfs.c:	struct completion kobj_unregister;
drivers/cpuidle/sysfs.c:	init_completion(&kdrv->kobj_unregister);
drivers/cpuidle/sysfs.c:	wait_for_completion(&kdrv->kobj_unregister);
drivers/cpuidle/sysfs.c:	init_completion(&kdev->kobj_unregister);
drivers/cpuidle/sysfs.c:	wait_for_completion(&kdev->kobj_unregister);
drivers/tty/metag_da.c:#include <linux/completion.h>
drivers/tty/metag_da.c:	struct completion	 xmit_empty;
drivers/tty/metag_da.c:		wait_for_completion(&dport->xmit_empty);
drivers/tty/metag_da.c:		reinit_completion(&dport->xmit_empty);
drivers/tty/metag_da.c:		init_completion(&dport->xmit_empty);
drivers/tty/serial/rp2.c:#include <linux/completion.h>
drivers/tty/serial/rp2.c:	struct completion		fw_loaded;
drivers/tty/serial/rp2.c:	init_completion(&card->fw_loaded);
drivers/tty/serial/rp2.c:	wait_for_completion(&card->fw_loaded);
drivers/tty/serial/sunzilog.c: * completion.
drivers/tty/serial/amba-pl011.c:	struct completion	complete;
drivers/tty/serial/amba-pl011.c:	 * This completion interrupt occurs typically when the
drivers/tty/serial/msm_serial.c:			 * trigger DMA RX completion
drivers/tty/serial/mxs-auart.c: * automatically cleared after auto-baud completion.
drivers/tty/hvc/hvc_iucv.c:	wait_queue_head_t	sndbuf_waitq;	/* wait for send completion */
drivers/tty/hvc/hvc_iucv.c: * flush_sndbuf_sync() - Flush send buffer and wait for completion
drivers/tty/hvc/hvc_iucv.c: * to flush any buffered terminal output data and waits for completion.
drivers/tty/hvc/hvc_iucv.c: * hvc_iucv_msg_complete() - IUCV handler to process message completion
drivers/tty/hvc/hvc_iucv.c: * The function is called upon completion of message delivery to remove the
drivers/tty/synclink.c: * 				DMA buffer is terminated in response to completion
drivers/tty/synclink.c: *	timeout		time to wait for send completion
drivers/tty/synclink.c: * 	update stats and do tx completion processing
drivers/tty/synclink.c: * upon completion of a transmit frame
drivers/tty/cyclades.c:			wait_for_completion_interruptible(&info->shutdown_wait);
drivers/tty/cyclades.c:		init_completion(&info->shutdown_wait);
drivers/tty/mips_ejtag_fdc.c:#include <linux/completion.h>
drivers/tty/mips_ejtag_fdc.c:	struct completion		 xmit_empty;
drivers/tty/mips_ejtag_fdc.c:		wait_for_completion(&dport->xmit_empty);
drivers/tty/mips_ejtag_fdc.c:		reinit_completion(&dport->xmit_empty);
drivers/tty/mips_ejtag_fdc.c:		init_completion(&dport->xmit_empty);
drivers/tty/n_gsm.c: *	us from colliding with another sender or a receive completion event.
drivers/tty/rocket.c:#include <linux/completion.h>
drivers/tty/synclinkmp.c: * update stats and do tx completion processing
drivers/vhost/vhost.c:	struct completion wait_event;
drivers/vhost/vhost.c:		init_completion(&flush.wait_event);
drivers/vhost/vhost.c:		wait_for_completion(&flush.wait_event);
drivers/vhost/scsi.c:	struct completion comp;
drivers/vhost/scsi.c:	struct llist_node tvc_completion_list;
drivers/vhost/scsi.c:	struct vhost_work vs_completion_work; /* cmd completion work item */
drivers/vhost/scsi.c:	struct llist_head vs_completion_list; /* cmd completion queue */
drivers/vhost/scsi.c:		init_completion(&new_inflight->comp);
drivers/vhost/scsi.c:	llist_add(&cmd->tvc_completion_list, &vs->vs_completion_list);
drivers/vhost/scsi.c:	vhost_work_queue(&vs->dev, &vs->vs_completion_work);
drivers/vhost/scsi.c:					vs_completion_work);
drivers/vhost/scsi.c:	llnode = llist_del_all(&vs->vs_completion_list);
drivers/vhost/scsi.c:				     tvc_completion_list);
drivers/vhost/scsi.c:	vhost_work_flush(&vs->dev, &vs->vs_completion_work);
drivers/vhost/scsi.c:		wait_for_completion(&old_inflight[i]->comp);
drivers/vhost/scsi.c:	vhost_work_init(&vs->vs_completion_work, vhost_scsi_complete_cmd_work);
drivers/hid/intel-ish-hid/ishtp-hid.h: * This structure is used to store completion flags and per client data like
drivers/hid/intel-ish-hid/ishtp-hid.h:	/* completion flags */
drivers/hid/intel-ish-hid/ipc/ipc.c:		/* ISHTP notification in IPC_RESET sequence completion */
drivers/hid/intel-ish-hid/ishtp/client.c: * completion
drivers/hid/intel-ish-hid/ishtp/bus.c: * @ipc_send_compl: completion callback
drivers/hid/intel-ish-hid/ishtp/bus.c: * @ipc_send_compl_prm: completion callback parameter
drivers/hid/intel-ish-hid/ishtp/bus.c: * the completion callback is called to schedule transmit of next fragment.
drivers/hid/intel-ish-hid/ishtp/bus.c: * ishtp_reset_compl_handler() - Reset completion handler
drivers/hid/intel-ish-hid/ishtp/bus.c: * ISHTP handler for IPC_RESET sequence completion to start
drivers/hid/hid-wiimote.h:#include <linux/completion.h>
drivers/hid/hid-wiimote.h:	struct completion ready;
drivers/hid/hid-wiimote.h:	reinit_completion(&wdata->state.ready);
drivers/hid/hid-wiimote.h:	/* The completion acts as implicit memory barrier so we can safely
drivers/hid/hid-wiimote.h:	ret = wait_for_completion_interruptible_timeout(&wdata->state.ready, HZ);
drivers/hid/hid-wiimote.h:	ret = wait_for_completion_timeout(&wdata->state.ready, HZ);
drivers/hid/hid-picolcd_cir.c:#include <linux/completion.h>
drivers/hid/hid-hyperv.c:#include <linux/completion.h>
drivers/hid/hid-hyperv.c:	struct completion	wait_event;
drivers/hid/hid-hyperv.c:	init_completion(&input_dev->wait_event);
drivers/hid/hid-hyperv.c:	t = wait_for_completion_timeout(&input_dev->wait_event, 5*HZ);
drivers/hid/hid-hyperv.c:	t = wait_for_completion_timeout(&input_dev->wait_event, 5*HZ);
drivers/hid/hid-wiimote-core.c:#include <linux/completion.h>
drivers/hid/hid-wiimote-core.c:	init_completion(&wdata->state.ready);
drivers/hid/hid-picolcd_core.c:#include <linux/completion.h>
drivers/hid/hid-picolcd_core.c:	init_completion(&work->ready);
drivers/hid/hid-picolcd_core.c:		wait_for_completion_interruptible_timeout(&work->ready, HZ*2);
drivers/hid/hid-picolcd_leds.c:#include <linux/completion.h>
drivers/hid/hid-picolcd.h:	struct completion ready;
drivers/hid/usbhid/hid-core.c: * Input interrupt completion handler.
drivers/hid/usbhid/hid-core.c: * Output interrupt completion handler.
drivers/hid/usbhid/hid-core.c: * Control pipe completion handler.
drivers/hid/usbhid/usbkbd.c: *		submitted and its completion handler has not returned yet
drivers/hid/hid-sensor-hub.c:		init_completion(&hsdev->pending.ready);
drivers/hid/hid-sensor-hub.c:		wait_for_completion_interruptible_timeout(
drivers/misc/tifm_7xx1.c:		timeout = wait_for_completion_timeout(&finish_resume, HZ);
drivers/misc/sgi-xp/xpc.h:#include <linux/completion.h>
drivers/misc/sgi-xp/xpc.h:	struct completion wdisconnect_wait;    /* wait for channel disconnect */
drivers/misc/sgi-xp/xpc_channel.c:	/* wake those waiting for notify completion */
drivers/misc/sgi-xp/xpc_sn2.c:		 * completion interrupts. This lets us fake a notify IRQ
drivers/misc/sgi-xp/xpc_main.c:		init_completion(&ch->wdisconnect_wait);
drivers/misc/sgi-xp/xpc_main.c:		wait_for_completion(&ch->wdisconnect_wait);
drivers/misc/sgi-xp/xpc_main.c:	wait_for_completion(&xpc_discovery_exited);
drivers/misc/sgi-xp/xpc_main.c:	wait_for_completion(&xpc_hb_checker_exited);
drivers/misc/arm-charlcd.c:#include <linux/completion.h>
drivers/misc/arm-charlcd.c: * @complete: completion structure for the last LCD command
drivers/misc/arm-charlcd.c:	struct completion complete;
drivers/misc/arm-charlcd.c:	ret = wait_for_completion_interruptible_timeout(&lcd->complete,
drivers/misc/arm-charlcd.c:	/* Disable IRQ after completion */
drivers/misc/arm-charlcd.c:			"wait_for_completion_interruptible_timeout() "
drivers/misc/arm-charlcd.c:		init_completion(&lcd->complete);
drivers/misc/vmw_vmci/vmci_resource.c:	init_completion(&resource->done);
drivers/misc/vmw_vmci/vmci_resource.c:	wait_for_completion(&resource->done);
drivers/misc/vmw_vmci/vmci_doorbell.c:#include <linux/completion.h>
drivers/misc/vmw_vmci/vmci_resource.h:	struct completion done;
drivers/misc/genwqe/card_ddcb.c: * A: active DDCB, this is where the code will look for the next completion.
drivers/misc/genwqe/card_ddcb.c: * x: DDCB is enqueued, we are waiting for its completion.
drivers/misc/genwqe/card_ddcb.c:	/* enable DDCB completion irq */
drivers/misc/genwqe/card_ddcb.c:	 * Higher values than 0x102 indicate completion with faults,
drivers/misc/genwqe/card_dev.c:		/* launch an DDCB and wait for completion */
drivers/misc/mei/mei_dev.h: * @tx_wait: wait queue for tx completion
drivers/misc/mei/mei_dev.h: * @rx_wait: wait queue for rx completion
drivers/misc/mei/mei_dev.h: * @timer_count:  watchdog timer for operation completion
drivers/misc/mei/mei_dev.h: * @write_waiting_list : write completion list
drivers/misc/mei/bus.c: * @blocking: wait for write completion
drivers/misc/mei/interrupt.c: * @complete_list: completion list
drivers/misc/mic/vop/vop_vringh.c:	init_completion(&vdev->destroy);
drivers/misc/mic/vop/vop_vringh.c:		wait_for_completion(&vdev->destroy);
drivers/misc/mic/vop/vop_vringh.c:		reinit_completion(&vdev->destroy);
drivers/misc/mic/vop/vop_main.h:	struct completion destroy;
drivers/misc/mic/vop/vop_main.c:	struct completion reset_done;
drivers/misc/mic/vop/vop_main.c:	init_completion(&vdev->reset_done);
drivers/misc/mic/vop/vop_main.c:		reinit_completion(&vdev->reset_done);
drivers/misc/mic/vop/vop_main.c:			wait_for_completion(&vdev->reset_done);
drivers/misc/mic/cosm/cosm_scif_server.c: * receive a shutdown status back from the card upon completion of shutdown and
drivers/misc/mic/scif/scif_fence.c:	init_completion(&fence_req->comp);
drivers/misc/mic/scif/scif_fence.c:	err = wait_for_completion_timeout(&fence_req->comp,
drivers/misc/mic/scif/scif_fence.c:	err = wait_for_completion_timeout(&fence_req->comp,
drivers/misc/mic/scif/scif_fence.c:	init_completion(&fence_req->comp);
drivers/misc/mic/scif/scif_rma.h:	struct completion comp;
drivers/misc/mic/scif/scif_nodeqp.c:		struct completion *node_info =
drivers/misc/mic/scif/scif_nodeqp.c:			(struct completion *)msg->payload[3];
drivers/misc/mic/scif/scif_nm.c:	wait_for_completion(&node_info);
drivers/misc/mic/scif/scif_epd.h: * @discon: completion used during disconnection
drivers/misc/mic/scif/scif_epd.h:	struct completion discon;
drivers/misc/mic/scif/scif_api.c:	init_completion(&ep->discon);
drivers/misc/mic/scif/scif_api.c:		wait_for_completion_timeout(&ep->discon,
drivers/misc/mic/scif/scif_mmap.c: * Return: Upon successful completion, scif_mmap() returns zero
drivers/misc/mic/scif/scif_dma.c: * struct scif_dma_comp_cb - SCIF DMA completion callback
drivers/misc/mic/scif/scif_dma.c: * @dma_completion_func: DMA completion callback
drivers/misc/mic/scif/scif_dma.c: * @cb_cookie: DMA completion callback cookie
drivers/misc/mic/scif/scif_dma.c:	void (*dma_completion_func)(void *cookie);
drivers/misc/mic/scif/scif_dma.c: * @comp_cb: DMA copy completion callback
drivers/misc/mic/scif/scif_dma.c:	struct completion *done = (struct completion *)arg;
drivers/misc/mic/scif/scif_dma.c:	reinit_completion(&done_wait);
drivers/misc/mic/scif/scif_dma.c:	err = wait_for_completion_timeout(&done_wait, SCIF_DMA_TO);
drivers/misc/mic/scif/scif_dma.c: * scif_rma_completion_cb:
drivers/misc/mic/scif/scif_dma.c: * RMA interrupt completion callback.
drivers/misc/mic/scif/scif_dma.c:static void scif_rma_completion_cb(void *data)
drivers/misc/mic/scif/scif_dma.c:	tx->callback = &scif_rma_completion_cb;
drivers/misc/mic/scif/scif_dma.c:	/* Allocate dma_completion cb */
drivers/misc/mic/scif/scif_dma.c:	comp_cb->dma_completion_func = &scif_rma_completion_cb;
drivers/misc/ti-st/st_kim.c:	reinit_completion(&kim_gdata->kim_rcvd);
drivers/misc/ti-st/st_kim.c:	timeout = wait_for_completion_interruptible_timeout(
drivers/misc/ti-st/st_kim.c:	reinit_completion(&kim_gdata->kim_rcvd);
drivers/misc/ti-st/st_kim.c:			/* reinit completion before sending for the
drivers/misc/ti-st/st_kim.c:			reinit_completion(&kim_gdata->kim_rcvd);
drivers/misc/ti-st/st_kim.c:			err = wait_for_completion_interruptible_timeout(
drivers/misc/ti-st/st_kim.c:			reinit_completion(&kim_gdata->kim_rcvd);
drivers/misc/ti-st/st_kim.c:/* to signal completion of line discipline installation
drivers/misc/ti-st/st_kim.c:		/* re-initialize the completion */
drivers/misc/ti-st/st_kim.c:		reinit_completion(&kim_gdata->ldisc_installed);
drivers/misc/ti-st/st_kim.c:		err = wait_for_completion_interruptible_timeout(
drivers/misc/ti-st/st_kim.c:	reinit_completion(&kim_gdata->ldisc_installed);
drivers/misc/ti-st/st_kim.c:	err = wait_for_completion_interruptible_timeout(
drivers/misc/ti-st/st_kim.c:	init_completion(&kim_gdata->kim_rcvd);
drivers/misc/ti-st/st_kim.c:	init_completion(&kim_gdata->ldisc_installed);
drivers/misc/cxl/hcalls.c:#define H_CONTROL_CA_FUNCTION_TERMINATE_PROCESS       8 /* terminate the process before completion */
drivers/misc/cxl/hcalls.c: * cxl_h_terminate_process - Terminate the process before completion
drivers/misc/cxl/hcalls.h: * cxl_h_terminate_process - Terminate the process before completion
drivers/misc/lattice-ecp3-config.c:	struct completion fw_loaded;
drivers/misc/lattice-ecp3-config.c:	init_completion(&data->fw_loaded);
drivers/misc/lattice-ecp3-config.c:	wait_for_completion(&data->fw_loaded);
drivers/misc/sgi-gru/grukservices.c: *		  interrupts on completion.
drivers/misc/sgi-gru/grukservices.c: *			  GRU instruction and must wait/check completion.
drivers/misc/sgi-gru/grukservices.c:			struct completion *cmp)
drivers/misc/sgi-gru/grukservices.c:	wait_for_completion(bs->bs_async_wq);
drivers/misc/sgi-gru/grufault.c:	struct completion *cmp;
drivers/misc/sgi-gru/grutables.h:	struct completion	*bs_async_wq;
drivers/misc/sgi-gru/grukservices.h: * 		cmp	  - completion structure for waiting for
drivers/misc/sgi-gru/grukservices.h: * 			    async completions
drivers/misc/sgi-gru/grukservices.h:				struct completion *cmp);
drivers/watchdog/mei_wdt.c:#include <linux/completion.h>
drivers/watchdog/mei_wdt.c: * @response: ping response completion
drivers/watchdog/mei_wdt.c:	struct completion response;
drivers/watchdog/mei_wdt.c:		init_completion(&wdt->response);
drivers/watchdog/mei_wdt.c:		ret = wait_for_completion_killable(&wdt->response);
drivers/watchdog/mei_wdt.c:	 * run only after ping completion, otherwise the flow will
drivers/watchdog/mei_wdt.c:	if (!completion_done(&wdt->response))
drivers/watchdog/mei_wdt.c:	init_completion(&wdt->response);
drivers/watchdog/mei_wdt.c:	if (!completion_done(&wdt->response))
drivers/watchdog/mtx-1_wdt.c:#include <linux/completion.h>
drivers/watchdog/mtx-1_wdt.c:	struct completion stop;
drivers/watchdog/mtx-1_wdt.c:	init_completion(&mtx1_wdt_device.stop);
drivers/watchdog/mtx-1_wdt.c:		wait_for_completion(&mtx1_wdt_device.stop);
drivers/watchdog/rdc321x_wdt.c:#include <linux/completion.h>
drivers/watchdog/rdc321x_wdt.c:	struct completion stop;
drivers/watchdog/rdc321x_wdt.c:	init_completion(&rdc321x_wdt_device.stop);
drivers/watchdog/rdc321x_wdt.c:		wait_for_completion(&rdc321x_wdt_device.stop);
drivers/watchdog/cpu5wdt.c:#include <linux/completion.h>
drivers/watchdog/cpu5wdt.c:	struct completion stop;
drivers/watchdog/cpu5wdt.c:	init_completion(&cpu5wdt_device.stop);
drivers/watchdog/cpu5wdt.c:		wait_for_completion(&cpu5wdt_device.stop);
drivers/cpufreq/pmac64-cpufreq.c:#include <linux/completion.h>
drivers/cpufreq/pmac64-cpufreq.c:	wait_for_completion(&comp);
drivers/cpufreq/pmac64-cpufreq.c:	/* Wait for completion */
drivers/cpufreq/maple-cpufreq.c:#include <linux/completion.h>
drivers/cpufreq/maple-cpufreq.c:	/* Wait for completion */
drivers/cpufreq/cpufreq.c:	init_completion(&policy->kobj_unregister);
drivers/cpufreq/cpufreq.c:	struct completion *cmp;
drivers/cpufreq/cpufreq.c:	wait_for_completion(cmp);
drivers/irqchip/irq-gic-v3.c:/* Wait for completion of a distributor change */
drivers/irqchip/irq-gic-v3.c:/* Wait for completion of a redistributor change */
drivers/irqchip/alphascale_asm9260-icoll.h: * indicate the completion of an interrupt on a specific level.
drivers/irqchip/irq-gic-v3-its.c:static void its_wait_for_range_completion(struct its_node *its,
drivers/irqchip/irq-gic-v3-its.c:	its_wait_for_range_completion(its, cmd, next_cmd);
drivers/ide/ide-tape.c:#include <linux/completion.h>
drivers/ide/ide-tape.c: * queue and wait for their completion.
drivers/ide/ide-tape.c:	 * switched from completion mode to buffer available mode.  No
drivers/ide/ide-tape.c: * queue requests here and wait for their completion.
drivers/ide/ide-probe.c:		init_completion(&drive->gendev_rel_comp);
drivers/ide/ide-probe.c:	init_completion(&hwif->gendev_rel_comp);
drivers/ide/ide-probe.c:		wait_for_completion(&drive->gendev_rel_comp);
drivers/ide/ide-probe.c:	wait_for_completion(&hwif->gendev_rel_comp);
drivers/ide/ide-io.c:#include <linux/completion.h>
drivers/ide/ide-io.c: *	be accidentally invoked as a result of any valid command completion
drivers/ide/ide.c:#include <linux/completion.h>
drivers/ide/ide-dma.c: *	after the completion of each use of ide_build_dmatable and before
drivers/ide/ide-proc.c: *	to the driver to change settings, and then wait on a sema for completion.
drivers/ide/pmac.c: * a read on KeyLargo ATA/66 and mark us as waiting for DMA completion
drivers/ide/ide-pm.c:	wait_for_completion_io(&wait);
drivers/ide/ide-eh.c: * atapi_reset_pollfunc() gets invoked to poll the interface for completion
drivers/ide/ide-eh.c: * reset_pollfunc() gets invoked to poll the interface for completion every 50ms
drivers/ide/ide-cd.c:#include <linux/completion.h>
drivers/ps3/ps3av.c:	struct completion done;
drivers/ps3/ps3av.c:	wait_for_completion(&ps3av->done);
drivers/ps3/ps3av.c:	init_completion(&ps3av->done);
drivers/ps3/ps3stor_lib.c:	init_completion(&dev->done);
drivers/ps3/ps3stor_lib.c:	wait_for_completion(&dev->done);
drivers/ps3/ps3stor_lib.c:	init_completion(&dev->done);
drivers/ps3/ps3stor_lib.c:	wait_for_completion(&dev->done);
drivers/s390/cio/chp.c:/* Wait queue for configure completion events. */
drivers/s390/cio/device_ops.c:#include <linux/completion.h>
drivers/s390/cio/eadm_sch.h:#include <linux/completion.h>
drivers/s390/cio/eadm_sch.h:	struct completion *completion;
drivers/s390/cio/device_fsm.c:	/* states to wait for i/o completion before doing something */
drivers/s390/cio/chsc_sch.h:	struct completion completion;
drivers/s390/cio/eadm_sch.c:#include <linux/completion.h>
drivers/s390/cio/eadm_sch.c:	if (private->completion)
drivers/s390/cio/eadm_sch.c:		complete(private->completion);
drivers/s390/cio/eadm_sch.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/s390/cio/eadm_sch.c:	private->completion = &completion;
drivers/s390/cio/eadm_sch.c:	wait_for_completion_io(&completion);
drivers/s390/cio/eadm_sch.c:	private->completion = NULL;
drivers/s390/cio/device_pgid.c:	struct completion done;
drivers/s390/cio/device_pgid.c:	init_completion(&data.done);
drivers/s390/cio/device_pgid.c:	if (wait_for_completion_interruptible(&data.done)) {
drivers/s390/cio/device_pgid.c:		wait_for_completion(&data.done);
drivers/s390/cio/device.h:	/* states to wait for i/o completion before doing something */
drivers/s390/cio/cio.c:		 * useless to wait for request completion
drivers/s390/cio/chsc_sch.c:	complete(&request->completion);
drivers/s390/cio/chsc_sch.c:		complete(&private->request->completion);
drivers/s390/cio/chsc_sch.c:	init_completion(&request->completion);
drivers/s390/cio/chsc_sch.c:		wait_for_completion(&request->completion);
drivers/s390/cio/chsc_sch.c:	init_completion(&on_close_request->completion);
drivers/s390/cio/chsc_sch.c:		wait_for_completion(&on_close_request->completion);
drivers/s390/net/lcs.c:	/* Asynchronous halt initialted. Wait for its completion. */
drivers/s390/net/lcs.h:	/* Callback for completion notification. */
drivers/s390/net/lcs.h:	/* Callback for completion notification. */
drivers/s390/net/qeth_core_main.c:	dev_err(&card->gdev->dev, "Failed to create completion queue\n");
drivers/s390/net/qeth_core_main.c:	/* completion */
drivers/s390/net/qeth_core_main.c:	/* completion */
drivers/s390/net/qeth_core.h:	 * outbound: found in completion queue
drivers/s390/net/qeth_core.h:	 * outbound: handled via transfer pending / completion queue
drivers/s390/crypto/zcrypt_msgtype50.c:	complete((struct completion *) msg->private);
drivers/s390/crypto/zcrypt_msgtype50.c:	struct completion work;
drivers/s390/crypto/zcrypt_msgtype50.c:	init_completion(&work);
drivers/s390/crypto/zcrypt_msgtype50.c:	rc = wait_for_completion_interruptible(&work);
drivers/s390/crypto/zcrypt_msgtype50.c:	struct completion work;
drivers/s390/crypto/zcrypt_msgtype50.c:	init_completion(&work);
drivers/s390/crypto/zcrypt_msgtype50.c:	rc = wait_for_completion_interruptible(&work);
drivers/s390/crypto/ap_bus.c: * ap_sm_reset_wait(): Test queue for completion of the reset operation
drivers/s390/crypto/ap_bus.c: * ap_sm_setirq_wait(): Test queue for completion of the irq enablement
drivers/s390/crypto/zcrypt_msgtype6.c:	struct completion work;
drivers/s390/crypto/zcrypt_msgtype6.c:	init_completion(&resp_type.work);
drivers/s390/crypto/zcrypt_msgtype6.c:	rc = wait_for_completion_interruptible(&resp_type.work);
drivers/s390/crypto/zcrypt_msgtype6.c:	init_completion(&resp_type.work);
drivers/s390/crypto/zcrypt_msgtype6.c:	rc = wait_for_completion_interruptible(&resp_type.work);
drivers/s390/crypto/zcrypt_msgtype6.c:	init_completion(&resp_type.work);
drivers/s390/crypto/zcrypt_msgtype6.c:	rc = wait_for_completion_interruptible(&resp_type.work);
drivers/s390/crypto/zcrypt_msgtype6.c:	init_completion(&resp_type.work);
drivers/s390/crypto/zcrypt_msgtype6.c:	rc = wait_for_completion_interruptible(&resp_type.work);
drivers/s390/crypto/zcrypt_msgtype6.c:	init_completion(&resp_type.work);
drivers/s390/crypto/zcrypt_msgtype6.c:	rc = wait_for_completion_interruptible(&resp_type.work);
drivers/s390/crypto/zcrypt_pcixcc.c:	struct completion work;
drivers/s390/scsi/zfcp_erp.c: * zfcp_erp_lun_shutdown_wait - Shutdown LUN and wait for erp completion
drivers/s390/scsi/zfcp_erp.c: * zfcp_erp_wait - wait for completion of error recovery on an adapter
drivers/s390/scsi/zfcp_erp.c: * @adapter: adapter for which to wait for completion of its error recovery
drivers/s390/scsi/zfcp_fsf.c: * zfcp_fsf_req_complete - process completion of a FSF request
drivers/s390/scsi/zfcp_fsf.c: * is called to process the completion status and trigger further
drivers/s390/scsi/zfcp_fsf.c:		complete(&req->completion);
drivers/s390/scsi/zfcp_fsf.c:	init_completion(&req->completion);
drivers/s390/scsi/zfcp_fsf.c:		wait_for_completion(&req->completion);
drivers/s390/scsi/zfcp_fsf.c:		wait_for_completion(&req->completion);
drivers/s390/scsi/zfcp_fsf.c:	wake_up(&wka_port->completion_wq);
drivers/s390/scsi/zfcp_fsf.c:	wake_up(&wka_port->completion_wq);
drivers/s390/scsi/zfcp_fc.c:	wait_event(wka_port->completion_wq,
drivers/s390/scsi/zfcp_fc.c:		wake_up(&wka_port->completion_wq);
drivers/s390/scsi/zfcp_fc.c:	init_waitqueue_head(&wka_port->completion_wq);
drivers/s390/scsi/zfcp_fc.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/s390/scsi/zfcp_fc.c:	fc_req->ct_els.handler_data = &completion;
drivers/s390/scsi/zfcp_fc.c:		wait_for_completion(&completion);
drivers/s390/scsi/zfcp_fc.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/s390/scsi/zfcp_fc.c:	ct_els->handler_data = &completion;
drivers/s390/scsi/zfcp_fc.c:		wait_for_completion(&completion);
drivers/s390/scsi/zfcp_fc.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/s390/scsi/zfcp_fc.c:	ct_els->handler_data = &completion;
drivers/s390/scsi/zfcp_fc.c:	wait_for_completion(&completion);
drivers/s390/scsi/zfcp_fc.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/s390/scsi/zfcp_fc.c:	ct_els->handler_data = &completion;
drivers/s390/scsi/zfcp_fc.c:		wait_for_completion(&completion);
drivers/s390/scsi/zfcp_fc.h: * @completion_wq: Wait for completion of open/close command
drivers/s390/scsi/zfcp_fc.h:	wait_queue_head_t	completion_wq;
drivers/s390/scsi/zfcp_dbf.h: * zfcp_dbf_hba_fsf_response - trace event for request completion
drivers/s390/scsi/zfcp_dbf.h: * zfcp_dbf_scsi_result - trace event for SCSI command completion
drivers/s390/scsi/zfcp_def.h:						      completion races */
drivers/s390/scsi/zfcp_def.h: * @completion: used to signal the completion of the request
drivers/s390/scsi/zfcp_def.h:	struct completion	completion;
drivers/s390/scsi/zfcp_scsi.c:	/* avoid race condition between late normal completion and abort */
drivers/s390/scsi/zfcp_scsi.c:		return FAILED; /* completion could be in progress */
drivers/s390/scsi/zfcp_scsi.c:	wait_for_completion(&abrt_req->completion);
drivers/s390/scsi/zfcp_scsi.c:	wait_for_completion(&fsf_req->completion);
drivers/s390/char/sclp_vt220.c: * buffer should be converted to 0x0a 0x0d. After completion, return the number
drivers/s390/char/diag_ftp.c: *    for completion (asynchronous execution).
drivers/s390/char/diag_ftp.c:	init_completion(&diag_ftp_rx_complete);
drivers/s390/char/diag_ftp.c:	wait_for_completion(&diag_ftp_rx_complete);
drivers/s390/char/sclp_async.c: * records which waits for send completion
drivers/s390/char/vmur.h:	struct completion *io_done;	/* do_ur_io waits; irq completes */
drivers/s390/char/tape_core.c: * tape is idle and wait uninterruptible for its completion.
drivers/s390/char/tape_core.c:	/* Request added to the queue. Wait for its completion. */
drivers/s390/char/tape_core.c: * tape is idle and wait uninterruptible for its completion.
drivers/s390/char/tape_core.c:	/* Request added to the queue. Wait for its completion. */
drivers/s390/char/tape_core.c:		/* Upon normal completion the device _is_ online */
drivers/s390/char/tape_core.c:			/* Upon normal completion the device _is_ online */
drivers/s390/char/tty3270.c: * Write request completion callback.
drivers/s390/char/tty3270.c: * Read request completion callback.
drivers/s390/char/sclp_rw.c: * interruption indicating completion of Service Call.
drivers/s390/char/sclp_rw.c:		/* Normal completion, buffer processed, message(s) sent */
drivers/s390/char/sclp_pci.c:#include <linux/completion.h>
drivers/s390/char/sclp_pci.c:	struct completion *completion = data;
drivers/s390/char/sclp_pci.c:	complete(completion);
drivers/s390/char/sclp_pci.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/s390/char/sclp_pci.c:	req.callback_data = &completion;
drivers/s390/char/sclp_pci.c:	wait_for_completion(&completion);
drivers/s390/char/sclp_sdias.c:#include <linux/completion.h>
drivers/s390/char/sclp_sdias.c:		/* initiated, wait for completion of service call */
drivers/s390/char/sclp_sdias.c:		wait_for_completion(&evbuf_accepted);
drivers/s390/char/sclp_sdias.c:		/* otherwise we wait for completion */
drivers/s390/char/sclp_sdias.c:		wait_for_completion(&evbuf_done);
drivers/s390/char/sclp_quiesce.c:/* Shutdown handler. Signal completion of shutdown by loading special PSW. */
drivers/s390/char/sclp_ftp.c:	struct completion *completion = data;
drivers/s390/char/sclp_ftp.c:	complete(completion);
drivers/s390/char/sclp_ftp.c:	struct completion completion;
drivers/s390/char/sclp_ftp.c:	req->callback_data = &completion;
drivers/s390/char/sclp_ftp.c:	init_completion(&completion);
drivers/s390/char/sclp_ftp.c:	wait_for_completion(&completion);
drivers/s390/char/sclp_ftp.c:	 * asynchronously and the completion is indicated with an
drivers/s390/char/sclp_ftp.c:	init_completion(&sclp_ftp_rx_complete);
drivers/s390/char/sclp_ftp.c:	wait_for_completion(&sclp_ftp_rx_complete);
drivers/s390/char/vmur.c: * on a completion event it publishes at urd->io_done. The function
drivers/s390/char/vmur.c:	wait_for_completion(&event);
drivers/s390/char/vmur.c: * cc=0  normal completion, we have a real device
drivers/s390/char/vmur.c: * cc=0  normal completion
drivers/s390/char/vmur.c: * cc=0  normal completion
drivers/s390/char/vmur.c: * cc=0  normal completion
drivers/s390/char/sclp.c:#include <linux/completion.h>
drivers/s390/char/sclp.c:	init_completion(&sclp_request_queue_flushed);
drivers/s390/char/sclp.c:		wait_for_completion(&sclp_request_queue_flushed);
drivers/s390/char/fs3270.c:			/* Started successfully. Now wait for completion. */
drivers/s390/char/con3270.c: * Write completion callback.
drivers/s390/char/con3270.c: * Read request completion callback.
drivers/s390/char/sclp_cpi_sys.c:#include <linux/completion.h>
drivers/s390/char/sclp_cpi_sys.c:	struct completion *completion = data;
drivers/s390/char/sclp_cpi_sys.c:	complete(completion);
drivers/s390/char/sclp_cpi_sys.c:	struct completion completion;
drivers/s390/char/sclp_cpi_sys.c:	init_completion(&completion);
drivers/s390/char/sclp_cpi_sys.c:	req->callback_data = &completion;
drivers/s390/char/sclp_cpi_sys.c:	wait_for_completion(&completion);
drivers/s390/char/sclp_cmd.c:#include <linux/completion.h>
drivers/s390/char/sclp_cmd.c:	struct completion *completion = data;
drivers/s390/char/sclp_cmd.c:	complete(completion);
drivers/s390/char/sclp_cmd.c:	struct completion completion;
drivers/s390/char/sclp_cmd.c:	request->callback_data = &completion;
drivers/s390/char/sclp_cmd.c:	init_completion(&completion);
drivers/s390/char/sclp_cmd.c:	wait_for_completion(&completion);
drivers/s390/char/sclp_cmd.c: * and wait for completion. On success return 0. Return non-zero otherwise.
drivers/s390/char/sclp_cmd.c: * Perform read channel-path information sclp command and wait for completion.
drivers/s390/block/dcssblk.c:#include <linux/completion.h>
drivers/s390/block/dasd.c: * uses this to start a ccw that detects the format. The completion
drivers/s390/block/dasd.c: * it's completion.
drivers/s390/block/dasd.c: * Start requests from a ccw_queue and wait for their completion.
drivers/s390/block/dasd.c: * interruptible for it's completion.
drivers/s390/block/dasd.c:		req->completion_data = cqr;
drivers/s390/block/dasd.c:	struct dasd_ccw_req *cqr = req->completion_data;
drivers/s390/block/dasd.c:		/* schedule device tasklet and wait for completion */
drivers/s390/block/dasd_alias.c:	init_completion(&lcu->lcu_setup);
drivers/s390/block/dasd_eckd.h:	struct completion lcu_setup;
drivers/ata/sata_dwc_460ex.c:	 * tags we have gotten a completion interrupt.  One interrupt may serve
drivers/ata/sata_dwc_460ex.c:	 * as completion for more than one operation when commands are queued
drivers/ata/sata_dwc_460ex.c:		/* To be picked up by completion functions */
drivers/ata/sata_inic162x.c:	PIRQ_COMPLETE		= (1 << 2),  /* completion interrupt */
drivers/ata/libata-eh.c: *	Handles SCSI layer timeout.  We race with normal completion of
drivers/ata/libata-eh.c:	/* If we timed raced normal completion and there is nothing to
drivers/ata/libata-eh.c:	 * normal completion, error completion, and SCSI timeout.
drivers/ata/libata-eh.c:	 * Both completions can race against SCSI timeout.  When normal
drivers/ata/libata-eh.c:	 * completion wins, the qc never reaches EH.  When error
drivers/ata/libata-eh.c:	 * completion wins, the qc has ATA_QCFLAG_FAILED set.
drivers/ata/libata-eh.c:	 * Normal or error completion can occur after the timeout but
drivers/ata/libata-eh.c:	 * completions are honored.  A scmd is determined to have
drivers/ata/libata-eh.c:		   this as if normal completion won the race */
drivers/ata/libata-eh.c:				/* Normal completion occurred after
drivers/ata/libata-eh.c:		 * point but before EH completion, SCSI midlayer will
drivers/ata/libata-eh.c:	ehc->last_reset = jiffies;		/* update to completion time */
drivers/ata/libata-eh.c:	 * through reinit_completion() (see below) or complete_all()
drivers/ata/libata-eh.c:	 * wait_for_completion_timeout(), another ATA_EH_PARK action
drivers/ata/libata-eh.c:	reinit_completion(&ap->park_req_pending);
drivers/ata/libata-eh.c:		deadline = wait_for_completion_timeout(&ap->park_req_pending,
drivers/ata/libata-sff.c:	 * For normal completion, qc->result_tf is not relevant. For
drivers/ata/libata-sff.c:				 * sff_irq_clear() w/o racing with completion.
drivers/ata/libata-sff.c: *	@r_err: Value of error register on completion
drivers/ata/pata_pxa.c:#include <linux/completion.h>
drivers/ata/pata_pxa.c:	struct completion	dma_done;
drivers/ata/pata_pxa.c:	init_completion(&pd->dma_done);
drivers/ata/pata_pxa.c:	    wait_for_completion_timeout(&pd->dma_done, HZ))
drivers/ata/pata_pxa.c:		ata_dev_err(qc->dev, "Timeout waiting for DMA completion!");
drivers/ata/libata-scsi.c:	/* handle completion from new EH */
drivers/ata/libata-scsi.c:	/* successful completion or old EH failure path */
drivers/ata/sata_nv.c:		 * statuses, so that any CPB completions after this
drivers/ata/ahci_xgene.c: * Waits for completion of multiple commands and restarts
drivers/ata/ahci_xgene.c:	 * completion of outstanding IDENTIFY DEVICE commands before
drivers/ata/ahci_xgene.c: * a mismatch and results in command completion failure. The
drivers/ata/ahci_xgene.c: * a mismatch and results in command completion failure. The workaround
drivers/ata/ahci_xgene.c: * a mismatch and results in command completion failure. The workaround
drivers/ata/pata_octeon_cf.c:	 * If the port is not waiting for completion, it must have
drivers/ata/libata-core.c:#include <linux/completion.h>
drivers/ata/libata-core.c:	struct completion *waiting = qc->private_data;
drivers/ata/libata-core.c:	rc = wait_for_completion_timeout(&wait, msecs_to_jiffies(timeout));
drivers/ata/libata-core.c:	/* command should be marked inactive atomically with qc completion */
drivers/ata/libata-core.c:	/* call completion callback */
drivers/ata/libata-core.c:	 * Old EH depends on ata_qc_complete() nullifying completion
drivers/ata/libata-core.c:		 * completion.
drivers/ata/libata-core.c:	init_completion(&ap->park_req_pending);
drivers/ata/libahci.c:	/* wait for completion, spec says 500ms, give it 1000 */
drivers/ata/libahci.c:	/* while resetting, invalid completions are expected */
drivers/ata/libahci.c:	 * in completion path to determine whether NCQ phase is in
drivers/ata/sata_sx4.c:	/* command completion, but no data xfer */
drivers/ata/sata_mv.c:				cfg |= (1 << 18); /* enab early completion */
drivers/ata/sata_mv.c: *	Note: we don't get updated shadow regs on *completion*
drivers/ata/sata_mv.c:	 *   MSB is saved ATA status from command completion.
drivers/ata/pata_arasan_cf.c:#include <linux/completion.h>
drivers/ata/pata_arasan_cf.c:	struct completion cf_completion;
drivers/ata/pata_arasan_cf.c:	struct completion dma_completion;
drivers/ata/pata_arasan_cf.c:	complete(&acdev->dma_completion);
drivers/ata/pata_arasan_cf.c:	if (!wait_for_completion_timeout(&acdev->cf_completion, TIMEOUT)) {
drivers/ata/pata_arasan_cf.c:	if (!wait_for_completion_timeout(&acdev->dma_completion, TIMEOUT)) {
drivers/ata/pata_arasan_cf.c:		dev_err(acdev->host->dev, "wait_for_completion_timeout\n");
drivers/ata/pata_arasan_cf.c:		complete(&acdev->cf_completion);
drivers/ata/pata_arasan_cf.c:		complete(&acdev->cf_completion);
drivers/ata/pata_arasan_cf.c:			complete(&acdev->cf_completion);
drivers/ata/pata_arasan_cf.c:	init_completion(&acdev->cf_completion);
drivers/ata/pata_arasan_cf.c:	init_completion(&acdev->dma_completion);
drivers/ata/sata_sil24.c:	PRB_CTRL_NIEN		= (1 << 6), /* Mask completion irq */
drivers/ata/sata_sil24.c:	/* temporarily plug completion and error interrupts */
drivers/ata/sata_sil24.c:	/* apply workaround for completion IRQ loss on PCI-X errata */
drivers/ata/sata_sil24.c:				 "Applying completion IRQ loss on PCI-X errata fix\n");
drivers/fpga/socfpga.c:#include <linux/completion.h>
drivers/fpga/socfpga.c:	struct completion status_complete;
drivers/fpga/socfpga.c:	init_completion(&priv->status_complete);
drivers/fpga/socfpga.c:	timeout = wait_for_completion_interruptible_timeout(
drivers/fpga/zynq-fpga.c:#include <linux/completion.h>
drivers/fpga/zynq-fpga.c:	struct completion dma_done;
drivers/fpga/zynq-fpga.c:	reinit_completion(&priv->dma_done);
drivers/fpga/zynq-fpga.c:	wait_for_completion(&priv->dma_done);
drivers/fpga/zynq-fpga.c:	init_completion(&priv->dma_done);
drivers/iio/pressure/zpa2326.c: * pressure samples only). Measurement cycle completion may be signaled by a
drivers/iio/pressure/zpa2326.c: * @result:     Allows sampling logic to get completion status of operations
drivers/iio/pressure/zpa2326.c: *              operation completion.
drivers/iio/pressure/zpa2326.c: *              to detect completion.
drivers/iio/pressure/zpa2326.c:	struct completion               data_ready;
drivers/iio/pressure/zpa2326.c:	 *   - or oneshot completion polling machinery : see
drivers/iio/pressure/zpa2326.c: * completion, in which case we must simply wake it up.
drivers/iio/pressure/zpa2326.c: * zpa2326_wait_oneshot_completion() - Wait for oneshot data ready interrupt.
drivers/iio/pressure/zpa2326.c:static int zpa2326_wait_oneshot_completion(const struct iio_dev   *indio_dev,
drivers/iio/pressure/zpa2326.c:	zpa2326_dbg(indio_dev, "waiting for one shot completion interrupt");
drivers/iio/pressure/zpa2326.c:	ret = wait_for_completion_interruptible_timeout(
drivers/iio/pressure/zpa2326.c:	init_completion(&private->data_ready);
drivers/iio/pressure/zpa2326.c: * zpa2326_poll_oneshot_completion() - Actively poll for one shot data ready.
drivers/iio/pressure/zpa2326.c:static int zpa2326_poll_oneshot_completion(const struct iio_dev *indio_dev)
drivers/iio/pressure/zpa2326.c:	zpa2326_dbg(indio_dev, "polling for one shot completion");
drivers/iio/pressure/zpa2326.c:	/* Poll for conversion completion in hardware. */
drivers/iio/pressure/zpa2326.c:	zpa2326_warn(indio_dev, "failed to poll one shot completion (%d)", err);
drivers/iio/pressure/zpa2326.c:		ret = zpa2326_wait_oneshot_completion(indio_dev, priv);
drivers/iio/pressure/zpa2326.c:		ret = zpa2326_poll_oneshot_completion(indio_dev);
drivers/iio/pressure/zpa2326.c:			/* No interrupt available: poll for completion. */
drivers/iio/pressure/zpa2326.c:			if (zpa2326_poll_oneshot_completion(indio_dev))
drivers/iio/pressure/zpa2326.c:			if (zpa2326_wait_oneshot_completion(indio_dev, priv))
drivers/iio/pressure/bmp280-core.c:#include <linux/completion.h>
drivers/iio/pressure/bmp280-core.c:	struct completion done;
drivers/iio/pressure/bmp280-core.c:		init_completion(&data->done);
drivers/iio/pressure/bmp280-core.c:		 * If we have a completion interrupt, use it, wait up to
drivers/iio/pressure/bmp280-core.c:		ret = wait_for_completion_timeout(&data->done,
drivers/iio/pressure/bmp280-core.c:			dev_err(data->dev, "timeout waiting for completion\n");
drivers/iio/magnetometer/ak8974.c:#include <linux/completion.h>
drivers/iio/magnetometer/ak8974.c: * @drdy_complete: completion for DRDY
drivers/iio/magnetometer/ak8974.c:	struct completion drdy_complete;
drivers/iio/magnetometer/ak8974.c:		init_completion(&ak8974->drdy_complete);
drivers/iio/magnetometer/ak8974.c:		ret = wait_for_completion_timeout(&ak8974->drdy_complete,
drivers/iio/humidity/dht11.c:#include <linux/completion.h>
drivers/iio/humidity/dht11.c:	struct completion		completion;
drivers/iio/humidity/dht11.c:			complete(&dht11->completion);
drivers/iio/humidity/dht11.c:		reinit_completion(&dht11->completion);
drivers/iio/humidity/dht11.c:		ret = wait_for_completion_killable_timeout(&dht11->completion,
drivers/iio/humidity/dht11.c:	init_completion(&dht11->completion);
drivers/iio/proximity/sx9500.c:	struct completion completion;
drivers/iio/proximity/sx9500.c:		ret = wait_for_completion_interruptible(&data->completion);
drivers/iio/proximity/sx9500.c:	reinit_completion(&data->completion);
drivers/iio/proximity/sx9500.c:		complete(&data->completion);
drivers/iio/proximity/sx9500.c:	init_completion(&data->completion);
drivers/iio/adc/ad_sigma_delta.c:	reinit_completion(&sigma_delta->completion);
drivers/iio/adc/ad_sigma_delta.c:	ret = wait_for_completion_timeout(&sigma_delta->completion, 2*HZ);
drivers/iio/adc/ad_sigma_delta.c:	reinit_completion(&sigma_delta->completion);
drivers/iio/adc/ad_sigma_delta.c:	ret = wait_for_completion_interruptible_timeout(
drivers/iio/adc/ad_sigma_delta.c:			&sigma_delta->completion, HZ);
drivers/iio/adc/ad_sigma_delta.c:	reinit_completion(&sigma_delta->completion);
drivers/iio/adc/ad_sigma_delta.c:	wait_for_completion_timeout(&sigma_delta->completion, HZ);
drivers/iio/adc/ad_sigma_delta.c:	complete(&sigma_delta->completion);
drivers/iio/adc/ad_sigma_delta.c:	init_completion(&sigma_delta->completion);
drivers/iio/adc/palmas_gpadc.c:#include <linux/completion.h>
drivers/iio/adc/palmas_gpadc.c:	struct completion		conv_completion;
drivers/iio/adc/palmas_gpadc.c:	complete(&adc->conv_completion);
drivers/iio/adc/palmas_gpadc.c:	init_completion(&adc->conv_completion);
drivers/iio/adc/palmas_gpadc.c:	ret = wait_for_completion_timeout(&adc->conv_completion,
drivers/iio/adc/palmas_gpadc.c:	init_completion(&adc->conv_completion);
drivers/iio/adc/xilinx-xadc-core.c:	reinit_completion(&xadc->completion);
drivers/iio/adc/xilinx-xadc-core.c:	ret = wait_for_completion_interruptible_timeout(&xadc->completion, HZ);
drivers/iio/adc/xilinx-xadc-core.c:	reinit_completion(&xadc->completion);
drivers/iio/adc/xilinx-xadc-core.c:	ret = wait_for_completion_interruptible_timeout(&xadc->completion, HZ);
drivers/iio/adc/xilinx-xadc-core.c:		complete(&xadc->completion);
drivers/iio/adc/xilinx-xadc-core.c:	init_completion(&xadc->completion);
drivers/iio/adc/fsl-imx25-gcq.c:	struct completion completed;
drivers/iio/adc/fsl-imx25-gcq.c:	timeout = wait_for_completion_interruptible_timeout(
drivers/iio/adc/fsl-imx25-gcq.c:	init_completion(&priv->completed);
drivers/iio/adc/ti-adc12138.c:#include <linux/completion.h>
drivers/iio/adc/ti-adc12138.c:	struct completion complete;
drivers/iio/adc/ti-adc12138.c:	if (!wait_for_completion_timeout(&adc->complete, timeout))
drivers/iio/adc/ti-adc12138.c:	reinit_completion(&adc->complete);
drivers/iio/adc/ti-adc12138.c:	reinit_completion(&adc->complete);
drivers/iio/adc/ti-adc12138.c:		reinit_completion(&adc->complete);
drivers/iio/adc/ti-adc12138.c:	init_completion(&adc->complete);
drivers/iio/adc/twl6030-gpadc.c: * @irq_complete:	completion to signal end of conversion
drivers/iio/adc/twl6030-gpadc.c:	struct completion	irq_complete;
drivers/iio/adc/twl6030-gpadc.c:	timeout = wait_for_completion_interruptible_timeout(
drivers/iio/adc/twl6030-gpadc.c:	init_completion(&gpadc->irq_complete);
drivers/iio/adc/xilinx-xadc.h:	struct completion completion;
drivers/iio/adc/qcom-spmi-vadc.c:#include <linux/completion.h>
drivers/iio/adc/qcom-spmi-vadc.c:	struct completion	 complete;
drivers/iio/adc/qcom-spmi-vadc.c:		reinit_completion(&vadc->complete);
drivers/iio/adc/qcom-spmi-vadc.c:		ret = wait_for_completion_timeout(&vadc->complete, timeout);
drivers/iio/adc/qcom-spmi-vadc.c:	init_completion(&vadc->complete);
drivers/iio/adc/qcom-spmi-iadc.c:#include <linux/completion.h>
drivers/iio/adc/qcom-spmi-iadc.c:	struct completion complete;
drivers/iio/adc/qcom-spmi-iadc.c:		reinit_completion(&iadc->complete);
drivers/iio/adc/qcom-spmi-iadc.c:		ret = wait_for_completion_timeout(&iadc->complete,
drivers/iio/adc/qcom-spmi-iadc.c:	init_completion(&iadc->complete);
drivers/iio/adc/imx7d_adc.c:#include <linux/completion.h>
drivers/iio/adc/imx7d_adc.c:	struct completion completion;
drivers/iio/adc/imx7d_adc.c:		reinit_completion(&info->completion);
drivers/iio/adc/imx7d_adc.c:		ret = wait_for_completion_interruptible_timeout
drivers/iio/adc/imx7d_adc.c:				(&info->completion, IMX7D_ADC_TIMEOUT);
drivers/iio/adc/imx7d_adc.c:		complete(&info->completion);
drivers/iio/adc/imx7d_adc.c:	init_completion(&info->completion);
drivers/iio/adc/rockchip_saradc.c:#include <linux/completion.h>
drivers/iio/adc/rockchip_saradc.c:	struct completion	completion;
drivers/iio/adc/rockchip_saradc.c:		reinit_completion(&info->completion);
drivers/iio/adc/rockchip_saradc.c:		if (!wait_for_completion_timeout(&info->completion,
drivers/iio/adc/rockchip_saradc.c:	complete(&info->completion);
drivers/iio/adc/rockchip_saradc.c:	init_completion(&info->completion);
drivers/iio/adc/bcm_iproc_adc.c:	struct completion completion;
drivers/iio/adc/bcm_iproc_adc.c:				complete(&adc_priv->completion);
drivers/iio/adc/bcm_iproc_adc.c:	reinit_completion(&adc_priv->completion);
drivers/iio/adc/bcm_iproc_adc.c:	if (wait_for_completion_timeout(&adc_priv->completion,
drivers/iio/adc/bcm_iproc_adc.c:	init_completion(&adc_priv->completion);
drivers/iio/adc/stx104.c:		/* trigger ADC sample capture and wait for completion */
drivers/iio/adc/nau7802.c:	struct completion	value_ok;
drivers/iio/adc/nau7802.c:	reinit_completion(&st->value_ok);
drivers/iio/adc/nau7802.c:	ret = wait_for_completion_interruptible_timeout(&st->value_ok,
drivers/iio/adc/nau7802.c:	init_completion(&st->value_ok);
drivers/iio/adc/da9150-gpadc.c:#include <linux/completion.h>
drivers/iio/adc/da9150-gpadc.c:	struct completion complete;
drivers/iio/adc/da9150-gpadc.c:	/* Consume left-over completion from a previous timeout */
drivers/iio/adc/da9150-gpadc.c:	try_wait_for_completion(&gpadc->complete);
drivers/iio/adc/da9150-gpadc.c:	/* Check for actual completion */
drivers/iio/adc/da9150-gpadc.c:	wait_for_completion_timeout(&gpadc->complete, msecs_to_jiffies(5));
drivers/iio/adc/da9150-gpadc.c:	init_completion(&gpadc->complete);
drivers/iio/adc/mxs-lradc.c:#include <linux/completion.h>
drivers/iio/adc/mxs-lradc.c:	struct completion	completion;
drivers/iio/adc/mxs-lradc.c:	reinit_completion(&lradc->completion);
drivers/iio/adc/mxs-lradc.c:	/* Wait for completion on the channel, 1 second max. */
drivers/iio/adc/mxs-lradc.c:	ret = wait_for_completion_killable_timeout(&lradc->completion, HZ);
drivers/iio/adc/mxs-lradc.c:		complete(&lradc->completion);
drivers/iio/adc/mxs-lradc.c:	init_completion(&lradc->completion);
drivers/iio/adc/vf610_adc.c:#include <linux/completion.h>
drivers/iio/adc/vf610_adc.c:	struct completion completion;
drivers/iio/adc/vf610_adc.c:	if (!wait_for_completion_timeout(&info->completion, VF610_ADC_TIMEOUT))
drivers/iio/adc/vf610_adc.c:			complete(&info->completion);
drivers/iio/adc/vf610_adc.c:		reinit_completion(&info->completion);
drivers/iio/adc/vf610_adc.c:		ret = wait_for_completion_interruptible_timeout
drivers/iio/adc/vf610_adc.c:				(&info->completion, VF610_ADC_TIMEOUT);
drivers/iio/adc/vf610_adc.c:	init_completion(&info->completion);
drivers/iio/adc/exynos_adc.c:#include <linux/completion.h>
drivers/iio/adc/exynos_adc.c:	struct completion	completion;
drivers/iio/adc/exynos_adc.c:	reinit_completion(&info->completion);
drivers/iio/adc/exynos_adc.c:	timeout = wait_for_completion_timeout(&info->completion,
drivers/iio/adc/exynos_adc.c:	reinit_completion(&info->completion);
drivers/iio/adc/exynos_adc.c:	timeout = wait_for_completion_timeout(&info->completion,
drivers/iio/adc/exynos_adc.c:	complete(&info->completion);
drivers/iio/adc/exynos_adc.c:	init_completion(&info->completion);
drivers/iio/common/ssp_sensors/ssp_spi.c:	struct completion *done;
drivers/iio/common/ssp_sensors/ssp_spi.c:			   struct completion *done, int timeout)
drivers/iio/common/ssp_sensors/ssp_spi.c:		if (wait_for_completion_timeout(done,
drivers/iio/common/ssp_sensors/ssp_spi.c:			if (!completion_done(msg->done))
drivers/iio/common/ssp_sensors/ssp_spi.c:			if (!completion_done(msg->done))
drivers/iio/common/ssp_sensors/ssp.h: * @pending_lock:	lock protecting pending list and completion
drivers/parport/parport_ip32.c:#include <linux/completion.h>
drivers/parport/parport_ip32.c:	struct completion		irq_complete;
drivers/parport/parport_ip32.c:		reinit_completion(&priv->irq_complete);
drivers/parport/parport_ip32.c:			wait_for_completion_interruptible_timeout(
drivers/parport/parport_ip32.c:	reinit_completion(&priv->irq_complete);
drivers/parport/parport_ip32.c:		wait_for_completion_interruptible_timeout(&priv->irq_complete,
drivers/parport/parport_ip32.c:	init_completion(&priv->irq_complete);
drivers/pci/hotplug/shpchp_hpc.c:	 * Wait for command completion.
drivers/pci/hotplug/pciehp_hpc.c:	 * completions, we never need to wait between writes.
drivers/pci/hotplug/pciehp_hpc.c:	 * completion notifications unless the power/indicator/interlock
drivers/pci/hotplug/pciehp_hpc.c:	 * timeout message when we wait for completion of commands that
drivers/pci/hotplug/pciehp_hpc.c:	 * indicating completion of the above issued command.
drivers/pci/host/pcie-rockchip.c:			dev_dbg(dev, "overflow occurred in the completion receive FIFO\n");
drivers/pci/host/pcie-rockchip.c:			dev_dbg(dev, "a request timed out waiting for completion\n");
drivers/pci/host/pci-hyperv.c:	void (*completion_func)(void *context, struct pci_response *resp,
drivers/pci/host/pci-hyperv.c:	struct completion *survey_event;
drivers/pci/host/pci-hyperv.c:	struct completion remove_event;
drivers/pci/host/pci-hyperv.c:	struct completion host_event;
drivers/pci/host/pci-hyperv.c:	s32 completion_status;
drivers/pci/host/pci-hyperv.c: * hv_pci_generic_compl() - Invoked for a completion packet
drivers/pci/host/pci-hyperv.c: * for any message for which the completion packet contains a
drivers/pci/host/pci-hyperv.c:		comp_pkt->completion_status = resp->status;
drivers/pci/host/pci-hyperv.c:		comp_pkt->completion_status = -1;
drivers/pci/host/pci-hyperv.c:	comp_pkt->comp_pkt.completion_status = resp->status;
drivers/pci/host/pci-hyperv.c:	init_completion(&comp.comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:	ctxt.pkt.completion_func = hv_pci_compose_compl;
drivers/pci/host/pci-hyperv.c:	wait_for_completion(&comp.comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:	if (comp.comp_pkt.completion_status < 0) {
drivers/pci/host/pci-hyperv.c:			comp.comp_pkt.completion_status);
drivers/pci/host/pci-hyperv.c:	struct completion *event;
drivers/pci/host/pci-hyperv.c:	struct completion host_event;
drivers/pci/host/pci-hyperv.c: * @context:		The completion context.
drivers/pci/host/pci-hyperv.c: * This function is invoked on completion of a Query Resource
drivers/pci/host/pci-hyperv.c:	struct q_res_req_compl *completion = context;
drivers/pci/host/pci-hyperv.c:		dev_err(&completion->hpdev->hbus->hdev->device,
drivers/pci/host/pci-hyperv.c:			completion->hpdev->probed_bar[i] =
drivers/pci/host/pci-hyperv.c:	complete(&completion->host_event);
drivers/pci/host/pci-hyperv.c:	init_completion(&comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:	pkt.init_packet.completion_func = q_resource_requirements;
drivers/pci/host/pci-hyperv.c:	wait_for_completion(&comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:			comp_packet->completion_func(comp_packet->compl_ctxt,
drivers/pci/host/pci-hyperv.c:	init_completion(&comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:	pkt->completion_func = hv_pci_generic_compl;
drivers/pci/host/pci-hyperv.c:	wait_for_completion(&comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:	if (comp_pkt.completion_status < 0) {
drivers/pci/host/pci-hyperv.c:			comp_pkt.completion_status);
drivers/pci/host/pci-hyperv.c:	init_completion(&comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:	pkt->completion_func = hv_pci_generic_compl;
drivers/pci/host/pci-hyperv.c:	wait_for_completion(&comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:	if (comp_pkt.completion_status < 0) {
drivers/pci/host/pci-hyperv.c:			comp_pkt.completion_status);
drivers/pci/host/pci-hyperv.c:	struct completion comp;
drivers/pci/host/pci-hyperv.c:	init_completion(&comp);
drivers/pci/host/pci-hyperv.c:	wait_for_completion(&comp);
drivers/pci/host/pci-hyperv.c:		init_completion(&comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:		pkt->completion_func = hv_pci_generic_compl;
drivers/pci/host/pci-hyperv.c:		wait_for_completion(&comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:		if (comp_pkt.completion_status < 0) {
drivers/pci/host/pci-hyperv.c:				comp_pkt.completion_status);
drivers/pci/host/pci-hyperv.c:	init_completion(&hbus->remove_event);
drivers/pci/host/pci-hyperv.c:	init_completion(&comp_pkt.host_event);
drivers/pci/host/pci-hyperv.c:	pkt.teardown_packet.completion_func = hv_pci_generic_compl;
drivers/pci/host/pci-hyperv.c:		wait_for_completion_timeout(&comp_pkt.host_event, 10 * HZ);
drivers/pci/host/pci-hyperv.c:	wait_for_completion(&hbus->remove_event);
drivers/pci/host/pcie-xilinx.c:		dev_warn(dev, "Slave unexpected completion\n");
drivers/pci/host/pcie-xilinx.c:		dev_warn(dev, "Slave completion timeout\n");
drivers/pci/host/vmd.c: * read-back in this function forces the completion so it returns only after
drivers/pci/host/pcie-rcar.c:	/* Set the completion timer timeout to the maximum 50ms. */
drivers/pci/quirks.c:/* Intel 5000 and 5100 Memory controllers have an errata with read completion
drivers/pci/quirks.c: * until all of the devices are discovered and buses walked, read completion
drivers/pci/quirks.c:		dev_err(&dev->dev, "Error attempting to read the read completion coalescing register\n");
drivers/pci/quirks.c:		dev_err(&dev->dev, "Error attempting to write the read completion coalescing register\n");
drivers/pci/quirks.c:	pr_info_once("Read completion coalescing disabled due to hardware errata relating to 256B MPS\n");
drivers/pci/quirks.c: * If a non-compliant device generates a completion with a different
drivers/pci/quirks.c: * If the non-compliant device generates completions with zero attributes
drivers/pci/quirks.c: * Such devices effectively enable request redirect (RR) and completion
drivers/i2c/algos/i2c-algo-pca.c:#define pca_wait(adap) adap->wait_for_completion(adap->data)
drivers/i2c/busses/i2c-exynos5.c:	struct completion	msg_complete;
drivers/i2c/busses/i2c-exynos5.c:	reinit_completion(&i2c->msg_complete);
drivers/i2c/busses/i2c-exynos5.c:	timeout = wait_for_completion_timeout(&i2c->msg_complete,
drivers/i2c/busses/i2c-exynos5.c:	init_completion(&i2c->msg_complete);
drivers/i2c/busses/i2c-st.c: * @complete: completion of I2C message
drivers/i2c/busses/i2c-st.c:	struct completion	complete;
drivers/i2c/busses/i2c-st.c:	reinit_completion(&i2c_dev->complete);
drivers/i2c/busses/i2c-st.c:	timeout = wait_for_completion_timeout(&i2c_dev->complete,
drivers/i2c/busses/i2c-st.c:	init_completion(&i2c_dev->complete);
drivers/i2c/busses/i2c-pmcmsp.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-pmcmsp.c:	struct completion wait;			/* Completion for xfer */
drivers/i2c/busses/i2c-pmcmsp.c:	init_completion(&pmcmsptwi_data.wait);
drivers/i2c/busses/i2c-pmcmsp.c:		unsigned long timeleft = wait_for_completion_timeout(
drivers/i2c/busses/i2c-efm32.c:	struct completion done;
drivers/i2c/busses/i2c-efm32.c:	reinit_completion(&ddata->done);
drivers/i2c/busses/i2c-efm32.c:	wait_for_completion(&ddata->done);
drivers/i2c/busses/i2c-efm32.c:	init_completion(&ddata->done);
drivers/i2c/busses/i2c-designware-core.h: * @cmd_complete: tx completion indicator
drivers/i2c/busses/i2c-designware-core.h:	struct completion	cmd_complete;
drivers/i2c/busses/i2c-sh7760.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-sh7760.c:	struct completion xfer_done;
drivers/i2c/busses/i2c-sh7760.c:		init_completion(&id->xfer_done);
drivers/i2c/busses/i2c-sh7760.c:		wait_for_completion(&id->xfer_done);
drivers/i2c/busses/i2c-cadence.c:	struct completion xfer_done;
drivers/i2c/busses/i2c-cadence.c:	/* Signal completion only after everything is updated */
drivers/i2c/busses/i2c-cadence.c:	/* When receiving, handle data interrupt and completion interrupt */
drivers/i2c/busses/i2c-cadence.c:		/* Clear hold (if not repeated start) and signal completion */
drivers/i2c/busses/i2c-cadence.c:			 * Signal the completion of transaction and
drivers/i2c/busses/i2c-cadence.c:	reinit_completion(&id->xfer_done);
drivers/i2c/busses/i2c-cadence.c:	/* Wait for the signal of completion */
drivers/i2c/busses/i2c-cadence.c:	time_left = wait_for_completion_timeout(&id->xfer_done, adap->timeout);
drivers/i2c/busses/i2c-cadence.c:				"timeout waiting on completion\n");
drivers/i2c/busses/i2c-cadence.c:		 * This controller does not give completion interrupt after a
drivers/i2c/busses/i2c-cadence.c:	init_completion(&id->xfer_done);
drivers/i2c/busses/i2c-highlander.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-highlander.c:	struct completion	cmd_complete;
drivers/i2c/busses/i2c-highlander.c:		wait_for_completion_timeout(&dev->cmd_complete,
drivers/i2c/busses/i2c-highlander.c:	init_completion(&dev->cmd_complete);
drivers/i2c/busses/i2c-qup.c:	struct completion	xfer;
drivers/i2c/busses/i2c-qup.c:	if (!wait_for_completion_timeout(&qup->xfer, TOUT_MAX * HZ)) {
drivers/i2c/busses/i2c-qup.c:		if (!wait_for_completion_timeout(&qup->xfer, HZ))
drivers/i2c/busses/i2c-qup.c:	left = wait_for_completion_timeout(&qup->xfer, HZ);
drivers/i2c/busses/i2c-qup.c:		reinit_completion(&qup->xfer);
drivers/i2c/busses/i2c-qup.c:	init_completion(&qup->xfer);
drivers/i2c/busses/i2c-brcmstb.c:	struct completion done;
drivers/i2c/busses/i2c-brcmstb.c:/* i2c xfer completion function, handles both irq and polling mode */
drivers/i2c/busses/i2c-brcmstb.c:static int brcmstb_i2c_wait_for_completion(struct brcmstb_i2c_dev *dev)
drivers/i2c/busses/i2c-brcmstb.c:		if (!wait_for_completion_timeout(&dev->done, timeout))
drivers/i2c/busses/i2c-brcmstb.c:/* Send I2C request check completion */
drivers/i2c/busses/i2c-brcmstb.c:		reinit_completion(&dev->done);
drivers/i2c/busses/i2c-brcmstb.c:	rc = brcmstb_i2c_wait_for_completion(dev);
drivers/i2c/busses/i2c-brcmstb.c:	/* Initiate xfer, the function will return on completion */
drivers/i2c/busses/i2c-brcmstb.c:	init_completion(&dev->done);
drivers/i2c/busses/i2c-i801.c: * 1) i801 signals transaction completion with one of these interrupts:
drivers/i2c/busses/i2c-emev2.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-emev2.c:	struct completion msg_done;
drivers/i2c/busses/i2c-emev2.c:	reinit_completion(&priv->msg_done);
drivers/i2c/busses/i2c-emev2.c:	time_left = wait_for_completion_timeout(&priv->msg_done, priv->adap.timeout);
drivers/i2c/busses/i2c-emev2.c:	init_completion(&priv->msg_done);
drivers/i2c/busses/i2c-bcm2835.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-bcm2835.c:	struct completion completion;
drivers/i2c/busses/i2c-bcm2835.c:		complete(&i2c_dev->completion);
drivers/i2c/busses/i2c-bcm2835.c:		complete(&i2c_dev->completion);
drivers/i2c/busses/i2c-bcm2835.c:	reinit_completion(&i2c_dev->completion);
drivers/i2c/busses/i2c-bcm2835.c:	time_left = wait_for_completion_timeout(&i2c_dev->completion,
drivers/i2c/busses/i2c-bcm2835.c:	init_completion(&i2c_dev->completion);
drivers/i2c/busses/i2c-uniphier-f.c:	struct completion comp;
drivers/i2c/busses/i2c-uniphier-f.c:			 * but do not wait for its completion.
drivers/i2c/busses/i2c-uniphier-f.c:	reinit_completion(&priv->comp);
drivers/i2c/busses/i2c-uniphier-f.c:	time_left = wait_for_completion_timeout(&priv->comp, adap->timeout);
drivers/i2c/busses/i2c-uniphier-f.c:	init_completion(&priv->comp);
drivers/i2c/busses/i2c-designware-core.c:	reinit_completion(&dev->cmd_complete);
drivers/i2c/busses/i2c-designware-core.c:	if (!wait_for_completion_timeout(&dev->cmd_complete, adap->timeout)) {
drivers/i2c/busses/i2c-designware-core.c:	init_completion(&dev->cmd_complete);
drivers/i2c/busses/i2c-bcm-kona.c:	struct completion done;
drivers/i2c/busses/i2c-bcm-kona.c:	reinit_completion(&dev->done);
drivers/i2c/busses/i2c-bcm-kona.c:	time_left = wait_for_completion_timeout(&dev->done, time_left);
drivers/i2c/busses/i2c-bcm-kona.c:	reinit_completion(&dev->done);
drivers/i2c/busses/i2c-bcm-kona.c:	time_left = wait_for_completion_timeout(&dev->done, time_left);
drivers/i2c/busses/i2c-bcm-kona.c:	reinit_completion(&dev->done);
drivers/i2c/busses/i2c-bcm-kona.c:	time_left = wait_for_completion_timeout(&dev->done, time_left);
drivers/i2c/busses/i2c-bcm-kona.c:	reinit_completion(&dev->done);
drivers/i2c/busses/i2c-bcm-kona.c:		time_left = wait_for_completion_timeout(&dev->done, time_left);
drivers/i2c/busses/i2c-bcm-kona.c:		dev_err(dev->device, "completion timed out\n");
drivers/i2c/busses/i2c-bcm-kona.c:	init_completion(&dev->done);
drivers/i2c/busses/i2c-pca-platform.c:static int i2c_pca_pf_waitforcompletion(void *pd)
drivers/i2c/busses/i2c-pca-platform.c:	i2c->algo_data.wait_for_completion = i2c_pca_pf_waitforcompletion;
drivers/i2c/busses/i2c-nomadik.c: * @xfer_complete: acknowledge completion for a I2C message.
drivers/i2c/busses/i2c-nomadik.c:	struct completion		xfer_complete;
drivers/i2c/busses/i2c-nomadik.c:	 * On the completion, the I2C internal logic clears these
drivers/i2c/busses/i2c-nomadik.c:	 * should poll on these bits waiting for the completion.
drivers/i2c/busses/i2c-nomadik.c: * master mode. There is a completion timeout. If there is no transfer
drivers/i2c/busses/i2c-nomadik.c:	init_completion(&dev->xfer_complete);
drivers/i2c/busses/i2c-nomadik.c:	timeout = wait_for_completion_timeout(
drivers/i2c/busses/i2c-nomadik.c:	init_completion(&dev->xfer_complete);
drivers/i2c/busses/i2c-nomadik.c:	timeout = wait_for_completion_timeout(
drivers/i2c/busses/i2c-uniphier.c:	struct completion comp;
drivers/i2c/busses/i2c-uniphier.c:	reinit_completion(&priv->comp);
drivers/i2c/busses/i2c-uniphier.c:	time_left = wait_for_completion_timeout(&priv->comp, adap->timeout);
drivers/i2c/busses/i2c-uniphier.c:	init_completion(&priv->comp);
drivers/i2c/busses/i2c-ibm_iic.c:		/* Wait for completion */
drivers/i2c/busses/i2c-davinci.c:	struct completion	cmd_complete;
drivers/i2c/busses/i2c-davinci.c:	struct completion	xfr_complete;
drivers/i2c/busses/i2c-davinci.c:	reinit_completion(&dev->cmd_complete);
drivers/i2c/busses/i2c-davinci.c:	time_left = wait_for_completion_timeout(&dev->cmd_complete,
drivers/i2c/busses/i2c-davinci.c:		wait_for_completion(&dev->xfr_complete);
drivers/i2c/busses/i2c-davinci.c:	init_completion(&dev->cmd_complete);
drivers/i2c/busses/i2c-davinci.c:	init_completion(&dev->xfr_complete);
drivers/i2c/busses/i2c-bfin-twi.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-bfin-twi.c:	init_completion(&(iface->complete));
drivers/i2c/busses/i2c-bfin-twi.c:		if (!wait_for_completion_timeout(&iface->complete,
drivers/i2c/busses/i2c-bfin-twi.c:	init_completion(&(iface->complete));
drivers/i2c/busses/i2c-bfin-twi.c:		if (!wait_for_completion_timeout(&iface->complete,
drivers/i2c/busses/i2c-xgene-slimpro.c:	struct completion rd_complete;
drivers/i2c/busses/i2c-xgene-slimpro.c:		if (!wait_for_completion_timeout(&ctx->rd_complete,
drivers/i2c/busses/i2c-xgene-slimpro.c:		reinit_completion(&ctx->rd_complete);
drivers/i2c/busses/i2c-xgene-slimpro.c:	init_completion(&ctx->rd_complete);
drivers/i2c/busses/i2c-pca-isa.c:static int pca_isa_waitforcompletion(void *pd)
drivers/i2c/busses/i2c-pca-isa.c:	.wait_for_completion	= pca_isa_waitforcompletion,
drivers/i2c/busses/i2c-xlp9xx.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-xlp9xx.c:	struct completion msg_complete;
drivers/i2c/busses/i2c-xlp9xx.c:	reinit_completion(&priv->msg_complete);
drivers/i2c/busses/i2c-xlp9xx.c:	timeleft = wait_for_completion_timeout(&priv->msg_complete, timeleft);
drivers/i2c/busses/i2c-xlp9xx.c:	init_completion(&priv->msg_complete);
drivers/i2c/busses/i2c-jz4780.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-jz4780.c:	struct completion	trans_waitq;
drivers/i2c/busses/i2c-jz4780.c:	timeout = wait_for_completion_timeout(&i2c->trans_waitq,
drivers/i2c/busses/i2c-jz4780.c:	timeout = wait_for_completion_timeout(&i2c->trans_waitq,
drivers/i2c/busses/i2c-jz4780.c:	init_completion(&i2c->trans_waitq);
drivers/i2c/busses/i2c-mt65xx.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-mt65xx.c:	struct completion msg_complete;
drivers/i2c/busses/i2c-mt65xx.c:	reinit_completion(&i2c->msg_complete);
drivers/i2c/busses/i2c-mt65xx.c:	ret = wait_for_completion_timeout(&i2c->msg_complete,
drivers/i2c/busses/i2c-mt65xx.c:	completion_done(&i2c->msg_complete);
drivers/i2c/busses/i2c-mt65xx.c:	init_completion(&i2c->msg_complete);
drivers/i2c/busses/i2c-stu300.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-stu300.c: * @cmd_complete: acknowledge completion for an I2C command
drivers/i2c/busses/i2c-stu300.c:	struct completion	cmd_complete;
drivers/i2c/busses/i2c-stu300.c:	init_completion(&dev->cmd_complete);
drivers/i2c/busses/i2c-stu300.c:	ret = wait_for_completion_interruptible_timeout(&dev->cmd_complete,
drivers/i2c/busses/i2c-stu300.c:		       "wait_for_completion_interruptible_timeout() "
drivers/i2c/busses/i2c-stu300.c: * configured to wait for the flag using a completion.
drivers/i2c/busses/i2c-stu300.c:	init_completion(&dev->cmd_complete);
drivers/i2c/busses/i2c-stu300.c:	ret = wait_for_completion_interruptible_timeout(&dev->cmd_complete,
drivers/i2c/busses/i2c-stu300.c:		       "wait_for_completion_interruptible_timeout()"
drivers/i2c/busses/i2c-hix5hd2.c:	struct completion msg_complete;
drivers/i2c/busses/i2c-hix5hd2.c:	reinit_completion(&priv->msg_complete);
drivers/i2c/busses/i2c-hix5hd2.c:	timeout = wait_for_completion_timeout(&priv->msg_complete,
drivers/i2c/busses/i2c-hix5hd2.c:	init_completion(&priv->msg_complete);
drivers/i2c/busses/i2c-meson.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-meson.c:	struct completion	done;
drivers/i2c/busses/i2c-meson.c:	reinit_completion(&i2c->done);
drivers/i2c/busses/i2c-meson.c:	time_left = wait_for_completion_timeout(&i2c->done, time_left);
drivers/i2c/busses/i2c-meson.c:	init_completion(&i2c->done);
drivers/i2c/busses/i2c-mv64xxx.c:mv64xxx_i2c_wait_for_completion(struct mv64xxx_i2c_data *drv_data)
drivers/i2c/busses/i2c-mv64xxx.c:	mv64xxx_i2c_wait_for_completion(drv_data);
drivers/i2c/busses/i2c-mv64xxx.c:	mv64xxx_i2c_wait_for_completion(drv_data);
drivers/i2c/busses/i2c-riic.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-riic.c:	struct completion msg_done;
drivers/i2c/busses/i2c-riic.c:	reinit_completion(&riic->msg_done);
drivers/i2c/busses/i2c-riic.c:		time_left = wait_for_completion_timeout(&riic->msg_done, riic->adapter.timeout);
drivers/i2c/busses/i2c-riic.c:	init_completion(&riic->msg_done);
drivers/i2c/busses/i2c-at91.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-at91.c:	struct completion cmd_complete;
drivers/i2c/busses/i2c-at91.c:	reinit_completion(&dev->cmd_complete);
drivers/i2c/busses/i2c-at91.c:	time_left = wait_for_completion_timeout(&dev->cmd_complete,
drivers/i2c/busses/i2c-at91.c:	init_completion(&dev->cmd_complete);
drivers/i2c/busses/i2c-bcm-iproc.c:	struct completion done;
drivers/i2c/busses/i2c-bcm-iproc.c:	reinit_completion(&iproc_i2c->done);
drivers/i2c/busses/i2c-bcm-iproc.c:	time_left = wait_for_completion_timeout(&iproc_i2c->done, time_left);
drivers/i2c/busses/i2c-bcm-iproc.c:	init_completion(&iproc_i2c->done);
drivers/i2c/busses/i2c-pnx.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-pnx.c:		/* initialize the completion var */
drivers/i2c/busses/i2c-pnx.c:		init_completion(&alg_data->mif.complete);
drivers/i2c/busses/i2c-pnx.c:		/* Wait for completion */
drivers/i2c/busses/i2c-pnx.c:		wait_for_completion(&alg_data->mif.complete);
drivers/i2c/busses/i2c-pnx.c:	init_completion(&alg_data->mif.complete);
drivers/i2c/busses/i2c-digicolor.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-digicolor.c:	struct completion	done;
drivers/i2c/busses/i2c-digicolor.c:	reinit_completion(&i2c->done);
drivers/i2c/busses/i2c-digicolor.c:	timeout = wait_for_completion_timeout(&i2c->done, timeout);
drivers/i2c/busses/i2c-digicolor.c:	init_completion(&i2c->done);
drivers/i2c/busses/i2c-axxia.c: * @msg_complete: xfer completion object
drivers/i2c/busses/i2c-axxia.c:	struct completion msg_complete;
drivers/i2c/busses/i2c-axxia.c:	reinit_completion(&idev->msg_complete);
drivers/i2c/busses/i2c-axxia.c:	time_left = wait_for_completion_timeout(&idev->msg_complete,
drivers/i2c/busses/i2c-axxia.c:	reinit_completion(&idev->msg_complete);
drivers/i2c/busses/i2c-axxia.c:	time_left = wait_for_completion_timeout(&idev->msg_complete,
drivers/i2c/busses/i2c-axxia.c:	init_completion(&idev->msg_complete);
drivers/i2c/busses/i2c-imx.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-imx.c:	struct completion	cmd_complete;
drivers/i2c/busses/i2c-imx.c:	init_completion(&dma->cmd_complete);
drivers/i2c/busses/i2c-imx.c:	reinit_completion(&i2c_imx->dma->cmd_complete);
drivers/i2c/busses/i2c-imx.c:	time_left = wait_for_completion_timeout(
drivers/i2c/busses/i2c-imx.c:	reinit_completion(&i2c_imx->dma->cmd_complete);
drivers/i2c/busses/i2c-imx.c:	time_left = wait_for_completion_timeout(
drivers/i2c/busses/i2c-tegra.c: * @msg_complete: transfer completion notifier
drivers/i2c/busses/i2c-tegra.c:	struct completion msg_complete;
drivers/i2c/busses/i2c-tegra.c:	reinit_completion(&i2c_dev->msg_complete);
drivers/i2c/busses/i2c-tegra.c:	time_left = wait_for_completion_timeout(&i2c_dev->msg_complete,
drivers/i2c/busses/i2c-tegra.c:		time_left, completion_done(&i2c_dev->msg_complete),
drivers/i2c/busses/i2c-tegra.c:	init_completion(&i2c_dev->msg_complete);
drivers/i2c/busses/i2c-wmt.c:	struct completion	complete;
drivers/i2c/busses/i2c-wmt.c:	reinit_completion(&i2c_dev->complete);
drivers/i2c/busses/i2c-wmt.c:		wait_result = wait_for_completion_timeout(&i2c_dev->complete,
drivers/i2c/busses/i2c-wmt.c:	reinit_completion(&i2c_dev->complete);
drivers/i2c/busses/i2c-wmt.c:		wait_result = wait_for_completion_timeout(&i2c_dev->complete,
drivers/i2c/busses/i2c-wmt.c:	init_completion(&i2c_dev->complete);
drivers/i2c/busses/i2c-lpc2k.c:	/* Wait for transfer completion */
drivers/i2c/busses/i2c-ismt.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-ismt.c:	struct completion cmp;			/* interrupt completion */
drivers/i2c/busses/i2c-ismt.c: * ismt_process_desc() - handle the completion of the descriptor
drivers/i2c/busses/i2c-ismt.c:	reinit_completion(&priv->cmp);
drivers/i2c/busses/i2c-ismt.c:	/* Now we wait for interrupt completion, 1s */
drivers/i2c/busses/i2c-ismt.c:	time_left = wait_for_completion_timeout(&priv->cmp, HZ*1);
drivers/i2c/busses/i2c-ismt.c:		dev_err(dev, "completion wait timed out\n");
drivers/i2c/busses/i2c-ismt.c:	init_completion(&priv->cmp);
drivers/i2c/busses/i2c-sirf.c:	struct completion done;	/* indicates completion of message transfer */
drivers/i2c/busses/i2c-sirf.c:	if (wait_for_completion_timeout(&siic->done, timeout) == 0) {
drivers/i2c/busses/i2c-sirf.c:	init_completion(&siic->done);
drivers/i2c/busses/i2c-sun6i-p2wi.c:	struct completion complete;
drivers/i2c/busses/i2c-sun6i-p2wi.c:	reinit_completion(&p2wi->complete);
drivers/i2c/busses/i2c-sun6i-p2wi.c:	wait_for_completion(&p2wi->complete);
drivers/i2c/busses/i2c-sun6i-p2wi.c:	init_completion(&p2wi->complete);
drivers/i2c/busses/i2c-omap.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-omap.c:	struct completion	cmd_complete;
drivers/i2c/busses/i2c-omap.c:	reinit_completion(&omap->cmd_complete);
drivers/i2c/busses/i2c-omap.c:	timeout = wait_for_completion_timeout(&omap->cmd_complete,
drivers/i2c/busses/i2c-omap.c:	init_completion(&omap->cmd_complete);
drivers/i2c/busses/i2c-img-scb.c: *   ACK) is given to the hardware, with detection of completion by bits
drivers/i2c/busses/i2c-img-scb.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-img-scb.c: * This delays completion until we've finished with the registers, so that the
drivers/i2c/busses/i2c-img-scb.c: * function waiting for completion can safely disable the clock to save power.
drivers/i2c/busses/i2c-img-scb.c:	struct completion msg_complete;
drivers/i2c/busses/i2c-img-scb.c:	/* We handle transaction completion AFTER accessing registers */
drivers/i2c/busses/i2c-img-scb.c:	/* now we've finished using regs, handle transaction completion */
drivers/i2c/busses/i2c-img-scb.c:	reinit_completion(&i2c->msg_complete);
drivers/i2c/busses/i2c-img-scb.c:	time_left = wait_for_completion_timeout(&i2c->msg_complete,
drivers/i2c/busses/i2c-img-scb.c:		reinit_completion(&i2c->msg_complete);
drivers/i2c/busses/i2c-img-scb.c:		time_left = wait_for_completion_timeout(&i2c->msg_complete,
drivers/i2c/busses/i2c-img-scb.c:	init_completion(&i2c->msg_complete);
drivers/i2c/busses/i2c-mxs.c:#include <linux/completion.h>
drivers/i2c/busses/i2c-mxs.c: * @cmd_complete: completion object for transaction wait
drivers/i2c/busses/i2c-mxs.c:	struct completion cmd_complete;
drivers/i2c/busses/i2c-mxs.c:		reinit_completion(&i2c->cmd_complete);
drivers/i2c/busses/i2c-mxs.c:		time_left = wait_for_completion_timeout(&i2c->cmd_complete,
drivers/i2c/busses/i2c-mxs.c:	init_completion(&i2c->cmd_complete);
drivers/i2c/i2c-core.c:#include <linux/completion.h>
drivers/i2c/i2c-core.c:	init_completion(&adap->dev_released);
drivers/i2c/i2c-core.c:	wait_for_completion(&adap->dev_released);
drivers/staging/nvec/nvec.h:#include <linux/completion.h>
drivers/staging/nvec/nvec.h: * @ec_transfer: A completion that will be completed once a message has been
drivers/staging/nvec/nvec.h: * @sync_write: A completion to signal that a synchronous message is complete
drivers/staging/nvec/nvec.h:	struct completion ec_transfer;
drivers/staging/nvec/nvec.h:	struct completion sync_write;
drivers/staging/nvec/nvec.c:#include <linux/completion.h>
drivers/staging/nvec/nvec.c:	if (!(wait_for_completion_timeout(&nvec->sync_write,
drivers/staging/nvec/nvec.c:		err = wait_for_completion_interruptible_timeout(
drivers/staging/nvec/nvec.c:	init_completion(&nvec->sync_write);
drivers/staging/nvec/nvec.c:	init_completion(&nvec->ec_transfer);
drivers/staging/octeon-usb/octeon-hcd.h:	 *	completion.
drivers/staging/octeon-usb/octeon-hcd.c: * Signal the completion of a transaction and free it. The
drivers/staging/comedi/drivers/s626.c:	 * Wait for completion of upload from shadow RAM to
drivers/staging/comedi/drivers/ni_atmio16d.c:	/* enable interrupts for conversion completion */
drivers/staging/comedi/drivers/jr3_pci.h:	 * command_word0 to indicate successful completion. Alternatively
drivers/staging/comedi/drivers/jr3_pci.c:			/* Allow 20 ms for completion */
drivers/staging/comedi/drivers/jr3_pci.c:			/* Allow 20 ms for completion */
drivers/staging/comedi/drivers/jr3_pci.c:			/* Allow 40 ms for completion */
drivers/staging/comedi/drivers/amplc_pci230.c: * Returns false if AO finished due to completion or error, true if still going.
drivers/staging/comedi/drivers/plx9080.h:/* DMA Clear Count Mode - count in descriptor cleared on completion */
drivers/staging/lustre/lustre/obdecho/echo_client.c:static void echo_page_completion(const struct lu_env *env,
drivers/staging/lustre/lustre/obdecho/echo_client.c:			.cpo_completion  = echo_page_completion,
drivers/staging/lustre/lustre/obdecho/echo_client.c:			.cpo_completion  = echo_page_completion,
drivers/staging/lustre/lustre/mdc/mdc_locks.c:		.ei_cb_cp	= ldlm_completion_ast,
drivers/staging/lustre/lustre/llite/lproc_llite.c:	init_completion(&sbi->ll_kobj_unregister);
drivers/staging/lustre/lustre/llite/lproc_llite.c:		wait_for_completion(&sbi->ll_kobj_unregister);
drivers/staging/lustre/lustre/llite/llite_close.c:	init_completion(&lcq->lcq_comp);
drivers/staging/lustre/lustre/llite/llite_close.c:	wait_for_completion(&lcq->lcq_comp);
drivers/staging/lustre/lustre/llite/llite_close.c:	init_completion(&lcq->lcq_comp);
drivers/staging/lustre/lustre/llite/llite_close.c:	wait_for_completion(&lcq->lcq_comp);
drivers/staging/lustre/lustre/llite/vvp_req.c:static void vvp_req_completion(const struct lu_env *env,
drivers/staging/lustre/lustre/llite/vvp_req.c:	.cro_completion = vvp_req_completion
drivers/staging/lustre/lustre/llite/xattr_cache.c:		.ei_cb_cp = &ldlm_completion_ast,
drivers/staging/lustre/lustre/llite/statahead.c:	einfo->ei_cb_cp  = ldlm_completion_ast;
drivers/staging/lustre/lustre/llite/vvp_page.c:static void vvp_page_completion_read(const struct lu_env *env,
drivers/staging/lustre/lustre/llite/vvp_page.c:static void vvp_page_completion_write(const struct lu_env *env,
drivers/staging/lustre/lustre/llite/vvp_page.c:	 * ->cpo_completion method. The underlying transfer should be notified
drivers/staging/lustre/lustre/llite/vvp_page.c:			.cpo_completion  = vvp_page_completion_read,
drivers/staging/lustre/lustre/llite/vvp_page.c:			.cpo_completion  = vvp_page_completion_write,
drivers/staging/lustre/lustre/llite/vvp_page.c:vvp_transient_page_completion(const struct lu_env *env,
drivers/staging/lustre/lustre/llite/vvp_page.c:			.cpo_completion  = vvp_transient_page_completion,
drivers/staging/lustre/lustre/llite/vvp_page.c:			.cpo_completion  = vvp_transient_page_completion,
drivers/staging/lustre/lustre/llite/file.c:		.ei_cb_cp	= ldlm_flock_completion_ast,
drivers/staging/lustre/lustre/llite/file.c:	 * blocked and then granted via completion ast, we have to fetch
drivers/staging/lustre/lustre/llite/file.c:	 * completion AST because it doesn't have a large enough buffer
drivers/staging/lustre/lustre/llite/file.c:		.ei_cb_cp = &ldlm_completion_ast,
drivers/staging/lustre/lustre/llite/llite_internal.h:	struct completion	 ll_kobj_unregister;
drivers/staging/lustre/lustre/llite/llite_internal.h:	struct completion	lcq_comp;
drivers/staging/lustre/lustre/ptlrpc/lproc_ptlrpc.c:		wait_for_completion(&svc->srv_kobj_unregister);
drivers/staging/lustre/lustre/ptlrpc/lproc_ptlrpc.c:	init_completion(&svc->srv_kobj_unregister);
drivers/staging/lustre/lustre/ptlrpc/import.c: * for all the RPC completions, and finally notify the obd to
drivers/staging/lustre/lustre/ptlrpc/import.c:		/* Wait for all requests to error out and call completion
drivers/staging/lustre/lustre/ptlrpc/import.c:	 * We override/ignore the server rpc completion estimate here,
drivers/staging/lustre/lustre/ptlrpc/client.c: * an error in flight and calls their completion handler.
drivers/staging/lustre/lustre/ptlrpc/client.c:		 * timed out, signals are enabled allowing completion with
drivers/staging/lustre/lustre/ptlrpc/service.c:			/* Ignore return code; we're racing with completion */
drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c: * requests when they don't want to wait for their completion.
drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c: * replies and calling completion callbacks as necessary.
drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c: * completion handler or a deadlock might occur where ptlrpcd enters some
drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c:	init_completion(&pc->pc_starting);
drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c:	init_completion(&pc->pc_finishing);
drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c:	wait_for_completion(&pc->pc_starting);
drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c:	wait_for_completion(&pc->pc_finishing);
drivers/staging/lustre/lustre/ptlrpc/niobuf.c: * thread-safe (i.e. only interlocks with completion callback).
drivers/staging/lustre/lustre/ptlrpc/niobuf.c:	 * one.  If it fails, it must be because completion just happened,
drivers/staging/lustre/lustre/obdclass/llog.c:	complete(&lpi->lpi_completion);
drivers/staging/lustre/lustre/obdclass/llog.c:		init_completion(&lpi->lpi_completion);
drivers/staging/lustre/lustre/obdclass/llog.c:		wait_for_completion(&lpi->lpi_completion);
drivers/staging/lustre/lustre/obdclass/lprocfs_status.c:	init_completion(&obd->obd_kobj_unregister);
drivers/staging/lustre/lustre/obdclass/lprocfs_status.c:	wait_for_completion(&obd->obd_kobj_unregister);
drivers/staging/lustre/lustre/obdclass/cl_io.c: * Invokes per-request transfer completion call-backs
drivers/staging/lustre/lustre/obdclass/cl_io.c: * (cl_req_operations::cro_completion()) bottom-to-top.
drivers/staging/lustre/lustre/obdclass/cl_io.c:void cl_req_completion(const struct lu_env *env, struct cl_req *req, int rc)
drivers/staging/lustre/lustre/obdclass/cl_io.c:		if (slice->crs_ops->cro_completion)
drivers/staging/lustre/lustre/obdclass/cl_io.c:			slice->crs_ops->cro_completion(env, slice, rc);
drivers/staging/lustre/lustre/obdclass/cl_io.c:EXPORT_SYMBOL(cl_req_completion);
drivers/staging/lustre/lustre/obdclass/cl_io.c:			cl_req_completion(env, req, result);
drivers/staging/lustre/lustre/obdclass/cl_io.c: * Wait until all IO completes. Transfer completion routine has to call
drivers/staging/lustre/lustre/obdclass/cl_page.c:			[CPS_CACHED]  = 1, /* io completion */
drivers/staging/lustre/lustre/obdclass/cl_page.c:			[CPS_CACHED]  = 1, /* io completion */
drivers/staging/lustre/lustre/obdclass/cl_page.c: * Notify layers about transfer completion.
drivers/staging/lustre/lustre/obdclass/cl_page.c: * \see cl_page_operations::cpo_completion()
drivers/staging/lustre/lustre/obdclass/cl_page.c:void cl_page_completion(const struct lu_env *env,
drivers/staging/lustre/lustre/obdclass/cl_page.c:	/* cl_page::cp_req already cleared by the caller (osc_completion()) */
drivers/staging/lustre/lustre/obdclass/cl_page.c:	CL_PAGE_INVOID_REVERSE(env, pg, CL_PAGE_OP(io[crt].cpo_completion),
drivers/staging/lustre/lustre/obdclass/cl_page.c:EXPORT_SYMBOL(cl_page_completion);
drivers/staging/lustre/lustre/obdclass/genops.c:static struct completion	obd_zombie_start;
drivers/staging/lustre/lustre/obdclass/genops.c:static struct completion	obd_zombie_stop;
drivers/staging/lustre/lustre/obdclass/genops.c:	init_completion(&obd_zombie_start);
drivers/staging/lustre/lustre/obdclass/genops.c:	init_completion(&obd_zombie_stop);
drivers/staging/lustre/lustre/obdclass/genops.c:	wait_for_completion(&obd_zombie_start);
drivers/staging/lustre/lustre/obdclass/genops.c:	wait_for_completion(&obd_zombie_stop);
drivers/staging/lustre/lustre/obdclass/llog_internal.h:	struct completion	lpi_completion;
drivers/staging/lustre/lustre/include/lustre/lustre_errno.h:#define LUSTRE_EIOCBQUEUED	529	/* iocb queued, will get completion
drivers/staging/lustre/lustre/include/obd.h:	 * ->ap_completion() call-backs are executed under this lock. As we
drivers/staging/lustre/lustre/include/obd.h:	struct completion	trd_starting;
drivers/staging/lustre/lustre/include/obd.h:	struct completion	trd_finishing;
drivers/staging/lustre/lustre/include/obd.h:	struct completion	obd_kobj_unregister;
drivers/staging/lustre/lustre/include/lustre_dlm.h:	struct completion	 pl_kobj_unregister;
drivers/staging/lustre/lustre/include/lustre_dlm.h:	struct completion	ns_kobj_unregister;
drivers/staging/lustre/lustre/include/lustre_dlm.h:/** Type for completion callback function of a lock. */
drivers/staging/lustre/lustre/include/lustre_dlm.h:typedef int (*ldlm_completion_callback)(struct ldlm_lock *lock, __u64 flags,
drivers/staging/lustre/lustre/include/lustre_dlm.h:	/** Lock completion handler pointer. Called when lock is granted. */
drivers/staging/lustre/lustre/include/lustre_dlm.h:	ldlm_completion_callback l_completion_ast;
drivers/staging/lustre/lustre/include/lustre_dlm.h:	/** List item ldlm_add_ast_work_item() for case of completion ASTs. */
drivers/staging/lustre/lustre/include/lustre_dlm.h:	void *ei_cb_cp;  /** lock completion callback */
drivers/staging/lustre/lustre/include/lustre_dlm.h:int ldlm_flock_completion_ast(struct ldlm_lock *lock, __u64 flags, void *data);
drivers/staging/lustre/lustre/include/lustre_dlm.h:	ldlm_completion_callback lcs_completion;
drivers/staging/lustre/lustre/include/lustre_dlm.h:int ldlm_completion_ast_async(struct ldlm_lock *lock, __u64 flags, void *data);
drivers/staging/lustre/lustre/include/lustre_dlm.h:int ldlm_completion_ast(struct ldlm_lock *lock, __u64 flags, void *data);
drivers/staging/lustre/lustre/include/lustre_net.h:	 * Scratchpad for passing args to completion interpreter. Users
drivers/staging/lustre/lustre/include/lustre_net.h: * Provides a way to call "completion callbacks" when all requests in the set
drivers/staging/lustre/lustre/include/lustre_net.h:	 * List of completion callbacks to be called when the set is completed
drivers/staging/lustre/lustre/include/lustre_net.h:	/** opaq argument passed to completion \a set_interpret callback. */
drivers/staging/lustre/lustre/include/lustre_net.h:	/** Async completion handler, called when reply is received */
drivers/staging/lustre/lustre/include/lustre_net.h:	/** Async completion context */
drivers/staging/lustre/lustre/include/lustre_net.h: * Call completion handler for rpc if any, return it's status or original
drivers/staging/lustre/lustre/include/lustre_net.h:	struct completion		 srv_kobj_unregister;
drivers/staging/lustre/lustre/include/lustre_net.h:	 * Start completion.
drivers/staging/lustre/lustre/include/lustre_net.h:	struct completion		pc_starting;
drivers/staging/lustre/lustre/include/lustre_net.h:	 * Stop completion.
drivers/staging/lustre/lustre/include/lustre_net.h:	struct completion		pc_finishing;
drivers/staging/lustre/lustre/include/lustre_import.h:	/** Wait queue for those who need to wait for recovery completion */
drivers/staging/lustre/lustre/include/cl_object.h: *    various events changing page state (such as transfer completion, or
drivers/staging/lustre/lustre/include/cl_object.h:	 * this state is achieved, transfer completion handler (with either
drivers/staging/lustre/lustre/include/cl_object.h:		 * \see cl_page_completion()
drivers/staging/lustre/lustre/include/cl_object.h:		void (*cpo_completion)(const struct lu_env *env,
drivers/staging/lustre/lustre/include/cl_object.h:	 *    with completion handlers. Osc uses client obd lock for this
drivers/staging/lustre/lustre/include/cl_object.h:		 * queue->c2_qout, completion callback with non-zero ioret is
drivers/staging/lustre/lustre/include/cl_object.h:	 * Called top-to-bottom from cl_req_completion() to notify layers that
drivers/staging/lustre/lustre/include/cl_object.h:	void (*cro_completion)(const struct lu_env *env,
drivers/staging/lustre/lustre/include/cl_object.h: * On transfer completion (or transfer timeout, or failure to initiate the
drivers/staging/lustre/lustre/include/cl_object.h: * transfer of an allocated req), cl_req_operations::cro_completion() method
drivers/staging/lustre/lustre/include/cl_object.h: * is called, after execution of cl_page_operations::cpo_completion() of all
drivers/staging/lustre/lustre/include/cl_object.h:void cl_page_completion(const struct lu_env *env,
drivers/staging/lustre/lustre/include/cl_object.h:void cl_req_completion(const struct lu_env *env, struct cl_req *req, int ioret);
drivers/staging/lustre/lustre/include/cl_object.h: * every page submitted for transfer. Transfer completion routine updates
drivers/staging/lustre/lustre/include/cl_object.h:	/** completion to be signaled when transfer is complete. */
drivers/staging/lustre/lustre/include/lustre_dlm_flags.h: * The proper fix is to do the granting inside of the completion AST,
drivers/staging/lustre/lustre/include/lustre_dlm_flags.h:/** completion AST to be executed */
drivers/staging/lustre/lustre/lov/lov_dev.c:static void lov_req_completion(const struct lu_env *env,
drivers/staging/lustre/lustre/lov/lov_dev.c:	.cro_completion = lov_req_completion
drivers/staging/lustre/lustre/lov/lovsub_dev.c:static void lovsub_req_completion(const struct lu_env *env,
drivers/staging/lustre/lustre/lov/lovsub_dev.c:	.cro_completion = lovsub_req_completion
drivers/staging/lustre/lustre/mgc/mgc_request.c:			wait_for_completion(&rq_exit);
drivers/staging/lustre/lustre/mgc/mgc_request.c:		wait_for_completion(&rq_start);
drivers/staging/lustre/lustre/mgc/mgc_request.c:		.ei_cb_cp	= ldlm_completion_ast,
drivers/staging/lustre/lustre/osc/osc_lock.c:	einfo->ei_cb_cp  = ldlm_completion_ast;
drivers/staging/lustre/lustre/osc/osc_cache.c:static void osc_ap_completion(const struct lu_env *env, struct client_obd *cli,
drivers/staging/lustre/lustre/osc/osc_cache.c:		osc_ap_completion(env, cli, oap, sent, rc);
drivers/staging/lustre/lustre/osc/osc_cache.c:static int osc_completion(const struct lu_env *env, struct osc_async_page *oap,
drivers/staging/lustre/lustre/osc/osc_cache.c:	 * released in cl_page_completion() and nothing except for the
drivers/staging/lustre/lustre/osc/osc_cache.c:	cl_page_completion(env, page, crt, rc);
drivers/staging/lustre/lustre/osc/osc_cache.c:static void osc_ap_completion(const struct lu_env *env, struct client_obd *cli,
drivers/staging/lustre/lustre/osc/osc_cache.c:	rc = osc_completion(env, oap, oap->oap_cmd, rc);
drivers/staging/lustre/lustre/osc/osc_cache.c:		CERROR("completion on oap %p obj %p returns %d.\n",
drivers/staging/lustre/lustre/osc/osc_cache.c:			osc_ap_completion(env, cli, oap, 0, -ENOMEM);
drivers/staging/lustre/lustre/osc/osc_io.c:		init_completion(&cbargs->opc_sync);
drivers/staging/lustre/lustre/osc/osc_io.c:		wait_for_completion(&cbargs->opc_sync);
drivers/staging/lustre/lustre/osc/osc_io.c:	init_completion(&cbargs->opc_sync);
drivers/staging/lustre/lustre/osc/osc_io.c:		wait_for_completion(&cbargs->opc_sync);
drivers/staging/lustre/lustre/osc/osc_io.c:static void osc_req_completion(const struct lu_env *env,
drivers/staging/lustre/lustre/osc/osc_io.c:	.cro_completion = osc_req_completion
drivers/staging/lustre/lustre/osc/osc_request.c:	cl_req_completion(env, aa->aa_clerq, rc < 0 ? rc :
drivers/staging/lustre/lustre/osc/osc_request.c:	/* We need to decrement before osc_ap_completion->osc_wake_cache_waiters
drivers/staging/lustre/lustre/osc/osc_request.c:			cl_req_completion(env, clerq, rc);
drivers/staging/lustre/lustre/osc/osc_request.c:	LASSERT(lock->l_completion_ast == einfo->ei_cb_cp);
drivers/staging/lustre/lustre/osc/osc_cl_internal.h:		struct completion	opc_sync;
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c: * Add a lock to list of just granted locks to send completion AST to.
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:		LDLM_DEBUG(lock, "lock granted; sending completion AST.");
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:	if (work_list && lock->l_completion_ast)
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:			if (lock->l_completion_ast) {
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:				int err = lock->l_completion_ast(lock,
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:		lock->l_completion_ast = cbs->lcs_completion;
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c: * Process a call to completion AST callback for a lock in ast_work list
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:	ldlm_completion_callback completion_callback;
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:	/* It's possible to receive a completion AST before we've set
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:	 * the l_completion_ast pointer: either because the AST arrived
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:	/* save l_completion_ast since it can be changed by
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:	completion_callback = lock->l_completion_ast;
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:	if (completion_callback)
drivers/staging/lustre/lustre/ldlm/ldlm_lock.c:		rc = completion_callback(lock, 0, (void *)arg);
drivers/staging/lustre/lustre/ldlm/ldlm_resource.c:	wait_for_completion(&ns->ns_kobj_unregister);
drivers/staging/lustre/lustre/ldlm/ldlm_resource.c:	init_completion(&ns->ns_kobj_unregister);
drivers/staging/lustre/lustre/ldlm/ldlm_resource.c:			if (lock->l_completion_ast)
drivers/staging/lustre/lustre/ldlm/ldlm_resource.c:				lock->l_completion_ast(lock, LDLM_FL_FAILED,
drivers/staging/lustre/lustre/ldlm/ldlm_pool.c:	init_completion(&pl->pl_kobj_unregister);
drivers/staging/lustre/lustre/ldlm/ldlm_pool.c:	wait_for_completion(&pl->pl_kobj_unregister);
drivers/staging/lustre/lustre/ldlm/ldlm_pool.c:static struct completion ldlm_pools_comp;
drivers/staging/lustre/lustre/ldlm/ldlm_pool.c:	init_completion(&ldlm_pools_comp);
drivers/staging/lustre/lustre/ldlm/ldlm_pool.c:	wait_for_completion(&ldlm_pools_comp);
drivers/staging/lustre/lustre/ldlm/ldlm_flock.c:		 * policy function is ldlm_flock_completion_ast inside which
drivers/staging/lustre/lustre/ldlm/ldlm_flock.c:	 * could be freed before the completion AST can be sent.
drivers/staging/lustre/lustre/ldlm/ldlm_flock.c: * Flock completion callback function.
drivers/staging/lustre/lustre/ldlm/ldlm_flock.c:ldlm_flock_completion_ast(struct ldlm_lock *lock, __u64 flags, void *data)
drivers/staging/lustre/lustre/ldlm/ldlm_flock.c:EXPORT_SYMBOL(ldlm_flock_completion_ast);
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:	struct completion	blp_comp;
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:	struct completion	blwi_comp;
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c: * Callback handler for receiving incoming completion ASTs.
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:	LDLM_DEBUG(lock, "client completion callback handler START");
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:	/* If we receive the completion AST before the actual enqueue returned,
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:		LDLM_DEBUG(lock, "completion AST, new lock mode");
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:		LDLM_DEBUG(lock, "completion AST, new policy data");
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:		LDLM_DEBUG(lock, "completion AST, new resource");
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:		LDLM_DEBUG(lock, "completion AST includes blocking AST");
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:	LDLM_DEBUG_NOLOCK("client completion callback handler END (lock %p)",
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:		wait_for_completion(&blwi->blwi_comp);
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:	init_completion(&blwi->blwi_comp);
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:		CDEBUG(D_INODE, "completion ast\n");
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:	struct completion	bltd_comp;
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:	init_completion(&bltd.bltd_comp);
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:	wait_for_completion(&bltd.bltd_comp);
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:			init_completion(&blp->blp_comp);
drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c:			wait_for_completion(&blp->blp_comp);
drivers/staging/lustre/lustre/ldlm/ldlm_request.c: * - completion AST: when a lock is enqueued by some process, but cannot be
drivers/staging/lustre/lustre/ldlm/ldlm_request.c: *   the completion AST is sent to notify the caller when the lock is
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:static void interrupted_completion_wait(void *data)
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:static int ldlm_expired_completion_wait(void *data)
drivers/staging/lustre/lustre/ldlm/ldlm_request.c: * lock cancel, and their replies). Used for lock completion timeout on the
drivers/staging/lustre/lustre/ldlm/ldlm_request.c: * \param[in] lock	lock which is waiting the completion callback
drivers/staging/lustre/lustre/ldlm/ldlm_request.c: * Helper function for ldlm_completion_ast(), updating timings when lock is
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:static int ldlm_completion_tail(struct ldlm_lock *lock, void *data)
drivers/staging/lustre/lustre/ldlm/ldlm_request.c: * Implementation of ->l_completion_ast() for a client, that doesn't wait
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:int ldlm_completion_ast_async(struct ldlm_lock *lock, __u64 flags, void *data)
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:		return ldlm_completion_tail(lock, data);
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:EXPORT_SYMBOL(ldlm_completion_ast_async);
drivers/staging/lustre/lustre/ldlm/ldlm_request.c: * Generic LDLM "completion" AST. This is called in several cases:
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:int ldlm_completion_ast(struct ldlm_lock *lock, __u64 flags, void *data)
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:		lwi = LWI_INTR(interrupted_completion_wait, &lwd);
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:				       ldlm_expired_completion_wait,
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:				       interrupted_completion_wait, &lwd);
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:	return ldlm_completion_tail(lock, data);
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:EXPORT_SYMBOL(ldlm_completion_ast);
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:	/* If enqueue returned a blocked lock but the completion handler has
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:	/* If the lock has already been granted by a completion AST, don't
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:		/* We must lock or a racing completion might update lvb without
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:		 * a tiny window for completion to get in
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:		if (lock->l_completion_ast) {
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:			int err = lock->l_completion_ast(lock, *flags, NULL);
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:		/* Copy the LVB here, and not earlier, because the completion
drivers/staging/lustre/lustre/ldlm/ldlm_request.c:			.lcs_completion = einfo->ei_cb_cp,
drivers/staging/lustre/lnet/selftest/framework.c:/* completion handler for incoming framework RPCs */
drivers/staging/lustre/lnet/selftest/selftest.h:	int		  crpc_status;	  /* completion status */
drivers/staging/lustre/lnet/klnds/socklnd/socklnd_cb.c:	 * progress/completion.
drivers/staging/lustre/lnet/klnds/socklnd/socklnd_cb.c:	 * she has received this message to tell us we can signal completion.
drivers/staging/lustre/lnet/klnds/socklnd/socklnd.h:	__u64              ksnp_zc_next_cookie; /* ZC completion cookie */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	struct list_head   ibs_conns;    /* conns to check for rx completions */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	__u64           ibprm_cookie; /* opaque completion cookie */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	__u64           ibpam_src_cookie; /* reflected completion cookie */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	__u64           ibpam_dst_cookie; /* opaque completion cookie */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	__u64           ibgm_cookie;  /* opaque completion cookie */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:struct kib_completion_msg {
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	__u64           ibcm_cookie;  /* opaque completion cookie */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:		struct kib_completion_msg	completion;
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:#define IBLND_MSG_PUT_NAK   0xd3	/* completion (sink->src) */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:#define IBLND_MSG_PUT_DONE  0xd5	/* completion (src->sink) */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:#define IBLND_MSG_GET_DONE  0xd7	/* completion (src->sink: all OK) */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	enum ib_wc_status      rx_status;     /* completion status */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	int                   tx_status;      /* LNET completion status */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	unsigned long         tx_deadline;    /* completion deadline */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	__u64                 tx_cookie;      /* completion cookie */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	lnet_msg_t *tx_lntmsg[2]; /* lnet msgs to finalize on completion */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	struct list_head ibc_active_txs; /* active tx awaiting completion */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:	struct ib_cq          *ibc_cq;         /* completion queue */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:void kiblnd_cq_completion(struct ib_cq *cq, void *arg);
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c:		return hdr_size + sizeof(struct kib_completion_msg);
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c:			__swab32s(&msg->ibm_u.completion.ibcm_status);
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c:static int kiblnd_get_completion_vector(struct kib_conn *conn, int cpt)
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c:	cq_attr.comp_vector = kiblnd_get_completion_vector(conn, cpt);
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c:			  kiblnd_cq_completion, kiblnd_cq_event, conn,
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c:		CERROR("Can't request completion notification: %d\n", rc);
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.c:			 * NB locking needed now I'm racing with completion
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		CWARN("Bad completion: %swaiting, type %x (wanted %x)\n",
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:kiblnd_handle_completion(struct kib_conn *conn, int txtype, int status, __u64 cookie)
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		CWARN("Unmatched completion type %x cookie %#llx from %s\n",
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:kiblnd_send_completion(struct kib_conn *conn, int type, int status, __u64 cookie)
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		CERROR("Can't get tx for completion %x for %s\n",
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:	tx->tx_msg->ibm_u.completion.ibcm_status = status;
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:	tx->tx_msg->ibm_u.completion.ibcm_cookie = cookie;
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:	kiblnd_init_tx_msg(ni, tx, type, sizeof(struct kib_completion_msg));
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		kiblnd_handle_completion(conn, IBLND_MSG_PUT_REQ,
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:					 msg->ibm_u.completion.ibcm_status,
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:					 msg->ibm_u.completion.ibcm_cookie);
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		kiblnd_handle_completion(conn, IBLND_MSG_PUT_ACK,
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:					 msg->ibm_u.completion.ibcm_status,
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:					 msg->ibm_u.completion.ibcm_cookie);
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		kiblnd_handle_completion(conn, IBLND_MSG_GET_REQ,
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:					 msg->ibm_u.completion.ibcm_status,
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:					 msg->ibm_u.completion.ibcm_cookie);
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		/* tx completions outstanding... */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:	 * I could be racing with rdma completion.  Whoever makes 'tx' idle
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:	ibmsg->ibm_u.completion.ibcm_status = rc;
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:	ibmsg->ibm_u.completion.ibcm_cookie = dstcookie;
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:			   type, sizeof(struct kib_completion_msg));
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		tx->tx_lntmsg[0] = lntmsg;      /* finalise lntmsg[0,1] on completion */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		tx->tx_lntmsg[0] = lntmsg;      /* finalise lntmsg on completion */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:	tx->tx_lntmsg[0] = lntmsg;	      /* finalise lntmsg on completion */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		/* No RDMA: local completion may happen now! */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:			kiblnd_send_completion(rx->rx_conn, IBLND_MSG_PUT_NAK, 0,
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:			kiblnd_send_completion(rx->rx_conn, IBLND_MSG_PUT_NAK, rc,
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		tx->tx_lntmsg[0] = lntmsg;      /* finalise lntmsg on completion */
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:			kiblnd_send_completion(rx->rx_conn, IBLND_MSG_GET_DONE,
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:		 * We only get RDMA completion notification if it fails.  All
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:kiblnd_cq_completion(struct ib_cq *cq, void *arg)
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:	 * consuming my CQ I could be called after all completions have
drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c:				 * There may be another completion waiting; get
drivers/staging/lustre/lnet/lnet/router.c:#include <linux/completion.h>
drivers/staging/lustre/lnet/lnet/router.c:	init_completion(&the_lnet.ln_rc_signal);
drivers/staging/lustre/lnet/lnet/router.c:		wait_for_completion(&the_lnet.ln_rc_signal);
drivers/staging/lustre/lnet/lnet/router.c:	wait_for_completion(&the_lnet.ln_rc_signal);
drivers/staging/lustre/lnet/lnet/router.c:	/* The unlink event callback will signal final completion */
drivers/staging/lustre/lnet/lnet/lib-move.c: * There are several events associated with a PUT: completion of the send on
drivers/staging/lustre/lnet/lnet/lib-move.c: * used at the target node to indicate the completion of incoming data
drivers/staging/lustre/lnet/lnet/lib-move.c:	/* completion will be signalled by an event */
drivers/staging/lustre/lnet/lnet/lib-move.c:	/* completion will be signalled by an event */
drivers/staging/lustre/lnet/lnet/lib-msg.c:	 * signals completion.
drivers/staging/lustre/lnet/lnet/lib-md.c: * (Note that the check for unlinking a MD only occurs after the completion
drivers/staging/lustre/lnet/lnet/lib-md.c: *   the completion of the last operation by setting the unlinked field of
drivers/staging/lustre/lnet/lnet/lib-md.c:	 * when the LND is done, the completion event flags that the MD was
drivers/staging/lustre/lnet/lnet/acceptor.c:#include <linux/completion.h>
drivers/staging/lustre/lnet/lnet/acceptor.c:	struct completion	pta_signal;
drivers/staging/lustre/lnet/lnet/acceptor.c:	init_completion(&lnet_acceptor_state.pta_signal);
drivers/staging/lustre/lnet/lnet/acceptor.c:	wait_for_completion(&lnet_acceptor_state.pta_signal);
drivers/staging/lustre/lnet/lnet/acceptor.c:	wait_for_completion(&lnet_acceptor_state.pta_signal);
drivers/staging/lustre/lnet/lnet/api-ni.c:				/* Ensure completion in finite time... */
drivers/staging/lustre/lnet/lnet/api-ni.c:				CWARN("ping %s: late network completion\n",
drivers/staging/lustre/lnet/libcfs/tracefile.c:	struct completion	tctl_start;
drivers/staging/lustre/lnet/libcfs/tracefile.c:	struct completion	tctl_stop;
drivers/staging/lustre/lnet/libcfs/tracefile.c:	init_completion(&tctl->tctl_start);
drivers/staging/lustre/lnet/libcfs/tracefile.c:	init_completion(&tctl->tctl_stop);
drivers/staging/lustre/lnet/libcfs/tracefile.c:	wait_for_completion(&tctl->tctl_start);
drivers/staging/lustre/lnet/libcfs/tracefile.c:		wait_for_completion(&tctl->tctl_stop);
drivers/staging/lustre/lnet/libcfs/linux/linux-debug.c:#include <linux/completion.h>
drivers/staging/lustre/include/linux/lnet/lib-types.h:#include <linux/completion.h>
drivers/staging/lustre/include/linux/lnet/lib-types.h:	struct completion		  ln_rc_signal;
drivers/staging/lustre/include/linux/lnet/api.h: * local MDs. In particular, they signal the completion of a data transmission
drivers/staging/lustre/include/linux/lnet/types.h:	 * Indicates the completion status of the operation. It's 0 for
drivers/staging/lustre/include/linux/libcfs/libcfs_hash.h: * without being blocked on rehash completion, because rehash will release
drivers/staging/rtl8192e/rtllib_softmac.c:			 * as for the completion function, it does not need
drivers/staging/rtl8192e/rtllib_softmac.c:			 * as for the completion function, it does not need
drivers/staging/rts5208/rtsx.h:	struct completion	cmnd_ready;	 /* to sleep thread on	    */
drivers/staging/rts5208/rtsx.h:	struct completion	control_exit;	 /* control thread exit	    */
drivers/staging/rts5208/rtsx.h:	struct completion	polling_exit;	 /* polling thread exit	    */
drivers/staging/rts5208/rtsx.h:	struct completion	notify;		 /* thread begin/end	    */
drivers/staging/rts5208/rtsx.h:	struct completion	scanning_done;	 /* wait for scan thread    */
drivers/staging/rts5208/rtsx.h:	struct completion	*done;
drivers/staging/rts5208/rtsx_transport.c:	struct completion trans_done;
drivers/staging/rts5208/rtsx_transport.c:	init_completion(&trans_done);
drivers/staging/rts5208/rtsx_transport.c:	timeleft = wait_for_completion_interruptible_timeout(
drivers/staging/rts5208/rtsx_transport.c:	struct completion trans_done;
drivers/staging/rts5208/rtsx_transport.c:	init_completion(&trans_done);
drivers/staging/rts5208/rtsx_transport.c:	timeleft = wait_for_completion_interruptible_timeout(
drivers/staging/rts5208/rtsx_transport.c:		init_completion(&trans_done);
drivers/staging/rts5208/rtsx_transport.c:		timeleft = wait_for_completion_interruptible_timeout(
drivers/staging/rts5208/rtsx_transport.c:	struct completion trans_done;
drivers/staging/rts5208/rtsx_transport.c:		init_completion(&trans_done);
drivers/staging/rts5208/rtsx_transport.c:		timeleft = wait_for_completion_interruptible_timeout(
drivers/staging/rts5208/rtsx_transport.c:		init_completion(&trans_done);
drivers/staging/rts5208/rtsx_transport.c:		timeleft = wait_for_completion_interruptible_timeout(
drivers/staging/rts5208/rtsx_transport.c:	struct completion trans_done;
drivers/staging/rts5208/rtsx_transport.c:	init_completion(&trans_done);
drivers/staging/rts5208/rtsx_transport.c:	timeleft = wait_for_completion_interruptible_timeout(
drivers/staging/rts5208/rtsx.c:	wait_for_completion(&dev->notify);
drivers/staging/rts5208/rtsx.c:		if (wait_for_completion_interruptible(&dev->cmnd_ready))
drivers/staging/rts5208/rtsx.c:	 * complete()/wait_for_completion() is similar to up()/down(),
drivers/staging/rts5208/rtsx.c:		wait_for_completion(&dev->control_exit);
drivers/staging/rts5208/rtsx.c:		wait_for_completion(&dev->polling_exit);
drivers/staging/rts5208/rtsx.c:	wait_for_completion(&dev->scanning_done);
drivers/staging/rts5208/rtsx.c:	init_completion(&dev->cmnd_ready);
drivers/staging/rts5208/rtsx.c:	init_completion(&dev->control_exit);
drivers/staging/rts5208/rtsx.c:	init_completion(&dev->polling_exit);
drivers/staging/rts5208/rtsx.c:	init_completion(&(dev->notify));
drivers/staging/rts5208/rtsx.c:	init_completion(&dev->scanning_done);
drivers/staging/emxx_udc/emxx_udc.h:	struct completion		*pdone;
drivers/staging/ks7010/ks_wlan_net.c:#include <linux/completion.h>
drivers/staging/ks7010/ks_wlan_net.c:	if (!wait_for_completion_interruptible_timeout
drivers/staging/ks7010/ks7010_sdio.c:	init_completion(&priv->confirm_wait);
drivers/staging/ks7010/ks7010_sdio.c:	DPRINTK(5, "init_completion()\n");
drivers/staging/ks7010/ks7010_sdio.c:	if (!wait_for_completion_interruptible_timeout
drivers/staging/ks7010/ks7010_sdio.c:	if (!wait_for_completion_interruptible_timeout
drivers/staging/ks7010/ks7010_sdio.c:	init_completion(&priv->ks_wlan_hw.ks7010_sdio_wait);
drivers/staging/ks7010/ks7010_sdio.h:	struct completion ks7010_sdio_wait;
drivers/staging/ks7010/ks_wlan.h:#include <linux/completion.h>	/* struct completion */
drivers/staging/ks7010/ks_wlan.h:	struct completion wakeup_wait;
drivers/staging/ks7010/ks_wlan.h:	struct completion confirm_wait;
drivers/staging/ks7010/ks_hostif.c:		time_left = wait_for_completion_interruptible_timeout(
drivers/staging/ks7010/ks_hostif.c:	init_completion(&priv->psstatus.wakeup_wait);
drivers/staging/wlan-ng/hfa384x.h:	struct completion done;
drivers/staging/wlan-ng/hfa384x.h:	void *usercb_data;	/*  at CTLX completion  */
drivers/staging/wlan-ng/hfa384x.h:	struct tasklet_struct completion_bh;
drivers/staging/wlan-ng/prism2sta.c:		 * signify successful completion of both mlme_authenticate
drivers/staging/wlan-ng/prism2usb.c:		tasklet_kill(&hw->completion_bh);
drivers/staging/wlan-ng/hfa384x_usb.c:static void hfa384x_usbctlx_completion_task(unsigned long data);
drivers/staging/wlan-ng/hfa384x_usb.c:	tasklet_init(&hw->completion_bh,
drivers/staging/wlan-ng/hfa384x_usb.c:		     hfa384x_usbctlx_completion_task, (unsigned long)hw);
drivers/staging/wlan-ng/hfa384x_usb.c:		init_completion(&ctlx->done);
drivers/staging/wlan-ng/hfa384x_usb.c:	result = wait_for_completion_interruptible(&ctlx->done);
drivers/staging/wlan-ng/hfa384x_usb.c:		 * The completion task will send this CTLX
drivers/staging/wlan-ng/hfa384x_usb.c:*			command completion
drivers/staging/wlan-ng/hfa384x_usb.c:*			command completion
drivers/staging/wlan-ng/hfa384x_usb.c:*			command completion
drivers/staging/wlan-ng/hfa384x_usb.c: *       usercb          completion callback
drivers/staging/wlan-ng/hfa384x_usb.c: *       usercb_data     completion callback argument
drivers/staging/wlan-ng/hfa384x_usb.c:			/* Test for completion */
drivers/staging/wlan-ng/hfa384x_usb.c:* hfa384x_usbctlx_completion_task
drivers/staging/wlan-ng/hfa384x_usb.c:* Tasklet to call completion handlers for returned CTLXs
drivers/staging/wlan-ng/hfa384x_usb.c:static void hfa384x_usbctlx_completion_task(unsigned long data)
drivers/staging/wlan-ng/hfa384x_usb.c:		/* Call the completion function that this
drivers/staging/wlan-ng/hfa384x_usb.c:	 * If we succeed, then its completion handler will be
drivers/staging/wlan-ng/hfa384x_usb.c:		 * URB's completion function will not be called.
drivers/staging/wlan-ng/hfa384x_usb.c:	tasklet_schedule(&hw->completion_bh);
drivers/staging/wlan-ng/p80211netdev.h:	/* queue for indications waiting for cmd completion */
drivers/staging/iio/adc/spear_adc.c:#include <linux/completion.h>
drivers/staging/iio/adc/spear_adc.c:	struct completion completion;
drivers/staging/iio/adc/spear_adc.c:		wait_for_completion(&st->completion); /* set by ISR */
drivers/staging/iio/adc/spear_adc.c:	complete(&st->completion);
drivers/staging/iio/adc/spear_adc.c:	init_completion(&st->completion);
drivers/staging/iio/adc/lpc32xx_adc.c:#include <linux/completion.h>
drivers/staging/iio/adc/lpc32xx_adc.c:	struct completion completion;
drivers/staging/iio/adc/lpc32xx_adc.c:		wait_for_completion(&info->completion); /* set by ISR */
drivers/staging/iio/adc/lpc32xx_adc.c:	complete(&info->completion);
drivers/staging/iio/adc/lpc32xx_adc.c:	init_completion(&info->completion);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	VCHIQ_COMPLETION_DATA_T completions[MAX_COMPLETIONS];
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	int completion_insert;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	int completion_remove;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	struct mutex completion_mutex;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:*   add_completion
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:add_completion(VCHIQ_INSTANCE_T instance, VCHIQ_REASON_T reason,
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	VCHIQ_COMPLETION_DATA_T *completion;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	while (instance->completion_insert ==
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		(instance->completion_remove + MAX_COMPLETIONS)) {
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			"add_completion - completion queue full");
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	completion =
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		 &instance->completions[instance->completion_insert &
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	completion->header = header;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	completion->reason = reason;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	completion->service_userdata = user_service->service;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	completion->bulk_userdata = bulk_userdata;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	/* A write barrier is needed here to ensure that the entire completion
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			instance->completion_insert;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	instance->completion_insert++;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	** circular buffer for completion records.
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			/* If there is no MESSAGE_AVAILABLE in the completion
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				instance->completion_remove) < 0) {
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				status = add_completion(instance, reason,
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		** there is a MESSAGE_AVAILABLE in the completion queue then
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		** bypass the completion queue.
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			instance->completion_remove) >= 0) ||
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	return add_completion(instance, reason, header, user_service,
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			/* Wake the completion thread and ask it to exit */
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				instance->completion_remove - 1;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		mutex_lock(&instance->completion_mutex);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		while ((instance->completion_remove ==
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			instance->completion_insert)
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			mutex_unlock(&instance->completion_mutex);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			mutex_lock(&instance->completion_mutex);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		** completion record
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				VCHIQ_COMPLETION_DATA_T *completion;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				if (instance->completion_remove ==
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:					instance->completion_insert)
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				completion = &instance->completions[
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:					instance->completion_remove &
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				service = completion->service_userdata;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				completion->service_userdata =
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				header = completion->header;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:					/* The completion must point to the
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:					completion->header = msgbuf;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				if ((completion->reason ==
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:					completion,
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				instance->completion_remove++;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		mutex_unlock(&instance->completion_mutex);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		mutex_init(&instance->completion_mutex);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		mutex_lock(&instance->completion_mutex);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		/* Wake the completion thread and ask it to exit */
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		mutex_unlock(&instance->completion_mutex);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		/* Wake the slot handler if the completion queue is full. */
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		while (instance->completion_remove !=
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			instance->completion_insert) {
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			VCHIQ_COMPLETION_DATA_T *completion;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			completion = &instance->completions[
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:				instance->completion_remove &
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			service = completion->service_userdata;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			if (completion->reason == VCHIQ_SERVICE_CLOSED)
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			instance->completion_remove++;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:					"Instance %x: pid %d,%s completions "
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:					instance->completion_insert -
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:						instance->completion_remove,
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		if (wait_for_completion_interruptible(&arm_state->ka_evt)
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		init_completion(&arm_state->ka_evt);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		init_completion(&arm_state->vc_suspend_complete);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		init_completion(&arm_state->vc_resume_complete);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		 * completion while videocore is suspended. */
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		init_completion(&arm_state->resume_blocker);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		 * completion while resume is blocked */
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		init_completion(&arm_state->blocked_blocker);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		 * completion while things are waiting on the resume blocker */
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:** other state machine.  In addition, there are some completion events which
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:** VC_SUSPEND_IDLE - Initialise the suspend completion at the same time.
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:**			The suspend completion is completed after any suspend
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:**			the completion.  This reset occurs when videocore is
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:**			complete_all on the suspend completion to notify
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:**			We call complete_all on the suspend completion to notify
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:**			suspend completion and reset the resume state machine.
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:** VC_RESUME_IDLE - Initialise the resume completion at the same time.  The
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:**			resume completion is in it's 'done' state whenever
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:**			running can wait on this completion - it will only block
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:**			Call complete_all on the resume completion to unblock
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		reinit_completion(&arm_state->vc_suspend_complete);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		reinit_completion(&arm_state->vc_resume_complete);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		reinit_completion(&arm_state->blocked_blocker);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		if (wait_for_completion_interruptible_timeout(
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		if (wait_for_completion_interruptible_timeout(
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	reinit_completion(&arm_state->resume_blocker);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			"in progress - wait for completion", __func__);
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		rc = wait_for_completion_interruptible_timeout(
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		if (wait_for_completion_interruptible(
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		if (!try_wait_for_completion(&arm_state->resume_blocker)) {
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:			if (wait_for_completion_killable(
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:	if (!try_wait_for_completion(&arm_state->vc_resume_complete)) {
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:		if (wait_for_completion_killable(
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.h:	struct completion ka_evt;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.h:	struct completion vc_suspend_complete;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.h:	struct completion vc_resume_complete;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.h:	struct completion resume_blocker;
drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.h:	struct completion blocked_blocker;
drivers/staging/rtl8188eu/os_dep/usb_ops_linux.c:		goto check_completion;
drivers/staging/rtl8188eu/os_dep/usb_ops_linux.c:			goto check_completion;
drivers/staging/rtl8188eu/os_dep/usb_ops_linux.c:			goto check_completion;
drivers/staging/rtl8188eu/os_dep/usb_ops_linux.c:			goto check_completion;
drivers/staging/rtl8188eu/os_dep/usb_ops_linux.c:			goto check_completion;
drivers/staging/rtl8188eu/os_dep/usb_ops_linux.c:			goto check_completion;
drivers/staging/rtl8188eu/os_dep/usb_ops_linux.c:check_completion:
drivers/staging/rtl8188eu/os_dep/os_intfs.c:		wait_for_completion_interruptible(&padapter->cmdpriv.terminate_cmdthread_comp);
drivers/staging/rtl8188eu/os_dep/os_intfs.c:		wait_for_completion_interruptible(&padapter->cmdpriv.terminate_cmdthread_comp);
drivers/staging/rtl8188eu/core/rtw_cmd.c:	init_completion(&pcmdpriv->cmd_queue_comp);
drivers/staging/rtl8188eu/core/rtw_cmd.c:	init_completion(&pcmdpriv->terminate_cmdthread_comp);
drivers/staging/rtl8188eu/core/rtw_cmd.c:		if (wait_for_completion_interruptible(&pcmdpriv->cmd_queue_comp))
drivers/staging/rtl8188eu/core/rtw_xmit.c:	init_completion(&sctx->done);
drivers/staging/rtl8188eu/core/rtw_xmit.c:	if (!wait_for_completion_timeout(&sctx->done, expire)) {
drivers/staging/rtl8188eu/include/rtw_cmd.h:	struct completion cmd_queue_comp;
drivers/staging/rtl8188eu/include/rtw_cmd.h:	struct completion terminate_cmdthread_comp;
drivers/staging/rtl8188eu/include/rtw_xmit.h:	struct completion done;
drivers/staging/fsl-mc/README.txt:           -IRQs: command completion
drivers/staging/fsl-mc/include/mc-cmd.h:/* Command completion flag */
drivers/staging/fsl-mc/bus/mc-sys.c: * Timeout in milliseconds to wait for the completion of an MC command
drivers/staging/fsl-mc/bus/mc-sys.c: * iterations while waiting for MC command completion
drivers/staging/fsl-mc/bus/mc-sys.c: * Waits for the completion of an MC command doing preemptible polling.
drivers/staging/fsl-mc/bus/mc-sys.c: * @mc_status: MC command completion status
drivers/staging/fsl-mc/bus/mc-sys.c:		 * TODO: When MC command completion interrupts are supported
drivers/staging/fsl-mc/bus/mc-sys.c: * Waits for the completion of an MC command doing atomic polling.
drivers/staging/fsl-mc/bus/mc-sys.c: * @mc_status: MC command completion status
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:			/* as for the completion function, it does not need
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:			/* as for the completion function, it does not need
drivers/staging/wilc1000/wilc_wfi_netdevice.h:#include <linux/completion.h>
drivers/staging/wilc1000/wilc_wfi_netdevice.h:	struct completion cfg_event;
drivers/staging/wilc1000/wilc_wfi_netdevice.h:	struct completion sync_event;
drivers/staging/wilc1000/wilc_wfi_netdevice.h:	struct completion txq_event;
drivers/staging/wilc1000/wilc_wfi_netdevice.h:	struct completion txq_thread_started;
drivers/staging/wilc1000/wilc_wlan.h:/*time for expiring the completion of cfg packets*/
drivers/staging/wilc1000/host_interface.c:#include <linux/completion.h>
drivers/staging/wilc1000/host_interface.c:static struct completion hif_thread_comp;
drivers/staging/wilc1000/host_interface.c:static struct completion hif_driver_comp;
drivers/staging/wilc1000/host_interface.c:static struct completion hif_wait_response;
drivers/staging/wilc1000/host_interface.c:		wait_for_completion(&hif_drv->comp_test_key_block);
drivers/staging/wilc1000/host_interface.c:		wait_for_completion(&hif_drv->comp_test_key_block);
drivers/staging/wilc1000/host_interface.c:	wait_for_completion(&hif_drv->comp_test_key_block);
drivers/staging/wilc1000/host_interface.c:		wait_for_completion(&hif_drv->comp_test_key_block);
drivers/staging/wilc1000/host_interface.c:		wait_for_completion(&hif_drv->comp_test_key_block);
drivers/staging/wilc1000/host_interface.c:		wait_for_completion(&hif_drv->comp_test_key_block);
drivers/staging/wilc1000/host_interface.c:	wait_for_completion(&hif_wait_response);
drivers/staging/wilc1000/host_interface.c:		wait_for_completion(&hif_drv->comp_test_disconn_block);
drivers/staging/wilc1000/host_interface.c:		wait_for_completion(&hif_drv->comp_inactive_time);
drivers/staging/wilc1000/host_interface.c:	wait_for_completion(&hif_drv->comp_get_rssi);
drivers/staging/wilc1000/host_interface.c:		wait_for_completion(&hif_wait_response);
drivers/staging/wilc1000/host_interface.c:	init_completion(&hif_wait_response);
drivers/staging/wilc1000/host_interface.c:		init_completion(&hif_thread_comp);
drivers/staging/wilc1000/host_interface.c:		init_completion(&hif_driver_comp);
drivers/staging/wilc1000/host_interface.c:	init_completion(&hif_drv->comp_test_key_block);
drivers/staging/wilc1000/host_interface.c:	init_completion(&hif_drv->comp_test_disconn_block);
drivers/staging/wilc1000/host_interface.c:	init_completion(&hif_drv->comp_get_rssi);
drivers/staging/wilc1000/host_interface.c:	init_completion(&hif_drv->comp_inactive_time);
drivers/staging/wilc1000/host_interface.c:	wait_for_completion(&hif_driver_comp);
drivers/staging/wilc1000/host_interface.c:			wait_for_completion(&hif_thread_comp);
drivers/staging/wilc1000/host_interface.c:		wait_for_completion(&hif_wait_response);
drivers/staging/wilc1000/host_interface.c:	wait_for_completion(&hif_wait_response);
drivers/staging/wilc1000/linux_wlan.c:#include <linux/completion.h>
drivers/staging/wilc1000/linux_wlan.c:	/* FIXME: replace with mutex_lock or wait_for_completion */
drivers/staging/wilc1000/linux_wlan.c:		wait_for_completion(&wl->txq_event);
drivers/staging/wilc1000/linux_wlan.c:	if (!wait_for_completion_timeout(&wilc->sync_event,
drivers/staging/wilc1000/linux_wlan.c:	init_completion(&wl->txq_event);
drivers/staging/wilc1000/linux_wlan.c:	init_completion(&wl->cfg_event);
drivers/staging/wilc1000/linux_wlan.c:	init_completion(&wl->sync_event);
drivers/staging/wilc1000/linux_wlan.c:	init_completion(&wl->txq_thread_started);
drivers/staging/wilc1000/linux_wlan.c:	wait_for_completion(&wilc->txq_thread_started);
drivers/staging/wilc1000/host_interface.h:	struct completion comp_test_key_block;
drivers/staging/wilc1000/host_interface.h:	struct completion comp_test_disconn_block;
drivers/staging/wilc1000/host_interface.h:	struct completion comp_get_rssi;
drivers/staging/wilc1000/host_interface.h:	struct completion comp_inactive_time;
drivers/staging/wilc1000/wilc_wlan.c:#include <linux/completion.h>
drivers/staging/wilc1000/wilc_wlan.c:		wait_for_completion_timeout(&wilc->txq_event,
drivers/staging/wilc1000/wilc_wlan.c:		if (!wait_for_completion_timeout(&wilc->cfg_event,
drivers/staging/wilc1000/wilc_wlan.c:		if (!wait_for_completion_timeout(&wilc->cfg_event,
drivers/staging/unisys/visornic/visornic_main.c:	/* save the pointer to skb -- we'll need it for completion */
drivers/staging/unisys/visorbus/visorchipset.c:	int completion_status;
drivers/staging/unisys/visorbus/visorchipset.c:		msg->hdr.completion_status = (u32)(-response);
drivers/staging/unisys/visorbus/controlvmchannel.h:	/* Error status code or result of  message completion */
drivers/staging/unisys/visorbus/controlvmchannel.h:	u32 completion_status;
drivers/staging/unisys/visorbus/controlvmchannel.h:		u32 partial_completion:1;
drivers/staging/unisys/visorhba/visorhba_main.c: *                                   completion processing logic for a taskmgmt
drivers/staging/unisys/visorhba/visorhba_main.c:	 * will return the scsicmd pointer for completion
drivers/staging/unisys/visorhba/visorhba_main.c:		pr_err("visorhba: no completion context; cmd will time out\n");
drivers/staging/unisys/visorhba/visorhba_main.c: *	completion to the scsi midlayer.
drivers/staging/unisys/include/iochannel.h:	    * command completion.  Its value is preserved by iopart & returned
drivers/staging/unisys/include/iochannel.h:	     * command completion.  Its value is preserved by iopart & returned
drivers/staging/rtl8712/usb_ops_linux.c:	init_completion(&pintfpriv->io_retevt_comp);
drivers/staging/rtl8712/usb_ops_linux.c:	wait_for_completion_interruptible(&pintfpriv->io_retevt_comp);
drivers/staging/rtl8712/hal_init.c:	init_completion(&padapter->rtl8712_fw_ready);
drivers/staging/rtl8712/rtl871x_cmd.c:	init_completion(&pcmdpriv->cmd_queue_comp);
drivers/staging/rtl8712/rtl871x_cmd.c:	init_completion(&pcmdpriv->terminate_cmdthread_comp);
drivers/staging/rtl8712/os_intfs.c:		wait_for_completion_interruptible(&padapter->cmdpriv.terminate_cmdthread_comp);
drivers/staging/rtl8712/usb_intf.c:		wait_for_completion(&padapter->rtl8712_fw_ready);
drivers/staging/rtl8712/rtl8712_cmd.c:		if (wait_for_completion_interruptible(&pcmdpriv->cmd_queue_comp))
drivers/staging/rtl8712/drv_types.h:#include <linux/completion.h>
drivers/staging/rtl8712/drv_types.h:	struct completion rtl8712_fw_ready;
drivers/staging/rtl8712/rtl871x_cmd.h:	struct completion cmd_queue_comp;
drivers/staging/rtl8712/rtl871x_cmd.h:	struct completion terminate_cmdthread_comp;
drivers/staging/rtl8712/osdep_intf.h:	struct completion io_retevt_comp;
drivers/staging/fwserial/fwserial.c:/* FIXME: drop this workaround when __tty_hangup waits for ldisc completion */
drivers/staging/fwserial/dma_fifo.h:	unsigned int	 done;		/* updated upon dma completion        */
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.h:	/* IRQ number for DMA transfer completion at the image processor */
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:/* vpfe_imp_dma_isr() - ISR for ipipe dma completion */
drivers/staging/media/cec/cec-adap.c:	init_completion(&data->c);
drivers/staging/media/cec/cec-adap.c:	/* All done if we don't need to block waiting for completion */
drivers/staging/media/cec/cec-adap.c:	 * If we don't get a completion before this time something is really
drivers/staging/media/cec/cec-adap.c:	res = wait_for_completion_killable_timeout(&data->c,
drivers/staging/media/cec/cec-adap.c:	 * The wait for completion timed out or was interrupted, so mark this
drivers/staging/media/cec/cec-adap.c:	complete(&adap->config_completion);
drivers/staging/media/cec/cec-adap.c:	complete(&adap->config_completion);
drivers/staging/media/cec/cec-adap.c:	init_completion(&adap->config_completion);
drivers/staging/media/cec/cec-adap.c:		wait_for_completion(&adap->config_completion);
drivers/staging/media/lirc/lirc_imon.c:		struct completion finished;	/* wait for write to finish */
drivers/staging/media/lirc/lirc_imon.c:		int status;			/* status of tx completion */
drivers/staging/media/lirc/lirc_imon.c:	init_completion(&context->tx.finished);
drivers/staging/media/lirc/lirc_imon.c:		retval = wait_for_completion_interruptible(
drivers/staging/media/lirc/lirc_zilog.c:#include <linux/completion.h>
drivers/staging/media/lirc/lirc_sasem.c:		struct completion finished;  /* wait for write to finish  */
drivers/staging/media/lirc/lirc_sasem.c:		int status;		     /* status of tx completion */
drivers/staging/media/lirc/lirc_sasem.c:	init_completion(&context->tx.finished);
drivers/staging/media/lirc/lirc_sasem.c:		wait_for_completion(&context->tx.finished);
drivers/staging/media/lirc/lirc_sasem.c:		wait_for_completion(&context->tx.finished);
drivers/staging/media/omap4iss/iss_video.c: * field count and state fields before waking up its completion handler.
drivers/staging/media/bcm2048/radio-bcm2048.c:#include <linux/completion.h>
drivers/staging/media/bcm2048/radio-bcm2048.c:	struct completion compl;
drivers/staging/media/bcm2048/radio-bcm2048.c:	if (!wait_for_completion_timeout(&bdev->compl,
drivers/staging/media/bcm2048/radio-bcm2048.c:	init_completion(&bdev->compl);
drivers/staging/media/pulse8-cec/pulse8-cec.c:#include <linux/completion.h>
drivers/staging/media/pulse8-cec/pulse8-cec.c:	struct completion cmd_done;
drivers/staging/media/pulse8-cec/pulse8-cec.c:	init_completion(&pulse8->cmd_done);
drivers/staging/media/pulse8-cec/pulse8-cec.c:	if (!wait_for_completion_timeout(&pulse8->cmd_done, HZ))
drivers/staging/most/aim-network/networking.c:	.tx_completion = aim_resume_tx_channel,
drivers/staging/most/aim-network/networking.c:	.rx_completion = aim_rx_data,
drivers/staging/most/mostcore/core.c:#include <linux/completion.h>
drivers/staging/most/mostcore/core.c:	struct completion cleanup;
drivers/staging/most/mostcore/core.c: * Calls the completion handler of an attached AIM.
drivers/staging/most/mostcore/core.c:	if (c->aim0.refs && c->aim0.ptr->tx_completion)
drivers/staging/most/mostcore/core.c:		c->aim0.ptr->tx_completion(c->iface, c->channel_id);
drivers/staging/most/mostcore/core.c:	if (c->aim1.refs && c->aim1.ptr->tx_completion)
drivers/staging/most/mostcore/core.c:		c->aim1.ptr->tx_completion(c->iface, c->channel_id);
drivers/staging/most/mostcore/core.c: * @compl: pointer to completion function
drivers/staging/most/mostcore/core.c: * most_write_completion - write completion handler
drivers/staging/most/mostcore/core.c:static void most_write_completion(struct mbo *mbo)
drivers/staging/most/mostcore/core.c: * most_read_completion - read completion handler
drivers/staging/most/mostcore/core.c:static void most_read_completion(struct mbo *mbo)
drivers/staging/most/mostcore/core.c:	if (c->aim0.refs && c->aim0.ptr->rx_completion &&
drivers/staging/most/mostcore/core.c:	    c->aim0.ptr->rx_completion(mbo) == 0)
drivers/staging/most/mostcore/core.c:	if (c->aim1.refs && c->aim1.ptr->rx_completion &&
drivers/staging/most/mostcore/core.c:	    c->aim1.ptr->rx_completion(mbo) == 0)
drivers/staging/most/mostcore/core.c:					   most_read_completion);
drivers/staging/most/mostcore/core.c:					   most_write_completion);
drivers/staging/most/mostcore/core.c:	if (wait_for_completion_interruptible(&c->cleanup)) {
drivers/staging/most/mostcore/core.c:	wait_for_completion(&c->cleanup);
drivers/staging/most/mostcore/core.c:		init_completion(&c->cleanup);
drivers/staging/most/mostcore/mostcore.h: * @context: context for core completion handler
drivers/staging/most/mostcore/mostcore.h: * @complete: (in) completion routine
drivers/staging/most/mostcore/mostcore.h: * the transfer procedure by calling the completion routine.
drivers/staging/most/mostcore/mostcore.h: *   be returned back to the MostCore using completion routine.
drivers/staging/most/mostcore/mostcore.h: *   all enqueued for this channel MBOs using the completion routine.
drivers/staging/most/mostcore/mostcore.h: * @rx_completion: completion handler for received packets
drivers/staging/most/mostcore/mostcore.h: * @tx_completion: completion handler for transmitted packets
drivers/staging/most/mostcore/mostcore.h:	int (*rx_completion)(struct mbo *mbo);
drivers/staging/most/mostcore/mostcore.h:	int (*tx_completion)(struct most_interface *iface, int channel_idx);
drivers/staging/most/aim-sound/sound.c: * audio_rx_completion - completion handler for rx channels
drivers/staging/most/aim-sound/sound.c:static int audio_rx_completion(struct mbo *mbo)
drivers/staging/most/aim-sound/sound.c:		pr_err("sound_rx_completion(), invalid channel %d\n",
drivers/staging/most/aim-sound/sound.c: * audio_tx_completion - completion handler for tx channels
drivers/staging/most/aim-sound/sound.c:static int audio_tx_completion(struct most_interface *iface, int channel_id)
drivers/staging/most/aim-sound/sound.c:		pr_err("sound_tx_completion(), invalid channel %d\n",
drivers/staging/most/aim-sound/sound.c:	.rx_completion = audio_rx_completion,
drivers/staging/most/aim-sound/sound.c:	.tx_completion = audio_tx_completion,
drivers/staging/most/aim-cdev/cdev.c: * aim_rx_completion - completion handler for rx channels
drivers/staging/most/aim-cdev/cdev.c:static int aim_rx_completion(struct mbo *mbo)
drivers/staging/most/aim-cdev/cdev.c: * aim_tx_completion - completion handler for tx channels
drivers/staging/most/aim-cdev/cdev.c:static int aim_tx_completion(struct most_interface *iface, int channel_id)
drivers/staging/most/aim-cdev/cdev.c:	.rx_completion = aim_rx_completion,
drivers/staging/most/aim-cdev/cdev.c:	.tx_completion = aim_tx_completion,
drivers/staging/most/aim-v4l2/video.c:	 * From the other hand mostcore still calling rx_completion()
drivers/staging/most/aim-v4l2/video.c:	.rx_completion = aim_rx_data,
drivers/staging/most/hdm-dim2/dim2_hdm.c: * Return back the completed buffers to mostcore, using completion callback
drivers/staging/most/hdm-dim2/dim2_hdm.c: * completion call back.
drivers/staging/most/hdm-dim2/dim2_hal.c:	/* wait for transfer completion */
drivers/staging/most/hdm-usb/hdm_usb.c:#include <linux/completion.h>
drivers/staging/most/hdm-usb/hdm_usb.c: * calls the associated completion function of the core and removes
drivers/staging/most/hdm-usb/hdm_usb.c: * hdm_write_completion - completion function for submitted Tx URBs
drivers/staging/most/hdm-usb/hdm_usb.c: * the completion function.
drivers/staging/most/hdm-usb/hdm_usb.c:static void hdm_write_completion(struct urb *urb)
drivers/staging/most/hdm-usb/hdm_usb.c: * hdm_read_completion - completion function for submitted Rx URBs
drivers/staging/most/hdm-usb/hdm_usb.c: * padding bytes -if necessary- and calls the completion function.
drivers/staging/most/hdm-usb/hdm_usb.c: * USB device drivers may only test urb status values in completion handlers.
drivers/staging/most/hdm-usb/hdm_usb.c:static void hdm_read_completion(struct urb *urb)
drivers/staging/most/hdm-usb/hdm_usb.c:				  hdm_write_completion,
drivers/staging/most/hdm-usb/hdm_usb.c:				  hdm_read_completion,
drivers/staging/greybus/fw-management.c:#include <linux/completion.h>
drivers/staging/greybus/fw-management.c:	struct completion	completion;
drivers/staging/greybus/fw-management.c:	complete(&fw_mgmt->completion);
drivers/staging/greybus/fw-management.c:	complete(&fw_mgmt->completion);
drivers/staging/greybus/fw-management.c:		if (!wait_for_completion_timeout(&fw_mgmt->completion,
drivers/staging/greybus/fw-management.c:		if (!wait_for_completion_timeout(&fw_mgmt->completion,
drivers/staging/greybus/fw-management.c:	init_completion(&fw_mgmt->completion);
drivers/staging/greybus/interface.c:	complete(&intf->mode_switch_completion);
drivers/staging/greybus/interface.c:	ret = wait_for_completion_interruptible_timeout(
drivers/staging/greybus/interface.c:			&intf->mode_switch_completion, timeout);
drivers/staging/greybus/interface.c:	reinit_completion(&intf->mode_switch_completion);
drivers/staging/greybus/interface.c:	init_completion(&intf->mode_switch_completion);
drivers/staging/greybus/interface.c:		complete(&intf->mode_switch_completion);
drivers/staging/greybus/timesync.c:			"timeout SVC strobe completion %d/%d\n",
drivers/staging/greybus/operation.h:#include <linux/completion.h>
drivers/staging/greybus/operation.h:	struct completion	completion;
drivers/staging/greybus/loopback.c:	int (*completion)(struct gb_loopback_async_operation *op_async);
drivers/staging/greybus/loopback.c:	wait_queue_head_t wq_completion;
drivers/staging/greybus/loopback.c:	wake_up(&op_async->gb->wq_completion);
drivers/staging/greybus/loopback.c:	wait_event(gb->wq_completion,
drivers/staging/greybus/loopback.c:		if (op_async->completion)
drivers/staging/greybus/loopback.c:			if (op_async->completion(op_async))
drivers/staging/greybus/loopback.c:				       void *completion)
drivers/staging/greybus/loopback.c:	op_async->completion = completion;
drivers/staging/greybus/loopback.c:	wait_event_interruptible(gb->wq_completion,
drivers/staging/greybus/loopback.c:	init_waitqueue_head(&gb->wq_completion);
drivers/staging/greybus/es2.c:	struct completion response_received;
drivers/staging/greybus/es2.c:	init_completion(&rpc->response_received);
drivers/staging/greybus/es2.c:	retval = wait_for_completion_interruptible_timeout(
drivers/staging/greybus/interface.h:	struct completion mode_switch_completion;
drivers/staging/greybus/operation.c:/* Workqueue to handle Greybus operation completions. */
drivers/staging/greybus/operation.c:static struct workqueue_struct *gb_operation_completion_wq;
drivers/staging/greybus/operation.c:	init_completion(&operation->completion);
drivers/staging/greybus/operation.c:	complete(&operation->completion);
drivers/staging/greybus/operation.c: * @callback:	the operation completion callback
drivers/staging/greybus/operation.c:	ret = wait_for_completion_interruptible_timeout(&operation->completion,
drivers/staging/greybus/operation.c:	 * schedule its completion.
drivers/staging/greybus/operation.c:			queue_work(gb_operation_completion_wq,
drivers/staging/greybus/operation.c:		queue_work(gb_operation_completion_wq, &operation->work);
drivers/staging/greybus/operation.c:		queue_work(gb_operation_completion_wq, &operation->work);
drivers/staging/greybus/operation.c:	gb_operation_completion_wq = alloc_workqueue("greybus_completion",
drivers/staging/greybus/operation.c:	if (!gb_operation_completion_wq)
drivers/staging/greybus/operation.c:	destroy_workqueue(gb_operation_completion_wq);
drivers/staging/greybus/operation.c:	gb_operation_completion_wq = NULL;
drivers/staging/greybus/uart.c:#include <linux/completion.h>
drivers/staging/greybus/uart.c:	struct completion credits_complete;
drivers/staging/greybus/uart.c:	ret = wait_for_completion_timeout(&gb_tty->credits_complete,
drivers/staging/greybus/uart.c:	init_completion(&gb_tty->credits_complete);
drivers/bluetooth/btwilink.c:/* Number of seconds to wait for registration completion
drivers/bluetooth/btwilink.c: * @wait_reg_completion - completion sync between ti_st_open
drivers/bluetooth/btwilink.c: *	and st_reg_completion_cb.
drivers/bluetooth/btwilink.c:	struct completion wait_reg_completion;
drivers/bluetooth/btwilink.c:/* Called by ST layer to indicate protocol registration completion
drivers/bluetooth/btwilink.c:static void st_reg_completion_cb(void *priv_data, int data)
drivers/bluetooth/btwilink.c:	complete(&lhst->wait_reg_completion);
drivers/bluetooth/btwilink.c:		ti_st_proto[i].reg_complete_cb = st_reg_completion_cb;
drivers/bluetooth/btwilink.c:		/* Prepare wait-for-completion handler */
drivers/bluetooth/btwilink.c:		init_completion(&hst->wait_reg_completion);
drivers/bluetooth/btwilink.c:		 * st_reg_completion_cb()
drivers/bluetooth/btwilink.c:				"completion signal from ST");
drivers/bluetooth/btwilink.c:		timeleft = wait_for_completion_timeout
drivers/bluetooth/btwilink.c:			(&hst->wait_reg_completion,
drivers/bluetooth/btwilink.c:					"completion signal from ST",
drivers/atm/firestream.c:		   from having to wait for completion. On the other hand, we may
drivers/atm/firestream.c:		   need to wait for completion anyway, to see if it completed
drivers/atm/fore200e.h:    u32              status_haddr;    /* host DMA address of completion status  */
drivers/atm/fore200e.h:    u32 status_haddr;    /* host DMA address of completion status  */
drivers/atm/fore200e.h:    u32 status_haddr;       /* host DMA address of completion status  */
drivers/atm/fore200e.h:/* completion status */
drivers/atm/fore200e.h:    STATUS_COMPLETE = (1<<1),    /* completion status (written by cp) */
drivers/atm/fore200e.h:    STATUS_ERROR    = (1<<3)     /* completion status (written by cp) */
drivers/atm/fore200e.h:    u32       status_haddr;    /* host DMA address of completion status */
drivers/atm/fore200e.h:    struct chunk           status;                          /* array of completion status      */
drivers/atm/fore200e.h:    struct chunk          status;                         /* arry of completion status              */
drivers/atm/fore200e.h:    struct chunk           status;                         /* array of completion status             */
drivers/atm/fore200e.h:    struct chunk          status;                         /* array of completion status                */
drivers/atm/fore200e.c:		   not be popped after the completion of their emission, as they refer
drivers/atm/fore200e.c:		/* notify tx completion */
drivers/atm/horizon.c:  component in the IRQ handler is the BM completion handler. This can
drivers/atm/horizon.c:  The IRQ component handles TX completion (stats, free buffer, tx_busy
drivers/atm/horizon.c:  fresh data that has arrived on the card, the BM completion handler
drivers/atm/horizon.c:  is very similar to the TX completion handler. The data available
drivers/atm/horizon.c:  completion handler only runs when the lock is held; the data
drivers/atm/horizon.c:	PRINTD (DBG_RX|DBG_ERR, "spun out waiting PCI Bus Master RX completion");
drivers/atm/horizon.c:    PRINTD (DBG_RX|DBG_ERR, "unexpected RX bus master completion");
drivers/atm/horizon.c:	PRINTD (DBG_TX|DBG_ERR, "spun out waiting PCI Bus Master TX completion");
drivers/atm/horizon.c:    PRINTD (DBG_TX|DBG_ERR, "unexpected TX bus master completion");
drivers/atm/horizon.c:  // lock is cleared if we fail now, o/w after bus master completion
drivers/atm/horizon.c:    // (only an issue for slow hosts) RX completion goes before
drivers/atm/horizon.c:    // (only an issue for slow hosts) TX completion goes before RX
drivers/atm/ambassador.h:/* mailbox[1] = 0 in progress, -1 on completion */
drivers/atm/ambassador.h:  __be32 command_start;		/* SRB commands completions */
drivers/atm/ambassador.h:  __be32 command_end;		/* SRB commands completions */
drivers/atm/ambassador.h:  __be32 txcom_start;		/* tx completions */
drivers/atm/ambassador.h:  __be32 txcom_end;		/* tx completions */
drivers/atm/ambassador.h:    __be32 rx_start;		/* rx completions */
drivers/atm/iphase.c:	    IF_ERR(printk(DEV_LABEL "send desc:%d completion code %d error\n", 
drivers/atm/ambassador.c:  from the return (TX and RX completions). The adapter deals with out
drivers/atm/ambassador.c:  of order completions.
drivers/atm/ambassador.c:  card. There is no out of order completion or notification. The
drivers/atm/ambassador.c:/********** TX completion **********/
drivers/atm/ambassador.c:/********** RX completion **********/
drivers/atm/ambassador.c:  lists) are given to the TX queue pair, completions are returned.
drivers/atm/ambassador.c:      PRINTD (DBG_CMD, "wait: command slot completion");
drivers/atm/ambassador.c:    // deal with TX completion
drivers/atm/ambassador.c:    // deal with RX completion
drivers/atm/eni.c:		 * keeping track of TX completions all the time, so let's poll
drivers/isdn/hysdn/hysdn_net.c:	/* When the TX completion hw interrupt arrives, this
drivers/isdn/hysdn/hysdn_net.c:/* completion                                                          */
drivers/isdn/hardware/mISDN/hfcsusb.c:/* control completion routine handling background control cmds */
drivers/isdn/hardware/mISDN/hfcsusb.c:/* receive completion routine for all ISO tx fifos   */
drivers/isdn/hardware/mISDN/hfcsusb.c:					 * completions
drivers/isdn/hardware/mISDN/hfcsusb.c:/* receive completion routine for all interrupt rx fifos */
drivers/isdn/hardware/mISDN/hfcsusb.c:/* transmit completion routine for all ISO tx fifos */
drivers/isdn/hardware/mISDN/hfcsusb.c:						/* signal frame completion */
drivers/isdn/hardware/mISDN/hfcsusb.c:		 * abuse DChannel tx iso completion to trigger NT mode state
drivers/isdn/mISDN/stack.c:		wait_for_completion(&done);
drivers/isdn/mISDN/stack.c:		wait_for_completion(&done);
drivers/isdn/mISDN/l1oip.h:	struct completion	socket_complete;/* completion of sock thread */
drivers/isdn/mISDN/l1oip_core.c:	/* if we got killed, signal completion */
drivers/isdn/mISDN/l1oip_core.c:		wait_for_completion(&hc->socket_complete);
drivers/isdn/mISDN/l1oip_core.c:	init_completion(&hc->socket_complete);
drivers/isdn/hisax/hfc_usb.c:						/* here frame completion */
drivers/isdn/hisax/hfc_usb.c:				   to avoid overlapped iso completions */
drivers/isdn/hisax/st5481_init.c:	// we would actually better wait for completion of outstanding urbs
drivers/isdn/hisax/st5481_usb.c: * Called either by the completion or by usb_ctrl_msg.
drivers/isdn/hisax/st5481_usb.c: * Call the user provided completion routine and try
drivers/isdn/gigaset/i4l.c: *	ack		if != 0 LL wants to be notified on completion via
drivers/isdn/gigaset/i4l.c: * skb has been successfully sent, for signalling completion to the LL.
drivers/isdn/gigaset/capi.c: * skb has been successfully sent, for signalling completion to the LL.
drivers/isdn/gigaset/usb-gigaset.c: * Interrupt Input URB completion routine
drivers/isdn/gigaset/usb-gigaset.c:	case 0:			/* normal completion */
drivers/isdn/gigaset/common.c: * waiting for completion of the initialization.
drivers/isdn/gigaset/common.c: * waiting for completion of the shutdown.
drivers/isdn/gigaset/common.c: * waiting for completion of the shutdown.
drivers/isdn/gigaset/bas-gigaset.c: * check for completion of pending control request
drivers/isdn/gigaset/bas-gigaset.c: * USB completion handler for control pipe input
drivers/isdn/gigaset/bas-gigaset.c:	case 0:				/* normal completion */
drivers/isdn/gigaset/bas-gigaset.c: * USB completion handler for interrupt pipe input
drivers/isdn/gigaset/bas-gigaset.c: * USB completion handler for B channel isochronous input
drivers/isdn/gigaset/bas-gigaset.c: * USB completion handler for B channel isochronous output
drivers/isdn/gigaset/bas-gigaset.c:		case -EXDEV:			/* partial completion */
drivers/isdn/gigaset/bas-gigaset.c:		case 0:				/* normal completion */
drivers/isdn/gigaset/bas-gigaset.c:		case 0:				/* normal completion */
drivers/isdn/gigaset/bas-gigaset.c: * USB completion handler for control pipe output
drivers/isdn/gigaset/bas-gigaset.c:	case 0:					/* normal completion */
drivers/isdn/gigaset/bas-gigaset.c: * USB completion handler for AT command transmission
drivers/isdn/gigaset/bas-gigaset.c:	case 0:					/* normal completion */
drivers/isdn/gigaset/ser-gigaset.c:#include <linux/completion.h>
drivers/isdn/gigaset/ser-gigaset.c:	struct completion	dead_cmp;
drivers/isdn/gigaset/ser-gigaset.c:	init_completion(&cs->hw.ser->dead_cmp);
drivers/isdn/gigaset/ser-gigaset.c:			wait_for_completion(&cs->hw.ser->dead_cmp);
drivers/isdn/gigaset/gigaset.h: * - status: URB completion status
drivers/isdn/gigaset/gigaset.h:/* Called from hardware module to indicate completion of an skb */
drivers/bcma/driver_pci_host.c:		 * least return a completion TLP, with a completion status
drivers/bcma/driver_pci_host.c:		 * until we receive the successful completion status. Repeat
drivers/dma-buf/fence.c: * fence_signal_locked - signal completion of a fence
drivers/dma-buf/fence.c: * Signal completion for software callbacks on a fence, this will unblock
drivers/dma-buf/fence.c: * fence_signal - signal completion of a fence
drivers/dma-buf/fence.c: * Signal completion for software callbacks on a fence, this will unblock
drivers/uwb/i1480/dfu/i1480-dfu.h:#include <linux/completion.h>
drivers/uwb/i1480/dfu/i1480-dfu.h:	struct completion evt_complete;
drivers/uwb/i1480/dfu/i1480-dfu.h:	init_completion(&i1480->evt_complete);
drivers/uwb/i1480/dfu/dfu.c:	init_completion(&i1480->evt_complete);
drivers/uwb/i1480/dfu/dfu.c:	result = wait_for_completion_interruptible_timeout(
drivers/uwb/i1480/dfu/usb.c: * Just enables the completion read handler.
drivers/uwb/i1480/dfu/usb.c:	init_completion(&i1480->evt_complete);
drivers/uwb/i1480/dfu/usb.c:	result = wait_for_completion_interruptible_timeout(
drivers/uwb/reset.c:	struct completion completion;
drivers/uwb/reset.c:	complete(&p->completion);
drivers/uwb/reset.c:	init_completion(&params.completion);
drivers/uwb/reset.c:	wait_for_completion(&params.completion);
drivers/base/devtmpfs.c:	struct completion done;
drivers/base/devtmpfs.c:	init_completion(&req.done);
drivers/base/devtmpfs.c:	wait_for_completion(&req.done);
drivers/base/devtmpfs.c:	init_completion(&req.done);
drivers/base/devtmpfs.c:	wait_for_completion(&req.done);
drivers/base/devtmpfs.c:		wait_for_completion(&setup_done);
drivers/base/firmware_class.c:	struct completion completion;
drivers/base/firmware_class.c:	init_completion(&buf->completion);
drivers/base/firmware_class.c:	complete_all(&buf->completion);
drivers/base/firmware_class.c:	complete_all(&buf->completion);
drivers/base/firmware_class.c:			complete_all(&fw_buf->completion);
drivers/base/firmware_class.c:	timeout = wait_for_completion_interruptible_timeout(&buf->completion,
drivers/base/firmware_class.c:		ret = wait_for_completion_interruptible(&buf->completion);
drivers/base/firmware_class.c:	/* wait for completion of caching firmware for all devices */
drivers/base/power/runtime.c: * __pm_runtime_barrier - Cancel pending requests and wait for completions.
drivers/base/power/runtime.c: * pm_runtime_barrier - Flush pending requests and wait for completions.
drivers/base/power/main.c:	init_completion(&dev->power.completion);
drivers/base/power/main.c:	complete_all(&dev->power.completion);
drivers/base/power/main.c:	complete_all(&dev->power.completion);
drivers/base/power/main.c:		wait_for_completion(&dev->power.completion);
drivers/base/power/main.c:	complete_all(&dev->power.completion);
drivers/base/power/main.c:		reinit_completion(&dev->power.completion);
drivers/base/power/main.c:	complete_all(&dev->power.completion);
drivers/base/power/main.c:		reinit_completion(&dev->power.completion);
drivers/base/power/main.c:	complete_all(&dev->power.completion);
drivers/base/power/main.c:		reinit_completion(&dev->power.completion);
drivers/base/power/main.c:	complete_all(&dev->power.completion);
drivers/base/power/main.c:	reinit_completion(&dev->power.completion);
drivers/base/power/main.c:	complete_all(&dev->power.completion);
drivers/base/power/main.c:	reinit_completion(&dev->power.completion);
drivers/base/power/main.c:	complete_all(&dev->power.completion);
drivers/base/power/main.c:	reinit_completion(&dev->power.completion);
drivers/nvme/host/pci.c:#define CQ_SIZE(depth)		(depth * sizeof(struct nvme_completion))
drivers/nvme/host/pci.c:	struct completion ioq_wait;
drivers/nvme/host/pci.c:	volatile struct nvme_completion *cqes;
drivers/nvme/host/pci.c:		struct nvme_completion cqe = nvmeq->cqes[head];
drivers/nvme/host/pci.c:		 * queue to flush these to completion.
drivers/nvme/host/pci.c:		reinit_completion(&dev->ioq_wait);
drivers/nvme/host/pci.c:			timeout = wait_for_completion_io_timeout(&dev->ioq_wait, timeout);
drivers/nvme/host/pci.c:	init_completion(&dev->ioq_wait);
drivers/nvme/host/nvme.h:		kfree(req->completion_data);
drivers/nvme/host/nvme.h:		struct nvme_completion *cqe);
drivers/nvme/host/nvme.h:		struct nvme_completion *cqe, void *buffer, unsigned bufflen,
drivers/nvme/host/lightnvm.c:struct nvme_nvm_completion {
drivers/nvme/host/lightnvm.c:	__le64	result;		/* Used by LightNVM to return ppa completions */
drivers/nvme/host/lightnvm.c:	struct nvme_nvm_completion *cqe = rq->special;
drivers/nvme/host/lightnvm.c:				sizeof(struct nvme_nvm_completion), GFP_KERNEL);
drivers/nvme/host/fabrics.c:	struct nvme_completion cqe;
drivers/nvme/host/fabrics.c:	struct nvme_completion cqe;
drivers/nvme/host/fabrics.c:	struct nvme_completion cqe;
drivers/nvme/host/fabrics.c:	struct nvme_completion cqe;
drivers/nvme/host/core.c:	req->completion_data = range;
drivers/nvme/host/core.c:	 * on disk. This allows us to report completion on the full amount
drivers/nvme/host/core.c:		struct nvme_completion *cqe, void *buffer, unsigned bufflen,
drivers/nvme/host/core.c:	struct nvme_completion cqe;
drivers/nvme/host/core.c:	struct nvme_completion cqe;
drivers/nvme/host/core.c:	struct nvme_completion cqe;
drivers/nvme/host/core.c:		struct nvme_completion *cqe)
drivers/nvme/host/scsi.c:static int nvme_trans_completion(struct sg_io_hdr *hdr, u8 status, u8 sense_key,
drivers/nvme/host/scsi.c:	res = nvme_trans_completion(hdr, status, sense_key, asc, ascq);
drivers/nvme/host/scsi.c:		return nvme_trans_completion(hdr,
drivers/nvme/host/scsi.c:	/* Bytes 10,11: Extended selftest completion time = 0x0000 */
drivers/nvme/host/scsi.c:		return nvme_trans_completion(hdr,
drivers/nvme/host/scsi.c:			res = nvme_trans_completion(hdr,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:			res = nvme_trans_completion(hdr,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:			return nvme_trans_completion(hdr,
drivers/nvme/host/scsi.c:				res = nvme_trans_completion(hdr,
drivers/nvme/host/scsi.c:			res = nvme_trans_completion(hdr,
drivers/nvme/host/scsi.c:			res = nvme_trans_completion(hdr,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		return nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:			res = nvme_trans_completion(hdr,
drivers/nvme/host/scsi.c:	return nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		return nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		return nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		return nvme_trans_completion(hdr, SAM_STAT_GOOD, NO_SENSE, 0, 0);
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		res = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/scsi.c:		retcode = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,
drivers/nvme/host/rdma.c:	struct completion	cm_done;
drivers/nvme/host/rdma.c:	wait_for_completion_interruptible_timeout(&queue->cm_done,
drivers/nvme/host/rdma.c:			sizeof(struct nvme_completion), DMA_FROM_DEVICE);
drivers/nvme/host/rdma.c:			sizeof(struct nvme_completion), DMA_FROM_DEVICE);
drivers/nvme/host/rdma.c:	init_completion(&queue->cm_done);
drivers/nvme/host/rdma.c:	 * Unsignalled send completions are another giant desaster in the
drivers/nvme/host/rdma.c:	list.length = sizeof(struct nvme_completion);
drivers/nvme/host/rdma.c:		struct nvme_completion *cqe, struct ib_wc *wc, int tag)
drivers/nvme/host/rdma.c:	struct nvme_completion *cqe = qe->data;
drivers/nvme/host/rdma.c:	const size_t len = sizeof(struct nvme_completion);
drivers/nvme/target/loop.c:	struct nvme_completion	rsp;
drivers/nvme/target/loop.c:	struct nvme_completion *cqe = &iod->rsp;
drivers/nvme/target/nvmet.h:	struct completion	disable_done;
drivers/nvme/target/nvmet.h:	struct completion	free_done;
drivers/nvme/target/nvmet.h:	struct nvme_completion	*rsp;
drivers/nvme/target/admin-cmd.c:	id->iorcsz = cpu_to_le32(sizeof(struct nvme_completion) / 16);
drivers/nvme/target/core.c:	wait_for_completion(&ns->disable_done);
drivers/nvme/target/core.c:	init_completion(&ns->disable_done);
drivers/nvme/target/core.c:	wait_for_completion(&sq->free_done);
drivers/nvme/target/core.c:	init_completion(&sq->free_done);
drivers/nvme/target/fabrics-cmd.c:	/* zero out initial completion result, assign values as needed */
drivers/nvme/target/fabrics-cmd.c:	/* zero out initial completion result, assign values as needed */
drivers/nvme/target/rdma.c:	 * Spread the io queues across completion vectors,
drivers/net/irda/vlsi_ir.c:			 * for any len>0 packet. tx completion interrupt
drivers/net/irda/vlsi_ir.c:	 * after subsequent tx-completion
drivers/net/irda/sir_dev.c: * to wait for transmit completion before changing the port configuration
drivers/net/irda/sir_dev.c: * Both must be unlocked/restarted on completion - but only on final exit.
drivers/net/irda/sir_dev.c:		 *	on completion dev->new_speed gets cleared,
drivers/net/irda/sir_dev.c:			 *	on completion the queue gets restarted
drivers/net/irda/sir_dev.c:	/* serialize with write completion */
drivers/net/irda/sir_dev.c:		/* cannot sleep here for completion
drivers/net/irda/sir_dev.c:		/* cannot sleep here for completion
drivers/net/irda/sir_dev.c:		/* cannot sleep here for completion
drivers/net/irda/sir_dev.c:		/* cannot sleep here for completion
drivers/net/irda/sir_dev.c:	down(&dev->fsm.sem);		/* block on pending config completion */
drivers/net/irda/irda-usb.c:		/* We will do ` self->new_speed = -1; ' in the completion
drivers/net/irda/irda-usb.c:		/* We will do ` self->new_xbofs = -1; ' in the completion
drivers/net/irda/irda-usb.c:			 * in completion handler, we will come back here.
drivers/net/irda/irda-usb.c:			 * in completion handler, because urb->status will
drivers/net/irda/irda-usb.c: * Mostly called by the completion callback of the previous URB.
drivers/net/irda/irtty-sir.c: * context is either netdev->hard_xmit or some transmit-completion bh
drivers/net/irda/irtty-sir.c:		/* this call blocks for completion */
drivers/net/irda/stir4200.c: * USB bulk receive completion callback.
drivers/net/wireless/st/cw1200/wsm.h: * join complete to notify about completion
drivers/net/wireless/st/cw1200/wsm.h:	/* Packet identifier that meant to be used in completion. */
drivers/net/wireless/st/cw1200/wsm.c:	/* Wait for command completion */
drivers/net/wireless/st/cw1200/fwio.c:	/* Wait for the download completion */
drivers/net/wireless/st/cw1200/fwio.c:		pr_err("Wait for download completion failed: 0x%.8X\n", val32);
drivers/net/wireless/realtek/rtlwifi/wifi.h:#include <linux/completion.h>
drivers/net/wireless/realtek/rtlwifi/wifi.h:	struct completion firmware_loading_complete;
drivers/net/wireless/realtek/rtlwifi/pci.c:	init_completion(&rtlpriv->firmware_loading_complete);
drivers/net/wireless/realtek/rtlwifi/pci.c:	wait_for_completion(&rtlpriv->firmware_loading_complete);
drivers/net/wireless/realtek/rtlwifi/usb.c:	init_completion(&rtlpriv->firmware_loading_complete);
drivers/net/wireless/realtek/rtlwifi/usb.c:	wait_for_completion(&rtlpriv->firmware_loading_complete);
drivers/net/wireless/ralink/rt2x00/rt2x00usb.c:	struct work_struct *completion;
drivers/net/wireless/ralink/rt2x00/rt2x00usb.c:	 * Obtain the queue completion handler
drivers/net/wireless/ralink/rt2x00/rt2x00usb.c:		completion = &queue->rt2x00dev->txdone_work;
drivers/net/wireless/ralink/rt2x00/rt2x00usb.c:		completion = &queue->rt2x00dev->rxdone_work;
drivers/net/wireless/ralink/rt2x00/rt2x00usb.c:		 * Schedule the completion handler manually, when this
drivers/net/wireless/ralink/rt2x00/rt2x00usb.c:		queue_work(queue->rt2x00dev->workqueue, completion);
drivers/net/wireless/ralink/rt2x00/rt2x00.h:	 * other work structures and wait for their completion in order
drivers/net/wireless/intersil/hostap/hostap_download.c:	 * Make sure the INIT command does not generate a command completion
drivers/net/wireless/intersil/hostap/hostap_hw.c: * hfa384x_cmd - Issue a Prism2 command and wait (sleep) for completion
drivers/net/wireless/intersil/hostap/hostap_hw.c:	/* prepare to wait for command completion event, but do not sleep yet
drivers/net/wireless/intersil/hostap/hostap_hw.c:		goto wait_completion;
drivers/net/wireless/intersil/hostap/hostap_hw.c: wait_completion:
drivers/net/wireless/intersil/hostap/hostap_hw.c:	 * here. If the command completion event is still generated,
drivers/net/wireless/intersil/hostap/hostap_hw.c:			/* Command completion event is pending, but the
drivers/net/wireless/intersil/hostap/hostap_hw.c: * @callback: command completion callback function (%NULL = no callback)
drivers/net/wireless/intersil/hostap/hostap_hw.c: * callback function to indicate command completion. This can be called both
drivers/net/wireless/intersil/hostap/hostap_hw.c: * hfa384x_cmd_wait - Issue a Prism2 command and busy wait for completion
drivers/net/wireless/intersil/hostap/hostap_hw.c:        /* wait for command completion */
drivers/net/wireless/intersil/hostap/hostap_hw.c: * hfa384x_cmd_no_wait - Issue a Prism2 command; do not wait for completion
drivers/net/wireless/intersil/hostap/hostap_hw.c: * prism2_cmd_ev - Prism2 command completion event handler
drivers/net/wireless/intersil/hostap/hostap_hw.c: * Interrupt handler for command completion events. Called by the main
drivers/net/wireless/intersil/hostap/hostap_hw.c: * either wake up the sleeping process that is waiting for command completion
drivers/net/wireless/intersil/hostap/hostap_hw.c:			printk(KERN_DEBUG "%s: Command completion event, but "
drivers/net/wireless/intersil/hostap/hostap_hw.c:		printk(KERN_DEBUG "%s: Command completion event, but no "
drivers/net/wireless/intersil/hostap/hostap_hw.c:		printk(KERN_DEBUG "%s: Invalid command completion type %d\n",
drivers/net/wireless/intersil/hostap/hostap_hw.c:	/* Allow only command completion events during disable */
drivers/net/wireless/intersil/hostap/hostap_hw.c:	/* Since we did not wait for command completion, the card continues
drivers/net/wireless/intersil/hostap/hostap_hw.c:	 * command completion event is handled (prism2_cmd_ev() function) */
drivers/net/wireless/intersil/p54/p54usb.h:	struct completion fw_wait_load;
drivers/net/wireless/intersil/p54/p54pci.h:	struct completion boot_comp;
drivers/net/wireless/intersil/p54/p54pci.h:	struct completion fw_loaded;
drivers/net/wireless/intersil/p54/p54usb.c:	init_completion(&priv->fw_wait_load);
drivers/net/wireless/intersil/p54/p54usb.c:	wait_for_completion(&priv->fw_wait_load);
drivers/net/wireless/intersil/p54/p54spi.h:	struct completion fw_comp;
drivers/net/wireless/intersil/p54/p54.h:	struct completion stat_comp;
drivers/net/wireless/intersil/p54/p54.h:	struct completion beacon_comp;
drivers/net/wireless/intersil/p54/p54.h:	struct completion eeprom_comp;
drivers/net/wireless/intersil/p54/main.c:		wait_for_completion_interruptible_timeout(&priv->beacon_comp, HZ);
drivers/net/wireless/intersil/p54/main.c:	ret = wait_for_completion_interruptible_timeout(&priv->stat_comp, HZ);
drivers/net/wireless/intersil/p54/main.c:	init_completion(&priv->stat_comp);
drivers/net/wireless/intersil/p54/main.c:	init_completion(&priv->eeprom_comp);
drivers/net/wireless/intersil/p54/main.c:	init_completion(&priv->beacon_comp);
drivers/net/wireless/intersil/p54/p54spi.c:	timeout = wait_for_completion_interruptible_timeout(&priv->fw_comp,
drivers/net/wireless/intersil/p54/p54spi.c:	init_completion(&priv->fw_comp);
drivers/net/wireless/intersil/p54/fwio.c:	timeout = wait_for_completion_interruptible_timeout(
drivers/net/wireless/intersil/p54/p54pci.c:#include <linux/completion.h>
drivers/net/wireless/intersil/p54/p54pci.c:	init_completion(&priv->boot_comp);
drivers/net/wireless/intersil/p54/p54pci.c:	timeout = wait_for_completion_interruptible_timeout(
drivers/net/wireless/intersil/p54/p54pci.c:	init_completion(&priv->fw_loaded);
drivers/net/wireless/intersil/p54/p54pci.c:	wait_for_completion(&priv->fw_loaded);
drivers/net/wireless/intersil/orinoco/hermes.c:		       "while waiting for command 0x%04x completion.\n",
drivers/net/wireless/intersil/orinoco/hermes.c:		       "command 0x%04x completion.\n", hw->iobase, cmd);
drivers/net/wireless/intersil/orinoco/orinoco_usb.c:	struct completion done;	/* Signals that CTX is dead */
drivers/net/wireless/intersil/orinoco/orinoco_usb.c:	init_completion(&ctx->done);
drivers/net/wireless/intersil/orinoco/orinoco_usb.c:static inline void ezusb_complete_all(struct completion *comp)
drivers/net/wireless/intersil/orinoco/orinoco_usb.c:		/* Call the completion handler */
drivers/net/wireless/intersil/orinoco/orinoco_usb.c:			wait_for_completion(&ctx->done);
drivers/net/wireless/intel/iwlwifi/mvm/d3.c:	 * for d0i3 exit completion.
drivers/net/wireless/intel/iwlwifi/mvm/quota.c:	/* update all upon completion */
drivers/net/wireless/intel/iwlwifi/mvm/fw-api-tof.h: *				  earlier of: measurements completion / timeout
drivers/net/wireless/intel/iwlwifi/iwl-prph.h: *     Tx completion may end up being out-of-order).
drivers/net/wireless/intel/iwlwifi/dvm/rxon.c:		 * completion. If calibration has already been run
drivers/net/wireless/intel/iwlwifi/pcie/rx.c:		 Allocator has another 6 from pool for the request completion*/
drivers/net/wireless/intel/iwlwifi/iwl-drv.c:#include <linux/completion.h>
drivers/net/wireless/intel/iwlwifi/iwl-drv.c:	struct completion request_firmware_complete;
drivers/net/wireless/intel/iwlwifi/iwl-drv.c:	init_completion(&drv->request_firmware_complete);
drivers/net/wireless/intel/iwlwifi/iwl-drv.c:	wait_for_completion(&drv->request_firmware_complete);
drivers/net/wireless/intel/ipw2x00/ipw2100.c:		IPW_DEBUG_INFO("Command completion failed out after %dms.\n",
drivers/net/wireless/intel/ipw2x00/ipw2100.c: *       cycle and have the completion event trigger the wakeup
drivers/net/wireless/intel/ipw2x00/ipw2100.c:		 * driver upon completion.  Once received, the driver can
drivers/net/wireless/intel/ipw2x00/ipw2100.c:	/* Only userspace-requested scan completion events go out immediately */
drivers/net/wireless/intel/ipw2x00/ipw2200.c:		IPW_DEBUG_SCAN("Scan completion watchdog resetting "
drivers/net/wireless/intel/ipw2x00/ipw2200.c:		IPW_DEBUG_SCAN("Scan completion watchdog aborting scan "
drivers/net/wireless/intel/ipw2x00/ipw2200.c:	/* Only userspace-requested scan completion events go out immediately */
drivers/net/wireless/intel/ipw2x00/ipw2100.h:	 * check for completion) */
drivers/net/wireless/intel/iwlegacy/4965-mac.c:	init_completion(&il->_4965.firmware_loading_complete);
drivers/net/wireless/intel/iwlegacy/4965-mac.c:	wait_for_completion(&il->_4965.firmware_loading_complete);
drivers/net/wireless/intel/iwlegacy/common.h:			struct completion firmware_loading_complete;
drivers/net/wireless/intel/iwlegacy/4965.c:	/* the chain noise calibration will enabled PM upon completion
drivers/net/wireless/intel/iwlegacy/prph.h: * 5)  Wait for load completion:
drivers/net/wireless/intel/iwlegacy/prph.h: *     Tx completion may end up being out-of-order).
drivers/net/wireless/marvell/mwifiex/cfg80211.c: * the IBSS if it does not exist. On successful completion in either case,
drivers/net/wireless/marvell/mwifiex/cfg80211.c: * the user specified scan configuration. On successful completion,
drivers/net/wireless/marvell/mwifiex/cfg80211.c: * the user specified sched_scan configuration. On successful completion,
drivers/net/wireless/marvell/mwifiex/uap_txrx.c: * The completion callback is called after processing is complete.
drivers/net/wireless/marvell/mwifiex/util.c: * IOCTL completion callback handler.
drivers/net/wireless/marvell/mwifiex/txrx.c: * On successful completion, the function calls the completion callback
drivers/net/wireless/marvell/mwifiex/txrx.c: * Packet send completion callback handler.
drivers/net/wireless/marvell/mwifiex/txrx.c: * completion callback which checks conditions, updates statistics,
drivers/net/wireless/marvell/mwifiex/init.c: *      - Notify completion
drivers/net/wireless/marvell/mwifiex/init.c:	/* Notify completion */
drivers/net/wireless/marvell/mwifiex/sta_ioctl.c: * Wait queue completion handler.
drivers/net/wireless/marvell/mwifiex/sta_ioctl.c:	/* Wait for completion */
drivers/net/wireless/marvell/mwifiex/sta_rx.c: * The completion callback is called after processing in complete.
drivers/net/wireless/marvell/mwifiex/sta_rx.c: * The completion callback is called after processing in complete.
drivers/net/wireless/marvell/mwifiex/pcie.c:		 * send dnld-rdy intr again, wait for completion.
drivers/net/wireless/marvell/mwifiex/cmdevt.c: * This function will however call the receive completion callback
drivers/net/wireless/marvell/mwifiex/cmdevt.c: * The function also calls the completion callback if required, before
drivers/net/wireless/marvell/mwifiex/cmdevt.c: * The function calls the completion callback for all the command
drivers/net/wireless/marvell/mwifiex/cmdevt.c: * After processing, the function calls the completion callback
drivers/net/wireless/marvell/mwifiex/cmdevt.c: * commands in scan pending queue are cancelled. All the completion callbacks
drivers/net/wireless/marvell/mwifiex/cmdevt.c: * searched for matching IOCTL request. The completion callback of
drivers/net/wireless/marvell/mwifiex/wmm.c: * The packet sent completion callback handler are called with
drivers/net/wireless/marvell/mwifiex/wmm.c: * packet send completion callback is called with status failure.
drivers/net/wireless/marvell/mwifiex/11h.c:		    "indicating channel switch completion to kernel\n");
drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c: * of the scan completion.
drivers/net/wireless/marvell/mwl8k.c:#include <linux/completion.h>
drivers/net/wireless/marvell/mwl8k.c:	struct completion *hostcmd_wait;
drivers/net/wireless/marvell/mwl8k.c:	/* TX quiesce completion, protected by fw_mutex and tx_lock */
drivers/net/wireless/marvell/mwl8k.c:	struct completion *tx_wait;
drivers/net/wireless/marvell/mwl8k.c:	struct completion firmware_loading_complete;
drivers/net/wireless/marvell/mwl8k.c:		timeout = wait_for_completion_timeout(&tx_wait,
drivers/net/wireless/marvell/mwl8k.c:	 * Enable these stopped BSSes after completion of the commands
drivers/net/wireless/marvell/mwl8k.c:	timeout = wait_for_completion_timeout(&cmd_wait,
drivers/net/wireless/marvell/mwl8k.c:	init_completion(&priv->firmware_loading_complete);
drivers/net/wireless/marvell/mwl8k.c:	wait_for_completion(&priv->firmware_loading_complete);
drivers/net/wireless/marvell/libertas/cfg.c:	/* Wake up anything waiting on scan completion */
drivers/net/wireless/marvell/libertas/if_spi.c:	 * If auto-interrupts are on, the completion of certain transactions
drivers/net/wireless/marvell/libertas/dev.h:	/* Queue of things waiting for scan completion */
drivers/net/wireless/marvell/libertas/README:    will be displayed upon completion by use of the getscantable ioctl.
drivers/net/wireless/ath/ath10k/htc.c:static void ath10k_htc_notify_tx_completion(struct ath10k_htc_ep *ep,
drivers/net/wireless/ath/ath10k/htc.c:void ath10k_htc_tx_completion_handler(struct ath10k *ar, struct sk_buff *skb)
drivers/net/wireless/ath/ath10k/htc.c:	ath10k_htc_notify_tx_completion(ep, skb);
drivers/net/wireless/ath/ath10k/htc.c:	/* the skb now belongs to the completion handler */
drivers/net/wireless/ath/ath10k/htc.c:EXPORT_SYMBOL(ath10k_htc_tx_completion_handler);
drivers/net/wireless/ath/ath10k/htc.c:void ath10k_htc_rx_completion_handler(struct ath10k *ar, struct sk_buff *skb)
drivers/net/wireless/ath/ath10k/htc.c:			if (completion_done(&htc->ctl_resp)) {
drivers/net/wireless/ath/ath10k/htc.c:	ath10k_dbg(ar, ATH10K_DBG_HTC, "htc rx completion ep %d skb %pK\n",
drivers/net/wireless/ath/ath10k/htc.c:	/* skb is now owned by the rx completion handler */
drivers/net/wireless/ath/ath10k/htc.c:EXPORT_SYMBOL(ath10k_htc_rx_completion_handler);
drivers/net/wireless/ath/ath10k/htc.c:	time_left = wait_for_completion_timeout(&htc->ctl_resp,
drivers/net/wireless/ath/ath10k/htc.c:		ath10k_warn(ar, "failed to receive control response completion, polling..\n");
drivers/net/wireless/ath/ath10k/htc.c:		wait_for_completion_timeout(&htc->ctl_resp,
drivers/net/wireless/ath/ath10k/htc.c:	reinit_completion(&htc->ctl_resp);
drivers/net/wireless/ath/ath10k/htc.c:	time_left = wait_for_completion_timeout(&htc->ctl_resp,
drivers/net/wireless/ath/ath10k/htc.c:	init_completion(&htc->ctl_resp);
drivers/net/wireless/ath/ath10k/hif.h:	void *transfer_context; /* NULL = tx completion callback not called */
drivers/net/wireless/ath/ath10k/pci.c:		/* no need to call tx completion for NULL pointers */
drivers/net/wireless/ath/ath10k/pci.c:		ath10k_htc_tx_completion_handler(ar, skb);
drivers/net/wireless/ath/ath10k/pci.c:	ath10k_pci_process_rx_cb(ce_state, ath10k_htc_rx_completion_handler);
drivers/net/wireless/ath/ath10k/pci.c:	ath10k_pci_process_rx_cb(ce_state, ath10k_htc_rx_completion_handler);
drivers/net/wireless/ath/ath10k/pci.c:				 ath10k_htt_rx_pktlog_completion_handler);
drivers/net/wireless/ath/ath10k/pci.c:		/* no need to call tx completion for NULL pointers */
drivers/net/wireless/ath/ath10k/pci.c:		 * Decide whether to actually poll for completions, or just
drivers/net/wireless/ath/ath10k/pci.c:		ath10k_htc_tx_completion_handler(ar, skb);
drivers/net/wireless/ath/ath10k/pci.c: * not yet processed are on a completion queue. They
drivers/net/wireless/ath/ath10k/pci.c: * are handled when the completion thread shuts down.
drivers/net/wireless/ath/ath10k/htt.c:	init_completion(&htt->target_version_received);
drivers/net/wireless/ath/ath10k/htt.c:	status = wait_for_completion_timeout(&htt->target_version_received,
drivers/net/wireless/ath/ath10k/txrx.c:	/* If the original wait_for_completion() timed out before
drivers/net/wireless/ath/ath10k/txrx.c:		   "htt tx completion msdu_id %u status %d\n",
drivers/net/wireless/ath/ath10k/txrx.c:		ath10k_warn(ar, "received tx completion for invalid msdu_id: %d\n",
drivers/net/wireless/ath/ath10k/wmi.c:	time_left = wait_for_completion_timeout(&ar->wmi.service_ready,
drivers/net/wireless/ath/ath10k/wmi.c:	time_left = wait_for_completion_timeout(&ar->wmi.unified_ready,
drivers/net/wireless/ath/ath10k/wmi.c:			       enum wmi_scan_completion_reason reason)
drivers/net/wireless/ath/ath10k/wmi.c:	enum wmi_scan_completion_reason reason;
drivers/net/wireless/ath/ath10k/wmi.c:		/* There are no completions for beacons so wait for next SWBA
drivers/net/wireless/ath/ath10k/wmi.c:	reinit_completion(&ar->wmi.barrier);
drivers/net/wireless/ath/ath10k/wmi.c:	time_left = wait_for_completion_timeout(&ar->wmi.barrier,
drivers/net/wireless/ath/ath10k/wmi.c:	init_completion(&ar->wmi.service_ready);
drivers/net/wireless/ath/ath10k/wmi.c:	init_completion(&ar->wmi.unified_ready);
drivers/net/wireless/ath/ath10k/wmi.c:	init_completion(&ar->wmi.barrier);
drivers/net/wireless/ath/ath10k/ce.c:		 * The SW completion index has caught up with the cached
drivers/net/wireless/ath/ath10k/ce.c:		 * version of the HW completion index.
drivers/net/wireless/ath/ath10k/ce.c:		 * Update the cached HW completion index to see whether
drivers/net/wireless/ath/ath10k/htc.h:	struct completion ctl_resp;
drivers/net/wireless/ath/ath10k/htc.h:void ath10k_htc_tx_completion_handler(struct ath10k *ar, struct sk_buff *skb);
drivers/net/wireless/ath/ath10k/htc.h:void ath10k_htc_rx_completion_handler(struct ath10k *ar, struct sk_buff *skb);
drivers/net/wireless/ath/ath10k/wow.h:	struct completion wakeup_completed;
drivers/net/wireless/ath/ath10k/thermal.c:	reinit_completion(&ar->thermal.wmi_sync);
drivers/net/wireless/ath/ath10k/thermal.c:	time_left = wait_for_completion_timeout(&ar->thermal.wmi_sync,
drivers/net/wireless/ath/ath10k/mac.c:	reinit_completion(&ar->install_key_done);
drivers/net/wireless/ath/ath10k/mac.c:	time_left = wait_for_completion_timeout(&ar->install_key_done, 3 * HZ);
drivers/net/wireless/ath/ath10k/mac.c:	time_left = wait_for_completion_timeout(&ar->vdev_setup_done,
drivers/net/wireless/ath/ath10k/mac.c:	reinit_completion(&ar->vdev_setup_done);
drivers/net/wireless/ath/ath10k/mac.c:	reinit_completion(&ar->vdev_setup_done);
drivers/net/wireless/ath/ath10k/mac.c:	reinit_completion(&ar->vdev_setup_done);
drivers/net/wireless/ath/ath10k/mac.c:	reinit_completion(&ar->vdev_setup_done);
drivers/net/wireless/ath/ath10k/mac.c:	 * never transmitted. We delete the peer upon tx completion.
drivers/net/wireless/ath/ath10k/mac.c:		reinit_completion(&ar->offchan_tx_completed);
drivers/net/wireless/ath/ath10k/mac.c:		wait_for_completion_timeout(&ar->offchan_tx_completed, 3 * HZ);
drivers/net/wireless/ath/ath10k/mac.c:	ret = wait_for_completion_timeout(&ar->scan.completed, 3 * HZ);
drivers/net/wireless/ath/ath10k/mac.c:		ath10k_warn(ar, "failed to receive scan abortion completion: timed out\n");
drivers/net/wireless/ath/ath10k/mac.c:	/* Scan state should be updated upon scan completion but in case
drivers/net/wireless/ath/ath10k/mac.c:	 * dropped the scan completion event delivery due to transport pipe
drivers/net/wireless/ath/ath10k/mac.c:		 * abortion while scan completion was being processed.
drivers/net/wireless/ath/ath10k/mac.c:	ret = wait_for_completion_timeout(&ar->scan.started, 1 * HZ);
drivers/net/wireless/ath/ath10k/mac.c:	/* Some firmware revisions don't wait for beacon tx completion before
drivers/net/wireless/ath/ath10k/mac.c:	 * Since there are no beacon tx completions (implicit nor explicit)
drivers/net/wireless/ath/ath10k/mac.c:		reinit_completion(&ar->scan.started);
drivers/net/wireless/ath/ath10k/mac.c:		reinit_completion(&ar->scan.completed);
drivers/net/wireless/ath/ath10k/mac.c:		reinit_completion(&ar->scan.started);
drivers/net/wireless/ath/ath10k/mac.c:		reinit_completion(&ar->scan.completed);
drivers/net/wireless/ath/ath10k/mac.c:		reinit_completion(&ar->scan.on_channel);
drivers/net/wireless/ath/ath10k/mac.c:	ret = wait_for_completion_timeout(&ar->scan.on_channel, 3 * HZ);
drivers/net/wireless/ath/ath10k/mac.c:	reinit_completion(&ar->bss_survey_done);
drivers/net/wireless/ath/ath10k/mac.c:	ret = wait_for_completion_timeout(&ar->bss_survey_done, 3 * HZ);
drivers/net/wireless/ath/ath10k/core.c:	reinit_completion(&ar->target_suspend);
drivers/net/wireless/ath/ath10k/core.c:	time_left = wait_for_completion_timeout(&ar->target_suspend, 1 * HZ);
drivers/net/wireless/ath/ath10k/core.c:	init_completion(&ar->scan.started);
drivers/net/wireless/ath/ath10k/core.c:	init_completion(&ar->scan.completed);
drivers/net/wireless/ath/ath10k/core.c:	init_completion(&ar->scan.on_channel);
drivers/net/wireless/ath/ath10k/core.c:	init_completion(&ar->target_suspend);
drivers/net/wireless/ath/ath10k/core.c:	init_completion(&ar->wow.wakeup_completed);
drivers/net/wireless/ath/ath10k/core.c:	init_completion(&ar->install_key_done);
drivers/net/wireless/ath/ath10k/core.c:	init_completion(&ar->vdev_setup_done);
drivers/net/wireless/ath/ath10k/core.c:	init_completion(&ar->thermal.wmi_sync);
drivers/net/wireless/ath/ath10k/core.c:	init_completion(&ar->bss_survey_done);
drivers/net/wireless/ath/ath10k/core.c:	init_completion(&ar->offchan_tx_completed);
drivers/net/wireless/ath/ath10k/wmi.h: * completion with a timedout reason.
drivers/net/wireless/ath/ath10k/wmi.h:enum wmi_scan_completion_reason {
drivers/net/wireless/ath/ath10k/core.h:#include <linux/completion.h>
drivers/net/wireless/ath/ath10k/core.h:	struct completion service_ready;
drivers/net/wireless/ath/ath10k/core.h:	struct completion unified_ready;
drivers/net/wireless/ath/ath10k/core.h:	struct completion barrier;
drivers/net/wireless/ath/ath10k/core.h:	struct completion fw_stats_complete;
drivers/net/wireless/ath/ath10k/core.h:	struct completion tpc_complete;
drivers/net/wireless/ath/ath10k/core.h:	 * prevents completion timeouts and makes the driver more responsive to
drivers/net/wireless/ath/ath10k/core.h:	struct completion target_suspend;
drivers/net/wireless/ath/ath10k/core.h:		struct completion started;
drivers/net/wireless/ath/ath10k/core.h:		struct completion completed;
drivers/net/wireless/ath/ath10k/core.h:		struct completion on_channel;
drivers/net/wireless/ath/ath10k/core.h:	struct completion install_key_done;
drivers/net/wireless/ath/ath10k/core.h:	struct completion vdev_setup_done;
drivers/net/wireless/ath/ath10k/core.h:	struct completion offchan_tx_completed;
drivers/net/wireless/ath/ath10k/core.h:	struct completion bss_survey_done;
drivers/net/wireless/ath/ath10k/htt_rx.c:	int status = MS(resp->data_tx_completion.flags, HTT_DATA_TX_STATUS);
drivers/net/wireless/ath/ath10k/htt_rx.c:		ath10k_warn(ar, "unhandled tx completion status %d\n", status);
drivers/net/wireless/ath/ath10k/htt_rx.c:	ath10k_dbg(ar, ATH10K_DBG_HTT, "htt tx completion num_msdus %d\n",
drivers/net/wireless/ath/ath10k/htt_rx.c:		   resp->data_tx_completion.num_msdus);
drivers/net/wireless/ath/ath10k/htt_rx.c:	for (i = 0; i < resp->data_tx_completion.num_msdus; i++) {
drivers/net/wireless/ath/ath10k/htt_rx.c:		msdu_id = resp->data_tx_completion.msdus[i];
drivers/net/wireless/ath/ath10k/htt_rx.c:		int status = __le32_to_cpu(resp->mgmt_tx_completion.status);
drivers/net/wireless/ath/ath10k/htt_rx.c:		tx_done.msdu_id = __le32_to_cpu(resp->mgmt_tx_completion.desc_id);
drivers/net/wireless/ath/ath10k/htt_rx.c:void ath10k_htt_rx_pktlog_completion_handler(struct ath10k *ar,
drivers/net/wireless/ath/ath10k/htt_rx.c:EXPORT_SYMBOL(ath10k_htt_rx_pktlog_completion_handler);
drivers/net/wireless/ath/ath10k/htt_rx.c:	 *  The napi poll() function may also process TX completions, in which
drivers/net/wireless/ath/ath10k/wow.c:	reinit_completion(&ar->target_suspend);
drivers/net/wireless/ath/ath10k/wow.c:	ret = wait_for_completion_timeout(&ar->target_suspend, 3 * HZ);
drivers/net/wireless/ath/ath10k/wow.c:		ath10k_warn(ar, "timed out while waiting for suspend completion\n");
drivers/net/wireless/ath/ath10k/wow.c:	reinit_completion(&ar->wow.wakeup_completed);
drivers/net/wireless/ath/ath10k/wow.c:	ret = wait_for_completion_timeout(&ar->wow.wakeup_completed, 3 * HZ);
drivers/net/wireless/ath/ath10k/wow.c:		ath10k_warn(ar, "timed out while waiting for wow wakeup completion\n");
drivers/net/wireless/ath/ath10k/htt_tx.c:	 * received. That's why HTC tx completion handler itself is ignored by
drivers/net/wireless/ath/ath10k/htt_tx.c:	 * it to simply rely a regular tx completion with discard status.
drivers/net/wireless/ath/ath10k/ce.h:	 * and completion processed by software.
drivers/net/wireless/ath/ath10k/ce.h:/* no interrupt on copy completion */
drivers/net/wireless/ath/ath10k/debug.c:		reinit_completion(&ar->debug.fw_stats_complete);
drivers/net/wireless/ath/ath10k/debug.c:		wait_for_completion_timeout(&ar->debug.fw_stats_complete,
drivers/net/wireless/ath/ath10k/debug.c:	reinit_completion(&ar->debug.tpc_complete);
drivers/net/wireless/ath/ath10k/debug.c:	time_left = wait_for_completion_timeout(&ar->debug.tpc_complete,
drivers/net/wireless/ath/ath10k/debug.c:	init_completion(&ar->debug.tpc_complete);
drivers/net/wireless/ath/ath10k/debug.c:	init_completion(&ar->debug.fw_stats_complete);
drivers/net/wireless/ath/ath10k/thermal.h:	struct completion wmi_sync;
drivers/net/wireless/ath/ath10k/htt.h:struct htt_mgmt_tx_completion {
drivers/net/wireless/ath/ath10k/htt.h:struct htt_data_tx_completion {
drivers/net/wireless/ath/ath10k/htt.h: *        the completion of the stats entry series
drivers/net/wireless/ath/ath10k/htt.h:		struct htt_mgmt_tx_completion mgmt_tx_completion;
drivers/net/wireless/ath/ath10k/htt.h:		struct htt_data_tx_completion data_tx_completion;
drivers/net/wireless/ath/ath10k/htt.h:	struct completion target_version_received;
drivers/net/wireless/ath/ath10k/htt.h:	/* This is used to group tx/rx completions separately and process them
drivers/net/wireless/ath/ath10k/htt.h:void ath10k_htt_rx_pktlog_completion_handler(struct ath10k *ar,
drivers/net/wireless/ath/ar5523/ar5523_hw.h:#define	UATH_CFLAGS_RXMSG	0x02	/* chunk contains rx completion */
drivers/net/wireless/ath/ar5523/ar5523.h:	struct completion	done;
drivers/net/wireless/ath/ar5523/ar5523.c:#include <linux/completion.h>
drivers/net/wireless/ath/ar5523/ar5523.c:	if (!wait_for_completion_timeout(&cmd->done, 2 * HZ)) {
drivers/net/wireless/ath/ar5523/ar5523.c:	init_completion(&cmd->done);
drivers/net/wireless/ath/ath5k/phy.c:	 * Enable calibration and wait until completion
drivers/net/wireless/ath/ath5k/phy.c:	 * Enable the PHY and wait until completion
drivers/net/wireless/ath/carl9170/carl9170.h:#include <linux/completion.h>
drivers/net/wireless/ath/carl9170/carl9170.h:	struct completion fw_load_wait;
drivers/net/wireless/ath/carl9170/carl9170.h:	struct completion fw_boot_wait;
drivers/net/wireless/ath/carl9170/carl9170.h:	struct completion tx_flush;
drivers/net/wireless/ath/carl9170/carl9170.h:	struct completion cmd_wait;
drivers/net/wireless/ath/carl9170/usb.c:	 * completion (hardirq context).
drivers/net/wireless/ath/carl9170/usb.c:	reinit_completion(&ar->cmd_wait);
drivers/net/wireless/ath/carl9170/usb.c:		time_left = wait_for_completion_timeout(&ar->cmd_wait, HZ);
drivers/net/wireless/ath/carl9170/usb.c:	if (wait_for_completion_timeout(&ar->fw_boot_wait, HZ) == 0) {
drivers/net/wireless/ath/carl9170/usb.c:	init_completion(&ar->cmd_wait);
drivers/net/wireless/ath/carl9170/usb.c:	init_completion(&ar->fw_boot_wait);
drivers/net/wireless/ath/carl9170/usb.c:	init_completion(&ar->fw_load_wait);
drivers/net/wireless/ath/carl9170/usb.c:	wait_for_completion(&ar->fw_load_wait);
drivers/net/wireless/ath/carl9170/main.c:		WARN_ON(wait_for_completion_timeout(&ar->tx_flush, HZ) == 0);
drivers/net/wireless/ath/carl9170/main.c:	init_completion(&ar->tx_flush);
drivers/net/wireless/ath/carl9170/tx.c:			 * race between the urb's completion routine:
drivers/net/wireless/ath/wil6210/wil6210.h:	struct completion	comp;
drivers/net/wireless/ath/wil6210/wil6210.h:	struct completion wmi_ready;
drivers/net/wireless/ath/wil6210/wil6210.h:	struct completion wmi_call;
drivers/net/wireless/ath/wil6210/txrx.c:	/* napi_synchronize waits for completion of the current NAPI but will
drivers/net/wireless/ath/wil6210/txrx.c:	 * This will prevent a race condition where the completion thread
drivers/net/wireless/ath/wil6210/txrx.c:	 * This will prevent a race condition where the completion thread
drivers/net/wireless/ath/wil6210/wmi.c:	remain = wait_for_completion_timeout(&wil->wmi_call,
drivers/net/wireless/ath/wil6210/wmi.h:/* Power Save command completion status codes */
drivers/net/wireless/ath/wil6210/main.c:	init_completion(&wil->wmi_ready);
drivers/net/wireless/ath/wil6210/main.c:	init_completion(&wil->wmi_call);
drivers/net/wireless/ath/wil6210/main.c:	init_completion(&wil->halp.comp);
drivers/net/wireless/ath/wil6210/main.c:	ulong left = wait_for_completion_timeout(&wil->wmi_ready, to);
drivers/net/wireless/ath/wil6210/main.c:	reinit_completion(&wil->wmi_ready);
drivers/net/wireless/ath/wil6210/main.c:	reinit_completion(&wil->wmi_call);
drivers/net/wireless/ath/wil6210/main.c:	reinit_completion(&wil->halp.comp);
drivers/net/wireless/ath/wil6210/main.c:		rc = wait_for_completion_timeout(&wil->halp.comp, to_jiffies);
drivers/net/wireless/ath/wcn36xx/wcn36xx.h:#include <linux/completion.h>
drivers/net/wireless/ath/wcn36xx/wcn36xx.h:	struct completion	hal_rsp_compl;
drivers/net/wireless/ath/wcn36xx/smd.c:	init_completion(&wcn->hal_rsp_compl);
drivers/net/wireless/ath/wcn36xx/smd.c:	if (wait_for_completion_timeout(&wcn->hal_rsp_compl,
drivers/net/wireless/ath/ath9k/hif_usb.h:	struct completion fw_done;
drivers/net/wireless/ath/ath9k/htc_hst.c:	time_left = wait_for_completion_timeout(&target->cmd_wait, HZ);
drivers/net/wireless/ath/ath9k/htc_hst.c:	time_left = wait_for_completion_timeout(&target->cmd_wait, HZ);
drivers/net/wireless/ath/ath9k/htc_hst.c:	time_left = wait_for_completion_timeout(&target->cmd_wait, HZ);
drivers/net/wireless/ath/ath9k/htc_hst.c:void ath9k_htc_txcompletion_cb(struct htc_target *htc_handle,
drivers/net/wireless/ath/ath9k/htc_hst.c:	init_completion(&target->target_wait);
drivers/net/wireless/ath/ath9k/htc_hst.c:	init_completion(&target->cmd_wait);
drivers/net/wireless/ath/ath9k/hif_usb.c:		ath9k_htc_txcompletion_cb(cmd->hif_dev->htc_handle,
drivers/net/wireless/ath/ath9k/hif_usb.c:	ath9k_htc_txcompletion_cb(cmd->hif_dev->htc_handle,
drivers/net/wireless/ath/ath9k/hif_usb.c:		ath9k_htc_txcompletion_cb(hif_dev->htc_handle,
drivers/net/wireless/ath/ath9k/hif_usb.c:			ath9k_htc_txcompletion_cb(hif_dev->htc_handle,
drivers/net/wireless/ath/ath9k/hif_usb.c:	init_completion(&hif_dev->fw_done);
drivers/net/wireless/ath/ath9k/hif_usb.c:	wait_for_completion(&hif_dev->fw_done);
drivers/net/wireless/ath/ath9k/hif_usb.c:	wait_for_completion(&hif_dev->fw_done);
drivers/net/wireless/ath/ath9k/ar9003_calib.c:		 * in the HW, poll for completion and then process
drivers/net/wireless/ath/ath9k/wmi.c:	init_completion(&wmi->cmd_wait);
drivers/net/wireless/ath/ath9k/wmi.c:	time_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);
drivers/net/wireless/ath/ath9k/xmit.c:			/* transmit completion, subframe is
drivers/net/wireless/ath/ath9k/xmit.c:			/* transmit completion */
drivers/net/wireless/ath/ath9k/xmit.c:		/* Process beacon completions separately */
drivers/net/wireless/ath/ath9k/htc_drv_txrx.c:	 * and that the TX completion/failed tasklets is killed.
drivers/net/wireless/ath/ath9k/link.c:	init_completion(&sc->paprd_complete);
drivers/net/wireless/ath/ath9k/link.c:	time_left = wait_for_completion_timeout(&sc->paprd_complete,
drivers/net/wireless/ath/ath9k/init.c:	struct completion complete;
drivers/net/wireless/ath/ath9k/init.c:	init_completion(&ec.complete);
drivers/net/wireless/ath/ath9k/init.c:	wait_for_completion(&ec.complete);
drivers/net/wireless/ath/ath9k/htc_hst.h:	struct completion target_wait;
drivers/net/wireless/ath/ath9k/htc_hst.h:	struct completion cmd_wait;
drivers/net/wireless/ath/ath9k/htc_hst.h:void ath9k_htc_txcompletion_cb(struct htc_target *htc_handle,
drivers/net/wireless/ath/ath9k/beacon.c:	/* EDMA devices check that in the tx completion function. */
drivers/net/wireless/ath/ath9k/wmi.h:	struct completion cmd_wait;
drivers/net/wireless/ath/ath9k/channel.c:	init_completion(&sc->go_beacon);
drivers/net/wireless/ath/ath9k/main.c:			 * For EDMA chips, TX completion is enabled for the
drivers/net/wireless/ath/ath9k/main.c:		init_completion(&sc->go_beacon);
drivers/net/wireless/ath/ath9k/main.c:		if (wait_for_completion_timeout(&sc->go_beacon,
drivers/net/wireless/ath/ath9k/ath9k.h:#include <linux/completion.h>
drivers/net/wireless/ath/ath9k/ath9k.h:	struct completion paprd_complete;
drivers/net/wireless/ath/ath9k/ath9k.h:	struct completion go_beacon;
drivers/net/wireless/ath/ath9k/htc_drv_init.c:	time_left = wait_for_completion_timeout(&priv->htc->target_wait, HZ);
drivers/net/wireless/ath/ath6kl/hif.h: *             driver to indicate the completion of operation through the
drivers/net/wireless/ath/ath6kl/hif.c:	ath6kl_dbg(ATH6KL_DBG_HIF, "hif rw completion pkt 0x%p status %d\n",
drivers/net/wireless/ath/ath6kl/hif.c:	packet->completion(packet->context, packet);
drivers/net/wireless/ath/ath6kl/hif.c:		 * completion routine of the callers read request. This can
drivers/net/wireless/ath/ath6kl/txrx.c:	 * will happen in the TX completion callback.
drivers/net/wireless/ath/ath6kl/htc.h:/* extended setup completion message */
drivers/net/wireless/ath/ath6kl/htc.h:	/* completion status */
drivers/net/wireless/ath/ath6kl/htc.h:	void (*completion) (struct htc_target *, struct htc_packet *);
drivers/net/wireless/ath/ath6kl/sdio.c:		 * FIXME: should we also call completion handler with
drivers/net/wireless/ath/ath6kl/usb.c:	 * until all scheduled work runs to completion.
drivers/net/wireless/ath/ath6kl/usb.c:/* hif usb rx/tx completion functions */
drivers/net/wireless/ath/ath6kl/htc_mbox.c:	packet->completion = NULL;
drivers/net/wireless/ath/ath6kl/htc_mbox.c:	/* do completion */
drivers/net/wireless/ath/ath6kl/htc_mbox.c:	if (!packet->completion)
drivers/net/wireless/ath/ath6kl/htc_mbox.c:		packet->completion = htc_tx_comp_handler;
drivers/net/wireless/ath/ath6kl/htc_mbox.c:				packet->completion(packet->context, packet);
drivers/net/wireless/ath/ath6kl/htc_mbox.c:	send_pkt->completion = NULL;
drivers/net/wireless/ath/ath6kl/htc_mbox.c:			packet->completion = NULL;
drivers/net/wireless/ath/ath6kl/htc_mbox.c:		/* cleanup any packets in sync completion queue */
drivers/net/wireless/ath/ath6kl/htc_mbox.c:	packet->completion = NULL;
drivers/net/wireless/ath/ath6kl/htc_mbox.c:		tx_pkt->completion = NULL;
drivers/net/wireless/ath/ath6kl/htc_mbox.c:	/* Indicate to the target of the setup completion */
drivers/net/wireless/ath/ath6kl/core.h:		struct completion fwlog_completion;
drivers/net/wireless/ath/ath6kl/debug.c:	complete(&ar->debug.fwlog_completion);
drivers/net/wireless/ath/ath6kl/debug.c:		init_completion(&ar->debug.fwlog_completion);
drivers/net/wireless/ath/ath6kl/debug.c:		ret = wait_for_completion_interruptible(
drivers/net/wireless/ath/ath6kl/debug.c:			&ar->debug.fwlog_completion);
drivers/net/wireless/ath/ath6kl/debug.c:	init_completion(&ar->debug.fwlog_completion);
drivers/net/wireless/ath/ath6kl/debug.c:	complete(&ar->debug.fwlog_completion);
drivers/net/wireless/ath/ath6kl/htc_pipe.c:static void do_send_completion(struct htc_endpoint *ep,
drivers/net/wireless/ath/ath6kl/htc_pipe.c:static void send_packet_completion(struct htc_target *target,
drivers/net/wireless/ath/ath6kl/htc_pipe.c:	/* do completion */
drivers/net/wireless/ath/ath6kl/htc_pipe.c:	do_send_completion(ep, &container);
drivers/net/wireless/ath/ath6kl/htc_pipe.c:		/* store in look up queue to match completions */
drivers/net/wireless/ath/ath6kl/htc_pipe.c:			send_packet_completion(target, packet);
drivers/net/wireless/ath/ath6kl/htc_pipe.c:		send_packet_completion(target, packet);
drivers/net/wireless/ath/ath6kl/htc_pipe.c:		send_packet_completion(target, packet);
drivers/net/wireless/ath/ath6kl/htc_pipe.c:	/* do completion on any packets that couldn't get in */
drivers/net/wireless/ath/ath6kl/htc_pipe.c:		do_send_completion(ep, pkt_queue);
drivers/net/wireless/ath/ath6kl/htc_pipe.c:static void do_recv_completion(struct htc_endpoint *ep,
drivers/net/wireless/ath/ath6kl/htc_pipe.c:static void recv_packet_completion(struct htc_target *target,
drivers/net/wireless/ath/ath6kl/htc_pipe.c:	/* do completion */
drivers/net/wireless/ath/ath6kl/htc_pipe.c:	do_recv_completion(ep, &container);
drivers/net/wireless/ath/ath6kl/htc_pipe.c:	recv_packet_completion(target, ep, packet);
drivers/net/wireless/ath/ath6kl/htc_pipe.c:		do_recv_completion(ep, &container);
drivers/net/wireless/ath/ath6kl/htc_pipe.c:		do_recv_completion(ep, pkt_queue);
drivers/net/wireless/atmel/at76c50x-usb.c:#define DBG_WAIT_COMPLETE	0x00200000	/* command completion */
drivers/net/wireless/atmel/at76c50x-usb.c:static int at76_wait_completion(struct at76_priv *priv, int cmd)
drivers/net/wireless/atmel/at76c50x-usb.c:				  "completion timeout for command %d\n", cmd);
drivers/net/wireless/atmel/at76c50x-usb.c:	ret = at76_wait_completion(priv, CMD_SET_MIB);
drivers/net/wireless/atmel/at76c50x-usb.c:			   "set_mib: at76_wait_completion failed with %d\n",
drivers/net/wireless/atmel/at76c50x-usb.c:	at76_wait_completion(priv, CMD_STARTUP);
drivers/net/wireless/atmel/at76c50x-usb.c:		at76_wait_completion(priv, CMD_RADIO_ON);
drivers/net/wireless/atmel/at76c50x-usb.c:	ret = at76_wait_completion(priv, CMD_JOIN);
drivers/net/wireless/atmel/at76c50x-usb.c:		wiphy_err(priv->hw->wiphy, "at76_wait_completion failed: %d\n",
drivers/net/wireless/atmel/atmel.c:	/* now check for completion of MAC initialization through
drivers/net/wireless/atmel/atmel.c:	   the FunCtrl field of the IFACE, poll MR1 to detect completion of
drivers/net/wireless/atmel/atmel.c:	   MAC initialization, check completion status, set interrupt mask,
drivers/net/wireless/broadcom/b43legacy/b43legacy.h:#include <linux/completion.h>
drivers/net/wireless/broadcom/b43legacy/b43legacy.h:	/* completion struct for firmware loading */
drivers/net/wireless/broadcom/b43legacy/b43legacy.h:	struct completion fw_load_complete;
drivers/net/wireless/broadcom/b43legacy/main.c:		init_completion(&dev->fw_load_complete);
drivers/net/wireless/broadcom/b43legacy/main.c:		wait_for_completion(&dev->fw_load_complete);
drivers/net/wireless/broadcom/b43/b43.h:#include <linux/completion.h>
drivers/net/wireless/broadcom/b43/b43.h:	/* a completion event structure needed if this call is asynchronous */
drivers/net/wireless/broadcom/b43/b43.h:	struct completion fw_load_complete;
drivers/net/wireless/broadcom/b43/main.c:		init_completion(&ctx->dev->fw_load_complete);
drivers/net/wireless/broadcom/b43/main.c:		wait_for_completion(&ctx->dev->fw_load_complete);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c:	init_completion(&cfg->vif_disabled);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h: * @vif_complete: completion for net attach.
drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h: * @nd_data_completed: completion for net detect data.
drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h:	struct completion vif_disabled;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:	reinit_completion(&afx_hdl->act_frm_scan);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:		wait_for_completion_timeout(&afx_hdl->act_frm_scan, duration);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:			wait_for_completion_timeout(&afx_hdl->act_frm_scan,
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:		 * So abort scan for off channel completion.
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c: * This function waits for a completion event before returning.
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:	reinit_completion(&p2p->send_af_done);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:	timeout = wait_for_completion_timeout(&p2p->send_af_done,
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:				wait_for_completion_timeout(&p2p->wait_next_af,
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:	init_completion(&p2p->send_af_done);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:	init_completion(&p2p->afx_hdl.act_frm_scan);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:	init_completion(&p2p->wait_next_af);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c:		wait_for_completion_timeout(&cfg->vif_disabled,
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.h:	struct completion act_frm_scan;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.h:	struct completion send_af_done;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.h:	struct completion wait_next_af;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c:	struct completion watchdog_wait;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c:		wait = wait_for_completion_interruptible(&bus->watchdog_wait);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c:			reinit_completion(&bus->watchdog_wait);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c:	init_completion(&bus->watchdog_wait);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h: *   complete: callback function for command completion (async only)
drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h: *   handle:   handle for completion callback (first arg in callback)
drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h: * @status: indicates completion status of PNO scan.
drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c:struct msgbuf_completion_hdr {
drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c:	struct msgbuf_completion_hdr	compl_hdr;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c:	struct msgbuf_completion_hdr	compl_hdr;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c:	struct msgbuf_completion_hdr	compl_hdr;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c:	struct msgbuf_completion_hdr	compl_hdr;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c:	struct msgbuf_completion_hdr	compl_hdr;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c:	struct msgbuf_completion_hdr	compl_hdr;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c:	struct msgbuf_completion_hdr	compl_hdr;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c:#include <linux/completion.h>
drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c:	struct completion resumed;
drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c:	init_completion(&sdiodev->freezer->resumed);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c:	reinit_completion(&sdiodev->freezer->resumed);
drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c:	wait_for_completion(&sdiodev->freezer->resumed);
drivers/net/wireless/broadcom/brcm80211/brcmsmac/dma.c:#define	D64_CTRL1_IOC		((u32)1 << 29)	/* interrupt on completion */
drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.c:/* process tx completion events in BMAC
drivers/net/wireless/cisco/airo.c:#define TXCTL_RELEASE (0<<5) /* release after completion */
drivers/net/wireless/cisco/airo.c:#define TXCTL_NORELEASE (1<<5) /* on completion returns to host */
drivers/net/wireless/zydas/zd1211rw/zd_usb.c:		complete(&intr->read_regs.completion);
drivers/net/wireless/zydas/zd1211rw/zd_usb.c:		complete(&intr->read_regs.completion);
drivers/net/wireless/zydas/zd1211rw/zd_usb.c: * completion. The frame must contain the control set and have all the
drivers/net/wireless/zydas/zd1211rw/zd_usb.c:	init_completion(&intr->read_regs.completion);
drivers/net/wireless/zydas/zd1211rw/zd_usb.c:	reinit_completion(&intr->read_regs.completion);
drivers/net/wireless/zydas/zd1211rw/zd_usb.c:	timeout = wait_for_completion_timeout(&usb->intr.read_regs.completion,
drivers/net/wireless/zydas/zd1211rw/zd_usb.h:#include <linux/completion.h>
drivers/net/wireless/zydas/zd1211rw/zd_usb.h:	struct completion completion;
drivers/net/wireless/mediatek/mt7601u/mt7601u.h:#include <linux/completion.h>
drivers/net/wireless/mediatek/mt7601u/mt7601u.h:	struct completion resp_cmpl;
drivers/net/wireless/mediatek/mt7601u/usb.c:	struct completion *cmpl = urb->context;
drivers/net/wireless/mediatek/mt7601u/mcu.c:		if (!wait_for_completion_timeout(&dev->mcu.resp_cmpl,
drivers/net/wireless/mediatek/mt7601u/mcu.c:	if (!wait_for_completion_timeout(&cmpl, msecs_to_jiffies(1000))) {
drivers/net/wireless/mediatek/mt7601u/mcu.c:	init_completion(&dev->mcu.resp_cmpl);
drivers/net/wireless/ti/wl18xx/main.c:static void wl18xx_tx_immediate_completion(struct wl1271 *wl)
drivers/net/wireless/ti/wl18xx/main.c:	.tx_immediate_compl = wl18xx_tx_immediate_completion,
drivers/net/wireless/ti/wl18xx/tx.c:		wl1271_warning("illegal id in tx completion: %d", id);
drivers/net/wireless/ti/wl1251/acx.h:/* Command processing completion */
drivers/net/wireless/ti/wl1251/tx.h:	 * upon frame sending completion.
drivers/net/wireless/ti/wlcore/ps.c:	 * the completion variable in one entity.
drivers/net/wireless/ti/wlcore/ps.c:		ret = wait_for_completion_timeout(
drivers/net/wireless/ti/wlcore/wlcore_i.h:#include <linux/completion.h>
drivers/net/wireless/ti/wlcore/wlcore.h:	struct completion *elp_compl;
drivers/net/wireless/ti/wlcore/wlcore.h:	struct completion nvs_loading_complete;
drivers/net/wireless/ti/wlcore/acx.h:/* Command processing completion*/
drivers/net/wireless/ti/wlcore/main.c:	/* complete the ELP completion */
drivers/net/wireless/ti/wlcore/main.c:	init_completion(&wl->nvs_loading_complete);
drivers/net/wireless/ti/wlcore/main.c:		wait_for_completion(&wl->nvs_loading_complete);
drivers/net/wireless/ti/wlcore/cmd.c:			     timeout ? "completion " : "");
drivers/net/wireless/ti/wlcore/tx.c:	 * only it uses Tx-completion.
drivers/net/wireless/ti/wlcore/tx.c:	 * only it uses Tx-completion.
drivers/net/wireless/rsi/rsi_main.h:	struct completion completion;
drivers/net/wireless/rsi/rsi_common.h:	init_completion(&thread->completion);
drivers/net/wireless/rsi/rsi_common.h:	wait_for_completion(&handle->completion);
drivers/net/wireless/rsi/rsi_91x_usb_ops.c:	complete_and_exit(&dev->rx_thread.completion, 0);
drivers/net/wireless/rsi/rsi_91x_main.c:	complete_and_exit(&common->tx_thread.completion, 0);
drivers/net/hyperv/netvsc.c:	init_completion(&net_device->channel_init_wait);
drivers/net/hyperv/netvsc.c:	wait_for_completion(&net_device->channel_init_wait);
drivers/net/hyperv/netvsc.c:	wait_for_completion(&net_device->channel_init_wait);
drivers/net/hyperv/netvsc.c:	wait_for_completion(&net_device->channel_init_wait);
drivers/net/hyperv/netvsc.c:static void netvsc_send_completion(struct netvsc_device *net_device,
drivers/net/hyperv/netvsc.c:			   "Unknown send completion type %d received!!\n",
drivers/net/hyperv/netvsc.c:static int netvsc_send_recv_completion(struct vmbus_channel *channel,
drivers/net/hyperv/netvsc.c:	/* Send the completion */
drivers/net/hyperv/netvsc.c:/* Check and send pending recv completions */
drivers/net/hyperv/netvsc.c:		ret = netvsc_send_recv_completion(channel, rcd->tid,
drivers/net/hyperv/netvsc.c:	 * All inbound packets other than send completion should be xfer page
drivers/net/hyperv/netvsc.c:		ret = netvsc_send_recv_completion(channel,
drivers/net/hyperv/netvsc.c:		netvsc_send_completion(net_device, channel, device, desc);
drivers/net/hyperv/rndis_filter.c:	struct completion  wait_event;
drivers/net/hyperv/rndis_filter.c:	init_completion(&request->wait_event);
drivers/net/hyperv/rndis_filter.c:		/* completion msgs */
drivers/net/hyperv/rndis_filter.c:	wait_for_completion(&request->wait_event);
drivers/net/hyperv/rndis_filter.c:	wait_for_completion(&request->wait_event);
drivers/net/hyperv/rndis_filter.c:	wait_for_completion(&request->wait_event);
drivers/net/hyperv/rndis_filter.c:	wait_for_completion(&request->wait_event);
drivers/net/hyperv/rndis_filter.c:	wait_for_completion(&request->wait_event);
drivers/net/hyperv/rndis_filter.c:	wait_for_completion(&request->wait_event);
drivers/net/hyperv/rndis_filter.c:	/* Wait for all send completions */
drivers/net/hyperv/rndis_filter.c:	wait_for_completion(&net_device->channel_init_wait);
drivers/net/hyperv/rndis_filter.c:	 * completion to avoid race.
drivers/net/hyperv/rndis_filter.c:		wait_for_completion(&net_dev->channel_init_wait);
drivers/net/hyperv/hyperv_net.h:	void *buf; /* queued receive completions */
drivers/net/hyperv/hyperv_net.h:	struct completion channel_init_wait;
drivers/net/can/at91_can.c: * With completion of the last of the lower mailboxes, we reenable the
drivers/net/can/janz-ican3.c:	struct completion termination_comp;
drivers/net/can/janz-ican3.c:	struct completion buserror_comp;
drivers/net/can/janz-ican3.c:	if (!wait_for_completion_timeout(&mod->buserror_comp, HZ)) {
drivers/net/can/janz-ican3.c:	if (!wait_for_completion_timeout(&mod->termination_comp, HZ)) {
drivers/net/can/janz-ican3.c:	init_completion(&mod->termination_comp);
drivers/net/can/janz-ican3.c:	init_completion(&mod->buserror_comp);
drivers/net/can/spi/mcp251x.c:#include <linux/completion.h>
drivers/net/can/usb/kvaser_usb.c:#include <linux/completion.h>
drivers/net/can/usb/kvaser_usb.c:	struct completion start_comp, stop_comp;
drivers/net/can/usb/kvaser_usb.c:	if (completion_done(&priv->start_comp) &&
drivers/net/can/usb/kvaser_usb.c:	init_completion(&priv->start_comp);
drivers/net/can/usb/kvaser_usb.c:	if (!wait_for_completion_timeout(&priv->start_comp,
drivers/net/can/usb/kvaser_usb.c: * of URB completions.
drivers/net/can/usb/kvaser_usb.c:	init_completion(&priv->stop_comp);
drivers/net/can/usb/kvaser_usb.c:	if (!wait_for_completion_timeout(&priv->stop_comp,
drivers/net/can/usb/kvaser_usb.c:	init_completion(&priv->start_comp);
drivers/net/can/usb/kvaser_usb.c:	init_completion(&priv->stop_comp);
drivers/net/vmxnet3/vmxnet3_drv.c:	/* no out of order completion */
drivers/net/vmxnet3/vmxnet3_drv.c:	 * tx completions in that queue as well
drivers/net/vmxnet3/vmxnet3_drv.c: * Handle completion interrupts on tx queues
drivers/net/vmxnet3/vmxnet3_drv.c: * Handle completion interrupts on rx queues. Returns whether or not the
drivers/net/vmxnet3/vmxnet3_drv.c:	 * completion.
drivers/net/vmxnet3/vmxnet3_drv.c:	 * completion.
drivers/net/vmxnet3/vmxnet3_drv.c:	 * completion.
drivers/net/vmxnet3/vmxnet3_ethtool.c:	 * completion.
drivers/net/vmxnet3/vmxnet3_defs.h:	u32 cq:1;       /* completion request */
drivers/net/vmxnet3/vmxnet3_defs.h:	u32 cq:1;       /* completion request */
drivers/net/vmxnet3/vmxnet3_defs.h:	u32		type:7;       /* completion type */
drivers/net/vmxnet3/vmxnet3_defs.h:	u32		type:7;       /* completion type */
drivers/net/vmxnet3/vmxnet3_defs.h:	u32		type:7;       /* completion type */
drivers/net/vmxnet3/vmxnet3_defs.h:	u32		type:7;       /* completion type */
drivers/net/vmxnet3/vmxnet3_defs.h:	u32		type:7;       /* completion type */
drivers/net/vmxnet3/vmxnet3_defs.h:/* a union for accessing all cmd/completion descriptors */
drivers/net/vmxnet3/vmxnet3_defs.h: VMXNET3_ERR_TXD_REUSE    = 0x80000001,  /* reuse TxDesc before tx completion */
drivers/net/vmxnet3/vmxnet3_defs.h:/* completion descriptor types */
drivers/net/ppp/ppp_synctty.c:#include <linux/completion.h>
drivers/net/ppp/ppp_synctty.c:	struct completion dead_cmp;
drivers/net/ppp/ppp_synctty.c:	init_completion(&ap->dead_cmp);
drivers/net/ppp/ppp_synctty.c:		wait_for_completion(&ap->dead_cmp);
drivers/net/dsa/qca8k.c:	/* wait for completion */
drivers/net/wimax/i2400m/usb-fw.c: * @completion: completion varible to complete when done
drivers/net/wimax/i2400m/usb-fw.c:			 struct completion *completion)
drivers/net/wimax/i2400m/usb-fw.c:			 __i2400mu_bm_notif_cb, completion,
drivers/net/wimax/i2400m/usb-fw.c:	DECLARE_COMPLETION_ONSTACK(notif_completion);
drivers/net/wimax/i2400m/usb-fw.c:		init_completion(&notif_completion);
drivers/net/wimax/i2400m/usb-fw.c:					      &notif_completion);
drivers/net/wimax/i2400m/usb-fw.c:		val = wait_for_completion_interruptible_timeout(
drivers/net/wimax/i2400m/usb-fw.c:			&notif_completion, HZ);
drivers/net/wimax/i2400m/control.c:	/* Setup the completion, ack_skb ("we are waiting") and send
drivers/net/wimax/i2400m/control.c:	init_completion(&i2400m->msg_completion);
drivers/net/wimax/i2400m/control.c:	result = wait_for_completion_interruptible_timeout(
drivers/net/wimax/i2400m/control.c:		&i2400m->msg_completion, ack_timeout);
drivers/net/wimax/i2400m/control.c:		goto error_wait_for_completion;
drivers/net/wimax/i2400m/control.c:		goto error_wait_for_completion;
drivers/net/wimax/i2400m/control.c:error_wait_for_completion:
drivers/net/wimax/i2400m/driver.c:	struct completion completion;
drivers/net/wimax/i2400m/driver.c:		.completion = COMPLETION_INITIALIZER_ONSTACK(ctx.completion),
drivers/net/wimax/i2400m/driver.c:	result = wait_for_completion_timeout(&ctx.completion, 4*HZ);
drivers/net/wimax/i2400m/driver.c:	complete(&i2400m->msg_completion);
drivers/net/wimax/i2400m/driver.c:		complete(&i2400m->msg_completion);
drivers/net/wimax/i2400m/driver.c:		complete(&ctx->completion);
drivers/net/wimax/i2400m/driver.c:	init_completion(&i2400m->msg_completion);
drivers/net/wimax/i2400m/i2400m.h:#include <linux/completion.h>
drivers/net/wimax/i2400m/i2400m.h: * @msg_completion: used to wait for an ack to a control command sent
drivers/net/wimax/i2400m/i2400m.h: *     Only valid after @msg_completion is woken up. Only updateable
drivers/net/wimax/i2400m/i2400m.h: *     if @msg_completion is armed. Only touched by
drivers/net/wimax/i2400m/i2400m.h:	struct completion msg_completion;
drivers/net/wimax/i2400m/rx.c: * for it in i2400m->msg_completion.
drivers/net/wimax/i2400m/rx.c:	complete(&i2400m->msg_completion);
drivers/net/ieee802154/adf7242.c:	struct completion tx_complete;
drivers/net/ieee802154/adf7242.c:	reinit_completion(&lp->tx_complete);
drivers/net/ieee802154/adf7242.c:	ret = wait_for_completion_interruptible_timeout(&lp->tx_complete,
drivers/net/ieee802154/adf7242.c:			/* save CSMA-CA completion status */
drivers/net/ieee802154/adf7242.c:	init_completion(&lp->tx_complete);
drivers/net/ieee802154/cc2520.c:	struct completion tx_complete;	/* Work completion for Tx */
drivers/net/ieee802154/cc2520.c:	rc = wait_for_completion_interruptible(&priv->tx_complete);
drivers/net/ieee802154/cc2520.c:	init_completion(&priv->tx_complete);
drivers/net/ieee802154/at86rf230.c:	struct completion state_complete;
drivers/net/ieee802154/at86rf230.c:	rc = wait_for_completion_timeout(&lp->state_complete,
drivers/net/ieee802154/at86rf230.c:	init_completion(&lp->state_complete);
drivers/net/plip/plip.c:#include <linux/completion.h>
drivers/net/plip/plip.c:	struct completion killed_timer_cmp;
drivers/net/plip/plip.c:		init_completion(&nl->killed_timer_cmp);
drivers/net/plip/plip.c:		wait_for_completion(&nl->killed_timer_cmp);
drivers/net/wan/dscc4.c:	 * I would expect XPR near CE completion (before ? after ?).
drivers/net/wan/dscc4.c:			 * DataComplete can't be trusted for Tx completion.
drivers/net/wan/lmc/lmc_main.c:        /* Do not interrupt on completion of this packet */
drivers/net/wan/lmc/lmc_main.c:        /* This generates an interrupt on completion of this packet */
drivers/net/wan/lmc/lmc_main.c:        /* Do not interrupt on completion of this packet */
drivers/net/wan/lmc/lmc_main.c:        /* This generates an interrupt on completion of this packet */
drivers/net/wan/farsync.c:/* Since we need to set the high bit to enable the completion interrupt this
drivers/net/wan/farsync.c:	u16 txa_done;		/* Obsolete completion flags */
drivers/net/wan/farsync.c: *      error and not waiting for completion.
drivers/net/wan/farsync.c:	/* Check for rx completions on all ports on this card */
drivers/net/wan/z85230.c: *	z8530_rx_done - Receive completion callback
drivers/net/ethernet/realtek/8139too.c:#include <linux/completion.h>
drivers/net/ethernet/ezchip/nps_enet.c: * We got one for RX and the other for TX (completion).
drivers/net/ethernet/ezchip/Kconfig:	  Device supports interrupts for RX and TX(completion).
drivers/net/ethernet/hp/hp100.h:#define HP100_EN_PDL_WB         0x40	/* 1: Status of PDL completion may be */
drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c:	 *      (usecs > 0 && time_since_first_completion >= usecs) ||
drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c:	 * condition time_since_first_completion >= usecs
drivers/net/ethernet/netronome/nfp/nfp_net_common.c: * someone else may be cleaning the TX ring completions so we need to be
drivers/net/ethernet/netronome/nfp/nfp_net_common.c:	/* We can race with the TX completion out of NAPI so recheck */
drivers/net/ethernet/tile/tilegx.c:/* Maximum completions per cpu per device (must be a power of two).
drivers/net/ethernet/tile/tilegx.c: * egress might block waiting for free space in a completions array.
drivers/net/ethernet/tile/tilegx.c:/* Size of completions data to allocate.
drivers/net/ethernet/tile/tilegx.c:/* Timeout to wake the per-cpu egress timer to free completions. */
drivers/net/ethernet/tile/tilegx.c:/* A single completion. */
drivers/net/ethernet/tile/tilegx.c:	/* The "complete_count" when the completion will be complete. */
drivers/net/ethernet/tile/tilegx.c:	/* The buffer to be freed when the completion is complete. */
drivers/net/ethernet/tile/tilegx.c:/* The completions for a given cpu and echannel. */
drivers/net/ethernet/tile/tilegx.c:	/* The completions. */
drivers/net/ethernet/tile/tilegx.c:	/* The number of completions used. */
drivers/net/ethernet/tile/tilegx.c:	/* The number of completions freed. */
drivers/net/ethernet/tile/tilegx.c:	/* A timer for handling egress completions. */
drivers/net/ethernet/tile/tilegx.c:	/* ISSUE: Handle completions? */
drivers/net/ethernet/tile/tilegx.c:/* Free some completions.  This must be called with interrupts blocked. */
drivers/net/ethernet/tile/tilegx.c:/* Add a completion.  This must be called with interrupts blocked.
drivers/net/ethernet/tile/tilegx.c: * tile_net_equeue_try_reserve() will have ensured a free completion entry.
drivers/net/ethernet/tile/tilegx.c: * completions expected for this tile.
drivers/net/ethernet/tile/tilegx.c:/* Allocate per-cpu resources (memory for completions and idescs).
drivers/net/ethernet/tile/tilegx.c:/* Acquire a completion entry and an egress slot, or if we can't,
drivers/net/ethernet/tile/tilegx.c:	/* Try to acquire a completion entry. */
drivers/net/ethernet/tile/tilegx.c:		/* Freeing some completions gives the equeue time to drain. */
drivers/net/ethernet/tile/tilegx.c:	/* Try to acquire a completion entry and an egress slot. */
drivers/net/ethernet/tile/tilegx.c:	/* Add a completion record. */
drivers/net/ethernet/tile/tilegx.c:	/* Try to acquire a completion entry and an egress slot. */
drivers/net/ethernet/tile/tilegx.c:	/* Add a completion record. */
drivers/net/ethernet/tile/tilepro.c: * NOTE: Failing to free completions for an arbitrarily long time
drivers/net/ethernet/tile/tilepro.c:	/* A timer for handling egress completions. */
drivers/net/ethernet/tile/tilepro.c: * Grab some LEPP completions, and store them in "comps", of size
drivers/net/ethernet/tile/tilepro.c: * "comps_size", and return the number of completions which were
drivers/net/ethernet/tile/tilepro.c: * completions expected (on behalf of any tile).
drivers/net/ethernet/tile/tilepro.c: * ISSUE: Maybe instead track number of expected completions, and free
drivers/net/ethernet/tile/tilepro.c:	 * get here, there are no pending completions, but just in case,
drivers/net/ethernet/tile/tilepro.c:	/* Handle completions if needed to make room. */
drivers/net/ethernet/tile/tilepro.c:	/* of available completions, and comparing it to 4. */
drivers/net/ethernet/tile/tilepro.c:	/* Handle completions. */
drivers/net/ethernet/tile/tilepro.c:			.send_completion = final,
drivers/net/ethernet/tile/tilepro.c:	/* Handle completions if needed to make room. */
drivers/net/ethernet/tile/tilepro.c:	/* of available completions, and comparing it to 4. */
drivers/net/ethernet/tile/tilepro.c:	/* Handle completions. */
drivers/net/ethernet/altera/altera_tse.h:	u32 (*tx_completions)(struct altera_tse_private *);
drivers/net/ethernet/altera/altera_sgdma.c:u32 sgdma_tx_completions(struct altera_tse_private *priv)
drivers/net/ethernet/altera/altera_msgdma.c:u32 msgdma_tx_completions(struct altera_tse_private *priv)
drivers/net/ethernet/altera/altera_tse_main.c:	ready = priv->dmaops->tx_completions(priv);
drivers/net/ethernet/altera/altera_tse_main.c:	.tx_completions = sgdma_tx_completions,
drivers/net/ethernet/altera/altera_tse_main.c:	.tx_completions = msgdma_tx_completions,
drivers/net/ethernet/altera/altera_sgdma.h:u32 sgdma_tx_completions(struct altera_tse_private *);
drivers/net/ethernet/altera/altera_msgdma.h:u32 msgdma_tx_completions(struct altera_tse_private *);
drivers/net/ethernet/nxp/lpc_eth.c:	/* Wait for completion */
drivers/net/ethernet/stmicro/stmmac/stmmac_main.c: * stmmac_tx_clean - to manage the transmission completion
drivers/net/ethernet/stmicro/stmmac/stmmac_main.c: * interrupt on completion bit.
drivers/net/ethernet/stmicro/stmmac/common.h:	/* Clear interrupt on tx frame completion. When this bit is
drivers/net/ethernet/intel/fm10k/fm10k_main.c:	/* place incomplete frames back on ring for completion */
drivers/net/ethernet/intel/fm10k/fm10k_main.c:	 * run the check_tx_hang logic with a transmit completion
drivers/net/ethernet/intel/i40evf/i40e_type.h:	struct i40e_aqc_get_veb_parameters_completion info;
drivers/net/ethernet/intel/i40evf/i40e_common.c: * completion before returning.
drivers/net/ethernet/intel/i40evf/i40evf_main.c:		i40evf_virtchnl_completion(adapter, v_msg->v_opcode,
drivers/net/ethernet/intel/i40evf/i40e_adminq.c:	 * in case of asynchronous completions
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h: * - _completion for direct return data
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h: *     uses the same completion and data structure as Add VSI
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_add_get_update_vsi_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_get_update_vsi_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_add_update_pv_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_update_pv_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_get_pv_params_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_get_pv_params_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_add_veb_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_veb_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_get_veb_parameters_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_get_veb_parameters_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_add_remove_macvlan_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_remove_macvlan_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_add_remove_vlan_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h: * Uses generic i40e_aqc_add_remove_tag_completion for completion
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_add_remove_tag_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_remove_tag_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h: * Uses generic i40e_aqc_add_remove_tag_completion for completion
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_add_remove_mcast_etag_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_remove_mcast_etag_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_update_tag_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_update_tag_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h: * and the generic direct completion structure
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_add_remove_control_packet_filter_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_remove_control_packet_filter_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h: * and the generic indirect completion structure
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_remove_cloud_filters_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_remove_cloud_filters_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_add_delete_mirror_rule_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_delete_mirror_rule_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:/* Add Udp Tunnel command and completion (direct 0x0B00) */
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_add_udp_tunnel_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_udp_tunnel_completion);
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:struct i40e_aqc_del_udp_tunnel_completion {
drivers/net/ethernet/intel/i40evf/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_del_udp_tunnel_completion);
drivers/net/ethernet/intel/i40evf/i40e_virtchnl.h: * until reset completion is indicated. The admin queue must be reinitialized
drivers/net/ethernet/intel/i40evf/i40evf.h:void i40evf_virtchnl_completion(struct i40evf_adapter *adapter,
drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c: * i40evf_virtchnl_completion
drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c: * Asynchronous completion function for admin queue messages. Rather than busy
drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c:void i40evf_virtchnl_completion(struct i40evf_adapter *adapter,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	/* place incomplete frames back on ring for completion */
drivers/net/ethernet/intel/ixgbevf/vf.c: *  @autoneg_wait_to_complete: true when waiting for completion is needed
drivers/net/ethernet/intel/e100.c: *	is the next CB to check for completion; cb_to_send is the first
drivers/net/ethernet/intel/e100.c: *	mapped shared memory, and completion status is contained within
drivers/net/ethernet/intel/e100.c:	/* no interrupt for every tx completion, delay = 256us if not 557 */
drivers/net/ethernet/intel/e100.c:	/* wait for completion */
drivers/net/ethernet/intel/igbvf/vf.c:		/* notify PF of VF reset completion */
drivers/net/ethernet/intel/igb/igb_main.c:	/* place incomplete frames back on ring for completion */
drivers/net/ethernet/intel/igb/e1000_nvm.c: *  igb_poll_eerd_eewr_done - Poll for EEPROM read/write completion
drivers/net/ethernet/intel/igb/e1000_nvm.c: *  Polls the EEPROM status bit for either read or write completion based
drivers/net/ethernet/intel/igb/e1000_i210.c: *  completion status.  NOTE: silicon which is EEPROM-less will fail trying
drivers/net/ethernet/intel/igb/e1000_mac.c: *  igb_get_auto_rd_done - Check for auto read completion
drivers/net/ethernet/intel/igb/e1000_mac.c: *  completion.
drivers/net/ethernet/intel/igb/e1000_phy.c: *  successful completion, else return corresponding error code.
drivers/net/ethernet/intel/igb/e1000_phy.c: *  igb_wait_autoneg - Wait for auto-neg completion
drivers/net/ethernet/intel/igb/e1000_82575.c:static s32  igb_set_pcie_completion_timeout(struct e1000_hw *hw);
drivers/net/ethernet/intel/igb/e1000_82575.c: *  completion status.  NOTE: silicon which is EEPROM-less will fail trying
drivers/net/ethernet/intel/igb/e1000_82575.c:	/* flush the write to verify completion */
drivers/net/ethernet/intel/igb/e1000_82575.c:		/* flush the write to verify completion */
drivers/net/ethernet/intel/igb/e1000_82575.c:	/* set the completion timeout for interface */
drivers/net/ethernet/intel/igb/e1000_82575.c:	ret_val = igb_set_pcie_completion_timeout(hw);
drivers/net/ethernet/intel/igb/e1000_82575.c:		hw_dbg("PCI-E Set completion timeout has failed.\n");
drivers/net/ethernet/intel/igb/e1000_82575.c: *  igb_set_pcie_completion_timeout - set pci-e completion timeout
drivers/net/ethernet/intel/igb/e1000_82575.c:static s32 igb_set_pcie_completion_timeout(struct e1000_hw *hw)
drivers/net/ethernet/intel/igb/e1000_82575.c:	 * directly in order to set the completion timeout value for
drivers/net/ethernet/intel/igb/e1000_82575.c:	/* disable completion timeout resend */
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  When K1 is enabled for 1Gbps, the MAC can miss 2 DMA completion indications
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  e1000_lan_init_done_ich8lan - Check for PHY config completion
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  @timeout: maximum time to wait for completion
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  This function starts a flash cycle and waits for its completion.
drivers/net/ethernet/intel/e1000e/ich8lan.c: *  Read appropriate register for the config done bit for completion status
drivers/net/ethernet/intel/e1000e/mac.c: *  e1000e_get_auto_rd_done - Check for auto read completion
drivers/net/ethernet/intel/e1000e/nvm.c: *  e1000e_poll_eerd_eewr_done - Poll for EEPROM read/write completion
drivers/net/ethernet/intel/e1000e/nvm.c: *  Polls the EEPROM status bit for either read or write completion based
drivers/net/ethernet/intel/e1000e/82571.c: *  poll for completion.
drivers/net/ethernet/intel/e1000e/82571.c:	 * Need to wait for Phy configuration completion before accessing
drivers/net/ethernet/intel/e1000e/82571.c:		 * completions are occurring, particularly with ASPM enabled.
drivers/net/ethernet/intel/e1000e/phy.c: *  successful completion, else return corresponding error code.
drivers/net/ethernet/intel/e1000e/phy.c: *  e1000_wait_autoneg - Wait for auto-neg completion
drivers/net/ethernet/intel/i40e/i40e_type.h:	struct i40e_aqc_get_veb_parameters_completion info;
drivers/net/ethernet/intel/i40e/i40e_common.c:	struct i40e_aqc_add_get_update_vsi_completion *resp =
drivers/net/ethernet/intel/i40e/i40e_common.c:		(struct i40e_aqc_add_get_update_vsi_completion *)
drivers/net/ethernet/intel/i40e/i40e_common.c:	struct i40e_aqc_add_get_update_vsi_completion *resp =
drivers/net/ethernet/intel/i40e/i40e_common.c:		(struct i40e_aqc_add_get_update_vsi_completion *)
drivers/net/ethernet/intel/i40e/i40e_common.c:	struct i40e_aqc_add_get_update_vsi_completion *resp =
drivers/net/ethernet/intel/i40e/i40e_common.c:		(struct i40e_aqc_add_get_update_vsi_completion *)
drivers/net/ethernet/intel/i40e/i40e_common.c:	struct i40e_aqc_add_veb_completion *resp =
drivers/net/ethernet/intel/i40e/i40e_common.c:		(struct i40e_aqc_add_veb_completion *)&desc.params.raw;
drivers/net/ethernet/intel/i40e/i40e_common.c:	struct i40e_aqc_get_veb_parameters_completion *cmd_resp =
drivers/net/ethernet/intel/i40e/i40e_common.c:		(struct i40e_aqc_get_veb_parameters_completion *)
drivers/net/ethernet/intel/i40e/i40e_common.c:	struct i40e_aqc_add_delete_mirror_rule_completion *resp =
drivers/net/ethernet/intel/i40e/i40e_common.c:	(struct i40e_aqc_add_delete_mirror_rule_completion *)&desc.params.raw;
drivers/net/ethernet/intel/i40e/i40e_common.c:	/* The completion specifies the maximum time in ms that the driver
drivers/net/ethernet/intel/i40e/i40e_common.c:	struct i40e_aqc_del_udp_tunnel_completion *resp =
drivers/net/ethernet/intel/i40e/i40e_common.c:		(struct i40e_aqc_del_udp_tunnel_completion *)&desc.params.raw;
drivers/net/ethernet/intel/i40e/i40e_common.c:	struct i40e_aqc_add_remove_control_packet_filter_completion *resp =
drivers/net/ethernet/intel/i40e/i40e_common.c:		(struct i40e_aqc_add_remove_control_packet_filter_completion *)
drivers/net/ethernet/intel/i40e/i40e_nvm.c: * on ARQ completion event reception by caller.
drivers/net/ethernet/intel/i40e/i40e_adminq.c:	 * in case of asynchronous completions
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h: * - _completion for direct return data
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h: *     uses the same completion and data structure as Add VSI
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_add_get_update_vsi_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_get_update_vsi_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_add_update_pv_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_update_pv_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_get_pv_params_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_get_pv_params_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_add_veb_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_veb_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_get_veb_parameters_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_get_veb_parameters_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_add_remove_macvlan_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_remove_macvlan_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_add_remove_vlan_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h: * Uses generic i40e_aqc_add_remove_tag_completion for completion
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_add_remove_tag_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_remove_tag_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h: * Uses generic i40e_aqc_add_remove_tag_completion for completion
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_add_remove_mcast_etag_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_remove_mcast_etag_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_update_tag_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_update_tag_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h: * and the generic direct completion structure
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_add_remove_control_packet_filter_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_remove_control_packet_filter_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h: * and the generic indirect completion structure
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_remove_cloud_filters_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_remove_cloud_filters_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_add_delete_mirror_rule_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_delete_mirror_rule_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:/* Add Udp Tunnel command and completion (direct 0x0B00) */
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_add_udp_tunnel_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_add_udp_tunnel_completion);
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:struct i40e_aqc_del_udp_tunnel_completion {
drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h:I40E_CHECK_CMD_LENGTH(i40e_aqc_del_udp_tunnel_completion);
drivers/net/ethernet/intel/i40e/i40e_virtchnl.h: * until reset completion is indicated. The admin queue must be reinitialized
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c: *  @autoneg_wait_to_complete: true when waiting for completion is needed
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c: *  @autoneg_wait_to_complete: true when waiting for completion is needed
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c: *  @autoneg_wait_to_complete: true when waiting for completion is needed
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	/* write hashes and fdirctrl register, poll for completion */
drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c:	/* write hashes and fdirctrl register, poll for completion */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: * ixgbe_pcie_timeout_poll - Return number of times to poll for completion
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  completion timeout, in units of 100 microsec.  Never return less than
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	 * remaining completions from the PCIe bus to trickle in, and then reset
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  @timeout: time in ms to wait for command completion
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	/* Check command successful completion. */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	/* wait for a last completion before clearing buffers */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c: *  @autoneg_wait_to_complete: true when waiting for completion is needed
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	 * run the check_tx_hang logic with a transmit completion
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		/* place incomplete frames back on ring for completion */
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:	/* Record completion for next time. */
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * ixgbe_iosf_wait - Wait for IOSF command completion
drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c: * @autoneg_wait_to_complete: true when waiting for completion is needed
drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c: *  ixgbe_set_pcie_completion_timeout - set pci-e completion timeout
drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c:static void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw)
drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c:	 * directly in order to set the completion timeout value for
drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c:	/* disable completion timeout resend */
drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c: *  Then set pcie completion timeout
drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c:	/* set the completion timeout for interface */
drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c:	ixgbe_set_pcie_completion_timeout(hw);
drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c: *  @autoneg_wait_to_complete: true when waiting for completion is needed
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c: *  Restart autonegotiation and PHY and waits for completion.
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:	/* Restart PHY autonegotiation and wait for completion */
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c: *	Restart autonegotiation and PHY and waits for completion.
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:	/* Restart PHY autonegotiation and wait for completion */
drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c:	/* reset the PHY and poll for completion */
drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c: *  @autoneg_wait_to_complete: true when waiting for completion is needed
drivers/net/ethernet/micrel/ks8851.c: * @irq: IRQ on completion of the packet.
drivers/net/ethernet/micrel/ks8851.c: * needs, such as IRQ on completion. Send the header and the packet data to
drivers/net/ethernet/micrel/ks8851.c:		fid |= TXFR_TXIC;	/* irq on completion */
drivers/net/ethernet/smsc/smsc9420.c:	/* to ensure PCI write completion, we must perform a PCI read */
drivers/net/ethernet/smsc/smsc9420.c:	/* to ensure PCI write completion, we must perform a PCI read */
drivers/net/ethernet/aurora/nb8800.c:	val |= TCR_DIE;		/* interrupt on DMA chain completion */
drivers/net/ethernet/aurora/nb8800.c:	/* On tango4 interrupt on DMA completion per frame works and gives
drivers/net/ethernet/aurora/nb8800.c:	/* Disable unnecessary interrupt on rx completion */
drivers/net/ethernet/aurora/nb8800.c:	/* Request interrupt on descriptor DMA completion */
drivers/net/ethernet/ibm/ehea/ehea.h:/* Send completion signaling */
drivers/net/ethernet/ibm/ehea/ehea_main.c:			pr_err("Bad send completion status=0x%04X\n",
drivers/net/ethernet/ibm/ibmvnic.h:	struct completion stats_done;
drivers/net/ethernet/ibm/ibmvnic.h:	struct completion init_done;
drivers/net/ethernet/ibm/ibmvnic.h:	struct completion fw_done;
drivers/net/ethernet/ibm/ibmvnic.c:#include <linux/completion.h>
drivers/net/ethernet/ibm/ibmvnic.c:	init_completion(&adapter->fw_done);
drivers/net/ethernet/ibm/ibmvnic.c:	wait_for_completion(&adapter->fw_done);
drivers/net/ethernet/ibm/ibmvnic.c:	init_completion(&adapter->stats_done);
drivers/net/ethernet/ibm/ibmvnic.c:	wait_for_completion(&adapter->stats_done);
drivers/net/ethernet/ibm/ibmvnic.c:	init_completion(&adapter->fw_done);
drivers/net/ethernet/ibm/ibmvnic.c:	wait_for_completion(&adapter->fw_done);
drivers/net/ethernet/ibm/ibmvnic.c:	init_completion(&adapter->fw_done);
drivers/net/ethernet/ibm/ibmvnic.c:	wait_for_completion(&adapter->fw_done);
drivers/net/ethernet/ibm/ibmvnic.c:	reinit_completion(&adapter->init_done);
drivers/net/ethernet/ibm/ibmvnic.c:	if (!wait_for_completion_timeout(&adapter->init_done, timeout)) {
drivers/net/ethernet/ibm/ibmvnic.c:			reinit_completion(&adapter->init_done);
drivers/net/ethernet/ibm/ibmvnic.c:			if (!wait_for_completion_timeout(&adapter->init_done,
drivers/net/ethernet/ibm/ibmvnic.c:	init_completion(&adapter->init_done);
drivers/net/ethernet/ibm/ibmvnic.c:	if (!wait_for_completion_timeout(&adapter->init_done, timeout))
drivers/net/ethernet/ibm/ibmvnic.c:			reinit_completion(&adapter->init_done);
drivers/net/ethernet/ibm/ibmvnic.c:			if (!wait_for_completion_timeout(&adapter->init_done,
drivers/net/ethernet/marvell/sky2.c: *  1. The hardware will tell us about partial completion of multi-part
drivers/net/ethernet/marvell/mvmdio.c:	 * but also reflects SMI completion), use that to wait for
drivers/net/ethernet/marvell/mvmdio.c:	 * SMI access completion instead of polling the SMI busy bit.
drivers/net/ethernet/marvell/mv643xx_eth.c:		 * which will free the skb on TX completion.
drivers/net/ethernet/qlogic/qed/qed_hsi.h:/* Completion params for aggregated interrupt completion */
drivers/net/ethernet/qlogic/qed/qed_ll2.c:		   "Got an LL2 Rx completion: [Buffer at phys 0x%llx, offset 0x%02x] Length 0x%04x Parse_flags 0x%04x vlan 0x%04x Opaque data [0x%08x:0x%08x]\n",
drivers/net/ethernet/qlogic/qed/qed_ll2.c:static int qed_ll2_txq_completion(struct qed_hwfn *p_hwfn, void *p_cookie)
drivers/net/ethernet/qlogic/qed/qed_ll2.c:qed_ll2_rxq_completion_gsi(struct qed_hwfn *p_hwfn,
drivers/net/ethernet/qlogic/qed/qed_ll2.c:			  "GSI Rx completion but active_descq is empty\n");
drivers/net/ethernet/qlogic/qed/qed_ll2.c:static int qed_ll2_rxq_completion_reg(struct qed_hwfn *p_hwfn,
drivers/net/ethernet/qlogic/qed/qed_ll2.c:			  "LL2 Rx completion but active_descq is empty\n");
drivers/net/ethernet/qlogic/qed/qed_ll2.c:static int qed_ll2_rxq_completion(struct qed_hwfn *p_hwfn, void *cookie)
drivers/net/ethernet/qlogic/qed/qed_ll2.c:			rc = qed_ll2_rxq_completion_gsi(p_hwfn, p_ll2_conn,
drivers/net/ethernet/qlogic/qed/qed_ll2.c:			rc = qed_ll2_rxq_completion_reg(p_hwfn, p_ll2_conn,
drivers/net/ethernet/qlogic/qed/qed_ll2.c:	comp_rx_cb = qed_ll2_rxq_completion;
drivers/net/ethernet/qlogic/qed/qed_ll2.c:	comp_tx_cb = qed_ll2_txq_completion;
drivers/net/ethernet/qlogic/qed/qed_ll2.c:		 * we can't free memory, will need to wait for completion.
drivers/net/ethernet/qlogic/qed/qed_dev.c:	/* Poll until completion */
drivers/net/ethernet/qlogic/qed/qed_sp_commands.c:		DP_NOTICE(p_hwfn, "Unknown SPQE completion mode %d\n",
drivers/net/ethernet/qlogic/qed/qed_l2.h:			     bool eq_completion_only, bool cqe_completion);
drivers/net/ethernet/qlogic/qed/qed_l2.h: * @param complete_cqe_flg	Post completion to the CQE Ring if set
drivers/net/ethernet/qlogic/qed/qed_l2.h: * @param complete_event_flg	Post completion to the Event Ring if set
drivers/net/ethernet/qlogic/qed/qed_spq.c:		/* validate we receive completion update */
drivers/net/ethernet/qlogic/qed/qed_spq.c:		/* validate we receive completion update */
drivers/net/ethernet/qlogic/qed/qed_spq.c:		DP_NOTICE(p_hwfn, "Unknown SPQE completion mode %d\n",
drivers/net/ethernet/qlogic/qed/qed_spq.c:qed_async_event_completion(struct qed_hwfn *p_hwfn,
drivers/net/ethernet/qlogic/qed/qed_spq.c:			  "Unknown Async completion for protocol: %d\n",
drivers/net/ethernet/qlogic/qed/qed_spq.c:int qed_eq_completion(struct qed_hwfn *p_hwfn, void *cookie)
drivers/net/ethernet/qlogic/qed/qed_spq.c:			if (qed_async_event_completion(p_hwfn, p_eqe))
drivers/net/ethernet/qlogic/qed/qed_spq.c:		} else if (qed_spq_completion(p_hwfn,
drivers/net/ethernet/qlogic/qed/qed_spq.c:	/* register EQ completion on the SP SB */
drivers/net/ethernet/qlogic/qed/qed_spq.c:	qed_int_register_cb(p_hwfn, qed_eq_completion,
drivers/net/ethernet/qlogic/qed/qed_spq.c:static int qed_cqe_completion(struct qed_hwfn *p_hwfn,
drivers/net/ethernet/qlogic/qed/qed_spq.c:	return qed_spq_completion(p_hwfn, cqe->echo, 0, NULL);
drivers/net/ethernet/qlogic/qed/qed_spq.c:int qed_eth_cqe_completion(struct qed_hwfn *p_hwfn,
drivers/net/ethernet/qlogic/qed/qed_spq.c:	rc = qed_cqe_completion(p_hwfn, cqe, PROTOCOLID_ETH);
drivers/net/ethernet/qlogic/qed/qed_spq.c:	INIT_LIST_HEAD(&p_spq->completion_pending);
drivers/net/ethernet/qlogic/qed/qed_spq.c:		list_add_tail(&p_ent->list, &p_spq->completion_pending);
drivers/net/ethernet/qlogic/qed/qed_spq.c:		/* For entries in QED BLOCK mode, the completion code cannot
drivers/net/ethernet/qlogic/qed/qed_spq.c:int qed_spq_completion(struct qed_hwfn *p_hwfn,
drivers/net/ethernet/qlogic/qed/qed_spq.c:	list_for_each_entry_safe(p_ent, tmp, &p_spq->completion_pending, list) {
drivers/net/ethernet/qlogic/qed/qed_spq.c:			 * out-of-order completions, by marking the completions
drivers/net/ethernet/qlogic/qed/qed_spq.c:			   "Got completion for echo %04x - doesn't match echo %04x in completion pending list\n",
drivers/net/ethernet/qlogic/qed/qed_spq.c:			   "Got a completion without a callback function\n");
drivers/net/ethernet/qlogic/qed/qed_hw.c:	/* Whether to write a completion word to the completion destination:
drivers/net/ethernet/qlogic/qed/qed_hw.c:	 * 0-Do not write a completion word
drivers/net/ethernet/qlogic/qed/qed_hw.c:	 * 1-Write the completion word
drivers/net/ethernet/qlogic/qed/qed_hw.c:	dma_addr_t *p_addr = &p_hwfn->dmae_info.completion_word_phys_addr;
drivers/net/ethernet/qlogic/qed/qed_hw.c:	u32 **p_comp = &p_hwfn->dmae_info.p_completion_word;
drivers/net/ethernet/qlogic/qed/qed_hw.c:	if (p_hwfn->dmae_info.p_completion_word) {
drivers/net/ethernet/qlogic/qed/qed_hw.c:		p_phys = p_hwfn->dmae_info.completion_word_phys_addr;
drivers/net/ethernet/qlogic/qed/qed_hw.c:				  p_hwfn->dmae_info.p_completion_word, p_phys);
drivers/net/ethernet/qlogic/qed/qed_hw.c:		p_hwfn->dmae_info.p_completion_word = NULL;
drivers/net/ethernet/qlogic/qed/qed_hw.c:	while (*p_hwfn->dmae_info.p_completion_word != DMAE_COMPLETION_VAL) {
drivers/net/ethernet/qlogic/qed/qed_hw.c:				  *p_hwfn->dmae_info.p_completion_word,
drivers/net/ethernet/qlogic/qed/qed_hw.c:		/* to sync the completion_word since we are not
drivers/net/ethernet/qlogic/qed/qed_hw.c:		 * using the volatile keyword for p_completion_word
drivers/net/ethernet/qlogic/qed/qed_hw.c:		*p_hwfn->dmae_info.p_completion_word = 0;
drivers/net/ethernet/qlogic/qed/qed_hw.c:	dma_addr_t phys = p_hwfn->dmae_info.completion_word_phys_addr;
drivers/net/ethernet/qlogic/qed/qed_vf.h:	u8 cqe_completion;
drivers/net/ethernet/qlogic/qed/qed_vf.h: * @param cqe_completion
drivers/net/ethernet/qlogic/qed/qed_vf.h:		       u16 rx_qid, bool cqe_completion);
drivers/net/ethernet/qlogic/qed/qed_vf.h:				     u16 rx_qid, bool cqe_completion)
drivers/net/ethernet/qlogic/qed/qed_vf.c:int qed_vf_pf_rxq_stop(struct qed_hwfn *p_hwfn, u16 rx_qid, bool cqe_completion)
drivers/net/ethernet/qlogic/qed/qed_vf.c:	req->cqe_completion = cqe_completion;
drivers/net/ethernet/qlogic/qed/qed_l2.c:			     bool eq_completion_only, bool cqe_completion)
drivers/net/ethernet/qlogic/qed/qed_l2.c:		return qed_vf_pf_rxq_stop(p_hwfn, rx_queue_id, cqe_completion);
drivers/net/ethernet/qlogic/qed/qed_l2.c:	/* Cleaning the queue requires the completion to arrive there.
drivers/net/ethernet/qlogic/qed/qed_l2.c:		 !eq_completion_only) || cqe_completion;
drivers/net/ethernet/qlogic/qed/qed_l2.c:		eq_completion_only;
drivers/net/ethernet/qlogic/qed/qed_l2.c:				      params->eq_completion_only, false);
drivers/net/ethernet/qlogic/qed/qed_l2.c:static int qed_fp_cqe_completion(struct qed_dev *dev,
drivers/net/ethernet/qlogic/qed/qed_l2.c:	return qed_eth_cqe_completion(&dev->hwfns[rss_id % dev->num_hwfns],
drivers/net/ethernet/qlogic/qed/qed_l2.c:	.eth_cqe_completion = &qed_fp_cqe_completion,
drivers/net/ethernet/qlogic/qed/qed_sriov.c:				u16 rxq_id, u8 num_rxqs, bool cqe_completion)
drivers/net/ethernet/qlogic/qed/qed_sriov.c:						      cqe_completion);
drivers/net/ethernet/qlogic/qed/qed_sriov.c:				  req->num_rxqs, req->cqe_completion);
drivers/net/ethernet/qlogic/qed/qed_mcp.h: * @brief - drains the nig, allowing completion to pass in case of pauses.
drivers/net/ethernet/qlogic/qed/qed.h:	dma_addr_t	completion_word_phys_addr;
drivers/net/ethernet/qlogic/qed/qed.h:	/* The memory location where the DMAE writes the completion
drivers/net/ethernet/qlogic/qed/qed.h:	u32		*p_completion_word;
drivers/net/ethernet/qlogic/qed/qed_sp.h:	QED_SPQ_MODE_EBLOCK,    /* QED should block until completion */
drivers/net/ethernet/qlogic/qed/qed_sp.h: * @brief qed_eth_cqe_completion - handles the completion of a
drivers/net/ethernet/qlogic/qed/qed_sp.h:int qed_eth_cqe_completion(struct qed_hwfn *p_hwfn,
drivers/net/ethernet/qlogic/qed/qed_sp.h:	struct list_head	completion_pending;
drivers/net/ethernet/qlogic/qed/qed_sp.h:	/* Bitmap for handling out-of-order completions */
drivers/net/ethernet/qlogic/qed/qed_sp.h: * @brief qed_eq_completion - Completes currently pending EQ elements
drivers/net/ethernet/qlogic/qed/qed_sp.h:int qed_eq_completion(struct qed_hwfn *p_hwfn,
drivers/net/ethernet/qlogic/qed/qed_sp.h: * @brief qed_spq_completion - Completes a single event
drivers/net/ethernet/qlogic/qed/qed_sp.h: * @param echo - echo value from cookie (used for determining completion)
drivers/net/ethernet/qlogic/qed/qed_sp.h:int qed_spq_completion(struct qed_hwfn *p_hwfn,
drivers/net/ethernet/qlogic/qed/qed_sp.h:	/* Information regarding operation upon sending & completion */
drivers/net/ethernet/qlogic/qed/qed_sp.h: * configure the function related parameters and write its completion to the
drivers/net/ethernet/qlogic/qed/qed_sp.h: * sent and the last completion written to the PFs Event Ring. This ramrod also
drivers/net/ethernet/qlogic/qed/qed_roce.c:			 * for completion
drivers/net/ethernet/qlogic/qede/qede_ethtool.c:		DP_NOTICE(edev, "Tx completion didn't happen\n");
drivers/net/ethernet/qlogic/qede/qede_ethtool.c:		/* Get the CQE from the completion ring */
drivers/net/ethernet/qlogic/qede/qede_main.c:		/* Get the CQE from the completion ring */
drivers/net/ethernet/qlogic/qede/qede_main.c:			edev->ops->eth_cqe_completion(
drivers/net/ethernet/qlogic/qede/qede_main.c:	/* Allocate FW completion ring */
drivers/net/ethernet/qlogic/netxen/netxen_nic.h: *	47:40 - completion id
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:				 "%s: Wait for diag completion\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			 "%s: Wait for diag completion\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov.h:	struct completion		resp_cmpl;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov.h:	struct completion		ch_free_cmpl;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	complete(&mbx->completion);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:static void qlcnic_83xx_poll_for_mbx_completion(struct qlcnic_adapter *adapter,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		if (!wait_for_completion_timeout(&cmd->completion, timeout)) {
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		qlcnic_83xx_poll_for_mbx_completion(adapter, cmd);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			netdev_err(netdev, "%s: Did not receive loopback IDC completion AEN\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			netdev_err(netdev, "%s: Did not receive loopback IDC completion AEN\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	reinit_completion(&mbx->completion);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:qlcnic_83xx_notify_cmd_completion(struct qlcnic_adapter *adapter,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	complete(&cmd->completion);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		qlcnic_83xx_notify_cmd_completion(adapter, cmd);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	qlcnic_83xx_notify_cmd_completion(adapter, cmd);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	complete(&mbx->completion);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		init_completion(&cmd->completion);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		if (wait_for_completion_timeout(&mbx->completion,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	init_completion(&mbx->completion);
drivers/net/ethernet/qlogic/qlcnic/qlcnic.h: *	47:40 - completion id
drivers/net/ethernet/qlogic/qlcnic/qlcnic.h:	struct completion	completion;
drivers/net/ethernet/qlogic/qlcnic/qlcnic.h:	struct completion	completion;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		init_completion(&vf->ch_free_cmpl);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	if (!wait_for_completion_timeout(&cmd.completion, timeout)) {
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	init_completion(&(*trans)->resp_cmpl);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	struct completion *cmpl = &trans->resp_cmpl;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	if (wait_for_completion_timeout(cmpl, QLC_MBOX_RESP_TIMEOUT))
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	struct completion *cmpl = &vf->ch_free_cmpl;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	if (!wait_for_completion_timeout(cmpl, QLC_MBOX_CH_FREE_TIMEOUT)) {
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:/* Process an inter-device event completion.
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c: * If good, signal the caller's completion.
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:		complete(&qdev->ide_completion);
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c: *  it's completion. */
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:		 * command completion.
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:		 * will be spawned. If it's our completion
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:		/* It's either the completion for our mailbox
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:		 * completion then get out.
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:			wait_for_completion_timeout(&qdev->ide_completion,
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:		 * We might have a good completion or a request for
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c: * events that may sleep waiting for completion.
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:	ql_enable_completion_interrupt(qdev, 0);
drivers/net/ethernet/qlogic/qlge/qlge.h:	u16 cq_id;		/* completion (rx) queue for tx completions */
drivers/net/ethernet/qlogic/qlge/qlge.h:	TX_Q = 3,		/* Handles outbound completions. */
drivers/net/ethernet/qlogic/qlge/qlge.h:	RX_Q = 4,		/* Handles inbound completions. */
drivers/net/ethernet/qlogic/qlge/qlge.h:	struct cqicb cqicb;	/* The chip's completion queue init control block. */
drivers/net/ethernet/qlogic/qlge/qlge.h:	 *  (CPU count * outbound completion rx_ring) +
drivers/net/ethernet/qlogic/qlge/qlge.h:	 *  (irq_vector_cnt * inbound (RSS) completion rx_ring)
drivers/net/ethernet/qlogic/qlge/qlge.h:	struct completion ide_completion;
drivers/net/ethernet/qlogic/qlge/qlge.h:u32 ql_enable_completion_interrupt(struct ql_adapter *qdev, u32 intr);
drivers/net/ethernet/qlogic/qlge/qlge_main.c: * sets address, triggers download, waits for completion.
drivers/net/ethernet/qlogic/qlge/qlge_main.c:u32 ql_enable_completion_interrupt(struct ql_adapter *qdev, u32 intr)
drivers/net/ethernet/qlogic/qlge/qlge_main.c:static u32 ql_disable_completion_interrupt(struct ql_adapter *qdev, u32 intr)
drivers/net/ethernet/qlogic/qlge/qlge_main.c:static void ql_enable_all_completion_interrupts(struct ql_adapter *qdev)
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		ql_enable_completion_interrupt(qdev, i);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:/* Process an inbound completion from an rx ring. */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:/* Process an inbound completion from an rx ring. */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:/* Process an inbound completion from an rx ring. */
drivers/net/ethernet/qlogic/qlge/qlge_main.c: * completion.  It will be rewritten for readability in the near
drivers/net/ethernet/qlogic/qlge/qlge_main.c:/* Process an inbound completion from an rx ring. */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:/* Process an inbound completion from an rx ring. */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:/* Process an outbound completion from an rx ring. */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	/* While there are entries in the completion queue. */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	/* While there are entries in the completion queue. */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		/* If this TX completion ring belongs to this vector and
drivers/net/ethernet/qlogic/qlge/qlge_main.c:				     "%s: Servicing TX completion ring %d.\n",
drivers/net/ethernet/qlogic/qlge/qlge_main.c:			     "%s: Servicing RX completion ring %d.\n",
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		ql_enable_completion_interrupt(qdev, rx_ring->irq);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:/* MSI-X Multiple Vector Interrupt Handler for inbound completions. */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	var = ql_disable_completion_interrupt(qdev, intr_context->intr);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		 * We've got an async event or mailbox completion.
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		ql_disable_completion_interrupt(qdev, intr_context->intr);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		ql_disable_completion_interrupt(qdev, intr_context->intr);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	ql_enable_completion_interrupt(qdev, intr_context->intr);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	 * When we get the completion we can use it to establish the context.
drivers/net/ethernet/qlogic/qlge/qlge_main.c: * with the completion queues for this device.
drivers/net/ethernet/qlogic/qlge/qlge_main.c:/* Allocate queues and buffers for this completions queue based
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	 * Allocate the completion queue for this rx_ring.
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		/* Inbound completion handling rx_rings run in
drivers/net/ethernet/qlogic/qlge/qlge_main.c: * TX completion rings.  This function loops through
drivers/net/ethernet/qlogic/qlge/qlge_main.c: * the TX completion rings and assigns the vector that
drivers/net/ethernet/qlogic/qlge/qlge_main.c: * 2 vectors (so 2 RSS rings) and 8 TX completion rings.
drivers/net/ethernet/qlogic/qlge/qlge_main.c: * and TX completion rings 0,1,2 and 3.  Vector 1 would
drivers/net/ethernet/qlogic/qlge/qlge_main.c: * service RSS ring 1 and TX completion rings 4,5,6 and 7.
drivers/net/ethernet/qlogic/qlge/qlge_main.c: * will service 1 RSS ring and 1 or more TX completion
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		 * TX completion rings.
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	/* Tell the TX completion rings which MSIx vector
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	/* If there is more than one inbound completion queue
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	ql_enable_all_completion_interrupts(qdev);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		 * The completion queue ID for the tx rings start
drivers/net/ethernet/qlogic/qlge/qlge_main.c:			 * Outbound queue handles outbound completions only.
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	init_completion(&qdev->ide_completion);
drivers/net/ethernet/qlogic/qla3xxx.c: * The difference between 3022 and 3032 for inbound completions:
drivers/net/ethernet/qlogic/qla3xxx.c: * 3022 uses two buffers per completion.  The first buffer contains
drivers/net/ethernet/qlogic/qla3xxx.c:		 * is necessary for 3022 IP completions.
drivers/net/ethernet/qlogic/qla3xxx.c:	/* While there are entries in the completion queue. */
drivers/net/ethernet/qlogic/qla3xxx.c:		 * if the inbound completion is for a VLAN.
drivers/net/ethernet/samsung/sxgbe/sxgbe_desc.h:	/* Clear interrupt on tx frame completion. When this bit is
drivers/net/ethernet/samsung/sxgbe/sxgbe_desc.h:	/* Set Interrupt on completion bit */
drivers/net/ethernet/samsung/sxgbe/sxgbe_desc.c:/* Clear interrupt on tx frame completion. When this bit is
drivers/net/ethernet/samsung/sxgbe/sxgbe_desc.c:/* Set Interrupt on completion bit */
drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c: * interrupt on completion bit.
drivers/net/ethernet/chelsio/cxgb3/firmware_exports.h: * Ingress Traffic (e.g. DMA completion credit)  for TUNNEL Queue[i] is sent
drivers/net/ethernet/chelsio/cxgb3/sge.c:	 * We do not use Tx completion interrupts to free DMAd Tx packets.
drivers/net/ethernet/chelsio/cxgb3/sge.c: *	indications and completion credits for the queue set's Tx queues.
drivers/net/ethernet/chelsio/cxgb3/cxgb3_ctl_defs.h: * Structure used to request an operation on an RDMA completion queue.
drivers/net/ethernet/chelsio/cxgb3/cxgb3_ctl_defs.h: * Structure used to setup RDMA completion queues.
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	@reg: the register to check for completion
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	@mask: a single-bit field within @reg that indicates completion
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	@valp: where to store the value of the register at completion time
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	at the time it indicated completion is stored there.  Returns 0 if the
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c:		{F_SPLCMPDIS, "PCI split completion discarded", -1, 1},
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c:		{F_UNXSPLCMP, "PCI unexpected split completion error", -1, 1},
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c:		{F_RCVSPLCMPERR, "PCI received split completion error", -1,
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c:		 "PCI unexpected split completion DMA read error", -1, 1},
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c:		 "PCI unexpected split completion DMA command error", -1, 1},
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	t3_sge_init_cqcntxt - initialize an SGE completion queue context
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	@credits: completion queue credits
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	Initialize an SGE completion queue context and make it ready for use.
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	t3_sge_disable_cqcntxt - disable an SGE completion queue
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	@id: the completion queue context id
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	Disable an SGE completion queue.  The caller is responsible for
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	t3_sge_cqcntxt_op - perform an operation on a completion queue context
drivers/net/ethernet/chelsio/cxgb3/t3_hw.c: *	Perform the selected operation on an SGE completion queue context.
drivers/net/ethernet/chelsio/cxgb3/mc5.c: * Issue a command to the TCAM and wait for its completion.  The address and
drivers/net/ethernet/chelsio/cxgb4vf/sge.c:		 * completion notifications to us and we mostly perform TX
drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c: *	@sleep_ok: if true we may sleep while awaiting command completion
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:	 * notifications of TX DMA completions.
drivers/net/ethernet/chelsio/cxgb/subr.c: *	@reg: the register to check for completion
drivers/net/ethernet/chelsio/cxgb/subr.c: *	@mask: a single-bit field within @reg that indicates completion
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c: *	@reg: the register to check for completion
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c: *	@mask: a single-bit field within @reg that indicates completion
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c: *	@valp: where to store the value of the register at completion time
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c: *	at the time it indicated completion is stored there.  Returns 0 if the
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c: *	@sleep_ok: if true we may sleep while awaiting command completion
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c:		{ RCCP_F, "Rx completions control array parity error", -1, 1 },
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c:		{ PIOCPLPERR_F, "PCI PIO completion FIFO parity error", -1, 1 },
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c:		{ RXCPLPERR_F, "PCI Rx completion parity error", -1, 1 },
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c:		{ UNXSPLCPLERR_F, "PCI unexpected split completion error",
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c:		{ PIOCPLGRPPERR_F, "PCI PIO completion Group FIFO parity error",
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c: *	@sleep_ok: if true we may sleep while awaiting command completion
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c:static void set_pcie_completion_timeout(struct adapter *adapter, u8 range)
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c:	/* Set pci completion timeout value to 4 seconds. */
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c:	set_pcie_completion_timeout(adapter, 0xd);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c: * it till we get a reply from the firmware on the completion status of the
drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c: * filter specification in order to facilitate signaling completion of the
drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c: * facilitate signaling completion of the operation.
drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c:	 * mark it as a successful completion so they don't stall waiting
drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c:		complete(&ctx->completion);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c:	init_completion(&ctx.completion);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c:	ret = wait_for_completion_timeout(&ctx.completion, 10 * HZ);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c:	init_completion(&ctx.completion);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c:	ret = wait_for_completion_timeout(&ctx.completion, 10 * HZ);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c:			complete(&ctx->completion);
drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h:/* completion flag (hi) - firmware generates a cpl_fw6_ack */
drivers/net/ethernet/chelsio/cxgb4/cxgb4.h:	u16 nciq;		/* # of completion queues */
drivers/net/ethernet/chelsio/cxgb4/cxgb4.h:	struct filter_ctx *ctx; /* Caller's completion hook */
drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h: * cxgb4_del_filter() to wait for an asynchronous completion.
drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h:	struct completion completion;	/* completion rendezvous */
drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c:	/* Tell uP to route control queue completions to rdma rspq */
drivers/net/ethernet/xilinx/ll_temac.h: *	1    IrqOnEnd    generate an interrupt at completion of DMA  op
drivers/net/ethernet/xilinx/xilinx_axienet_main.c: * This function is invoked from the Axi DMA Tx isr to notify the completion
drivers/net/ethernet/xilinx/xilinx_emaclite.c: * updates the stats and frees the socket buffer. The Tx completion is signaled
drivers/net/ethernet/3com/typhoon.c:enum completion_wait_values {
drivers/net/ethernet/3com/3c589_cs.c:static void tc589_wait_for_completion(struct net_device *dev, int cmd)
drivers/net/ethernet/3com/3c589_cs.c:	tc589_wait_for_completion(dev, TxReset);
drivers/net/ethernet/3com/3c589_cs.c:			tc589_wait_for_completion(dev, TxReset);
drivers/net/ethernet/3com/3c589_cs.c:					tc589_wait_for_completion(dev, TxReset);
drivers/net/ethernet/3com/3c589_cs.c:					tc589_wait_for_completion(dev, RxReset);
drivers/net/ethernet/3com/3c589_cs.c:		tc589_wait_for_completion(dev, RxDiscard);
drivers/net/ethernet/3com/3c59x.c:an extra interrupt or polling for the completion of each transfer, as well
drivers/net/ethernet/3com/3c574_cs.c:static void tc574_wait_for_completion(struct net_device *dev, int cmd);
drivers/net/ethernet/3com/3c574_cs.c:		tc574_wait_for_completion(dev, TxReset);
drivers/net/ethernet/3com/3c574_cs.c:		tc574_wait_for_completion(dev, RxReset);
drivers/net/ethernet/3com/3c574_cs.c:static void tc574_wait_for_completion(struct net_device *dev, int cmd)
drivers/net/ethernet/3com/3c574_cs.c:	tc574_wait_for_completion(dev, TotalReset|0x10);
drivers/net/ethernet/3com/3c574_cs.c:	tc574_wait_for_completion(dev, TxReset);
drivers/net/ethernet/3com/3c574_cs.c:	tc574_wait_for_completion(dev, RxReset);
drivers/net/ethernet/3com/3c574_cs.c:	tc574_wait_for_completion(dev, TxReset);
drivers/net/ethernet/3com/3c574_cs.c:			tc574_wait_for_completion(dev, TxReset);
drivers/net/ethernet/3com/3c574_cs.c:					tc574_wait_for_completion(dev, TxReset);
drivers/net/ethernet/3com/3c574_cs.c:					tc574_wait_for_completion(dev, RxReset);
drivers/net/ethernet/3com/3c574_cs.c:		tc574_wait_for_completion(dev, RxDiscard);
drivers/net/ethernet/3com/typhoon.h: * status:	0 on completion
drivers/net/ethernet/sun/sungem.c:		 * on the buffer address.  We sync on the RX completion
drivers/net/ethernet/sun/sungem.c:		/* Run TX completion thread */
drivers/net/ethernet/sun/cassini.h: * the source. tx completion register 3 is replicated in [19 - 31]
drivers/net/ethernet/sun/cassini.h:						      RX completion reg updated.
drivers/net/ethernet/sun/cassini.h:#define    INTR_RX_COMP_FULL           0x00000080  /* no more room in completion
drivers/net/ethernet/sun/cassini.h:						      use in completion descr
drivers/net/ethernet/sun/cassini.h:#define    INTR_TX_COMP_3_MASK         0xFFF80000  /* mask for TX completion
drivers/net/ethernet/sun/cassini.h: * reset. poll until TX and RX read back as 0's for completion.
drivers/net/ethernet/sun/cassini.h:#define    TX_CFG_COMPWB_Q1            0x02000000  /* completion writeback happens at
drivers/net/ethernet/sun/cassini.h:#define    TX_CFG_COMPWB_Q2            0x04000000  /* completion writeback happens at
drivers/net/ethernet/sun/cassini.h:#define    TX_CFG_COMPWB_Q3            0x08000000  /* completion writeback happens at
drivers/net/ethernet/sun/cassini.h:#define    TX_CFG_COMPWB_Q4            0x10000000  /* completion writeback happens at
drivers/net/ethernet/sun/cassini.h:#define    TX_CFG_INTR_COMPWB_DIS      0x20000000  /* disable pre-interrupt completion
drivers/net/ethernet/sun/cassini.h:#define    TX_SM_2_COMP_WB_MASK        0x07    /* completion writeback sm */
drivers/net/ethernet/sun/cassini.h:#define  REG_TX_COMP0                  0x2048  /* TX completion reg #1 */
drivers/net/ethernet/sun/cassini.h:/* values of TX_COMPLETE_1-4 are written. each completion register
drivers/net/ethernet/sun/cassini.h: * NOTE: completion reg values are only written back prior to TX_INTME and
drivers/net/ethernet/sun/cassini.h: * offset from base addr      completion # byte
drivers/net/ethernet/sun/cassini.h:#define  REG_TX_COMPWB_DB_LOW       0x2058  /* TX completion write back
drivers/net/ethernet/sun/cassini.h:#define  REG_TX_COMPWB_DB_HI        0x205C  /* TX completion write back
drivers/net/ethernet/sun/cassini.h: * dynamically with new weights set upon completion of the current
drivers/net/ethernet/sun/cassini.h:						 clears on completion. */
drivers/net/ethernet/sun/cassini.h: * completion ring size = (1 << n)*128 -> [128 - 32k], n < 9
drivers/net/ethernet/sun/cassini.h:/* 8KB aligned 64-bit pointer to the base of the RX free/completion rings.
drivers/net/ethernet/sun/cassini.h:#define  REG_RX_CB_LOW                     0x4030  /* RX completion ring
drivers/net/ethernet/sun/cassini.h:#define  REG_RX_CB_HI                      0x4034  /* RX completion ring
drivers/net/ethernet/sun/cassini.h:#define  REG_RX_COMP                       0x4038  /* (ro) RX completion */
drivers/net/ethernet/sun/cassini.h: * completion tail register.
drivers/net/ethernet/sun/cassini.h:#define  REG_RX_COMP_HEAD                  0x403C  /* RX completion head */
drivers/net/ethernet/sun/cassini.h:#define  REG_RX_COMP_TAIL                  0x4040  /* RX completion tail */
drivers/net/ethernet/sun/cassini.h:							 this many sets of completion
drivers/net/ethernet/sun/cassini.h: * many free desc and completion entries are available for hw use.
drivers/net/ethernet/sun/cassini.h:							 completion entries
drivers/net/ethernet/sun/cassini.h:							 on completion. */
drivers/net/ethernet/sun/cassini.h:							 completion writebacks
drivers/net/ethernet/sun/cassini.h:							 completion wb. */
drivers/net/ethernet/sun/cassini.h:#define  REG_PLUS_RX_CB1_LOW            0x4208  /* RX completion ring
drivers/net/ethernet/sun/cassini.h:#define  REG_PLUS_RX_CB1_HI             0x420C  /* RX completion ring
drivers/net/ethernet/sun/cassini.h:#define  REG_PLUS_RX_COMP1             0x4224  /* (ro) RX completion 2
drivers/net/ethernet/sun/cassini.h:#define  REG_PLUS_RX_COMP1_HEAD        0x4228  /* (ro) RX completion 2
drivers/net/ethernet/sun/cassini.h:#define  REG_PLUS_RX_COMP1_TAIL        0x422C  /* RX completion 2
drivers/net/ethernet/sun/cassini.h: * to start BIST. controller clears _START on completion. _START can also
drivers/net/ethernet/sun/cassini.h:						      on completion of an
drivers/net/ethernet/sun/cassini.h: * execution completion. during a read operation, this register will also
drivers/net/ethernet/sun/cassini.h: * completion.
drivers/net/ethernet/sun/cassini.h:							 completion, 1 means
drivers/net/ethernet/sun/cassini.h:							 completion, field is
drivers/net/ethernet/sun/cassini.h: * the completion ring.
drivers/net/ethernet/sun/cassini.h:/* received packets are put on the completion ring. */
drivers/net/ethernet/sun/sungem.h: * the host must poll this register for completion.  Also, after
drivers/net/ethernet/sun/sungem.h: * completion this register holds the data returned by the transceiver
drivers/net/ethernet/sun/cassini.c: *  page-based RX descriptor engine with separate completion rings
drivers/net/ethernet/sun/cassini.c: * RX DATA: the rx completion ring has all the info, but the rx desc
drivers/net/ethernet/sun/cassini.c:#define USE_TX_COMPWB      /* use completion writeback registers */
drivers/net/ethernet/sun/cassini.c:	/* disable completion interrupts and selectively mask */
drivers/net/ethernet/sun/cassini.c:	/* poll for completion */
drivers/net/ethernet/sun/cassini.c:	/* poll for completion */
drivers/net/ethernet/sun/cassini.c:	/* rx completion registers */
drivers/net/ethernet/sun/cassini.c:	 * free desc and completion entries. these are used to trigger
drivers/net/ethernet/sun/cassini.c:		/* use the completion writeback registers */
drivers/net/ethernet/sun/cassini.c:/* process a completion ring. packets are set up in three basic ways:
drivers/net/ethernet/sun/cassini.c: *       the capability of using multiple RX completion rings, it isn't
drivers/net/ethernet/sun/cassini.c:/* put completion entries back on the ring */
drivers/net/ethernet/sun/cassini.c:/* cassini can use all four PCI interrupts for the completion ring.
drivers/net/ethernet/sun/cassini.c:	/* final rx completion */
drivers/net/ethernet/sun/cassini.c:	/* set up tx completion writeback registers. must be 8-byte aligned */
drivers/net/ethernet/sun/cassini.c:	/* enable completion writebacks, enable paced mode,
drivers/net/ethernet/sun/cassini.c:	/* disable RX MAC and wait for completion */
drivers/net/ethernet/sun/cassini.c:	/* disable hash filter and wait for completion */
drivers/net/ethernet/emulex/benet/be_hw.h: * complete. Upon completion, the MAILBOX will contain a valid completion
drivers/net/ethernet/emulex/benet/be_main.c:	 * and set event, completion, vlan bits accordingly
drivers/net/ethernet/emulex/benet/be_main.c:/* Throwaway the data in the Rx completion */
drivers/net/ethernet/emulex/benet/be_main.c:	/* Copy data in the first descriptor of this completion */
drivers/net/ethernet/emulex/benet/be_main.c:	/* More frags present for this completion */
drivers/net/ethernet/emulex/benet/be_main.c:/* Process the RX completion indicated by rxcp when GRO is disabled */
drivers/net/ethernet/emulex/benet/be_main.c:/* Process the RX completion indicated by rxcp when GRO is enabled */
drivers/net/ethernet/emulex/benet/be_main.c:	/* Consume pending rx completions.
drivers/net/ethernet/emulex/benet/be_main.c:	 * Wait for the flush completion (identified by zero num_rcvd)
drivers/net/ethernet/emulex/benet/be_main.c:	/* Use the default EQ for MCC completions */
drivers/net/ethernet/emulex/benet/be_main.c:		 * completions of the last RXQ (default one) are also processed
drivers/net/ethernet/emulex/benet/be_main.c:	/* Wait for all pending tx completions to arrive so that
drivers/net/ethernet/emulex/benet/be_main.c:	 * mcc completions
drivers/net/ethernet/emulex/benet/be_main.c:	init_completion(&adapter->et_cmd_compl);
drivers/net/ethernet/emulex/benet/be.h:	u32 rx_compl_err;	/* completions with err set */
drivers/net/ethernet/emulex/benet/be.h:	struct completion et_cmd_compl;
drivers/net/ethernet/emulex/benet/be_cmds.c:/* Notify MCC requests and wait for completion */
drivers/net/ethernet/emulex/benet/be_cmds.c: * Polls on the mbox doorbell till a command completion (or a timeout) occurs
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_err(&adapter->pdev->dev, "invalid mailbox completion\n");
drivers/net/ethernet/emulex/benet/be_cmds.c:	if (!wait_for_completion_timeout(&adapter->et_cmd_compl,
drivers/net/ethernet/emulex/benet/be_cmds.c:	if (!wait_for_completion_timeout(&adapter->et_cmd_compl,
drivers/net/ethernet/emulex/benet/be_cmds.c:	if (!wait_for_completion_timeout(&adapter->et_cmd_compl,
drivers/net/ethernet/emulex/benet/be_cmds.c:	wait_for_completion(&adapter->et_cmd_compl);
drivers/net/ethernet/adaptec/starfire.c:/* The completion queues are fixed at 1024 entries i.e. 4K or 8KB. */
drivers/net/ethernet/adaptec/starfire.c:minimum-length padding.  It does not use the completion queue
drivers/net/ethernet/adaptec/starfire.c:should fit in a single descriptor.  The driver does not use the completion
drivers/net/ethernet/adaptec/starfire.c:	/* Pointers to completion queues (full pages). */
drivers/net/ethernet/adaptec/starfire.c:	/* Clear the completion rings. */
drivers/net/ethernet/adaptec/starfire.c:				printk(KERN_DEBUG "%s: Tx completion #%d entry %d is %#8.8x.\n",
drivers/net/ethernet/neterion/vxge/vxge-main.c:	 * completion will resume the queue.
drivers/net/ethernet/neterion/vxge/vxge-config.c: * This function poll's for the vpath reset completion and re initializes
drivers/net/ethernet/neterion/vxge/vxge-traffic.c: * completions (the very first completion is passed by HW via
drivers/net/ethernet/neterion/vxge/vxge-traffic.c: * completions (the very first completion is passed by HW via
drivers/net/ethernet/neterion/vxge/vxge-traffic.c:	/* no more completions */
drivers/net/ethernet/neterion/vxge/vxge-traffic.c: * the driver via supplied completion	callback.
drivers/net/ethernet/neterion/vxge/vxge-traffic.c: * the driver via supplied completion callback.
drivers/net/ethernet/neterion/vxge/vxge-traffic.h: * @ini_num_cpl_rcvd: The number of PCI read completions received by the
drivers/net/ethernet/neterion/vxge/vxge-traffic.h: * @ini_num_cpl_byte_rcvd: The number of PCI read completion bytes received by
drivers/net/ethernet/neterion/vxge/vxge-traffic.h: * @pci.depl_cplh[vplane0] 	0x01e2 	2 	Number of times completion
drivers/net/ethernet/neterion/vxge/vxge-traffic.h: * @pci.depl_cpld[vplane0] 	0x026a 	2 	Number of times completion data
drivers/net/ethernet/neterion/vxge/vxge-traffic.h: * @total_compl_cnt: Total descriptor completion count.
drivers/net/ethernet/neterion/vxge/vxge-traffic.h: *                        without new completions.
drivers/net/ethernet/neterion/vxge/vxge-traffic.h: *                     of completions per interrupt.
drivers/net/ethernet/neterion/vxge/vxge-config.h: * @callback: Channel completion callback. HW invokes the callback when there
drivers/net/ethernet/neterion/vxge/vxge-config.h: *            are new completions on that channel. In many implementations
drivers/net/ethernet/neterion/vxge/vxge-config.h: * @callback: Fifo completion callback. HW invokes the callback when there
drivers/net/ethernet/neterion/vxge/vxge-config.h: *             are new completions on that fifo. In many implementations
drivers/net/ethernet/neterion/vxge/vxge-config.h: *	       completion of a UDP or TCP LSO operation and indicates the number
drivers/net/ethernet/neterion/vxge/vxge-config.h: * @callback: Ring completion callback. HW invokes the callback when there
drivers/net/ethernet/neterion/vxge/vxge-config.h: *            are new completions on that ring. In many implementations
drivers/net/ethernet/neterion/vxge/vxge-config.h: *              and retrieve on completion, information specific
drivers/net/ethernet/neterion/vxge/vxge-config.h: * Fifo completion callback (type declaration). A single per-fifo
drivers/net/ethernet/neterion/vxge/vxge-config.h: * one new completion on a given fifo. Upon processing the first @txdlh driver
drivers/net/ethernet/neterion/vxge/vxge-config.h: * is _supposed_ to continue consuming completions using:
drivers/net/ethernet/neterion/vxge/vxge-config.h: * Note that failure to process new completions in a timely fashion
drivers/net/ethernet/neterion/vxge/vxge-config.h: * @callback: Fifo completion callback. HW invokes the callback when there
drivers/net/ethernet/neterion/vxge/vxge-config.h: *            are new completions on that fifo. In many implementations
drivers/net/ethernet/neterion/vxge/vxge-config.h: *              store, and retrieve on completion, information specific
drivers/net/ethernet/via/via-rhine.c:	 * seen the transmit request, especially as the transmit completion
drivers/net/ethernet/via/via-rhine.c:	/* Pity we can't rely on the nearby BQL completion implicit barrier. */
drivers/net/ethernet/brocade/bna/bnad.h:	struct completion	comp;
drivers/net/ethernet/brocade/bna/bnad.h:struct bnad_completion {
drivers/net/ethernet/brocade/bna/bnad.h:	struct completion	ioc_comp;
drivers/net/ethernet/brocade/bna/bnad.h:	struct completion	ucast_comp;
drivers/net/ethernet/brocade/bna/bnad.h:	struct completion	mcast_comp;
drivers/net/ethernet/brocade/bna/bnad.h:	struct completion	tx_comp;
drivers/net/ethernet/brocade/bna/bnad.h:	struct completion	rx_comp;
drivers/net/ethernet/brocade/bna/bnad.h:	struct completion	stats_comp;
drivers/net/ethernet/brocade/bna/bnad.h:	struct completion	enet_comp;
drivers/net/ethernet/brocade/bna/bnad.h:	struct completion	mtu_comp;
drivers/net/ethernet/brocade/bna/bnad.h:	struct bnad_completion bnad_completions;
drivers/net/ethernet/brocade/bna/bnad.h:void bnad_cb_completion(void *arg, enum bfa_status status);
drivers/net/ethernet/brocade/bna/bnad_debugfs.c:	init_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad_debugfs.c:				bnad_cb_completion, &fcomp);
drivers/net/ethernet/brocade/bna/bnad_debugfs.c:	wait_for_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad_debugfs.c:	reinit_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad_debugfs.c:				bnad_cb_completion, &fcomp);
drivers/net/ethernet/brocade/bna/bnad_debugfs.c:	wait_for_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad.c: * Reinitialize completions in CQ, once Rx is taken down
drivers/net/ethernet/brocade/bna/bnad.c: * bnad_txcmpl_process : Frees the Tx bufs on Tx completion
drivers/net/ethernet/brocade/bna/bnad.c:		 * the other fields of completion entry. Hence, do not load
drivers/net/ethernet/brocade/bna/bnad.c:		 * other fields of completion entry *before* the 'valid' is
drivers/net/ethernet/brocade/bna/bnad.c:		 * in reading stale values in completion entry.
drivers/net/ethernet/brocade/bna/bnad.c:		/* Check all the completions for this frame.
drivers/net/ethernet/brocade/bna/bnad.c:				 * after writing the other fields of completion
drivers/net/ethernet/brocade/bna/bnad.c:				 * completion entry *before* the 'valid' is
drivers/net/ethernet/brocade/bna/bnad.c:				 * stale values in completion entry.
drivers/net/ethernet/brocade/bna/bnad.c:	bnad->bnad_completions.ioc_comp_status = BNA_CB_SUCCESS;
drivers/net/ethernet/brocade/bna/bnad.c:	complete(&bnad->bnad_completions.ioc_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	bnad->bnad_completions.ioc_comp_status = BNA_CB_FAIL;
drivers/net/ethernet/brocade/bna/bnad.c:	complete(&bnad->bnad_completions.ioc_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	bnad->bnad_completions.ioc_comp_status = BNA_CB_SUCCESS;
drivers/net/ethernet/brocade/bna/bnad.c:	complete(&bnad->bnad_completions.ioc_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	complete(&bnad->bnad_completions.enet_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	complete(&bnad->bnad_completions.tx_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	complete(&bnad->bnad_completions.rx_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	bnad->bnad_completions.mcast_comp_status = BNA_CB_SUCCESS;
drivers/net/ethernet/brocade/bna/bnad.c:	complete(&bnad->bnad_completions.mcast_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	bnad->bnad_completions.mtu_comp_status = BNA_CB_SUCCESS;
drivers/net/ethernet/brocade/bna/bnad.c:	complete(&bnad->bnad_completions.mtu_comp);
drivers/net/ethernet/brocade/bna/bnad.c:bnad_cb_completion(void *arg, enum bfa_status status)
drivers/net/ethernet/brocade/bna/bnad.c:	init_completion(&bnad->bnad_completions.tx_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	wait_for_completion(&bnad->bnad_completions.tx_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	init_completion(&bnad->bnad_completions.rx_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	wait_for_completion(&bnad->bnad_completions.rx_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	init_completion(&bnad->bnad_completions.mcast_comp);
drivers/net/ethernet/brocade/bna/bnad.c:		wait_for_completion(&bnad->bnad_completions.mcast_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	if (bnad->bnad_completions.mcast_comp_status != BNA_CB_SUCCESS)
drivers/net/ethernet/brocade/bna/bnad.c:	init_completion(&bnad->bnad_completions.ioc_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	wait_for_completion_timeout(&bnad->bnad_completions.ioc_comp,
drivers/net/ethernet/brocade/bna/bnad.c:	err = bnad->bnad_completions.ioc_comp_status;
drivers/net/ethernet/brocade/bna/bnad.c:	init_completion(&bnad->bnad_completions.ioc_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	bnad->bnad_completions.ioc_comp_status = BNA_CB_WAITING;
drivers/net/ethernet/brocade/bna/bnad.c:	wait_for_completion_timeout(&bnad->bnad_completions.ioc_comp,
drivers/net/ethernet/brocade/bna/bnad.c:	err = bnad->bnad_completions.ioc_comp_status;
drivers/net/ethernet/brocade/bna/bnad.c:	init_completion(&bnad->bnad_completions.enet_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	wait_for_completion(&bnad->bnad_completions.enet_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	init_completion(&bnad->bnad_completions.mtu_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	wait_for_completion(&bnad->bnad_completions.mtu_comp);
drivers/net/ethernet/brocade/bna/bnad.c:	return bnad->bnad_completions.mtu_comp_status;
drivers/net/ethernet/brocade/bna/bnad.c:		 * to explicitly process completions here
drivers/net/ethernet/brocade/bna/bfa_ioc.c:/* IOC disable completion entry. */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:/* Notify enable completion callback */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:/* IOC disable completion entry. */
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 * just wait for an initialization completion interrupt.
drivers/net/ethernet/brocade/bna/bfa_ioc.c:	 * Provide enable completion callback and AEN notification.
drivers/net/ethernet/brocade/bna/bfi_enet.h:	BFI_ENET_CMD_WAITING	= 6,	/* !< Waiting for completion */
drivers/net/ethernet/brocade/bna/bfi_enet.h: * On the completion queue.  RxQ ID = even is for large/data buffer queues
drivers/net/ethernet/brocade/bna/bna_hw_defs.h: * Bit 31 is set in every end of frame completion
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:	init_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:				bnad_cb_completion, &fcomp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:	wait_for_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:	init_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:				bnad_cb_completion, &fcomp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:	wait_for_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:	init_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:				bnad_cb_completion, &fcomp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:	wait_for_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:	init_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:				bnad_cb_completion, &fcomp);
drivers/net/ethernet/brocade/bna/bnad_ethtool.c:	wait_for_completion(&fcomp.comp);
drivers/net/ethernet/brocade/bna/bfi.h:	BFI_MC_IOIM_IOCOM	= 17,	/*!< good IO completion		    */
drivers/net/ethernet/toshiba/tc35815.c:	/* When the TX completion hw interrupt arrives, this
drivers/net/ethernet/toshiba/spider_net.c:	 * interrupt, as we poll for the completion of the read operation
drivers/net/ethernet/toshiba/spider_net.c:		/* we don't use semaphores, as we poll for the completion
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	init_completion(&wl->cmd_done_intr);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	wait_for_completion(&wl->cmd_done_intr);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	init_completion(&cmd->done);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	/* wait for command completion */
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	wait_for_completion(&cmd->done);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	init_completion(&wl->scan_done);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	init_completion(&wl->assoc_done);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	rc = wait_for_completion_timeout(&wl->assoc_done, HZ * 4);/*FIXME*/
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	 * Wait for bss scan completion
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	wait_for_completion(&wl->scan_done);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	init_completion(&wl->cmd_done_intr);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	init_completion(&wl->scan_done);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:		wait_for_completion_timeout(&wl->scan_done, HZ);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.h:	struct completion scan_done;
drivers/net/ethernet/toshiba/ps3_gelic_wireless.h:	struct completion cmd_done_intr;
drivers/net/ethernet/toshiba/ps3_gelic_wireless.h:	struct completion assoc_done;
drivers/net/ethernet/toshiba/ps3_gelic_wireless.h:	struct completion done;
drivers/net/ethernet/sgi/meth.h:   dma completion. */
drivers/net/ethernet/freescale/fman/fman.c:		/* Wait for reset completion */
drivers/net/ethernet/freescale/fman/fman.c:		/* Wait for reset completion */
drivers/net/ethernet/freescale/fman/fman_mac.h:	/* 10GEC MDIO command completion interrupt */
drivers/net/ethernet/freescale/fman/fman_mac.h:	/* dTSEC MII management read completion */
drivers/net/ethernet/freescale/fman/fman_mac.h:	/* dTSEC MII management write completion */
drivers/net/ethernet/freescale/fec_main.c:	reinit_completion(&fep->mdio_done);
drivers/net/ethernet/freescale/fec_main.c:	time_left = wait_for_completion_timeout(&fep->mdio_done,
drivers/net/ethernet/freescale/fec_main.c:	reinit_completion(&fep->mdio_done);
drivers/net/ethernet/freescale/fec_main.c:	time_left = wait_for_completion_timeout(&fep->mdio_done,
drivers/net/ethernet/freescale/fec_main.c:	init_completion(&fep->mdio_done);
drivers/net/ethernet/freescale/gianfar.c:	/* Store incomplete frames for completion */
drivers/net/ethernet/freescale/gianfar.c:	/* run Tx cleanup to completion */
drivers/net/ethernet/freescale/gianfar.c:		/* run Tx cleanup to completion */
drivers/net/ethernet/freescale/gianfar.c:	/* Check for transmit completion */
drivers/net/ethernet/freescale/ucc_geth.c:	/* Stop NAPI, and possibly wait for its completion. */
drivers/net/ethernet/freescale/fec.h:	struct	completion mdio_done;
drivers/net/ethernet/apm/xgene/xgene_enet_main.c:static int xgene_enet_tx_completion(struct xgene_enet_desc_ring *cp_ring,
drivers/net/ethernet/apm/xgene/xgene_enet_main.c:		netdev_err(cp_ring->ndev, "completion skb is NULL\n");
drivers/net/ethernet/apm/xgene/xgene_enet_main.c:	bool is_completion;
drivers/net/ethernet/apm/xgene/xgene_enet_main.c:		is_completion = false;
drivers/net/ethernet/apm/xgene/xgene_enet_main.c:			ret = xgene_enet_tx_completion(ring, raw_desc);
drivers/net/ethernet/apm/xgene/xgene_enet_main.c:			is_completion = true;
drivers/net/ethernet/apm/xgene/xgene_enet_main.c:		if (is_completion)
drivers/net/ethernet/apm/xgene/xgene_enet_main.c:			/* allocate tx completion descriptor ring */
drivers/net/ethernet/cavium/thunder/nicvf_queues.c:/* Initialize completion queue */
drivers/net/ethernet/cavium/thunder/nicvf_queues.c:	/* Disable completion queue */
drivers/net/ethernet/cavium/thunder/nicvf_queues.c:	/* Reset completion queue */
drivers/net/ethernet/cavium/thunder/nicvf_queues.c:/* Configures completion queue */
drivers/net/ethernet/cavium/thunder/nicvf_queues.c:	/* Reset completion queue */
drivers/net/ethernet/cavium/thunder/nicvf_queues.c:	/* Set completion queue base address */
drivers/net/ethernet/cavium/thunder/nicvf_queues.c:	/* Free completion queue */
drivers/net/ethernet/cavium/thunder/nicvf_queues.c:	/* Alloc completion queue */
drivers/net/ethernet/cavium/thunder/nicvf_queues.c:	/* Dummy descriptors to get TSO pkt completion notification */
drivers/net/ethernet/cavium/thunder/nicvf_ethtool.c:	/* All completion queue's registers */
drivers/net/ethernet/cavium/thunder/nicvf_main.c:	/* Enable completion queue interrupt */
drivers/net/ethernet/cavium/liquidio/response_manager.c:static void oct_poll_req_completion(struct work_struct *work);
drivers/net/ethernet/cavium/liquidio/response_manager.c:	INIT_DELAYED_WORK(&cwq->wk.work, oct_poll_req_completion);
drivers/net/ethernet/cavium/liquidio/response_manager.c:static void oct_poll_req_completion(struct work_struct *work)
drivers/net/ethernet/cavium/liquidio/request_manager.c:		octeon_update_tx_completion_counters(buf, reqtype, &pkts_compl,
drivers/net/ethernet/cavium/liquidio/request_manager.c:		octeon_report_tx_completion_to_bql(iq->app_ctx, pkts_compl,
drivers/net/ethernet/cavium/liquidio/request_manager.c:	 * for cases where there are no IQ completion interrupts.
drivers/net/ethernet/cavium/liquidio/lio_ethtool.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_ethtool.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_ethtool.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_ethtool.c:	init_completion(&ctrl->complete);
drivers/net/ethernet/cavium/liquidio/lio_ethtool.c:	wait_for_completion_timeout(&ctrl->complete, msecs_to_jiffies(1000));
drivers/net/ethernet/cavium/liquidio/lio_ethtool.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/octeon_network.h:	struct completion complete;
drivers/net/ethernet/cavium/liquidio/octeon_network.h: * \brief Link control command completion callback
drivers/net/ethernet/cavium/liquidio/octeon_network.h:void liquidio_link_ctrl_cmd_completion(void *nctrl_ptr);
drivers/net/ethernet/cavium/liquidio/octeon_main.h:void octeon_update_tx_completion_counters(void *buf, int reqtype,
drivers/net/ethernet/cavium/liquidio/octeon_main.h:void octeon_report_tx_completion_to_bql(void *txq, unsigned int pkts_compl,
drivers/net/ethernet/cavium/liquidio/lio_main.c:	struct completion init;
drivers/net/ethernet/cavium/liquidio/lio_main.c:	struct completion started;
drivers/net/ethernet/cavium/liquidio/lio_main.c:static struct completion first_stage;
drivers/net/ethernet/cavium/liquidio/lio_main.c:	init_completion(&hs->init);
drivers/net/ethernet/cavium/liquidio/lio_main.c:	init_completion(&hs->started);
drivers/net/ethernet/cavium/liquidio/lio_main.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_main.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_main.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_main.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_main.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_main.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_main.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_main.c:	init_completion(&first_stage);
drivers/net/ethernet/cavium/liquidio/lio_main.c:	wait_for_completion_timeout(&first_stage, msecs_to_jiffies(1000));
drivers/net/ethernet/cavium/liquidio/lio_main.c:			wait_for_completion(&hs->init);
drivers/net/ethernet/cavium/liquidio/lio_main.c:			wait_for_completion_timeout(&hs->started,
drivers/net/ethernet/cavium/liquidio/lio_core.c:	nctrl.cb_fn = liquidio_link_ctrl_cmd_completion;
drivers/net/ethernet/cavium/liquidio/lio_core.c:void octeon_report_tx_completion_to_bql(void *txq, unsigned int pkts_compl,
drivers/net/ethernet/cavium/liquidio/lio_core.c:void octeon_update_tx_completion_counters(void *buf, int reqtype,
drivers/net/ethernet/cavium/liquidio/lio_core.c: * than in bulk. Usage of NO_NAPI in txq completion is
drivers/net/ethernet/cavium/liquidio/lio_core.c:void liquidio_link_ctrl_cmd_completion(void *nctrl_ptr)
drivers/net/ethernet/broadcom/cnic_if.h:struct cnic_ctl_completion {
drivers/net/ethernet/broadcom/cnic_if.h:		struct cnic_ctl_completion comp;
drivers/net/ethernet/broadcom/tg3.h:/* Send data completion control registers */
drivers/net/ethernet/broadcom/tg3.h:/* Send BD completion control registers */
drivers/net/ethernet/broadcom/tg3.h:/* DMA completion registers */
drivers/net/ethernet/broadcom/bnx2.c:		/* partial BD completions possible with TSO packets */
drivers/net/ethernet/broadcom/bnx2.c:	/* Wait for completion. */
drivers/net/ethernet/broadcom/bnx2.c:	/* Wait for completion. */
drivers/net/ethernet/broadcom/bnx2.c:	/* Wait for completion. */
drivers/net/ethernet/broadcom/bnxt/bnxt.h:	/* grp_info indexed by completion ring index */
drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c:	/* 2 completion records per rx packet */
drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c:	/* 2 completion records per rx packet */
drivers/net/ethernet/broadcom/bnxt/bnxt.c: * -EBUSY  - completion ring does not have all the agg buffers yet
drivers/net/ethernet/broadcom/bnxt/bnxt.c:			else if (rc == -EBUSY)	/* partial completion */
drivers/net/ethernet/broadcom/bnxt/bnxt.c:	/* ACK completion ring before freeing tx ring and producing new
drivers/net/ethernet/broadcom/bnxt/bnxt.c:	 * buffers in rx/agg rings to prevent overflowing the completion
drivers/net/ethernet/broadcom/bnxt/bnxt.c:			else if (rc == -EBUSY)	/* partial completion */
drivers/net/ethernet/broadcom/bnxt/bnxt.c:				   "Invalid completion received on special ring\n");
drivers/net/ethernet/broadcom/bnxt/bnxt.c:		netdev_warn(bp->dev, "completion ring size %d reduced to %d.\n",
drivers/net/ethernet/broadcom/bnxt/bnxt.c:		/* Association of transmit ring with completion ring */
drivers/net/ethernet/broadcom/bnxt/bnxt.c:	/* Each rx completion (2 records) should be DMAed immediately.
drivers/net/ethernet/broadcom/bnxt/bnxt.c:	 * DMA 1/4 of the completion buffers at a time.
drivers/net/ethernet/broadcom/tg3.c: * is bogus tx completions. We try to recover by setting the
drivers/net/ethernet/broadcom/tg3.c:	/* run TX completion thread */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c:	 * and set-mac completion
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c:		BNX2X_ERR("EQ completion for unknown VF, cid %d, abs_vfid %d\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:	 * which also implies there won't be any completion to clear the
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:		 * completions and we may dismiss the pending list.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:	/* Ramrod completion is pending */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:	/* Wait for a ramrod completion if was requested */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:		/* Ramrod completion is pending */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:		/* Ramrod completion is pending */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:		/* Wait for a ramrod completion if was requested */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c: * code in case of failure, positive (EBUSY) value if there is a completion
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c: * Checks that the arrived completion is expected.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c: * that will be used in the completion flow to set the `state'
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:	/* Forget all pending for completion commands if a driver only state
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c: * Checks that the arrived completion is expected.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:	 * legal completion.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c: * that will be used in the completion flow to set the `state'
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:	/* Forget all pending for completion commands if a driver only state
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:		 * if not pending for function_stop ramrod completion
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c: *         (EBUSY) value if there is a completion to that is
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:			BNX2X_ERR("timeout waiting for previous ramrod completion\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	/* Wait for completion of requested */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	 * as we don't want a true completion to disrupt us in the middle.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c:	/* issue the command and wait for completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h: * bnx2x_sp_event - handle ramrods completion.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h:		BNX2X_ERR("Filtering completion timed out. sp_state 0x%lx, mask 0x%lx\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h:	/* Commands pending for an completion. */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h:	 *         if there are pending for completion commands,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h:	 * Should be called on a completion arrival.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h:	 *         completion commands. Positive value if there are
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h:	 *         pending for execution or for completion commands.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h:	 * Wait for completion of all commands. Don't schedule new ones,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h:	 * just wait. It assumes that the completion code will schedule
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h: * Return: 0 - if operation was successful and there is no pending completions,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h: *         positive number - if there are pending completions,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h: * Return: 0 is operation was successful and there are no pending completions,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h: *         completions.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #0 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #1 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #2 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #3 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 13] The start address in the internal RAM for the completion
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h: * if there was a completion error since the last time this register was
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h: * completion error since the last time this register was cleared. */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h: * completion did not return yet. 1 - tag is unused. Same functionality as
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h: * that there was a completion with uncorrectable error for the
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h: * indicates that there was a completion with uncorrectable error for the
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h: * indicates that there was a completion with uncorrectable error for the
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h: * indicates that there was a completion with uncorrectable error for the
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h: * indicates that there was a completion with uncorrectable error for the
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:   not finish yet (not all completions have arrived for it) */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [R 5] Number of entries in the ufifo; his fifo has l2p completions */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #0 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #1 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #2 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #3 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 13] The start address in the internal RAM for the completion
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #0 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #1 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #2 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #3 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 13] The start address in the internal RAM for the completion
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #0 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #1 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #2 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 16] The maximum value of the completion counter #3 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [RW 13] The start address in the internal RAM for the completion
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [W 17] Generate an operation after completion; bit-16 is
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* fill in the completion parameters */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:/* issue a dmae command over the init-channel and wait for completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* reset completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* wait for completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* issue the command and wait for completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* issue the command and wait for completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		DP(BNX2X_MSG_SP, "At timeout completion address contained %x\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* Zero completion for next FLR */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		 * an unexpected completion.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* no need to wait for RAMROD completion, so don't
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		DP(BNX2X_MSG_SP, "Got SETUP_MAC completions\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		DP(BNX2X_MSG_SP, "Got SETUP_VLAN completions\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		DP(BNX2X_MSG_SP, "Got SETUP_MCAST completions\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		/* clear pending completion bit */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:			   "got set_timesync ramrod completion\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:			/* Handle EQ completions */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* Wait for completion of requested */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* We want to wait for completion in this context */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* We want to wait for completion in this context */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	 * received completion for the transaction the state is TX_STOPPED.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	 * State will return to STARTED after completion of TX_STOPPED-->STARTED
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	 * a race between the completion code and this code.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c: * This function will wait until the ramrod completion returns.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:/* count denotes the number of new completions we have seen */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* first we tell CNIC and only then we count this as a completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:			BNX2X_ERR("rx_mode completion timed out!\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:			BNX2X_ERR("rx_mode completion timed out!\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:/* EQ completions */
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:/* FCoE L2 connection completions */
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:	 * completions in the default status block.
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h: * @wait_for_comp:	if 'true' block until completion
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:/* E2 and onward - PCI error handling in the completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c:		/* vf doesn't collect HW statistics, and doesn't get completions
drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c:	 * (statistics) ramrod completion.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c:	/* wait for completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c:	/* wait for completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c:	/* Poll for completion */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c:	/* Poll for completion */
drivers/net/ethernet/broadcom/bnx2.h:	u16 status_completion_producer_index;
drivers/net/ethernet/broadcom/bnx2.h:	u16 status_completion_producer_index;
drivers/net/ethernet/broadcom/bnx2.h:	u16 status_completion_producer_index;
drivers/net/ethernet/broadcom/bnx2.h:	u16 status_completion_producer_index;
drivers/net/ethernet/broadcom/cnic_defs.h:/* KCQ (kernel completion queue) response op codes */
drivers/net/ethernet/broadcom/cnic_defs.h:/* KCQ (kernel completion queue) completion status */
drivers/net/ethernet/broadcom/cnic_defs.h:	u32 completion_seq;
drivers/net/ethernet/broadcom/cnic_defs.h:	u32 completion_seq;
drivers/net/ethernet/broadcom/cnic_defs.h:	__le32 completion_status;
drivers/net/ethernet/broadcom/cnic_defs.h: * CQ DB CQ producer and pending completion counter
drivers/net/ethernet/broadcom/cnic_defs.h: * CQ DB pending completion ITT array
drivers/net/ethernet/broadcom/cnic.c:static void cnic_spq_completion(struct cnic_dev *dev, int cmd, u32 count)
drivers/net/ethernet/broadcom/cnic.c:		kcqe.completion_status =
drivers/net/ethernet/broadcom/cnic.c:	kcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;
drivers/net/ethernet/broadcom/cnic.c:	kcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE;
drivers/net/ethernet/broadcom/cnic.c:		kcqe.completion_status =
drivers/net/ethernet/broadcom/cnic.c:	kcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;
drivers/net/ethernet/broadcom/cnic.c:	kcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;
drivers/net/ethernet/broadcom/cnic.c:	kcqe.completion_status = FCOE_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE;
drivers/net/ethernet/broadcom/cnic.c:	kcqe.completion_status = FCOE_KCQE_COMPLETION_STATUS_ERROR;
drivers/net/ethernet/broadcom/cnic.c:			kcqe.completion_status = 0;
drivers/net/ethernet/broadcom/cnic.c:			/* Possibly bnx2x parity error, send completion
drivers/net/ethernet/broadcom/cnic.c:			/* Possibly bnx2x parity error, send completion
drivers/net/ethernet/broadcom/cnic.c:		cnic_spq_completion(dev, DRV_CTL_RET_L5_SPQ_CREDIT_CMD, comp);
drivers/net/ethernet/broadcom/cnic.c:static int cnic_l2_completion(struct cnic_local *cp)
drivers/net/ethernet/broadcom/cnic.c:			comp = cnic_l2_completion(cp);
drivers/net/ethernet/broadcom/cnic.c:		struct cnic_ctl_completion *comp = &info->data.comp;
drivers/net/ethernet/broadcom/cnic.c:		if (l4kcqe->status != 0 || l5kcqe->completion_status != 0) {
drivers/net/ethernet/broadcom/cnic.c:			netdev_warn(dev->netdev, "RAMROD CLOSE compl with status 0x%x completion status 0x%x\n",
drivers/net/ethernet/broadcom/cnic.c:				    l4kcqe->status, l5kcqe->completion_status);
drivers/net/ethernet/broadcom/cnic.c:		while (cp->status_blk.bnx2->status_completion_producer_index &&
drivers/net/ethernet/broadcom/cnic.c:		if (cp->status_blk.bnx2->status_completion_producer_index) {
drivers/net/ethernet/broadcom/cnic.c:		while (sblk->status_completion_producer_index && i < 10) {
drivers/net/ethernet/broadcom/cnic.c:		if (sblk->status_completion_producer_index)
drivers/net/ethernet/broadcom/cnic.c:		&sblk->status_completion_producer_index;
drivers/net/ethernet/broadcom/cnic.c:			&msblk->status_completion_producer_index;
drivers/net/ethernet/broadcom/cnic.c:		cnic_spq_completion(dev, DRV_CTL_RET_L2_SPQ_CREDIT_CMD, 1);
drivers/net/ethernet/broadcom/cnic.c:		cnic_spq_completion(dev, DRV_CTL_RET_L2_SPQ_CREDIT_CMD, 1);
drivers/net/ethernet/broadcom/bcmsysport.c:/* Reclaim queued SKBs for transmission completion, lockless version */
drivers/net/ethernet/broadcom/bcmsysport.c:	/* Ensure write completion of the descriptor status/length
drivers/net/ethernet/broadcom/bcmsysport.c:	/* Poll for RMDA disabling completion */
drivers/net/ethernet/broadcom/bcmsysport.c:	/* Poll for TMDA disabling completion */
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		 "Force firmware to assume aligned completions");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		 * and try to get the completion quickly
drivers/net/ethernet/myricom/myri10ge/myri10ge.c: * around unaligned completion packets (myri10ge_rss_ethp_z8e.dat), and it
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	 * completions) in order to see if it works on this host.
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	 * Run a DMA test which watches for unaligned completions and
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		 * completions */
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:				 "Assuming aligned completions (forced)\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:				 "Assuming unaligned completions (forced)\n");
drivers/net/ethernet/8390/ne2k-pci.c:			{0x00,	EN0_IMR},	/* Mask completion irq. */
drivers/net/ethernet/8390/pcnet_cs.c:	{0x00,	EN0_IMR},	/* Mask completion irq. */
drivers/net/ethernet/8390/zorro8390.c:			{0x00,	NE_EN0_IMR},	/* Mask completion irq */
drivers/net/ethernet/8390/axnet_cs.c:	{0x00,	EN0_IMR},	/* Mask completion irq. */
drivers/net/ethernet/8390/axnet_cs.c: * stack. We also handle transmit completions and wake the transmit path if
drivers/net/ethernet/8390/lib8390.c: * stack. We also handle transmit completions and wake the transmit path if
drivers/net/ethernet/8390/mcf8390.c:			{0x00,	NE_EN0_IMR},	/* Mask completion irq */
drivers/net/ethernet/8390/ne.c:			{0x00,	EN0_IMR},	/* Mask completion irq. */
drivers/net/ethernet/8390/apne.c:	    {0x00,	NE_EN0_IMR},	/* Mask completion irq. */
drivers/net/ethernet/agere/et131x.c:	/* Load the completion writeback physical address */
drivers/net/ethernet/agere/et131x.c:	/* Load the completion writeback physical address */
drivers/net/ethernet/agere/et131x.c: * Checks the hardware for available packets, using completion ring
drivers/net/ethernet/agere/et131x.c:	 * the same "wrap" indicator as the current completion indicator
drivers/net/ethernet/agere/et131x.c:		 * request issued by the JAGCore has occurred or a completion is
drivers/net/ethernet/amazon/ena/ena_com.h:	/* The completion queue head doorbell register */
drivers/net/ethernet/amazon/ena/ena_com.h:	u32 no_completion;
drivers/net/ethernet/amazon/ena/ena_com.h:	/* Indicate if the admin queue should poll for completion */
drivers/net/ethernet/amazon/ena/ena_com.h: * Initialize the admin submission and completion queues.
drivers/net/ethernet/amazon/ena/ena_com.h: * won't send any additional admin completions/aenq.
drivers/net/ethernet/amazon/ena/ena_com.h: * Create the submission and the completion queues.
drivers/net/ethernet/amazon/ena/ena_com.h: * @io_cq - IO completion queue handler.
drivers/net/ethernet/amazon/ena/ena_com.h:/* ena_com_set_admin_polling_mode - Set the admin completion queue polling mode
drivers/net/ethernet/amazon/ena/ena_com.h: * Set the admin completion mode.
drivers/net/ethernet/amazon/ena/ena_com.h:/* ena_com_set_admin_polling_mode - Get the admin completion queue polling mode
drivers/net/ethernet/amazon/ena/ena_com.h: * Get the admin completion mode.
drivers/net/ethernet/amazon/ena/ena_com.h: * polling on the admin completion queue for the commands completion,
drivers/net/ethernet/amazon/ena/ena_com.h: * This method go over the admin completion queue and wake up all the pending
drivers/net/ethernet/amazon/ena/ena_com.h: * The caller should then call ena_com_wait_for_abort_completion to make sure
drivers/net/ethernet/amazon/ena/ena_com.h:/* ena_com_wait_for_abort_completion - Wait for admin commands abort.
drivers/net/ethernet/amazon/ena/ena_com.h:void ena_com_wait_for_abort_completion(struct ena_com_dev *ena_dev);
drivers/net/ethernet/amazon/ena/ena_com.h:/* ena_com_create_io_cq - Create io completion queue.
drivers/net/ethernet/amazon/ena/ena_com.h: * @io_cq - io completion queue handler
drivers/net/ethernet/amazon/ena/ena_com.h: * Create IO completion queue.
drivers/net/ethernet/amazon/ena/ena_com.h:/* ena_com_destroy_io_cq - Destroy io completion queue.
drivers/net/ethernet/amazon/ena/ena_com.h: * @io_cq - io completion queue handler
drivers/net/ethernet/amazon/ena/ena_com.h: * Destroy IO completion queue.
drivers/net/ethernet/amazon/ena/ena_com.h: * @cmd_completion: command completion return value.
drivers/net/ethernet/amazon/ena/ena_com.h: * @cmd_comp_size: command completion size.
drivers/net/ethernet/amazon/ena/ena_com.h: * completion.
drivers/net/ethernet/amazon/ena/ena_com.h: * The completion will be copyed into cmd_comp.
drivers/net/ethernet/amazon/ena/ena_netdev.h:/* The number of tx packet completions that will be handled each NAPI poll
drivers/net/ethernet/amazon/ena/ena_netdev.h:	/* Holds the empty requests for TX out of order completions */
drivers/net/ethernet/amazon/ena/ena_eth_io_defs.h:	 * 28 : comp_req - Indicates whether completion
drivers/net/ethernet/amazon/ena/ena_eth_io_defs.h:	 * 28 : comp_req - Indicates whether completion
drivers/net/ethernet/amazon/ena/ena_ethtool.c:	ENA_STAT_ENA_COM_ENTRY(no_completion),
drivers/net/ethernet/amazon/ena/ena_admin_defs.h:enum ena_admin_aq_completion_status {
drivers/net/ethernet/amazon/ena/ena_admin_defs.h:enum ena_admin_completion_policy_type {
drivers/net/ethernet/amazon/ena/ena_admin_defs.h:	/* completion queue entry for each sq descriptor */
drivers/net/ethernet/amazon/ena/ena_admin_defs.h:	/* completion queue entry upon request in sq descriptor */
drivers/net/ethernet/amazon/ena/ena_admin_defs.h:	 * 6:4 : completion_policy - Describing what policy
drivers/net/ethernet/amazon/ena/ena_admin_defs.h:	 *    to use for generation completion entry (cqe) in
drivers/net/ethernet/amazon/ena/ena_admin_defs.h:	/* associated completion queue id. This CQ must be created prior to
drivers/net/ethernet/amazon/ena/ena_admin_defs.h:	 * completion_policy is set to completion_policy_head_on_demand or
drivers/net/ethernet/amazon/ena/ena_admin_defs.h:	 * completion_policy_head. Has to be cache aligned
drivers/net/ethernet/amazon/ena/ena_admin_defs.h:	/* completion queue depth in # of entries. must be power of 2 */
drivers/net/ethernet/amazon/ena/ena_eth_com.h:		pr_debug("Write completion queue doorbell for queue %d: head: %d\n",
drivers/net/ethernet/amazon/ena/ena_netdev.c:	/* Req id ring for TX out of order completions */
drivers/net/ethernet/amazon/ena/ena_netdev.c:	 * 1 - perform smp barrier before reading next_to_completion
drivers/net/ethernet/amazon/ena/ena_netdev.c:		 * next_to_completion and terminates.
drivers/net/ethernet/amazon/ena/ena_netdev.c:	ena_com_wait_for_abort_completion(ena_dev);
drivers/net/ethernet/amazon/ena/ena_netdev.c:static void check_for_missing_tx_completions(struct ena_adapter *adapter)
drivers/net/ethernet/amazon/ena/ena_netdev.c:						  "The number of lost tx completion is above the threshold (%d > %d). Reset the device\n",
drivers/net/ethernet/amazon/ena/ena_netdev.c:	check_for_missing_tx_completions(adapter);
drivers/net/ethernet/amazon/ena/ena_netdev.c:	ena_com_wait_for_abort_completion(ena_dev);
drivers/net/ethernet/amazon/ena/ena_eth_com.c:	/* When the current completion descriptor phase isn't the same as the
drivers/net/ethernet/amazon/ena/ena_eth_com.c:	 * this completion.
drivers/net/ethernet/amazon/ena/ena_com.c:	struct completion wait_event;
drivers/net/ethernet/amazon/ena/ena_com.c:	reinit_completion(&comp_ctx->wait_event);
drivers/net/ethernet/amazon/ena/ena_com.c:			init_completion(&comp_ctx->wait_event);
drivers/net/ethernet/amazon/ena/ena_com.c:	/* Use the basic completion descriptor for Rx */
drivers/net/ethernet/amazon/ena/ena_com.c:static void ena_com_handle_single_admin_completion(struct ena_com_admin_queue *admin_queue,
drivers/net/ethernet/amazon/ena/ena_com.c:static void ena_com_handle_admin_completion(struct ena_com_admin_queue *admin_queue)
drivers/net/ethernet/amazon/ena/ena_com.c:	/* Go over all the completions */
drivers/net/ethernet/amazon/ena/ena_com.c:		/* Do not read the rest of the completion entry before the
drivers/net/ethernet/amazon/ena/ena_com.c:		ena_com_handle_single_admin_completion(admin_queue, cqe);
drivers/net/ethernet/amazon/ena/ena_com.c:			pr_err("Wait for completion (polling) timeout\n");
drivers/net/ethernet/amazon/ena/ena_com.c:			/* ENA didn't have any completion */
drivers/net/ethernet/amazon/ena/ena_com.c:			admin_queue->stats.no_completion++;
drivers/net/ethernet/amazon/ena/ena_com.c:		ena_com_handle_admin_completion(admin_queue);
drivers/net/ethernet/amazon/ena/ena_com.c:	wait_for_completion_timeout(&comp_ctx->wait_event,
drivers/net/ethernet/amazon/ena/ena_com.c:	 * 1) No completion (timeout reached)
drivers/net/ethernet/amazon/ena/ena_com.c:	 * 2) There is completion but the device didn't get any msi-x interrupt.
drivers/net/ethernet/amazon/ena/ena_com.c:		ena_com_handle_admin_completion(admin_queue);
drivers/net/ethernet/amazon/ena/ena_com.c:		admin_queue->stats.no_completion++;
drivers/net/ethernet/amazon/ena/ena_com.c:			pr_err("The ena device have completion but the driver didn't receive any MSI-X interrupt (cmd %d)\n",
drivers/net/ethernet/amazon/ena/ena_com.c:			pr_err("The ena device doesn't send any completion for the admin cmd %d status %d\n",
drivers/net/ethernet/amazon/ena/ena_com.c:/* There are two types to wait for completion.
drivers/net/ethernet/amazon/ena/ena_com.c: * Polling mode - wait until the completion is available.
drivers/net/ethernet/amazon/ena/ena_com.c: * Async mode - wait on wait queue until the completion is ready
drivers/net/ethernet/amazon/ena/ena_com.c: * It is expected that the IRQ called ena_com_handle_admin_completion
drivers/net/ethernet/amazon/ena/ena_com.c: * to mark the completions.
drivers/net/ethernet/amazon/ena/ena_com.c:	struct ena_admin_acq_create_sq_resp_desc cmd_completion;
drivers/net/ethernet/amazon/ena/ena_com.c:					    (struct ena_admin_acq_entry *)&cmd_completion,
drivers/net/ethernet/amazon/ena/ena_com.c:					    sizeof(cmd_completion));
drivers/net/ethernet/amazon/ena/ena_com.c:	io_sq->idx = cmd_completion.sq_idx;
drivers/net/ethernet/amazon/ena/ena_com.c:		(uintptr_t)cmd_completion.sq_doorbell_offset);
drivers/net/ethernet/amazon/ena/ena_com.c:				+ cmd_completion.llq_headers_offset);
drivers/net/ethernet/amazon/ena/ena_com.c:			cmd_completion.llq_descriptors_offset);
drivers/net/ethernet/amazon/ena/ena_com.c:	struct ena_admin_acq_create_cq_resp_desc cmd_completion;
drivers/net/ethernet/amazon/ena/ena_com.c:					    (struct ena_admin_acq_entry *)&cmd_completion,
drivers/net/ethernet/amazon/ena/ena_com.c:					    sizeof(cmd_completion));
drivers/net/ethernet/amazon/ena/ena_com.c:	io_cq->idx = cmd_completion.cq_idx;
drivers/net/ethernet/amazon/ena/ena_com.c:		cmd_completion.cq_interrupt_unmask_register_offset);
drivers/net/ethernet/amazon/ena/ena_com.c:	if (cmd_completion.cq_head_db_register_offset)
drivers/net/ethernet/amazon/ena/ena_com.c:			cmd_completion.cq_head_db_register_offset);
drivers/net/ethernet/amazon/ena/ena_com.c:	if (cmd_completion.numa_node_register_offset)
drivers/net/ethernet/amazon/ena/ena_com.c:			cmd_completion.numa_node_register_offset);
drivers/net/ethernet/amazon/ena/ena_com.c:void ena_com_wait_for_abort_completion(struct ena_com_dev *ena_dev)
drivers/net/ethernet/amazon/ena/ena_com.c:	ena_com_handle_admin_completion(&ena_dev->admin_queue);
drivers/net/ethernet/cisco/enic/enic_main.c:	 * cycle.  An intr event is the completion of a
drivers/net/ethernet/cisco/enic/enic_main.c:	 * cycle.  An intr event is the completion of a
drivers/net/ethernet/cisco/enic/enic.h:	/* completion queue cache line section */
drivers/net/ethernet/cisco/enic/cq_enet_desc.h:/* Ethernet completion queue descriptor: 16B */
drivers/net/ethernet/cisco/enic/cq_desc.h: * All completion queues have this basic layout.  The
drivers/net/ethernet/cisco/enic/cq_desc.h: * type_specfic area is unique for each completion
drivers/net/ethernet/cisco/enic/vnic_wq.h:	uint8_t cq_entry; /* Gets completion event from hw */
drivers/net/ethernet/sfc/mcdi.c:	/* Poll for completion. Poll quickly (once a us) for the 1st jiffy,
drivers/net/ethernet/sfc/mcdi.c:static int efx_mcdi_await_completion(struct efx_nic *efx)
drivers/net/ethernet/sfc/mcdi.c:	/* Check if efx_mcdi_set_mode() switched us back to polled completions.
drivers/net/ethernet/sfc/mcdi.c:	 * In which case, poll for completions directly. If efx_mcdi_ev_cpl()
drivers/net/ethernet/sfc/mcdi.c: * asynchronous completion function, and release the interface.
drivers/net/ethernet/sfc/mcdi.c:		/* Ensure that if the completion event arrives later,
drivers/net/ethernet/sfc/mcdi.c:		 * completion after we've already transitioned back to
drivers/net/ethernet/sfc/mcdi.c:		rc = efx_mcdi_await_completion(efx);
drivers/net/ethernet/sfc/mcdi.c: * efx_mcdi_rpc - Issue an MCDI command and wait for completion
drivers/net/ethernet/sfc/mcdi.c: * @complete: Function to be called on completion or cancellation.
drivers/net/ethernet/sfc/mcdi.c: * event completions have been disabled due to an error.
drivers/net/ethernet/sfc/mcdi.c: * (a) the completion event is received (in NAPI context)
drivers/net/ethernet/sfc/mcdi.c:/* Switch to polled MCDI completions.  This can be called in various
drivers/net/ethernet/sfc/mcdi.c:	 * If in fail-fast state, don't switch to polled completion.
drivers/net/ethernet/sfc/mcdi.c:	/* We can switch from event completion to polled completion, because
drivers/net/ethernet/sfc/mcdi.c:	 * efx_mcdi_await_completion() will then call efx_mcdi_poll().
drivers/net/ethernet/sfc/mcdi.c:	 * We need an smp_wmb() to synchronise with efx_mcdi_await_completion(),
drivers/net/ethernet/sfc/mcdi.c:	/* If already in event completion mode, nothing to do.
drivers/net/ethernet/sfc/mcdi.c:	 * If in fail-fast state, don't switch to event completion.  FLR
drivers/net/ethernet/sfc/mcdi.c:	/* We can't switch from polled to event completion in the middle of a
drivers/net/ethernet/sfc/mcdi.c:	 * request, because the completion method is specified in the request.
drivers/net/ethernet/sfc/mcdi.c:		 * queue as completions, and one to event queue 0.
drivers/net/ethernet/sfc/mcdi.c:		 * because we want to wait for all completions.
drivers/net/ethernet/sfc/mcdi.c:		/* Re-enable polled MCDI completion */
drivers/net/ethernet/sfc/net_driver.h: * Since the TX completion path always executes on the same
drivers/net/ethernet/sfc/net_driver.h: * performance is increased by ensuring that the completion
drivers/net/ethernet/sfc/net_driver.h: * executing on one CPU which is different from the completion
drivers/net/ethernet/sfc/net_driver.h: *	completion path.
drivers/net/ethernet/sfc/net_driver.h: * @merge_events: Number of TX merged completion events
drivers/net/ethernet/sfc/net_driver.h: *	completion path.
drivers/net/ethernet/sfc/net_driver.h: * @empty_read_count: If the completion path has seen the queue as empty
drivers/net/ethernet/sfc/net_driver.h:	/* Members used mainly on the completion path */
drivers/net/ethernet/sfc/net_driver.h: * @n_rx_merge_events: Number of RX merged completion events
drivers/net/ethernet/sfc/net_driver.h: * @flush_wq: wait queue used by efx_nic_flush_queues() to wait for flush completions.
drivers/net/ethernet/sfc/farch_regs.h:/* Sub-fields of an RX flush completion event */
drivers/net/ethernet/sfc/ethtool.c: * completion (or other event).  Unless the module parameter
drivers/net/ethernet/sfc/ethtool.c: * shared between RX and TX completions.  In this case, when RX IRQ
drivers/net/ethernet/sfc/ethtool.c: * The hardware does not support a limit on the number of completions
drivers/net/ethernet/sfc/falcon.c:/* Wait for SPI command completion */
drivers/net/ethernet/sfc/falcon.c:/* Wait up to 10 ms for buffered write completion */
drivers/net/ethernet/sfc/falcon.c:	/* Wait up to 10 ms for completion, then reinitialise */
drivers/net/ethernet/sfc/mcdi.h: * @MCDI_MODE_POLL: poll for MCDI completion, until timeout
drivers/net/ethernet/sfc/mcdi.h: * @mode: Poll for mcdi completion, or wait for an mcdi_event.
drivers/net/ethernet/sfc/mcdi.h: * @credits: Number of spurious MCDI completion events allowed before we
drivers/net/ethernet/sfc/vfdi.h: * @u.init_txq.evq: Instance of event queue to target transmit completion
drivers/net/ethernet/sfc/vfdi.h: * @u.init_txq.label: Label used in transmit completion events.
drivers/net/ethernet/sfc/ef10.c:		/* Check that RX completion merging is valid, i.e.
drivers/net/ethernet/sfc/ef10.c:		/* Merged completion for multiple non-scattered packets */
drivers/net/ethernet/sfc/ef10.c:	/* Transmit completion */
drivers/net/ethernet/sfc/ef10.c:	 * data through to the completion function.
drivers/net/ethernet/sfc/ef10.c:	/* Pack up the variables needed on completion */
drivers/net/ethernet/sfc/efx.c:	 * plus some extra for link state events and MCDI completions. */
drivers/net/ethernet/sfc/efx.c:	 * reset is scheduled. So switch back to poll'd MCDI completions. */
drivers/net/ethernet/sfc/siena_sriov.c: *	to wait for flush completions.
drivers/net/ethernet/sfc/siena_sriov.c:	/* Ignore flush completions triggered by an FLR */
drivers/net/ethernet/sfc/farch.c:				 * receive a flush completion event
drivers/net/ethernet/sfc/farch.c:		 * completion). If that fails, fall back to the old scheme.
drivers/net/ethernet/sfc/farch.c: * completion events.  This means that efx->rxq_flush_outstanding remained at 4
drivers/net/ethernet/sfc/farch.c: * after the FLR; also, efx->active_queues was non-zero (as no flush completion
drivers/net/ethernet/sfc/farch.c:/* Handle a transmit completion event
drivers/net/ethernet/sfc/farch.c: * The NIC batches TX completion events; the message we receive is of
drivers/net/ethernet/sfc/farch.c:		/* Transmit completion */
drivers/net/ethernet/sfc/farch.c: * of all transmit completions.
drivers/net/ethernet/sfc/tx.c:	 * queue, it is possible for the completion path to race with
drivers/net/ethernet/sfc/tx.c:	 * after which there will be no more completions to wake it.
drivers/net/ethernet/sfc/tx.c:				  "TX queue %d spurious TX completion id %x\n",
drivers/net/ethernet/sfc/tx.c: * completion events will be directed back to the CPU that transmitted
drivers/net/ethernet/sfc/mcdi_pcol.h: * All MCDI commands support completion by shared memory response. Each
drivers/net/ethernet/sfc/mcdi_pcol.h: * Some MCDI commands support completion by event, in which any associated
drivers/net/ethernet/sfc/mcdi_pcol.h: * OUT.GLOBAL_FLAGS is guaranteed to exist in the completion payload. The other
drivers/net/ethernet/sfc/mcdi_pcol.h: * sensor notifications and MCDI completions
drivers/net/ethernet/sfc/mcdi_pcol.h: * Poll for BIST completion. Returns a single status code, and optionally some
drivers/net/ethernet/sfc/mcdi_pcol.h:/* Type of TX event, ordinary TX completion, low or high part of TX timestamp
drivers/net/ethernet/sfc/mcdi_pcol.h:/* enum: This is a TX completion event, not a timestamp */
drivers/net/ethernet/sfc/selftest.c:		 * transmit completion counting */
drivers/net/ethernet/sfc/selftest.c:	/* Count the number of tx completions, and decrement the refcnt. Any
drivers/net/ethernet/sfc/selftest.c:	/* Check TX completion and received packet counts */
drivers/net/ethernet/sfc/selftest.c:			  "TX completion events in %s loopback test\n",
drivers/net/ethernet/mellanox/mlxsw/pci.c:		dev_err(&pdev->dev, "Failed to initialize completion queues\n");
drivers/net/ethernet/mellanox/mlxsw/pci.c:	mlxsw_pci_wqe_c_set(wqe, 1); /* always report completion */
drivers/net/ethernet/mellanox/mlxsw/cmd.h: * following an unsuccessful completion of the command. It is required
drivers/net/ethernet/mellanox/mlxsw/cmd.h: * Number of the CQ that this Descriptor Queue reports completions to.
drivers/net/ethernet/mellanox/mlxsw/cmd.h: * a completion with error (flushed) for all descriptors posted in the RDQ/SDQ.
drivers/net/ethernet/mellanox/mlxsw/cmd.h: * Event Queue this CQ reports completion events to.
drivers/net/ethernet/mellanox/mlxsw/cmd.h: * CQ consumer counter (poll for completion) or Request completion
drivers/net/ethernet/mellanox/mlxsw/core.c:#include <linux/completion.h>
drivers/net/ethernet/mellanox/mlxsw/core.c:	struct completion completion;
drivers/net/ethernet/mellanox/mlxsw/core.c:	complete(&trans->completion);
drivers/net/ethernet/mellanox/mlxsw/core.c:	init_completion(&trans->completion);
drivers/net/ethernet/mellanox/mlxsw/core.c:	wait_for_completion(&trans->completion);
drivers/net/ethernet/mellanox/mlxsw/pci.h: * If set it indicates that a completion should be reported upon
drivers/net/ethernet/mellanox/mlxsw/pci.h: * Command completion event - token
drivers/net/ethernet/mellanox/mlxsw/pci.h: * Command completion event - status
drivers/net/ethernet/mellanox/mlxsw/pci.h: * Command completion event - output parameter - higher part
drivers/net/ethernet/mellanox/mlxsw/pci.h: * Command completion event - output parameter - lower part
drivers/net/ethernet/mellanox/mlx5/core/srq.c:	init_completion(&srq->free);
drivers/net/ethernet/mellanox/mlx5/core/srq.c:	wait_for_completion(&srq->free);
drivers/net/ethernet/mellanox/mlx5/core/en_main.c:	mcq->comp       = mlx5e_completion_event;
drivers/net/ethernet/mellanox/mlx5/core/en_main.c:	mcq->comp       = mlx5e_completion_event;
drivers/net/ethernet/mellanox/mlx5/core/cq.c:	 * while migrating a CQ, completions on the old EQs could
drivers/net/ethernet/mellanox/mlx5/core/cq.c:void mlx5_cq_completion(struct mlx5_core_dev *dev, u32 cqn)
drivers/net/ethernet/mellanox/mlx5/core/cq.c:	init_completion(&cq->free);
drivers/net/ethernet/mellanox/mlx5/core/cq.c:	wait_for_completion(&cq->free);
drivers/net/ethernet/mellanox/mlx5/core/en.h:	/* dirtied @completion */
drivers/net/ethernet/mellanox/mlx5/core/en.h:	/* pointers to per tx element info: write@xmit, read@completion */
drivers/net/ethernet/mellanox/mlx5/core/en.h:void mlx5e_completion_event(struct mlx5_core_cq *mcq);
drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c:	/* avoid losing completion event during/after polling cqs */
drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c:void mlx5e_completion_event(struct mlx5_core_cq *mcq)
drivers/net/ethernet/mellanox/mlx5/core/health.c:static void trigger_cmd_completions(struct mlx5_core_dev *dev)
drivers/net/ethernet/mellanox/mlx5/core/health.c:		trigger_cmd_completions(dev);
drivers/net/ethernet/mellanox/mlx5/core/eq.c:			mlx5_cq_completion(dev, cqn);
drivers/net/ethernet/mellanox/mlx5/core/qp.c:	init_completion(&qp->common.free);
drivers/net/ethernet/mellanox/mlx5/core/qp.c:	wait_for_completion(&qp->common.free);
drivers/net/ethernet/mellanox/mlx5/core/main.c:		mlx5_core_dbg(dev, "allocated completion EQN %d\n", eq->eqn);
drivers/net/ethernet/mellanox/mlx5/core/main.c:		dev_err(&pdev->dev, "Failed to alloc completion EQs\n");
drivers/net/ethernet/mellanox/mlx5/core/cmd.c:		wait_for_completion(&ent->done);
drivers/net/ethernet/mellanox/mlx5/core/cmd.c:	} else if (!wait_for_completion_timeout(&ent->done, timeout)) {
drivers/net/ethernet/mellanox/mlx5/core/cmd.c: *    2. page queue commands do not support asynchrous completion
drivers/net/ethernet/mellanox/mlx5/core/cmd.c:		init_completion(&ent->done);
drivers/net/ethernet/mellanox/mlx4/mlx4.h:	/* lock on completion tasklet list */
drivers/net/ethernet/mellanox/mlx4/mlx4.h:void mlx4_cq_completion(struct mlx4_dev *dev, u32 cqn);
drivers/net/ethernet/mellanox/mlx4/en_selftest.c:	/* A loop over all completion vectors of current port,
drivers/net/ethernet/mellanox/mlx4/en_selftest.c:	 * completions to that vector and performing a NOP command
drivers/net/ethernet/mellanox/mlx4/srq.c:	init_completion(&srq->free);
drivers/net/ethernet/mellanox/mlx4/srq.c:	wait_for_completion(&srq->free);
drivers/net/ethernet/mellanox/mlx4/mlx4_en.h:	/* cache line used and dirtied in tx completion
drivers/net/ethernet/mellanox/mlx4/cq.c:	 * while migrating a CQ, completions on the old EQs could
drivers/net/ethernet/mellanox/mlx4/cq.c:void mlx4_cq_completion(struct mlx4_dev *dev, u32 cqn)
drivers/net/ethernet/mellanox/mlx4/cq.c:	init_completion(&cq->free);
drivers/net/ethernet/mellanox/mlx4/cq.c:	wait_for_completion(&cq->free);
drivers/net/ethernet/mellanox/mlx4/catas.c:	mlx4_cmd_wake_completions(dev);
drivers/net/ethernet/mellanox/mlx4/en_tx.c:		/* tx completion can avoid cache line miss for common cases */
drivers/net/ethernet/mellanox/mlx4/en_tx.c:	/* tx completion can avoid cache line miss for common cases */
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:		/* Arm CQ for TX completions */
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:	/* Process all completions if exist to prevent
drivers/net/ethernet/mellanox/mlx4/eq.c:			mlx4_cq_completion(dev, cqn);
drivers/net/ethernet/mellanox/mlx4/eq.c:	/* Temporary use polling for command completions */
drivers/net/ethernet/mellanox/mlx4/qp.c:	init_completion(&qp->free);
drivers/net/ethernet/mellanox/mlx4/qp.c:	wait_for_completion(&qp->free);
drivers/net/ethernet/mellanox/mlx4/main.c:		mlx4_err(dev, "Failed to initialize completion queue table, aborting\n");
drivers/net/ethernet/mellanox/mlx4/cmd.c:	struct completion	done;
drivers/net/ethernet/mellanox/mlx4/cmd.c:	reinit_completion(&context->done);
drivers/net/ethernet/mellanox/mlx4/cmd.c:	if (!wait_for_completion_timeout(&context->done,
drivers/net/ethernet/mellanox/mlx4/cmd.c:	reinit_completion(&context->done);
drivers/net/ethernet/mellanox/mlx4/cmd.c:			wait_for_completion_interruptible_timeout(&context->done,
drivers/net/ethernet/mellanox/mlx4/cmd.c:		ret_wait = (long)wait_for_completion_timeout(&context->done,
drivers/net/ethernet/mellanox/mlx4/cmd.c:				mlx4_warn(dev, "Failed to generate command completion eqe for slave %d\n",
drivers/net/ethernet/mellanox/mlx4/cmd.c:		 * cmd contexts to allow simulating completions
drivers/net/ethernet/mellanox/mlx4/cmd.c:		init_completion(&priv->cmd.context[i].done);
drivers/net/ethernet/mellanox/mlx4/cmd.c:void mlx4_cmd_wake_completions(struct mlx4_dev *dev)
drivers/net/ethernet/dec/tulip/de4x5.c:    /* Poll for setup frame completion (adapter interrupts are disabled now) */
drivers/net/ethernet/dec/tulip/interrupt.c:         /* The last op happens after poll completion. Which means the following:
drivers/net/ethernet/calxeda/xgmac.c:	/* Ensure tx_head update is visible to tx completion */
drivers/net/ethernet/calxeda/xgmac.c:		/* Ensure netif_stop_queue is visible to tx completion */
drivers/net/ethernet/calxeda/xgmac.c: *   Also it runs the TX completion thread
drivers/net/ethernet/ti/netcp_core.c:	/* open Tx completion queue */
drivers/net/ethernet/ti/netcp_core.c:	/* Set notification for Tx completion */
drivers/net/ethernet/ti/netcp_core.c:	/* open Rx completion queue */
drivers/net/ethernet/ti/netcp_core.c:	/* Set notification for Rx completion */
drivers/net/ethernet/ti/netcp_core.c:	/* Recycle Rx descriptors from completion queue */
drivers/net/ethernet/ti/netcp_core.c:	/* Recycle Tx descriptors from completion queue */
drivers/net/ethernet/ti/netcp_core.c:	ret = of_property_read_u32(node_interface, "tx-completion-queue",
drivers/net/ethernet/ti/netcp_core.c:		dev_warn(dev, "missing \"tx-completion-queue\" parameter\n");
drivers/net/ethernet/cirrus/cs89x0.c:	 * it runs like a dog.  We just return and wait for the Tx completion
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe.h:#define PCH_GBE_INT_MIIM_CMPLT    0x00010000 /* MIIM I/F Read completion */
drivers/net/usb/rndis_host.c: * RNDIS notifications from device: command completion; "reverse"
drivers/net/usb/usbnet.c: * completion callbacks.  2.5 should have fixed those bugs...
drivers/net/usb/usbnet.c:// unlink pending rx/tx; completion handlers do all other cleanup
drivers/net/usb/usbnet.c:		  "waited for %d urb completions\n", temp);
drivers/net/usb/usbnet.c: * NOTE:  with 2.5 we could do more of this using completion callbacks,
drivers/net/usb/usbnet.c:// tasklet (work deferred from completions, in_irq) or timer
drivers/net/usb/kaweth.c:// FIXME this completion stuff is a modified clone of
drivers/net/usb/kaweth.c: * completion handler for compatibility wrappers (sync control/bulk) *
drivers/net/usb/kaweth.c:static void usb_api_blocking_completion(struct urb *urb)
drivers/net/usb/kaweth.c:// Starts urb and waits for completion or timeout
drivers/net/usb/kaweth.c:			 len, usb_api_blocking_completion, NULL);
drivers/net/usb/smsc75xx.c:		netdev_warn(dev->net, "timeout on completion of Lite Reset\n");
drivers/net/usb/lan78xx.c:					    "timeout on OTP_PWR_DN completion");
drivers/net/usb/lan78xx.c:					    "Timeout on OTP_STATUS completion");
drivers/net/usb/lan78xx.c:				    "timeout on completion of LiteReset");
drivers/net/usb/lan78xx.c:			  "waited for %d urb completions\n", temp);
drivers/net/usb/smsc95xx.c:	/* Initiate async writes, as we can't wait for completion here */
drivers/net/usb/smsc95xx.c:		netdev_warn(dev->net, "timeout waiting for completion of Lite Reset\n");
drivers/net/caif/caif_spi.c:#include <linux/completion.h>
drivers/net/caif/caif_spi.c:	init_completion(&cfspi->comp);
drivers/net/caif/caif_virtio.c: * @rx_napi_complete:	Number of NAPI completions (RX)
drivers/net/caif/caif_spi_slave.c:#include <linux/completion.h>
drivers/net/caif/caif_spi_slave.c:		/* Wait for transfer completion. */
drivers/net/caif/caif_spi_slave.c:		wait_for_completion(&cfspi->comp);
drivers/net/fddi/defxx.c: *		architecture is a standard producer, consumer, completion model in
drivers/net/fddi/defxx.c: *   Adapter should be in DMA_UNAVAILABLE state upon completion of this
drivers/net/fddi/defxx.c: *   or updating completion indices.
drivers/net/fddi/defxx.c:	 * Transmit and receive producer and completion indices are updated on the
drivers/net/fddi/defxx.c:	/* Bump (and wrap) the completion index and write out to register */
drivers/net/fddi/defxx.c:	/* Bump (and wrap) the completion index and write out to register */
drivers/net/fddi/defxx.c: *   to various PDQ port registers, then polling for completion.
drivers/net/fddi/defxx.c:		 * Advance the producer (for recycling) and advance the completion
drivers/net/fddi/defxx.c:		 * completion index because they are both advanced at the same
drivers/net/fddi/defxx.c:	 *	 current xmt completion index when we complete this
drivers/net/fddi/defxx.c:	 *	 completion, except to indicate that the queue is empty.
drivers/net/fddi/defxx.c:	 * entire packet, we can simply bump the completion index by
drivers/net/fddi/defxx.c:	u8			comp;			/* local transmit completion index */
drivers/net/fddi/defxx.c:		 * Move to start of next packet by updating completion index
drivers/net/fddi/defxx.c:		 * simplify the completion code by incrementing the
drivers/net/fddi/defxx.c:		 * completion index by one.  This code will need to be
drivers/net/fddi/defxx.c:	u8			comp;			/* local transmit completion index */
drivers/net/fddi/defxx.c:		 * Move to start of next packet by updating completion index
drivers/net/fddi/defxx.c:		 * simplify the completion code by incrementing the
drivers/net/fddi/defxx.c:		 * completion index by one.  This code will need to be
drivers/net/fddi/defxx.h:	/* Store pointers to transmit buffers for transmit completion code */
drivers/soc/qcom/wcnss_ctrl.c: * @ack:	completion for outstanding requests
drivers/soc/qcom/wcnss_ctrl.c: * @cbc:	completion for cbc complete indication
drivers/soc/qcom/wcnss_ctrl.c:	struct completion ack;
drivers/soc/qcom/wcnss_ctrl.c:	struct completion cbc;
drivers/soc/qcom/wcnss_ctrl.c:	ret = wait_for_completion_timeout(&wcnss->ack, WCNSS_CBC_TIMEOUT);
drivers/soc/qcom/wcnss_ctrl.c:	ret = wait_for_completion_timeout(&wcnss->ack, WCNSS_REQUEST_TIMEOUT);
drivers/soc/qcom/wcnss_ctrl.c:	/* Wait for pending cold boot completion if indicated by the nv downloader */
drivers/soc/qcom/wcnss_ctrl.c:		ret = wait_for_completion_timeout(&wcnss->cbc, WCNSS_REQUEST_TIMEOUT);
drivers/soc/qcom/wcnss_ctrl.c:			dev_err(wcnss->dev, "expected cold boot completion\n");
drivers/soc/qcom/wcnss_ctrl.c:	init_completion(&wcnss->ack);
drivers/soc/qcom/wcnss_ctrl.c:	init_completion(&wcnss->cbc);
drivers/soc/qcom/smd-rpm.c: * @ack:		completion for acks
drivers/soc/qcom/smd-rpm.c:	struct completion ack;
drivers/soc/qcom/smd-rpm.c:	left = wait_for_completion_timeout(&rpm->ack, RPM_REQUEST_TIMEOUT);
drivers/soc/qcom/smd-rpm.c:	init_completion(&rpm->ack);
drivers/soc/tegra/fuse/fuse-tegra20.c:#include <linux/completion.h>
drivers/soc/tegra/fuse/fuse-tegra20.c:	reinit_completion(&fuse->apbdma.wait);
drivers/soc/tegra/fuse/fuse-tegra20.c:	time_left = wait_for_completion_timeout(&fuse->apbdma.wait,
drivers/soc/tegra/fuse/fuse-tegra20.c:	init_completion(&fuse->apbdma.wait);
drivers/soc/tegra/fuse/fuse.h:		struct completion wait;
drivers/soc/ti/knav_dma.c:	/* then disconnect the completion side */
drivers/soc/ti/wkup_m3_ipc.c:	ret = wait_for_completion_timeout(&m3_ipc->sync_complete,
drivers/soc/ti/wkup_m3_ipc.c:	wait_for_completion(&m3_ipc->rproc->firmware_loading_complete);
drivers/soc/ti/wkup_m3_ipc.c:	init_completion(&m3_ipc->sync_complete);
drivers/soc/ti/wkup_m3_ipc.c:	 * Wait for firmware loading completion in a thread so we
drivers/soc/fsl/qbman/qman_priv.h: * the FINISH flag, completion can be determined either by detecting the
drivers/soc/fsl/qbman/qman.c:		pr_crit("missing existing EQCR completions\n");
drivers/soc/fsl/qbman/qman.c:	 * NB we do this to "quiesce" EQCR. If we add enqueue-completions or
drivers/soc/fsl/qbman/qman.c:			/* Check for VDQCR completion */
drivers/soc/fsl/qbman/qman.c:	struct completion completion;
drivers/soc/fsl/qbman/qman.c:	complete(&cgr_comp->completion);
drivers/soc/fsl/qbman/qman.c:		init_completion(&cgr_comp.completion);
drivers/soc/fsl/qbman/qman.c:		wait_for_completion(&cgr_comp.completion);
drivers/soc/fsl/qbman/bman.c:		pr_crit("missing existing RCR completions\n");
drivers/crypto/mxs-dcp.c:	struct completion		completion[DCP_MAX_CHANS];
drivers/crypto/mxs-dcp.c:	reinit_completion(&sdcp->completion[chan]);
drivers/crypto/mxs-dcp.c:	ret = wait_for_completion_timeout(&sdcp->completion[chan],
drivers/crypto/mxs-dcp.c:			complete(&sdcp->completion[i]);
drivers/crypto/mxs-dcp.c:		init_completion(&sdcp->completion[i]);
drivers/crypto/atmel-sha.c:	/* wait for dma completion before can take more data */
drivers/crypto/ixp4xx_crypto.c:	struct completion completion;
drivers/crypto/ixp4xx_crypto.c:			complete(&ctx->completion);
drivers/crypto/ixp4xx_crypto.c:			complete(&ctx->completion);
drivers/crypto/ixp4xx_crypto.c:	init_completion(&ctx->completion);
drivers/crypto/ixp4xx_crypto.c:		wait_for_completion(&ctx->completion);
drivers/crypto/ixp4xx_crypto.c:	init_completion(&ctx->completion);
drivers/crypto/ixp4xx_crypto.c:		wait_for_completion(&ctx->completion);
drivers/crypto/ccp/ccp-dmaengine.c:		/* Check for DMA descriptor completion */
drivers/crypto/ccp/ccp-dev.c:	struct completion completion;
drivers/crypto/ccp/ccp-dev.c: * called to notify the caller of completion (if the cmd was not
drivers/crypto/ccp/ccp-dev.c:	complete(&tdata->completion);
drivers/crypto/ccp/ccp-dev.c:		/* Schedule the completion callback */
drivers/crypto/ccp/ccp-dev.c:		init_completion(&tdata.completion);
drivers/crypto/ccp/ccp-dev.c:		wait_for_completion(&tdata.completion);
drivers/crypto/ccp/ccp-crypto-main.c:	struct completion completion;
drivers/crypto/ccp/ccp-crypto-main.c:	 * the completion callbacks and retrieve the next cmd (cmd with
drivers/crypto/ccp/ccp-crypto-main.c:	 * completion callback for the request and the req pointer
drivers/crypto/ccp/ccp-dev.h:	 * backlog list is neeeded so that the backlog completion call
drivers/crypto/caam/caamrng.c:#include <linux/completion.h>
drivers/crypto/caam/caamrng.c:	struct completion filled;
drivers/crypto/caam/caamrng.c:	init_completion(&bd->filled);
drivers/crypto/caam/caamrng.c:			wait_for_completion(&bd->filled);
drivers/crypto/caam/caamrng.c:			wait_for_completion(&bd->filled);
drivers/crypto/caam/caamrng.c:	wait_for_completion(&bd->filled);
drivers/crypto/caam/Kconfig:	  Select number of descriptor completions to queue before
drivers/crypto/caam/Kconfig:	  more descriptor completions are queued without reaching the count
drivers/crypto/caam/key_gen.h:	struct completion completion;
drivers/crypto/caam/jr.c:	 * for reset completion status
drivers/crypto/caam/jr.c: * @cbk:  pointer to a callback function to be invoked upon completion
drivers/crypto/caam/caamhash.c:	init_completion(&result.completion);
drivers/crypto/caam/caamhash.c:		wait_for_completion_interruptible(&result.completion);
drivers/crypto/caam/key_gen.c:	complete(&res->completion);
drivers/crypto/caam/key_gen.c:	init_completion(&result.completion);
drivers/crypto/caam/key_gen.c:		wait_for_completion_interruptible(&result.completion);
drivers/crypto/marvell/hash.c:	struct completion completion;
drivers/crypto/marvell/hash.c:	complete(&result->completion);
drivers/crypto/marvell/hash.c:	init_completion(&result.completion);
drivers/crypto/marvell/hash.c:	wait_for_completion_interruptible(&result.completion);
drivers/crypto/marvell/hash.c:		init_completion(&result.completion);
drivers/crypto/marvell/hash.c:			wait_for_completion_interruptible(&result.completion);
drivers/crypto/chelsio/chcr_core.c:	/* call completion callback with failure status */
drivers/crypto/chelsio/chcr_algo.h:	struct completion completion;
drivers/crypto/qce/sha.c:	struct completion completion;
drivers/crypto/qce/sha.c:	complete(&result->completion);
drivers/crypto/qce/sha.c:	init_completion(&result.completion);
drivers/crypto/qce/sha.c:		ret = wait_for_completion_interruptible(&result.completion);
drivers/crypto/mv_cesa.c:	struct timer_list completion_timer;
drivers/crypto/mv_cesa.c:static void mv_completion_timer_callback(unsigned long unused)
drivers/crypto/mv_cesa.c:	       "completion timer expired (CESA %sactive), cleaning up.\n",
drivers/crypto/mv_cesa.c:	del_timer(&cpg->completion_timer);
drivers/crypto/mv_cesa.c:	setup_timer(&cpg->completion_timer, &mv_completion_timer_callback, 0);
drivers/crypto/mv_cesa.c:	mod_timer(&cpg->completion_timer,
drivers/crypto/mv_cesa.c:static void mv_crypto_algo_completion(void)
drivers/crypto/mv_cesa.c:static void mv_hash_algo_completion(void)
drivers/crypto/mv_cesa.c:	p->complete = mv_crypto_algo_completion;
drivers/crypto/mv_cesa.c:		p->complete = mv_hash_algo_completion;
drivers/crypto/mv_cesa.c:	if (!del_timer(&cpg->completion_timer)) {
drivers/crypto/omap-sham.c:	/* wait for dma completion before can take more data */
drivers/crypto/qat/qat_dh895xccvf/adf_drv.c:	init_completion(&accel_dev->vf.iov_msg_completion);
drivers/crypto/qat/qat_c62xvf/adf_drv.c:	init_completion(&accel_dev->vf.iov_msg_completion);
drivers/crypto/qat/qat_common/adf_vf_isr.c:		complete(&accel_dev->vf.iov_msg_completion);
drivers/crypto/qat/qat_common/adf_aer.c:#include <linux/completion.h>
drivers/crypto/qat/qat_common/adf_aer.c:	struct completion compl;
drivers/crypto/qat/qat_common/adf_aer.c:	init_completion(&reset_data->compl);
drivers/crypto/qat/qat_common/adf_aer.c:		unsigned long timeout = wait_for_completion_timeout(
drivers/crypto/qat/qat_common/adf_pf2vf_msg.c:	if (!wait_for_completion_timeout(&accel_dev->vf.iov_msg_completion,
drivers/crypto/qat/qat_common/adf_accel_devices.h:			struct completion iov_msg_completion;
drivers/crypto/qat/qat_c3xxxvf/adf_drv.c:	init_completion(&accel_dev->vf.iov_msg_completion);
drivers/crypto/ux500/cryp/cryp.h:#include <linux/completion.h>
drivers/crypto/ux500/cryp/cryp.h:	struct completion cryp_dma_complete;
drivers/crypto/ux500/cryp/cryp_core.c:#include <linux/completion.h>
drivers/crypto/ux500/cryp/cryp_core.c:	init_completion(&device_data->dma.cryp_dma_complete);
drivers/crypto/ux500/cryp/cryp_core.c:	wait_for_completion(&ctx->device->dma.cryp_dma_complete);
drivers/crypto/ux500/hash/hash_alg.h: * @complete:		Used to maintain state for a "completion".
drivers/crypto/ux500/hash/hash_alg.h:	struct completion	complete;
drivers/crypto/ux500/hash/hash_core.c:	init_completion(&device_data->dma.complete);
drivers/crypto/ux500/hash/hash_core.c:	wait_for_completion(&ctx->device->dma.complete);
drivers/crypto/talitos.c:	struct completion completion;
drivers/crypto/talitos.c:	complete(&res->completion);
drivers/crypto/talitos.c:	init_completion(&hresult.completion);
drivers/crypto/talitos.c:		ret = wait_for_completion_interruptible(
drivers/crypto/talitos.c:			&hresult.completion);
drivers/crypto/sahara.c:	struct completion	dma_completion;
drivers/crypto/sahara.c:	reinit_completion(&dev->dma_completion);
drivers/crypto/sahara.c:	timeout = wait_for_completion_timeout(&dev->dma_completion,
drivers/crypto/sahara.c:	reinit_completion(&dev->dma_completion);
drivers/crypto/sahara.c:	timeout = wait_for_completion_timeout(&dev->dma_completion,
drivers/crypto/sahara.c:	complete(&dev->dma_completion);
drivers/crypto/sahara.c:	init_completion(&dev->dma_completion);
drivers/crypto/nx/nx_csbcpb.h:	u8 completion_code;
drivers/crypto/nx/nx_csbcpb.h:	u8 completion_extension;
drivers/crypto/nx/nx-842-pseries.c:/* CE macros operate on the completion_extension field bits in the csbcpb.
drivers/crypto/nx/nx-842-pseries.c: * CE0 0=full completion, 1=partial completion
drivers/crypto/nx/nx-842-pseries.c: * CE1 0=CE0 indicates completion, 1=termination (output may be modified)
drivers/crypto/nx/nx-842-pseries.c:		dev_err(dev, "%s: cspcbp not valid upon completion.\n",
drivers/crypto/nx/nx-842-pseries.c:				csb->completion_code,
drivers/crypto/nx/nx-842-pseries.c:				csb->completion_extension);
drivers/crypto/nx/nx-842-pseries.c:	switch (csb->completion_code) {
drivers/crypto/nx/nx-842-pseries.c:					__func__, csb->completion_code);
drivers/crypto/nx/nx-842-pseries.c:					__func__, csb->completion_code);
drivers/crypto/nx/nx-842-pseries.c:	if (!NX842_CSBCPB_CE2(csb->completion_extension)) {
drivers/crypto/nx/nx-842-powernv.c:	/* verify CSB completion sequence is 0 */
drivers/crypto/nx/nx-842-powernv.c:		CSB_ERR(csb, "Invalid CSB completion sequence");
drivers/crypto/nx/nx-842-powernv.c:	/* successful completion */
drivers/crypto/nx/nx-aes-ccm.c:		/* for partial completion, copy following for next
drivers/crypto/nx/nx-aes-ccm.c:		/* for partial completion, copy following for next
drivers/crypto/atmel-aes.c:	/* Check for transfer completion. */
drivers/scsi/qlogicpti.h:	u16			completion_status;
drivers/scsi/qlogicpti.h:/* status entry completion status definitions */
drivers/scsi/qla1280.h:	/* NOTE: the sp->cmd will be NULL when this completion is
drivers/scsi/qla1280.h:	struct completion *wait;
drivers/scsi/qla1280.h: * ISP status entry - completion status definitions.
drivers/scsi/qla1280.h:	struct completion *mailbox_wait;
drivers/scsi/ncr53c8xx.c:**	completion (ncr_wakeup()). Doing so, we are sure that the header 
drivers/scsi/ncr53c8xx.c:	**	Command completion handling.
drivers/scsi/ncr53c8xx.c:	**	... signal completion to the host
drivers/scsi/ncr53c8xx.c:	**	... signal completion to the host
drivers/scsi/ncr53c8xx.c:**	Signal completion to the generic SCSI driver.
drivers/scsi/ncr53c8xx.c:	**	signal completion to generic driver.
drivers/scsi/ncr53c8xx.c:**	since the INTFLY is likely used for command completion 
drivers/scsi/pmcraid.c:	cmd->completion_req = 0;
drivers/scsi/pmcraid.c: * pmcraid_bist_done - completion function for PCI BIST
drivers/scsi/pmcraid.c: * pmcraid_reset_alert_done - completion routine for reset_alert
drivers/scsi/pmcraid.c: * pmcraid_internal_done - completion routine for internally generated cmds
drivers/scsi/pmcraid.c:	 * response. Same will be indicated as part of cmd->completion_req
drivers/scsi/pmcraid.c:	 * completion if this flag is set.
drivers/scsi/pmcraid.c:	if (cmd->completion_req) {
drivers/scsi/pmcraid.c:		cmd->completion_req = 0;
drivers/scsi/pmcraid.c:		complete(&cmd->wait_for_completion);
drivers/scsi/pmcraid.c: * pmcraid_erp_done - Process completion of SCSI error response from device
drivers/scsi/pmcraid.c: * This function also sets up timeout function, and command completion
drivers/scsi/pmcraid.c: * @cmd_done: command completion function, called once IOA responds
drivers/scsi/pmcraid.c: * @timeout: timeout to wait for this command completion
drivers/scsi/pmcraid.c: * pmcraid_ioa_shutdown_done - completion function for IOA shutdown command
drivers/scsi/pmcraid.c: * pmcraid_get_fwversion_done - completion function for get_fwversion
drivers/scsi/pmcraid.c: * Note: This command initiates reset and waits for its completion. Hence this
drivers/scsi/pmcraid.c:	init_completion(&cmd->wait_for_completion);
drivers/scsi/pmcraid.c:	cmd->completion_req = 1;
drivers/scsi/pmcraid.c:	 * will wake up the 'completion' queue.
drivers/scsi/pmcraid.c:	wait_for_completion(&cmd->wait_for_completion);
drivers/scsi/pmcraid.c: * pmcraid_io_done - SCSI completion function
drivers/scsi/pmcraid.c:	init_completion(&cancel_cmd->wait_for_completion);
drivers/scsi/pmcraid.c:	cancel_cmd->completion_req = 1;
drivers/scsi/pmcraid.c: * pmcraid_abort_complete - Waits for ABORT TASK completion
drivers/scsi/pmcraid.c: *	 returns SUCCESS if ABORT TASK has good completion
drivers/scsi/pmcraid.c:	wait_for_completion(&cancel_cmd->wait_for_completion);
drivers/scsi/pmcraid.c:	/* If the abort task is not timed out we will get a Good completion
drivers/scsi/pmcraid.c:	 * it, send ABORT_TASK to abort this and wait for its completion
drivers/scsi/pmcraid.c:	init_completion(&cmd->wait_for_completion);
drivers/scsi/pmcraid.c:	cmd->completion_req = 1;
drivers/scsi/pmcraid.c:	 * until the command completion regardless of timeout value specified in
drivers/scsi/pmcraid.c:		wait_for_completion(&cmd->wait_for_completion);
drivers/scsi/pmcraid.c:	} else if (!wait_for_completion_timeout(
drivers/scsi/pmcraid.c:			&cmd->wait_for_completion,
drivers/scsi/pmcraid.c:			wait_for_completion(&cancel_cmd->wait_for_completion);
drivers/scsi/pmcraid.c:			 * completed prior to aborting, return good completion.
drivers/scsi/pmcraid.c:		if (!wait_for_completion_timeout(
drivers/scsi/pmcraid.c:			&cmd->wait_for_completion,
drivers/scsi/pmcraid.c: * Issues an adapter shutdown to the card waits for its completion
drivers/scsi/pmcraid.c: *				completion of the ioa reset
drivers/scsi/pmcraid.c:	 * as part of set_supported_devs completion function.
drivers/scsi/3w-9xxx.c:	/* First check for internal completion of set param for time sync */
drivers/scsi/3w-9xxx.c:		/* Now poll for completion */
drivers/scsi/3w-9xxx.c:	/* Poll for completion */
drivers/scsi/3w-9xxx.c:	/* Poll for completion */
drivers/scsi/3w-9xxx.c:			/* Check for internal command completion */
drivers/scsi/gdth_proc.c:#include <linux/completion.h>
drivers/scsi/gdth_proc.c:static void gdth_wait_completion(gdth_ha_str *ha, int busnum, int id)
drivers/scsi/gdth_proc.c:            cmndinfo->wait_for_completion = 0;
drivers/scsi/gdth_proc.c:            while (!cmndinfo->wait_for_completion)
drivers/scsi/ch.c:#include <linux/completion.h>
drivers/scsi/ppa.c:static int ppa_completion(struct scsi_cmnd *cmd)
drivers/scsi/ppa.c:		retv = ppa_completion(cmd);
drivers/scsi/BusLogic.h:  completion codes are stored in the CCB; it only uses codes 1, 2, 4, and 5.
drivers/scsi/aic7xxx/aic7xxx_core.c: * Block our completion routine from starting the next untagged
drivers/scsi/aic7xxx/aic7xxx_core.c:	 * completion queues.  This avoids a costly PCI bus read in
drivers/scsi/aic7xxx/aic7xxx_core.c:		 * that requires host assistance for completion.
drivers/scsi/aic7xxx/aic7xxx_core.c:				 * for the command run to completion case.
drivers/scsi/aic7xxx/aic7xxx_core.c:		 * have queued for completion, 0'ing their control byte too.
drivers/scsi/aic7xxx/aic7xxx_core.c:	 * completion processing on any commands that 'completed'
drivers/scsi/aic7xxx/aic79xx_osm.c:	if (!wait_for_completion_timeout(&done, 5 * HZ)) {
drivers/scsi/aic7xxx/aic79xx_osm.c:		if (!wait_for_completion_timeout(&done, 5 * HZ)) {
drivers/scsi/aic7xxx/aic79xx_pci.c:	"%s: Received split completion error message in %s\n",
drivers/scsi/aic7xxx/aic79xx_pci.c:	"%s: Split completion data bucket in %s\n",
drivers/scsi/aic7xxx/aic79xx_pci.c:	"%s: Split completion address error in %s\n",
drivers/scsi/aic7xxx/aic79xx_pci.c:	"%s: Split completion byte count error in %s\n",
drivers/scsi/aic7xxx/aic79xx_pci.c:	"%s: Split completion read data parity error in %s\n",
drivers/scsi/aic7xxx/aic79xx_pci.c:	"%s: Split completion address attribute parity error in %s\n",
drivers/scsi/aic7xxx/aic7xxx_osm.h:	struct completion	*eh_done;
drivers/scsi/aic7xxx/aic79xx_osm.h:	struct completion	*eh_done;
drivers/scsi/aic7xxx/aic79xx_core.c:			/*len*/AHD_SCB_MAX * sizeof(struct ahd_completion), op);
drivers/scsi/aic7xxx/aic79xx_core.c:	 * completion queues.  This avoids a costly PCI bus read in
drivers/scsi/aic7xxx/aic79xx_core.c:	 * attempt to handle the DMA completion.
drivers/scsi/aic7xxx/aic79xx_core.c: * Run a data fifo to completion for a transaction we know
drivers/scsi/aic7xxx/aic79xx_core.c: * The valid_tag completion field indicates the validity
drivers/scsi/aic7xxx/aic79xx_core.c: * the queue. We use the sg_status field in the completion
drivers/scsi/aic7xxx/aic79xx_core.c: * entry to avoid referencing the hscb if the completion
drivers/scsi/aic7xxx/aic79xx_core.c:	struct ahd_completion *completion;
drivers/scsi/aic7xxx/aic79xx_core.c:		completion = &ahd->qoutfifo[ahd->qoutfifonext];
drivers/scsi/aic7xxx/aic79xx_core.c:		if (completion->valid_tag != ahd->qoutfifonext_valid_tag)
drivers/scsi/aic7xxx/aic79xx_core.c:		scb_index = ahd_le16toh(completion->tag);
drivers/scsi/aic7xxx/aic79xx_core.c:		} else if ((completion->sg_status & SG_STATUS_VALID) != 0) {
drivers/scsi/aic7xxx/aic79xx_core.c:		 * that requires host assistance for completion.
drivers/scsi/aic7xxx/aic79xx_core.c:			 * sequencer interrupt for its completion.
drivers/scsi/aic7xxx/aic79xx_core.c:				 * for the command run to completion case.
drivers/scsi/aic7xxx/aic79xx_core.c:	ahd->qoutfifo = (struct ahd_completion *)ahd->shared_data_map.vaddr;
drivers/scsi/aic7xxx/aic79xx_core.c:		   + AHD_QOUT_SIZE*sizeof(struct ahd_completion);
drivers/scsi/aic7xxx/aic79xx_core.c:		 * Do not issue a target abort when a split completion
drivers/scsi/aic7xxx/aic79xx_core.c:	 * sequencer has already marked for completion.
drivers/scsi/aic7xxx/aic79xx_core.c:	 * completion processing on any commands that 'completed'
drivers/scsi/aic7xxx/aic79xx_core.c:		 * a normal command completion.
drivers/scsi/aic7xxx/aic7xxx_osm.c:		if (!wait_for_completion_timeout(&done, 5 * HZ)) {
drivers/scsi/aic7xxx/aic79xx.seq:	cmp	QFREEZE_COUNT, A jne check_frozen_completions;
drivers/scsi/aic7xxx/aic79xx.seq:	cmp	QFREEZE_COUNT[1], A jne check_frozen_completions;
drivers/scsi/aic7xxx/aic79xx.seq:check_frozen_completions:
drivers/scsi/aic7xxx/aic79xx.seq:	 * If we have completions stalled waiting for the qfreeze
drivers/scsi/aic7xxx/aic79xx.seq:	 * queue the SCB for normal completion.  Otherwise, we
drivers/scsi/aic7xxx/aic79xx.seq:	 * then queue the completion.
drivers/scsi/aic7xxx/aic79xx.seq:	test	SCB_SCSI_STATUS, 0xff jz scbdma_queue_completion;
drivers/scsi/aic7xxx/aic79xx.seq:scbdma_queue_completion:
drivers/scsi/aic7xxx/aic79xx.seq:	 * completion entries.  In PCI mode, at least in 32/33
drivers/scsi/aic7xxx/aic79xx.seq:	 * completions to continue the data transfer.
drivers/scsi/aic7xxx/aic79xx.seq: * is responsible for polling for transfer completion.
drivers/scsi/aic7xxx/aic79xx.seq: * queue and trigger a completion interrupt via the idle loop.  Before doing
drivers/scsi/aic7xxx/aic79xx.seq:	 * the completion.
drivers/scsi/aic7xxx/aic79xx.seq:	call	queue_scb_completion;
drivers/scsi/aic7xxx/aic79xx.seq:queue_scb_completion:
drivers/scsi/aic7xxx/aic79xx.seq:	 * change, and/or the completion of the last segment.
drivers/scsi/aic7xxx/aic79xx.seq:	 * SCB completion.
drivers/scsi/aic7xxx/aic79xx.seq:	 * count since the status received flag, and thus completion
drivers/scsi/aic7xxx/aic79xx.h:struct ahd_completion
drivers/scsi/aic7xxx/aic79xx.h:	struct ahd_completion	  *qoutfifo;
drivers/scsi/aic7xxx/aic79xx.reg:						 * command completion method
drivers/scsi/aic7xxx/aic7xxx.seq:		 * change, and/or the completion of the last segment.
drivers/scsi/aic7xxx/aic7xxx.seq: * and trigger a completion interrupt.  Before doing so, check to see if there
drivers/scsi/aic7xxx/aic7xxx.seq:	 * the completion.
drivers/scsi/csiostor/csio_hw_t5.c:		{ RCCP_F, "Rx completions control array parity error", -1, 1 },
drivers/scsi/csiostor/csio_hw_t5.c:		{ PIOCPLGRPPERR_F, "PCI PIO completion Group FIFO parity error",
drivers/scsi/csiostor/csio_lnode.c: * csio_ln_fdmi_done - FDMI registeration completion
drivers/scsi/csiostor/csio_lnode.c: * csio_ln_fdmi_rhba_cbfn - RHBA completion
drivers/scsi/csiostor/csio_lnode.c: * csio_ln_fdmi_dprt_cbfn - DPRT completion
drivers/scsi/csiostor/csio_lnode.c: * csio_ln_fdmi_dhba_cbfn - DHBA completion
drivers/scsi/csiostor/csio_lnode.c: * csio_ln_vnp_read_cbfn - vnp read completion handler.
drivers/scsi/csiostor/csio_lnode.c:	/* io_req will be freed by completion handler */
drivers/scsi/csiostor/csio_wr.c: * Handle FW_IQ_CMD mailbox completion. Save off the assigned IQ/FL ids.
drivers/scsi/csiostor/csio_wr.c: * Handle FW_EQ_OFLD_CMD mailbox completion. Save off the assigned EQ ids.
drivers/scsi/csiostor/csio_wr.c: * Handle FW_IQ_CMD (free) mailbox completion.
drivers/scsi/csiostor/csio_wr.c: * Handle FW_OFLD_EQ_CMD (free) mailbox completion.
drivers/scsi/csiostor/csio_wr.c: * csio_wr_process_fl - Process a freelist completion.
drivers/scsi/csiostor/csio_wr.c: * @wr: The freelist completion WR in the ingress queue.
drivers/scsi/csiostor/csio_wr.c: * @iq_handler: Caller's handler for this completion.
drivers/scsi/csiostor/csio_wr.h:	uint16_t		wr_status;	/* WR completion status */
drivers/scsi/csiostor/csio_wr.h:						/* completion callback */
drivers/scsi/csiostor/csio_wr.h:	struct completion	cmplobj;	/* ioreq completion object */
drivers/scsi/csiostor/csio_wr.h:	uint32_t	n_stray_comp;		/* Stray completion intr */
drivers/scsi/csiostor/csio_isr.c: * csio_process_scsi_cmpl - Process a SCSI WR completion.
drivers/scsi/csiostor/csio_isr.c: * Processes SCSI completions on the SCSI IQ indicated by scm->iq_idx
drivers/scsi/csiostor/csio_isr.c: * by calling csio_wr_process_iq_idx. If there are completions on the
drivers/scsi/csiostor/csio_isr.c: * Once done, add these completions onto the freelist.
drivers/scsi/csiostor/csio_isr.c:	int isr_completions = 0;
drivers/scsi/csiostor/csio_isr.c:	/* Call back the completion routines */
drivers/scsi/csiostor/csio_isr.c:		isr_completions++;
drivers/scsi/csiostor/csio_isr.c:	if (isr_completions) {
drivers/scsi/csiostor/csio_isr.c:					      isr_completions);
drivers/scsi/csiostor/csio_isr.c: * for handling SCSI completions.
drivers/scsi/csiostor/csio_isr.c: * for handling SCSI completions.
drivers/scsi/csiostor/csio_init.c:	/* Use FW IQ for MGMT req completion */
drivers/scsi/csiostor/csio_hw.c: *	@reg: the register to check for completion
drivers/scsi/csiostor/csio_hw.c: *	@mask: a single-bit field within @reg that indicates completion
drivers/scsi/csiostor/csio_hw.c: *	@valp: where to store the value of the register at completion time
drivers/scsi/csiostor/csio_hw.c: *	at the time it indicated completion is stored there.  Returns 0 if the
drivers/scsi/csiostor/csio_hw.c: * FW_HELLO_CMD has to be polled for completion.
drivers/scsi/csiostor/csio_hw.c:	/* Post event to notify completion of configuration */
drivers/scsi/csiostor/csio_hw.c:	/* Set PCIe completion timeout to 4 seconds */
drivers/scsi/csiostor/csio_hw.c:			/* Post event to notify completion of configuration */
drivers/scsi/csiostor/csio_hw.c: * csio_mberr_worker - Worker thread (dpc) for mailbox/error completions
drivers/scsi/csiostor/csio_hw.c:	/* Now callback completions */
drivers/scsi/csiostor/csio_hw.c:	csio_mb_completions(hw, &cbfn_q);
drivers/scsi/csiostor/csio_hw.c: * into a local queue. Drops lock and calls the completions. Holds
drivers/scsi/csiostor/csio_hw.c:	csio_mb_completions(hw, &cbfn_q);
drivers/scsi/csiostor/csio_hw.c:				/* io_req will be freed by completion handler */
drivers/scsi/csiostor/csio_hw.c:			/* io_req will be freed by completion handler */
drivers/scsi/csiostor/csio_hw.c: * completion q. Allocate Egress and Ingress
drivers/scsi/csiostor/csio_rnode.c:		csio_dbg(hw, "Returning completion queue I/Os\n");
drivers/scsi/csiostor/csio_attr.c:		 * lock is held till completion of vnp mbox cmd.
drivers/scsi/csiostor/csio_scsi.h:#include <linux/completion.h>
drivers/scsi/csiostor/csio_scsi.h:						   * with completions.
drivers/scsi/csiostor/csio_mb.h:#include <linux/completion.h>
drivers/scsi/csiostor/csio_mb.h:	struct completion	cmplobj;		/* MB Completion
drivers/scsi/csiostor/csio_mb.h:	struct list_head	cbfn_q;			/* Mbox completion q */
drivers/scsi/csiostor/csio_mb.h:void csio_mb_completions(struct csio_hw *, struct list_head *);
drivers/scsi/csiostor/csio_scsi.c:			 * but prior to LUN reset completion (in the event that
drivers/scsi/csiostor/csio_scsi.c:		 * loss itself. This forces us to serialize such completions
drivers/scsi/csiostor/csio_scsi.c:		 * internally queue up such up such completions in the rnode.
drivers/scsi/csiostor/csio_scsi.c:		 * FW (because the ABORT and completion of the I/O crossed each
drivers/scsi/csiostor/csio_scsi.c:		 * completion.
drivers/scsi/csiostor/csio_scsi.c:		 * 2. The completion of an I/O and the receipt of
drivers/scsi/csiostor/csio_scsi.c:		 * FW (because the CLOSE and completion of the I/O crossed each
drivers/scsi/csiostor/csio_scsi.c:		 * completion.
drivers/scsi/csiostor/csio_scsi.c: * csio_scsi_cmpl_handler - WR completion handler for SCSI.
drivers/scsi/csiostor/csio_scsi.c: * This is the WR completion handler called per completion from the
drivers/scsi/csiostor/csio_scsi.c:	/* Call back the completion routines of the active_q */
drivers/scsi/csiostor/csio_scsi.c:	 * need the abort/close completion to be received on the same queue
drivers/scsi/csiostor/csio_scsi.c:	reinit_completion(&ioreq->cmplobj);
drivers/scsi/csiostor/csio_scsi.c:	wait_for_completion_timeout(&ioreq->cmplobj, msecs_to_jiffies(tmo));
drivers/scsi/csiostor/csio_scsi.c:	 * FCP_RSP_LEN_VAL in flags shall be set for TM completions.
drivers/scsi/csiostor/csio_scsi.c:	 * completion. Any other rsp_code means TM operation failed.
drivers/scsi/csiostor/csio_scsi.c:	csio_dbg(hw, "Waiting max %d secs for LUN reset completion\n",
drivers/scsi/csiostor/csio_scsi.c:	/* Wait for completion */
drivers/scsi/csiostor/csio_scsi.c:		init_completion(&ioreq->cmplobj);
drivers/scsi/csiostor/csio_mb.c:	/* Start completion timers in non-immediate modes and notify FW */
drivers/scsi/csiostor/csio_mb.c:	/* Poll for completion in immediate mode */
drivers/scsi/csiostor/csio_mb.c: * csio_mb_completions - Completion handler for Mailbox commands
drivers/scsi/csiostor/csio_mb.c:csio_mb_completions(struct csio_hw *hw, struct list_head *cbfn_q)
drivers/scsi/csiostor/csio_mb.c:		/* Add completion to tail of cbfn queue */
drivers/scsi/csiostor/csio_mb.c:	 * Could be a race b/w the completion handler and the timer
drivers/scsi/csiostor/csio_mb.c:	 * and the completion handler won that race.
drivers/scsi/csiostor/csio_mb.c:		/* Stop mailbox completion timer */
drivers/scsi/csiostor/csio_mb.c:		/* Add completion to tail of cbfn queue */
drivers/scsi/mpt3sas/mpt3sas_transport.c:	init_completion(&ioc->transport_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_transport.c:	wait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);
drivers/scsi/mpt3sas/mpt3sas_transport.c:	init_completion(&ioc->transport_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_transport.c:	wait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);
drivers/scsi/mpt3sas/mpt3sas_transport.c:	init_completion(&ioc->transport_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_transport.c:	wait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);
drivers/scsi/mpt3sas/mpt3sas_transport.c:	init_completion(&ioc->transport_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_transport.c:	wait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);
drivers/scsi/mpt3sas/mpt3sas_ctl.c: * mpt3sas_ctl_done - ctl module completion routine
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	init_completion(&ioc->ctl_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	wait_for_completion_timeout(&ioc->ctl_cmds.done, timeout*HZ);
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	init_completion(&ioc->ctl_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	wait_for_completion_timeout(&ioc->ctl_cmds.done,
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	init_completion(&ioc->ctl_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	wait_for_completion_timeout(&ioc->ctl_cmds.done,
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	init_completion(&ioc->ctl_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	wait_for_completion_timeout(&ioc->ctl_cmds.done,
drivers/scsi/mpt3sas/mpt3sas_config.c: * mpt3sas_config_done - config page completion routine
drivers/scsi/mpt3sas/mpt3sas_config.c:	init_completion(&ioc->config_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_config.c:	wait_for_completion_timeout(&ioc->config_cmds.done, timeout*HZ);
drivers/scsi/mpt3sas/mpt3sas_base.c: * mpt3sas_base_done - base internal command completion routine
drivers/scsi/mpt3sas/mpt3sas_base.c:	init_completion(&ioc->base_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_base.c:	wait_for_completion_timeout(&ioc->base_cmds.done,
drivers/scsi/mpt3sas/mpt3sas_base.c:	init_completion(&ioc->base_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_base.c:	wait_for_completion_timeout(&ioc->base_cmds.done,
drivers/scsi/mpt3sas/mpt3sas_base.c: * mpt3sas_port_enable_done - command completion routine for port enable
drivers/scsi/mpt3sas/mpt3sas_base.c:	init_completion(&ioc->port_enable_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_base.c:	wait_for_completion_timeout(&ioc->port_enable_cmds.done, 300*HZ);
drivers/scsi/mpt3sas/mpt3sas_base.c:	init_completion(&ioc->base_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_base.c:	wait_for_completion_timeout(&ioc->base_cmds.done, 30*HZ);
drivers/scsi/mpt3sas/mpt3sas_base.h: * @done: completion
drivers/scsi/mpt3sas/mpt3sas_base.h:	struct completion done;
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * _scsih_tm_done - tm completion routine
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	init_completion(&ioc->tm_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	wait_for_completion_timeout(&ioc->tm_cmds.done, timeout*HZ);
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * control request (MPI2_SAS_OP_REMOVE_DEVICE) from this completion.
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * and process it in a future completion.
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * This is the target reset completion routine.
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * _scsih_sas_control_complete - completion routine
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * This is the sas iounit control completion routine.
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * and process it in a future completion.
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * _scsih_tm_volume_tr_complete - target reset completion
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * completion of the volume target reset.
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * @done: function pointer to be invoked on completion
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	init_completion(&ioc->scsih_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	wait_for_completion_timeout(&ioc->scsih_cmds.done, 10*HZ);
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	init_completion(&ioc->scsih_cmds.done);
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	wait_for_completion_timeout(&ioc->scsih_cmds.done, 10*HZ);
drivers/scsi/mpt3sas/mpt3sas_scsih.c: * OK to resume normal operation. Use completion to allow
drivers/scsi/qla4xxx/ql4_fw.h:	uint8_t completionStatus;	/* 0B */
drivers/scsi/qla4xxx/ql4_fw.h:	uint8_t completionStatus;	/* 0C */
drivers/scsi/qla4xxx/ql4_os.c:	wait_for_completion_timeout(&ha->disable_acb_comp,
drivers/scsi/qla4xxx/ql4_os.c:	switch (sts->completionStatus) {
drivers/scsi/qla4xxx/ql4_os.c:			   sts->completionStatus);
drivers/scsi/qla4xxx/ql4_os.c: * completion handling).   Unfortunely, it sometimes calls the scheduler
drivers/scsi/qla4xxx/ql4_os.c:	qla4xxx_mailbox_premature_completion(ha);
drivers/scsi/qla4xxx/ql4_os.c:					qla4xxx_mailbox_premature_completion(
drivers/scsi/qla4xxx/ql4_os.c:				qla4xxx_mailbox_premature_completion(ha);
drivers/scsi/qla4xxx/ql4_os.c:		/* NOTE: AF_ONLINE flag set upon successful completion of
drivers/scsi/qla4xxx/ql4_os.c:	init_completion(&ha->mbx_intr_comp);
drivers/scsi/qla4xxx/ql4_os.c:	init_completion(&ha->disable_acb_comp);
drivers/scsi/qla4xxx/ql4_os.c:	init_completion(&ha->idc_comp);
drivers/scsi/qla4xxx/ql4_os.c:	init_completion(&ha->link_up_comp);
drivers/scsi/qla4xxx/ql4_os.c:	init_completion(&ha->disable_acb_comp);
drivers/scsi/qla4xxx/ql4_os.c:	 * NOTE: interrupts enabled upon successful completion
drivers/scsi/qla4xxx/ql4_os.c:	wait_for_completion_timeout(&ha->disable_acb_comp,
drivers/scsi/qla4xxx/ql4_os.c:		qla4xxx_mailbox_premature_completion(ha);
drivers/scsi/qla4xxx/ql4_def.h:	struct completion mbx_intr_comp;
drivers/scsi/qla4xxx/ql4_def.h:	struct completion disable_acb_comp;
drivers/scsi/qla4xxx/ql4_def.h:	struct completion idc_comp;
drivers/scsi/qla4xxx/ql4_def.h:	struct completion link_up_comp;
drivers/scsi/qla4xxx/ql4_bsg.c:	if (!wait_for_completion_timeout(&ha->idc_comp, (IDC_COMP_TOV * HZ))) {
drivers/scsi/qla4xxx/ql4_bsg.c:			if (!wait_for_completion_timeout(&ha->idc_comp,
drivers/scsi/qla4xxx/ql4_bsg.c:		if (!wait_for_completion_timeout(&ha->link_up_comp,
drivers/scsi/qla4xxx/ql4_iocb.c: * This routine notifies the ISP that one or more response/completion
drivers/scsi/qla4xxx/ql4_iocb.c: * This routine is notifies the ISP that one or more response/completion
drivers/scsi/qla4xxx/ql4_glbl.h:void qla4xxx_mailbox_premature_completion(struct scsi_qla_host *ha);
drivers/scsi/qla4xxx/ql4_isr.c:	switch (sts_entry->completionStatus) {
drivers/scsi/qla4xxx/ql4_isr.c:		     (sts_entry->completionStatus == SCS_DATA_OVERRUN)) {
drivers/scsi/qla4xxx/ql4_isr.c:		    cmd->device->lun, sts_entry->completionStatus));
drivers/scsi/qla4xxx/ql4_isr.c:			      sts_entry->completionStatus,
drivers/scsi/qla4xxx/ql4_isr.c:	srb->cc_stat = sts_entry->completionStatus;
drivers/scsi/qla4xxx/ql4_isr.c: * qla4xxx_process_response_queue - process response queue completions
drivers/scsi/qla4xxx/ql4_isr.c: * This routine process response queue completions in interrupt context.
drivers/scsi/qla4xxx/ql4_isr.c:		      sts_entry->completionStatus));
drivers/scsi/qla4xxx/ql4_mbx.c: * This routine issue mailbox commands and waits for completion.
drivers/scsi/qla4xxx/ql4_mbx.c:	/* Wait for completion */
drivers/scsi/qla4xxx/ql4_mbx.c:	 * you must poll the inbound Interrupt Mask for completion.
drivers/scsi/qla4xxx/ql4_mbx.c:	 * Wait for completion: Poll or completion queue
drivers/scsi/qla4xxx/ql4_mbx.c:		/* Do not poll for completion. Use completion queue */
drivers/scsi/qla4xxx/ql4_mbx.c:		wait_for_completion_timeout(&ha->mbx_intr_comp, MBOX_TOV * HZ);
drivers/scsi/qla4xxx/ql4_mbx.c:void qla4xxx_mailbox_premature_completion(struct scsi_qla_host *ha)
drivers/scsi/qla4xxx/ql4_mbx.c:			    "recovery, doing premature completion of "
drivers/scsi/qla4xxx/ql4_mbx.c:			    "recovery, doing premature completion of "
drivers/scsi/qla4xxx/ql4_mbx.c:	/* Do not wait for completion. The firmware will send us an
drivers/scsi/qla4xxx/ql4_mbx.c:	/* Firmware already posted completion on response queue */
drivers/scsi/qla4xxx/ql4_mbx.c:			if (!wait_for_completion_timeout(&ha->disable_acb_comp,
drivers/scsi/lpfc/lpfc_mbox.c:	/* save address for completion */
drivers/scsi/lpfc/lpfc_mbox.c: * form of mailbox command to the HBA. The timely completion of the heart
drivers/scsi/lpfc/lpfc_mbox.c:	/* Save address for later completion and set the owner to host so that
drivers/scsi/lpfc/lpfc_mbox.c:	/* save address for completion */
drivers/scsi/lpfc/lpfc_mbox.c:	/* save address for completion */
drivers/scsi/lpfc/lpfc_mbox.c:	/* Mailbox command that have a completion handler must also have a
drivers/scsi/lpfc/lpfc_mbox.c:	/* save address for completion */
drivers/scsi/lpfc/lpfc_mbox.c:	/* save address for completion */
drivers/scsi/lpfc/lpfc_mbox.c:	/* save address for completion */
drivers/scsi/lpfc/lpfc_disc.h: * state changed to PRLI_ISSUE. When the PRLI completion occurs, the state is
drivers/scsi/lpfc/lpfc_disc.h: * changed to PRLI_COMPL. If the completion indicates a mapped
drivers/scsi/lpfc/lpfc_disc.h: * handling. Upon completion, ALL nodes should be on either the mapped or
drivers/scsi/lpfc/lpfc_sli.c:/* There are only four IOCB completion types. */
drivers/scsi/lpfc/lpfc_sli.c:static bool lpfc_sli4_mbox_completions_pending(struct lpfc_hba *phba);
drivers/scsi/lpfc/lpfc_sli.c:static bool lpfc_sli4_process_missed_mbox_completions(struct lpfc_hba *phba);
drivers/scsi/lpfc/lpfc_sli.c:	/* Save off the mailbox pointer for completion */
drivers/scsi/lpfc/lpfc_sli.c:	/* Clear the mailbox pointer for completion */
drivers/scsi/lpfc/lpfc_sli.c: * by clearing the valid bit for each completion queue entry. Then it will
drivers/scsi/lpfc/lpfc_sli.c: * by clearing the valid bit for each completion queue entry. Then it will
drivers/scsi/lpfc/lpfc_sli.c:			/* if we send the rrq then the completion handler
drivers/scsi/lpfc/lpfc_sli.c: * LPFC_SOL_IOCB     if it is a solicited iocb completion
drivers/scsi/lpfc/lpfc_sli.c: * a completion call back for this iocb else the function will free the
drivers/scsi/lpfc/lpfc_sli.c:	 * If there is no completion routine to call, we can release the
drivers/scsi/lpfc/lpfc_sli.c:	 * that have no rsp ring completion, iocb_cmpl MUST be NULL.
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli_wake_mbox_wait - lpfc_sli_issue_mbox_wait mbox completion handler
drivers/scsi/lpfc/lpfc_sli.c: * This is completion handler function for mailbox commands issued from
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli_def_mbox_cmpl - Default mailbox completion handler
drivers/scsi/lpfc/lpfc_sli.c: * This function is the default mailbox completion handler. It
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_unreg_rpi_cmpl_clr - mailbox completion handler
drivers/scsi/lpfc/lpfc_sli.c: * This function is the unreg rpi mailbox completion handler. It
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli_handle_mb_event - Handle mailbox completions from firmware
drivers/scsi/lpfc/lpfc_sli.c: * service routine processes mailbox completion interrupt and adds completed
drivers/scsi/lpfc/lpfc_sli.c: * completion handler function of each mailbox.
drivers/scsi/lpfc/lpfc_sli.c:		 * It is a fatal error if unknown mbox command completion.
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli_process_sol_iocb - process solicited iocb completion
drivers/scsi/lpfc/lpfc_sli.c: * calls the completion handler for the command iocb. If there
drivers/scsi/lpfc/lpfc_sli.c: * is no completion handler, the function will free the resources
drivers/scsi/lpfc/lpfc_sli.c: * an already aborted command iocb, the status of the completion
drivers/scsi/lpfc/lpfc_sli.c:			 * Post all ELS completions to the worker thread.
drivers/scsi/lpfc/lpfc_sli.c:			 * All other are passed to the completion callback.
drivers/scsi/lpfc/lpfc_sli.c:			 * Ring <ringno> handler: unexpected completion IoTag
drivers/scsi/lpfc/lpfc_sli.c:					 "unexpected completion IoTag x%x "
drivers/scsi/lpfc/lpfc_sli.c: * LE bit set. The function will call the completion handler of the command iocb
drivers/scsi/lpfc/lpfc_sli.c: * if the response iocb indicates a completion for a command iocb or it is
drivers/scsi/lpfc/lpfc_sli.c: * an abort completion. The function will call lpfc_sli_process_unsol_iocb
drivers/scsi/lpfc/lpfc_sli.c:		phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_sli.c:						" completion\n",
drivers/scsi/lpfc/lpfc_sli.c: * completion of a command iocb. The function will call the
drivers/scsi/lpfc/lpfc_sli.c: * The function frees the resources or calls the completion handler if this
drivers/scsi/lpfc/lpfc_sli.c: * iocb is an abort completion. The function returns NULL when the response
drivers/scsi/lpfc/lpfc_sli.c:		 * associated with this iocb completion.
drivers/scsi/lpfc/lpfc_sli.c:		 * Fetch the IOCB command type and call the correct completion
drivers/scsi/lpfc/lpfc_sli.c:				/* Call the specified completion routine */
drivers/scsi/lpfc/lpfc_sli.c:		 * Build a completion list and call the appropriate handler.
drivers/scsi/lpfc/lpfc_sli.c:		phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_sli.c:			       "completion.\n", __func__);
drivers/scsi/lpfc/lpfc_sli.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_sli.c:		list_splice_init(&pring->txq, &completions);
drivers/scsi/lpfc/lpfc_sli.c:		list_splice_init(&pring->txq, &completions);
drivers/scsi/lpfc/lpfc_sli.c:	/* Cancel all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_sli.c:	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
drivers/scsi/lpfc/lpfc_sli.c:	/* There is no completion for a KILL_BOARD mbox cmd. Check for an error
drivers/scsi/lpfc/lpfc_sli.c: * The function does not guarantee completion of MBX_RESTART mailbox
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_arm_cqeq_intr - Arm sli-4 device completion and event queues
drivers/scsi/lpfc/lpfc_sli.c: * This routine is called to explicitly arm the SLI4 device's completion and
drivers/scsi/lpfc/lpfc_sli.c:	phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_mbox_completions_pending - check to see if any mailbox completions
drivers/scsi/lpfc/lpfc_sli.c: * This function checks if any mailbox completions are present on the mailbox
drivers/scsi/lpfc/lpfc_sli.c: * completion queue.
drivers/scsi/lpfc/lpfc_sli.c:lpfc_sli4_mbox_completions_pending(struct lpfc_hba *phba)
drivers/scsi/lpfc/lpfc_sli.c:	bool pending_completions = false;
drivers/scsi/lpfc/lpfc_sli.c:	/* Check for completions on mailbox completion queue */
drivers/scsi/lpfc/lpfc_sli.c:			pending_completions = true;
drivers/scsi/lpfc/lpfc_sli.c:	return pending_completions;
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_process_missed_mbox_completions - process mbox completions
drivers/scsi/lpfc/lpfc_sli.c: * For sli4, it is possible to miss an interrupt. As such mbox completions
drivers/scsi/lpfc/lpfc_sli.c: * checks to see if mbox completions are on the mailbox completion queue
drivers/scsi/lpfc/lpfc_sli.c: * and will process all the completions associated with the eq for the
drivers/scsi/lpfc/lpfc_sli.c: * mailbox completion queue.
drivers/scsi/lpfc/lpfc_sli.c:lpfc_sli4_process_missed_mbox_completions(struct lpfc_hba *phba)
drivers/scsi/lpfc/lpfc_sli.c:	/* Check to see if a mbox completion is pending */
drivers/scsi/lpfc/lpfc_sli.c:	mbox_pending = lpfc_sli4_mbox_completions_pending(phba);
drivers/scsi/lpfc/lpfc_sli.c:	 * If a mbox completion is pending, process all the events on EQ
drivers/scsi/lpfc/lpfc_sli.c:	 * associated with the mbox completion queue (this could include
drivers/scsi/lpfc/lpfc_sli.c:	/* If the mailbox completed, process the completion and return */
drivers/scsi/lpfc/lpfc_sli.c:	if (lpfc_sli4_process_missed_mbox_completions(phba))
drivers/scsi/lpfc/lpfc_sli.c: * this function will wait in a polling loop for the completion of the
drivers/scsi/lpfc/lpfc_sli.c: * for the mailbox completion. The no_wait is supported only when HBA
drivers/scsi/lpfc/lpfc_sli.c: * The sli layer owns the mailbox object until the completion of mailbox
drivers/scsi/lpfc/lpfc_sli.c:		lpfc_sli4_process_missed_mbox_completions(phba);
drivers/scsi/lpfc/lpfc_sli.c: * This routine executes a synchronous completion operation on the
drivers/scsi/lpfc/lpfc_sli.c: * mailbox by polling for its completion.
drivers/scsi/lpfc/lpfc_sli.c:			 * completion, iocb_cmpl MUST be 0.
drivers/scsi/lpfc/lpfc_sli.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_sli.c:	list_splice_init(&phba->sli.mboxq, &completions);
drivers/scsi/lpfc/lpfc_sli.c:		list_add_tail(&psli->mbox_active->list, &completions);
drivers/scsi/lpfc/lpfc_sli.c:	list_splice_init(&phba->sli.mboxq_cmpl, &completions);
drivers/scsi/lpfc/lpfc_sli.c:	while (!list_empty(&completions)) {
drivers/scsi/lpfc/lpfc_sli.c:		list_remove_head(&completions, pmb, LPFC_MBOXQ_t, list);
drivers/scsi/lpfc/lpfc_sli.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_sli.c:			list_move_tail(&iocb->list, &completions);
drivers/scsi/lpfc/lpfc_sli.c:	/* Cancel all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_sli.c:	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
drivers/scsi/lpfc/lpfc_sli.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_sli.c:		list_splice_init(&pring->txq, &completions);
drivers/scsi/lpfc/lpfc_sli.c:	/* Cancel all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_sli.c:	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
drivers/scsi/lpfc/lpfc_sli.c:	list_splice_init(&phba->elsbuf, &completions);
drivers/scsi/lpfc/lpfc_sli.c:	while (!list_empty(&completions)) {
drivers/scsi/lpfc/lpfc_sli.c:		list_remove_head(&completions, buf_ptr,
drivers/scsi/lpfc/lpfc_sli.c: * This function is the completion handler for the abort iocbs for
drivers/scsi/lpfc/lpfc_sli.c: * lock held. This function is the completion handler for ELS commands
drivers/scsi/lpfc/lpfc_sli.c:			"0139 Ignoring ELS cmd tag x%x completion Data: "
drivers/scsi/lpfc/lpfc_sli.c:	 * before calling the completion handler
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli_wake_iocb_wait - lpfc_sli_issue_iocb_wait's completion handler
drivers/scsi/lpfc/lpfc_sli.c: * This function is the completion handler for iocbs issued using
drivers/scsi/lpfc/lpfc_sli.c: * sleeps for the iocb completion.
drivers/scsi/lpfc/lpfc_sli.c:		 * completion handler has been supplied, call it.  Otherwise,
drivers/scsi/lpfc/lpfc_sli.c: * needed, the caller is expected to provide a completion function
drivers/scsi/lpfc/lpfc_sli.c: * completion function set in the iocb_cmpl field and then return
drivers/scsi/lpfc/lpfc_sli.c: * The function waits for the iocb completion using an
drivers/scsi/lpfc/lpfc_sli.c: * This function will sleep while waiting for iocb completion.
drivers/scsi/lpfc/lpfc_sli.c: * This function assumes that the iocb completions occur while
drivers/scsi/lpfc/lpfc_sli.c: * the thread which process iocb completion for this ring.
drivers/scsi/lpfc/lpfc_sli.c: * issuing the iocb and the iocb completion handler sets this
drivers/scsi/lpfc/lpfc_sli.c: * by the completion handler when the command completes.
drivers/scsi/lpfc/lpfc_sli.c:			 * completion function and set local status
drivers/scsi/lpfc/lpfc_sli.c: * The function waits for the mailbox completion using an
drivers/scsi/lpfc/lpfc_sli.c: * This function will sleep while waiting for mailbox completion.
drivers/scsi/lpfc/lpfc_sli.c: * This function assumes that the mailbox completion occurs while
drivers/scsi/lpfc/lpfc_sli.c: * the worker thread which processes mailbox completion.
drivers/scsi/lpfc/lpfc_sli.c:				phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_sli.c: * completion status information from the complete wcqe.
drivers/scsi/lpfc/lpfc_sli.c:	/* Convert BG errors for completion status */
drivers/scsi/lpfc/lpfc_sli.c: * @wcqe: Pointer to work-queue completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * This routine handles an ELS work-queue completion event and construct
drivers/scsi/lpfc/lpfc_sli.c: * @cqe: Pointer to mailbox completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * This routine process a mailbox completion queue entry with asynchrous
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_sp_handle_mbox_event - Handle a mailbox completion event
drivers/scsi/lpfc/lpfc_sli.c: * @cqe: Pointer to mailbox completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * This routine process a mailbox completion queue entry with mailbox
drivers/scsi/lpfc/lpfc_sli.c: * completion event.
drivers/scsi/lpfc/lpfc_sli.c:	phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_sli.c:	/* There is mailbox completion work to do */
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_sp_handle_mcqe - Process a mailbox completion queue entry
drivers/scsi/lpfc/lpfc_sli.c: * @cqe: Pointer to mailbox completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * This routine process a mailbox completion queue entry, it invokes the
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_sp_handle_els_wcqe - Handle els work-queue completion event
drivers/scsi/lpfc/lpfc_sli.c: * @wcqe: Pointer to work-queue completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * This routine handles an ELS work-queue completion event.
drivers/scsi/lpfc/lpfc_sli.c: * @wcqe: Pointer to work-queue completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * @cq: Pointer to a WQ completion queue.
drivers/scsi/lpfc/lpfc_sli.c: * @wcqe: Pointer to work-queue completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_sp_handle_rcqe - Process a receive-queue completion queue entry
drivers/scsi/lpfc/lpfc_sli.c: * @rcqe: Pointer to receive-queue completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * This routine process a receive-queue completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_sp_handle_cqe - Process a slow path completion queue entry
drivers/scsi/lpfc/lpfc_sli.c: * @cq: Pointer to the completion queue.
drivers/scsi/lpfc/lpfc_sli.c: * @wcqe: Pointer to a completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * This routine process a slow-path work-queue or receive queue completion queue
drivers/scsi/lpfc/lpfc_sli.c:		phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_sli.c:		phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_sli.c:		phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_sli.c: * completion event on a completion queue, if not, an error shall be logged
drivers/scsi/lpfc/lpfc_sli.c: * and just return. Otherwise, it will get to the corresponding completion
drivers/scsi/lpfc/lpfc_sli.c: * queue and process all the entries on that completion queue, rearm the
drivers/scsi/lpfc/lpfc_sli.c: * completion queue, and then return.
drivers/scsi/lpfc/lpfc_sli.c:				"0370 Invalid completion queue type (%d)\n",
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_fp_handle_fcp_wcqe - Process fast-path work queue completion entry
drivers/scsi/lpfc/lpfc_sli.c: * @wcqe: Pointer to work-queue completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * This routine process a fast-path work queue completion entry from fast-path
drivers/scsi/lpfc/lpfc_sli.c: * event queue for FCP command response completion.
drivers/scsi/lpfc/lpfc_sli.c: * @cq: Pointer to completion queue.
drivers/scsi/lpfc/lpfc_sli.c: * @wcqe: Pointer to work-queue completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_sli4_fp_handle_wcqe - Process fast-path work queue completion entry
drivers/scsi/lpfc/lpfc_sli.c: * @cq: Pointer to the completion queue.
drivers/scsi/lpfc/lpfc_sli.c: * @eqe: Pointer to fast-path completion queue entry.
drivers/scsi/lpfc/lpfc_sli.c: * This routine process a fast-path work queue completion entry from fast-path
drivers/scsi/lpfc/lpfc_sli.c: * event queue for FCP command response completion.
drivers/scsi/lpfc/lpfc_sli.c:		phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_sli.c:		phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_sli.c: * completion event on a completion queue, if not, an error shall be logged
drivers/scsi/lpfc/lpfc_sli.c: * and just return. Otherwise, it will get to the corresponding completion
drivers/scsi/lpfc/lpfc_sli.c: * queue and process all the entries on the completion queue, rearm the
drivers/scsi/lpfc/lpfc_sli.c: * completion queue, and then return.
drivers/scsi/lpfc/lpfc_sli.c:				"0366 Not a valid completion "
drivers/scsi/lpfc/lpfc_sli.c:				"3146 Fast-path completion queues "
drivers/scsi/lpfc/lpfc_sli.c:					"0367 Fast-path completion queue "
drivers/scsi/lpfc/lpfc_sli.c:				"0368 Miss-matched fast-path completion "
drivers/scsi/lpfc/lpfc_sli.c:				"0369 No entry from fast-path completion "
drivers/scsi/lpfc/lpfc_sli.c: * is for a completion event on a completion queue, if not, an error shall be
drivers/scsi/lpfc/lpfc_sli.c: * completion queue and process all the entries on the completion queue, rearm
drivers/scsi/lpfc/lpfc_sli.c: * the completion queue, and then return.
drivers/scsi/lpfc/lpfc_sli.c:				"9147 Not a valid completion "
drivers/scsi/lpfc/lpfc_sli.c:					"9148 OAS completion queue "
drivers/scsi/lpfc/lpfc_sli.c:				"9153 No entry from fast-path completion "
drivers/scsi/lpfc/lpfc_sli.c: * @cq: The queue structure to use to create the completion queue.
drivers/scsi/lpfc/lpfc_sli.c: * @eq: The event queue to bind this completion queue to.
drivers/scsi/lpfc/lpfc_sli.c: * This function creates a completion queue, as detailed in @wq, on a port,
drivers/scsi/lpfc/lpfc_sli.c: * is used to indicate which event queue to bind this completion queue to. This
drivers/scsi/lpfc/lpfc_sli.c: * completion queue. This function is asynchronous and will wait for the mailbox
drivers/scsi/lpfc/lpfc_sli.c:	/* Set up completion queue's type and subtype */
drivers/scsi/lpfc/lpfc_sli.c: * @cq: The completion queue to associate with this cq.
drivers/scsi/lpfc/lpfc_sli.c: * @cq: The completion queue to associate with this cq.
drivers/scsi/lpfc/lpfc_sli.c: * @cq: The completion queue to bind this work queue to.
drivers/scsi/lpfc/lpfc_sli.c: * is used to indicate which completion queue to bind this work queue to. This
drivers/scsi/lpfc/lpfc_sli.c: * @cq: The completion queue to bind this work queue to.
drivers/scsi/lpfc/lpfc_sli.c: * completion queue to bind received buffers that are posted to these queues to.
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_mbx_cmpl_add_fcf_record - add fcf mbox completion handler.
drivers/scsi/lpfc/lpfc_sli.c: * lpfc_mbx_cmpl_redisc_fcf_table - completion routine for rediscover FCF table
drivers/scsi/lpfc/lpfc_sli.c: * This routine is the completion routine for the rediscover FCF table mailbox
drivers/scsi/lpfc/lpfc_sli.c:	/* Cleanup any mailbox completions which are not yet processed */
drivers/scsi/lpfc/lpfc_sli.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_sli.c:			list_add_tail(&piocbq->list, &completions);
drivers/scsi/lpfc/lpfc_sli.c:	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
drivers/scsi/lpfc/lpfc_ct.c: * @cmpl: completion routine to call when command completes
drivers/scsi/lpfc/lpfc_ct.c:	/* Save for completion so we can release these resources */
drivers/scsi/lpfc/lpfc_ct.c: * @cmpl: completion routine to call when command completes
drivers/scsi/lpfc/lpfc_ct.c: * lpfc_cmpl_ct_disc_fdmi - Handle a discovery FDMI completion
drivers/scsi/lpfc/lpfc_ct.c: * This function to handle the completion of a driver initiated FDMI
drivers/scsi/lpfc/lpfc_vport.c:	 * release the other at the completion of the unreg_vpi that get's
drivers/scsi/lpfc/lpfc.h:	unsigned long last_completion_time;
drivers/scsi/lpfc/lpfc_sli4.h:	struct lpfc_queue *oas_cq; /* OAS completion queue */
drivers/scsi/lpfc/lpfc_scsi.c: * lpfc_update_stats - Update statistical data for the command completion
drivers/scsi/lpfc/lpfc_scsi.c: * This function is called when there is a command completion and this
drivers/scsi/lpfc/lpfc_scsi.c: * function updates the statistical data for the command completion.
drivers/scsi/lpfc/lpfc_scsi.c:					 * restore it on completion.
drivers/scsi/lpfc/lpfc_scsi.c:					 * restore it on completion.
drivers/scsi/lpfc/lpfc_scsi.c: * lpfc_scsi_cmd_iocb_cmpl - Scsi cmnd IOCB completion routine
drivers/scsi/lpfc/lpfc_scsi.c:	 * If there is a thread waiting for command completion
drivers/scsi/lpfc/lpfc_scsi.c: * lpfc_taskmgmt_def_cmpl - IOCB completion routine for task management command
drivers/scsi/lpfc/lpfc_scsi.c: * This routine is IOCB completion routine for device reset and target reset
drivers/scsi/lpfc/lpfc_scsi.c:	 * Store the midlayer's command structure for the completion phase
drivers/scsi/lpfc/lpfc_scsi.c:	 * see the completion before the eh fired. Just return SUCCESS.
drivers/scsi/lpfc/lpfc_scsi.c: * outstanding, then waits for their completions. The wait is
drivers/scsi/lpfc/lpfc_hbadisc.c:			complete((struct completion *)(evtp->evt_arg2));
drivers/scsi/lpfc/lpfc_hbadisc.c:			complete((struct completion *)(evtp->evt_arg2));
drivers/scsi/lpfc/lpfc_hbadisc.c:			complete((struct completion *)(evtp->evt_arg2));
drivers/scsi/lpfc/lpfc_hbadisc.c:			complete((struct completion *)(evtp->evt_arg2));
drivers/scsi/lpfc/lpfc_hbadisc.c:			complete((struct completion *)(evtp->evt_arg2));
drivers/scsi/lpfc/lpfc_hbadisc.c:	 * All Mailbox completions and LPFC_ELS_RING rcv ring IOCB events will
drivers/scsi/lpfc/lpfc_hbadisc.c: * command upon completion. It is setup in the LPFC_MBOXQ
drivers/scsi/lpfc/lpfc_hbadisc.c: * as the completion routine when the command is
drivers/scsi/lpfc/lpfc_hbadisc.c:	/* Mark successful completion of FCF table scan */
drivers/scsi/lpfc/lpfc_hbadisc.c: * lpfc_mbx_cmpl_read_fcf_rec - read fcf completion handler.
drivers/scsi/lpfc/lpfc_hbadisc.c: * This function handles completion of init vfi mailbox command.
drivers/scsi/lpfc/lpfc_hbadisc.c: * This function handles completion of init vpi mailbox command.
drivers/scsi/lpfc/lpfc_hbadisc.c: * command upon completion. It is setup in the LPFC_MBOXQ
drivers/scsi/lpfc/lpfc_hbadisc.c: * as the completion routine when the command is
drivers/scsi/lpfc/lpfc_hbadisc.c: * command upon completion. It is setup in the LPFC_MBOXQ
drivers/scsi/lpfc/lpfc_hbadisc.c: * as the completion routine when the command is
drivers/scsi/lpfc/lpfc_hbadisc.c: * command upon completion. It is setup in the LPFC_MBOXQ
drivers/scsi/lpfc/lpfc_hbadisc.c: * as the completion routine when the command is
drivers/scsi/lpfc/lpfc_hbadisc.c: * command upon completion. It is setup in the LPFC_MBOXQ
drivers/scsi/lpfc/lpfc_hbadisc.c: * as the completion routine when the command is
drivers/scsi/lpfc/lpfc_hbadisc.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_hbadisc.c:						       &completions);
drivers/scsi/lpfc/lpfc_hbadisc.c:	/* Cancel all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_hbadisc.c:	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
drivers/scsi/lpfc/lpfc_hbadisc.c: * lpfc_nlp_logo_unreg - Unreg mailbox completion handler before LOGO
drivers/scsi/lpfc/lpfc_hbadisc.c:	/* Cleanup REG_LOGIN completions which are not yet processed */
drivers/scsi/lpfc/lpfc_hbadisc.c: *  Ignore completion for all IOCBs on tx and txcmpl queue for ELS
drivers/scsi/lpfc/lpfc_hbadisc.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_hbadisc.c:			list_move_tail(&iocb->list, &completions);
drivers/scsi/lpfc/lpfc_hbadisc.c:	/* Cancel all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_hbadisc.c:	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
drivers/scsi/lpfc/lpfc_hbadisc.c:					 "completion error\n");
drivers/scsi/lpfc/lpfc_hbadisc.c: * command upon completion. It is setup in the LPFC_MBOXQ
drivers/scsi/lpfc/lpfc_hbadisc.c: * as the completion routine when the command is
drivers/scsi/lpfc/lpfc_bsg.c: * lpfc_bsg_send_mgmt_cmd_cmp - lpfc_bsg_send_mgmt_cmd's completion handler
drivers/scsi/lpfc/lpfc_bsg.c: * This function is the completion handler for iocbs issued using
drivers/scsi/lpfc/lpfc_bsg.c: * sleeps for the iocb completion.
drivers/scsi/lpfc/lpfc_bsg.c: * lpfc_bsg_rport_els_cmp - lpfc_bsg_rport_els's completion handler
drivers/scsi/lpfc/lpfc_bsg.c: * This function is the completion handler for iocbs issued using
drivers/scsi/lpfc/lpfc_bsg.c: * sleeps for the iocb completion.
drivers/scsi/lpfc/lpfc_bsg.c: * lpfc_issue_ct_rsp_cmp - lpfc_issue_ct_rsp's completion handler
drivers/scsi/lpfc/lpfc_bsg.c: * This function is the completion handler for iocbs issued using
drivers/scsi/lpfc/lpfc_bsg.c: * sleeps for the iocb completion.
drivers/scsi/lpfc/lpfc_bsg.c: * lpfc_bsg_issue_mbox_cmpl - lpfc_bsg_issue_mbox mbox completion handler
drivers/scsi/lpfc/lpfc_bsg.c: * This is completion handler function for mailbox commands issued from
drivers/scsi/lpfc/lpfc_bsg.c: * This is routine handles BSG job for mailbox commands completions with
drivers/scsi/lpfc/lpfc_bsg.c: * This is completion handler function for mailbox read commands with multiple
drivers/scsi/lpfc/lpfc_bsg.c: * This is completion handler function for mailbox write commands with multiple
drivers/scsi/lpfc/lpfc_bsg.c: * let our completion handler finish the command.
drivers/scsi/lpfc/lpfc_bsg.c: * lpfc_bsg_menlo_cmd_cmp - lpfc_menlo_cmd completion handler
drivers/scsi/lpfc/lpfc_bsg.c: * This function is the completion handler for iocbs issued using
drivers/scsi/lpfc/lpfc_bsg.c: * sleeps for the iocb completion.
drivers/scsi/lpfc/lpfc_bsg.c: * all the command completions will return the xri for the command.
drivers/scsi/lpfc/lpfc_bsg.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_bsg.c:	 * so the timeout is retried.  This avoids double completion issues
drivers/scsi/lpfc/lpfc_bsg.c:	 * command's completion handler executes.  Otherwise, prevent the
drivers/scsi/lpfc/lpfc_bsg.c:	 * command's completion handler from executing the job done callback
drivers/scsi/lpfc/lpfc_bsg.c:				list_move_tail(&check_iocb->list, &completions);
drivers/scsi/lpfc/lpfc_bsg.c:		if (list_empty(&completions))
drivers/scsi/lpfc/lpfc_bsg.c:		if (!list_empty(&completions)) {
drivers/scsi/lpfc/lpfc_bsg.c:			lpfc_sli_cancel_iocbs(phba, &completions,
drivers/scsi/lpfc/lpfc_bsg.c:				list_move_tail(&check_iocb->list, &completions);
drivers/scsi/lpfc/lpfc_bsg.c:		if (list_empty(&completions))
drivers/scsi/lpfc/lpfc_bsg.c:		if (!list_empty(&completions)) {
drivers/scsi/lpfc/lpfc_bsg.c:			lpfc_sli_cancel_iocbs(phba, &completions,
drivers/scsi/lpfc/lpfc_init.c: * This is the completion handler for driver's configuring asynchronous event
drivers/scsi/lpfc/lpfc_init.c: * lpfc_dump_wakeup_param_cmpl - dump memory mailbox command completion handler
drivers/scsi/lpfc/lpfc_init.c: * This is the completion handler for dump mailbox command for getting
drivers/scsi/lpfc/lpfc_init.c:	phba->last_completion_time = jiffies;
drivers/scsi/lpfc/lpfc_init.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_init.c:		list_splice_init(&pring->txcmplq, &completions);
drivers/scsi/lpfc/lpfc_init.c:		/* Cancel all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_init.c:		lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
drivers/scsi/lpfc/lpfc_init.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_init.c:	if (time_after(phba->last_completion_time +
drivers/scsi/lpfc/lpfc_init.c:		list_splice_init(&phba->elsbuf, &completions);
drivers/scsi/lpfc/lpfc_init.c:		while (!list_empty(&completions)) {
drivers/scsi/lpfc/lpfc_init.c:			list_remove_head(&completions, buf_ptr,
drivers/scsi/lpfc/lpfc_init.c:			} else if (time_before_eq(phba->last_completion_time,
drivers/scsi/lpfc/lpfc_init.c:					"2857 Last completion time not "
drivers/scsi/lpfc/lpfc_init.c:						 - phba->last_completion_time));
drivers/scsi/lpfc/lpfc_init.c:						 - phba->last_completion_time));
drivers/scsi/lpfc/lpfc_init.c: * @acqe_link: pointer to the async link completion queue entry.
drivers/scsi/lpfc/lpfc_init.c: * @acqe_link: pointer to the async link completion queue entry.
drivers/scsi/lpfc/lpfc_init.c: * @acqe_link: pointer to the async link completion queue entry.
drivers/scsi/lpfc/lpfc_init.c:	 * the READ_TOPOLOGY completion routine to continue without actually
drivers/scsi/lpfc/lpfc_init.c: * @acqe_fc: pointer to the async fc completion queue entry.
drivers/scsi/lpfc/lpfc_init.c: * @acqe_fc: pointer to the async SLI completion queue entry.
drivers/scsi/lpfc/lpfc_init.c: * @acqe_link: pointer to the async fcoe completion queue entry.
drivers/scsi/lpfc/lpfc_init.c: * @acqe_link: pointer to the async dcbx completion queue entry.
drivers/scsi/lpfc/lpfc_init.c: * @acqe_link: pointer to the async grp5 completion queue entry.
drivers/scsi/lpfc/lpfc_init.c:		/* Free the completion event processed to the free pool */
drivers/scsi/lpfc/lpfc_init.c: * rediscovery pending completion event.
drivers/scsi/lpfc/lpfc_init.c:	/* Free the completion queue EQ event pool */
drivers/scsi/lpfc/lpfc_init.c:		/* Release FCP completion queue */
drivers/scsi/lpfc/lpfc_init.c: * lpfc_sli4_cq_event_pool_create - Create completion-queue event free pool
drivers/scsi/lpfc/lpfc_init.c: * This routine is invoked to allocate and set up a pool of completion queue
drivers/scsi/lpfc/lpfc_init.c: * events. The body of the completion queue event is a completion queue entry
drivers/scsi/lpfc/lpfc_init.c: * the following HBA completion queue events for the worker thread to process:
drivers/scsi/lpfc/lpfc_init.c: *   - Receive queue completion unsolicited events
drivers/scsi/lpfc/lpfc_init.c: * lpfc_sli4_cq_event_pool_destroy - Free completion-queue event free pool
drivers/scsi/lpfc/lpfc_init.c: * This routine is invoked to free the pool of completion queue events at
drivers/scsi/lpfc/lpfc_init.c: * cleanup routine to free all the outstanding completion-queue events
drivers/scsi/lpfc/lpfc_init.c: * __lpfc_sli4_cq_event_alloc - Allocate a completion-queue event from free pool
drivers/scsi/lpfc/lpfc_init.c: * completion-queue event from the free pool.
drivers/scsi/lpfc/lpfc_init.c: * Return: Pointer to the newly allocated completion-queue event if successful
drivers/scsi/lpfc/lpfc_init.c: * lpfc_sli4_cq_event_alloc - Allocate a completion-queue event from free pool
drivers/scsi/lpfc/lpfc_init.c: * completion-queue event from the free pool.
drivers/scsi/lpfc/lpfc_init.c: * Return: Pointer to the newly allocated completion-queue event if successful
drivers/scsi/lpfc/lpfc_init.c: * __lpfc_sli4_cq_event_release - Release a completion-queue event to free pool
drivers/scsi/lpfc/lpfc_init.c: * @cq_event: pointer to the completion queue event to be freed.
drivers/scsi/lpfc/lpfc_init.c: * completion-queue event back into the free pool.
drivers/scsi/lpfc/lpfc_init.c: * lpfc_sli4_cq_event_release - Release a completion-queue event to free pool
drivers/scsi/lpfc/lpfc_init.c: * @cq_event: pointer to the completion queue event to be freed.
drivers/scsi/lpfc/lpfc_init.c: * completion-queue event back into the free pool.
drivers/scsi/lpfc/lpfc_init.c: * This routine is to free all the pending completion-queue events to the
drivers/scsi/lpfc/lpfc_init.c: * This function is called in the SLI4 code path to wait for completion
drivers/scsi/lpfc/lpfc_init.c:	/* Wait for completion of device XRI exchange busy */
drivers/scsi/lpfc/lpfc_init.c: * for the completion.  The expectation is that this routine is called
drivers/scsi/lpfc/lpfc_init.c: * for the completion.  The expectation is that this routine is called
drivers/scsi/lpfc/lpfc_nportdisc.c:	/* Cancel all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_nportdisc.c: * lpfc_mbx_cmpl_resume_rpi - Resume RPI completion routine
drivers/scsi/lpfc/lpfc_nportdisc.c: * This routine is invoked to issue a completion to a rcv'ed
drivers/scsi/lpfc/lpfc_nportdisc.c: * state changed to PRLI_ISSUE. When the PRLI completion occurs, the state is
drivers/scsi/lpfc/lpfc_nportdisc.c: * changed to UNMAPPED_NODE. If the completion indicates a mapped
drivers/scsi/lpfc/lpfc_nportdisc.c: * handling. Upon completion, ALL nodes should be on either the mapped or
drivers/scsi/lpfc/lpfc_attr.c:	struct completion online_compl;
drivers/scsi/lpfc/lpfc_attr.c:	init_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:	wait_for_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:	init_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:	wait_for_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:	struct completion online_compl;
drivers/scsi/lpfc/lpfc_attr.c:	init_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:	wait_for_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:	struct completion online_compl;
drivers/scsi/lpfc/lpfc_attr.c:	init_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:	wait_for_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:	struct completion online_compl;
drivers/scsi/lpfc/lpfc_attr.c:	init_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:		wait_for_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:	struct completion online_compl;
drivers/scsi/lpfc/lpfc_attr.c:	init_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:	wait_for_completion(&online_compl);
drivers/scsi/lpfc/lpfc_attr.c:# lpfc_max_scsicmpl_time: Use scsi command completion time to control I/O queue
drivers/scsi/lpfc/lpfc_attr.c:# SCSI command completion time is not used for controlling I/O queue depth. When
drivers/scsi/lpfc/lpfc_attr.c:# to limit the I/O completion time to the parameter value.
drivers/scsi/lpfc/lpfc_attr.c:	"Use command completion time to control queue depth");
drivers/scsi/lpfc/lpfc_attr.c:LPFC_ATTR_RW(cr_count, 1, 1, 255, "A count of I/O completions after which an "
drivers/scsi/lpfc/lpfc_attr.c:# lpfc_fcp_look_ahead: Look ahead for completions in FCP start routine
drivers/scsi/lpfc/lpfc_attr.c: * Driver always delay Nport discovery for subsequent FLOGI/FDISC completion
drivers/scsi/lpfc/lpfc_els.c: * This routine is called from FLOGI/FDISC completion handler functions.
drivers/scsi/lpfc/lpfc_els.c: * node nodename is changed in the completion service parameter else return
drivers/scsi/lpfc/lpfc_els.c: * NP_Port discovery after the FLOGI/FDISC completion if Clean address bit
drivers/scsi/lpfc/lpfc_els.c: * node nodename is changed in the completion service parameter.
drivers/scsi/lpfc/lpfc_els.c: * This routine is invoked by the lpfc_cmpl_els_flogi() completion callback
drivers/scsi/lpfc/lpfc_els.c: * function to handle the completion of a Fabric Login (FLOGI) into a fabric
drivers/scsi/lpfc/lpfc_els.c: * This routine is invoked by the lpfc_cmpl_els_flogi() completion callback
drivers/scsi/lpfc/lpfc_els.c: * function to handle the completion of a Fabric Login (FLOGI) into an N_Port
drivers/scsi/lpfc/lpfc_els.c: * This routine is the top-level completion callback function for issuing
drivers/scsi/lpfc/lpfc_els.c: * specific topology completion conditions.
drivers/scsi/lpfc/lpfc_els.c: * to lpfc_cmpl_els_flogi() routine is put to the IOCB completion callback
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion callback function for issuing the Port
drivers/scsi/lpfc/lpfc_els.c: * Login (PLOGI) command. For PLOGI completion, there must be an active
drivers/scsi/lpfc/lpfc_els.c: * (DSM) is set for this PLOGI completion. Finally, it checks whether
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion callback function for a Process Login
drivers/scsi/lpfc/lpfc_els.c: * ndlp to mark the PRLI completion.
drivers/scsi/lpfc/lpfc_els.c: * is put to the IOCB completion callback func field before invoking the
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c:		 * succeeded or failed because the ADISC completion
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion function for issuing the Address Discover
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion function for issuing the ELS Logout (LOGO)
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * This routine is a generic completion callback function for ELS commands.
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * IOCB completion callback function. If LPFC_DELAY_MEM_FREE flag is not
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion callback function to the Logout (LOGO)
drivers/scsi/lpfc/lpfc_els.c: * the completion of the LOGO process. It invokes the lpfc_nlp_not_used() to
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion callback function for unregister default
drivers/scsi/lpfc/lpfc_els.c: * decrements the ndlp reference count held for this completion callback
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion callback function for ELS Response IOCB
drivers/scsi/lpfc/lpfc_els.c: * field of the IOCB for the completion callback function to issue the
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * context_un.mbox field of the IOCB for the completion callback function
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: *   1 - Sent the acc response and waited for name server completion
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion callback function for the MBX_READ_LNK_STAT
drivers/scsi/lpfc/lpfc_els.c: * collects the link statistics from the completion of the MBX_READ_LNK_STAT
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion callback function for the MBX_READ_LNK_STAT
drivers/scsi/lpfc/lpfc_els.c: * collects the link statistics from the completion of the MBX_READ_LNK_STAT
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c:			/* Mbox completion will send ELS Response */
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c:				/* Mbox completion will send ELS Response */
drivers/scsi/lpfc/lpfc_els.c: * Successful the the completion handler will clear the RRQ.
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * the IOCBs with a non-NULL completion callback function, the callback
drivers/scsi/lpfc/lpfc_els.c: * un.ulpWord[4] set to IOERR_SLI_ABORTED. For IOCBs with a NULL completion
drivers/scsi/lpfc/lpfc_els.c: * the ELS transmit completion queue to issue an abort IOCB to any transmit
drivers/scsi/lpfc/lpfc_els.c: * completion queue IOCB that is associated with the @vport and is not
drivers/scsi/lpfc/lpfc_els.c: * abort IOCB to any transmit completion queueed IOCB, it does not guarantee
drivers/scsi/lpfc/lpfc_els.c:	/* Cancell all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_els.c: * the IOCBs with the completion callback function associated, the callback
drivers/scsi/lpfc/lpfc_els.c: * un.ulpWord[4] set to IOERR_SLI_ABORTED. For IOCBs without the completion
drivers/scsi/lpfc/lpfc_els.c: * it walks the ELS transmit completion queue to issue an abort IOCB to any
drivers/scsi/lpfc/lpfc_els.c: * transmit completion queue IOCB that is not an IOCB from libdfc (i.e., the
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion callback function to register new vport
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion callback function to a Fabric Discover
drivers/scsi/lpfc/lpfc_els.c: * single threaded, each FDISC completion callback function will reset
drivers/scsi/lpfc/lpfc_els.c: * assigned to the vport has been changed with the completion of the FDISC
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c: * This routine is the completion callback function to the issuing of a LOGO
drivers/scsi/lpfc/lpfc_els.c: * reference count held on ndlp for this completion function, indicating that
drivers/scsi/lpfc/lpfc_els.c: * will be stored into the context1 field of the IOCB for the completion
drivers/scsi/lpfc/lpfc_els.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_els.c:		list_move_tail(&piocb->list, &completions);
drivers/scsi/lpfc/lpfc_els.c:	/* Cancel all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_els.c:	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
drivers/scsi/lpfc/lpfc_els.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_els.c:			list_move_tail(&piocb->list, &completions);
drivers/scsi/lpfc/lpfc_els.c:	/* Cancel all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_els.c:	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
drivers/scsi/lpfc/lpfc_els.c:	LIST_HEAD(completions);
drivers/scsi/lpfc/lpfc_els.c:	list_splice_init(&phba->fabric_iocb_list, &completions);
drivers/scsi/lpfc/lpfc_els.c:	/* Cancel all the IOCBs from the completions list */
drivers/scsi/lpfc/lpfc_els.c:	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
drivers/scsi/lpfc/lpfc_hw4.h:/* completion queue entry structure (common fields for all cqe types) */
drivers/scsi/lpfc/lpfc_hw4.h:/* completion queue entry for wqe completions */
drivers/scsi/lpfc/lpfc_hw4.h:/* completion queue entry for wqe release */
drivers/scsi/lpfc/lpfc_hw4.h:/* completion queue entry structure for rqe completion */
drivers/scsi/lpfc/lpfc_hw4.h: * of a payload area of 256 bytes and a completion queue of length
drivers/scsi/sd.c:	rq->completion_data = page;
drivers/scsi/sd.c:	 * discarded on disk. This allows us to report completion on the full
drivers/scsi/sd.c:		__free_page(rq->completion_data);
drivers/scsi/sd.c: *	This function is called by the SCSI midlayer upon completion of an
drivers/scsi/cxlflash/common.h:	struct completion cevent;
drivers/scsi/cxlflash/sislite.h:#define SISL_MSI_RRQ_UPDATED       2	/* recommended for IO completion */
drivers/scsi/cxlflash/main.c:	cmd->sa.host_use[0] = 0; /* clears both completion and retry bytes */
drivers/scsi/cxlflash/main.c: * cmd_complete() - command completion handler
drivers/scsi/cxlflash/main.c:	timeout = wait_for_completion_timeout(&cmd->cevent, timeout);
drivers/scsi/cxlflash/main.c: *  in as part of the cleanup that occurs after the completion)
drivers/scsi/cxlflash/main.c:		init_completion(&cmd->cevent);
drivers/scsi/gdth.h:        volatile int wait_for_completion;
drivers/scsi/3w-sas.c:	/* First check for internal completion of set param for time sync */
drivers/scsi/3w-sas.c:		/* Now poll for completion */
drivers/scsi/3w-sas.c:	/* Poll for completion */
drivers/scsi/3w-sas.c:	/* Poll for completion */
drivers/scsi/3w-sas.c:		/* Check for internal command completion */
drivers/scsi/libiscsi_tcp.c:	 * lib iscsi will update this in the completion handling if there
drivers/scsi/BusLogic.c:	   Select an appropriate timeout value for awaiting command completion.
drivers/scsi/BusLogic.c:	   Wait 100 microseconds to allow completion of any initial diagnostic
drivers/scsi/BusLogic.c:	   queued for completion processing.
drivers/scsi/BusLogic.c:  blogic_qcompleted_ccb queues CCB for completion processing.
drivers/scsi/BusLogic.c:  Incoming Mailbox entries for completion processing.
drivers/scsi/BusLogic.c:	   completion processing is performed exactly once.  Therefore,
drivers/scsi/BusLogic.c:	   only Incoming Mailboxes with completion code Command Completed
drivers/scsi/BusLogic.c:	   At Host Request are saved for completion processing. When an
drivers/scsi/BusLogic.c:	   Incoming Mailbox has a completion code of Aborted Command Not
drivers/scsi/BusLogic.c:	   current Abort request was processed, and so completion processing
drivers/scsi/BusLogic.c:				   queue the CCB for completion processing.
drivers/scsi/BusLogic.c:			   performing completion processing for any CCBs
drivers/scsi/3w-xxxx.c:		/* Now poll for completion */
drivers/scsi/3w-xxxx.c:	/* Poll for completion */
drivers/scsi/3w-xxxx.c:	/* Poll for completion */
drivers/scsi/3w-xxxx.c:	/* Get the host lock for io completions */
drivers/scsi/3w-xxxx.c:			/* Check for internal command completion */
drivers/scsi/3w-xxxx.c:				/* Check for chrdev ioctl completion */
drivers/scsi/libiscsi.c:		 * Raced with completion. Blk layer has taken ownership
drivers/scsi/libiscsi.c: * for the completion.
drivers/scsi/53c700.c:#include <linux/completion.h>
drivers/scsi/53c700.c:	wait_for_completion(&complete);
drivers/scsi/arm/fas216.c:	 * Sanity check the completion - if we have zero bytes left
drivers/scsi/arm/fas216.h: * Purpose : queue a command for adapter to process, and process it to completion.
drivers/scsi/arm/acornscsi.c: *	      done - function called on completion, with pointer to command descriptor
drivers/scsi/libfc/fc_rport.c: * fc_rport_login_complete() - Handle parameters and completion of p-mp login.
drivers/scsi/libfc/fc_fcp.c: * callers to call the completion function while the lock is held and
drivers/scsi/libfc/fc_fcp.c:	 * and completes the transfer, call the completion handler.
drivers/scsi/libfc/fc_fcp.c:	 * call I/O completion if we do not have a SCSI command.
drivers/scsi/libfc/fc_fcp.c:	 * decided to force completion.
drivers/scsi/libfc/fc_fcp.c: * Called to send an abort and then wait for abort completion
drivers/scsi/libfc/fc_fcp.c:	init_completion(&fsp->tm_done);
drivers/scsi/libfc/fc_fcp.c:	ticks_left = wait_for_completion_timeout(&fsp->tm_done,
drivers/scsi/libfc/fc_fcp.c:	init_completion(&fsp->tm_done);
drivers/scsi/libfc/fc_fcp.c:	 * wait for completion of reset
drivers/scsi/libfc/fc_fcp.c:	rc = wait_for_completion_timeout(&fsp->tm_done, FC_SCSI_TM_TOV);
drivers/scsi/libfc/fc_exch.c: *	ULP completion.
drivers/scsi/libfc/fc_exch.c: *	RX-inferred completion.
drivers/scsi/libfc/fc_exch.c:	 * We must check for completion in case there are two threads
drivers/scsi/libfc/fc_disc.c: * @event: The discovery completion status
drivers/scsi/esp_scsi.c:#include <linux/completion.h>
drivers/scsi/esp_scsi.c:		     "Unexpected selection completion ireg[%x]\n", esp->ireg);
drivers/scsi/esp_scsi.c:	 * byte should be retrieved via PIO following completion
drivers/scsi/esp_scsi.c:	struct completion eh_done;
drivers/scsi/esp_scsi.c:	init_completion(&eh_done);
drivers/scsi/esp_scsi.c:	if (!wait_for_completion_timeout(&eh_done, 5 * HZ)) {
drivers/scsi/esp_scsi.c:	struct completion eh_reset;
drivers/scsi/esp_scsi.c:	init_completion(&eh_reset);
drivers/scsi/esp_scsi.c:	if (!wait_for_completion_timeout(&eh_reset, 5 * HZ)) {
drivers/scsi/esp_scsi.c:"	0x00000020	Log command completion\n"
drivers/scsi/libsas/sas_expander.c:	complete(&task->slow_task->completion);
drivers/scsi/libsas/sas_expander.c:	complete(&task->slow_task->completion);
drivers/scsi/libsas/sas_expander.c:		wait_for_completion(&task->slow_task->completion);
drivers/scsi/libsas/sas_init.c:	init_completion(&slow->completion);
drivers/scsi/libsas/sas_scsi_host.c:	 * any completions from the LLD.  Task is freed after this.
drivers/scsi/libsas/sas_scsi_host.c:	/* clean out any commands that won the completion vs eh race */
drivers/scsi/libsas/sas_scsi_host.c:	 * complete via the normal sas_task completion mechanism),
drivers/scsi/libsas/sas_scsi_host.c:	 * SAS_HA_FROZEN gives eh dominion over all sas_task completion.
drivers/scsi/libsas/sas_ata.c:static enum ata_completion_errors sas_to_ata_err(struct task_status_struct *ts)
drivers/scsi/libsas/sas_ata.c:	enum ata_completion_errors ac;
drivers/scsi/libsas/sas_ata.c:	struct completion *waiting;
drivers/scsi/storvsc_drv.c:#include <linux/completion.h>
drivers/scsi/storvsc_drv.c: * This flag indicates that the server should send back a completion for this
drivers/scsi/storvsc_drv.c:	struct completion wait_event;
drivers/scsi/storvsc_drv.c:	init_completion(&request->wait_event);
drivers/scsi/storvsc_drv.c:	t = wait_for_completion_timeout(&request->wait_event, 10*HZ);
drivers/scsi/storvsc_drv.c:	init_completion(&request->wait_event);
drivers/scsi/storvsc_drv.c:	t = wait_for_completion_timeout(&request->wait_event, 5*HZ);
drivers/scsi/storvsc_drv.c:static void storvsc_command_completion(struct storvsc_cmd_request *cmd_request,
drivers/scsi/storvsc_drv.c:static void storvsc_on_io_completion(struct storvsc_device *stor_device,
drivers/scsi/storvsc_drv.c:	storvsc_command_completion(request, stor_device);
drivers/scsi/storvsc_drv.c:		storvsc_on_io_completion(stor_device, vstor_packet, request);
drivers/scsi/storvsc_drv.c:	init_completion(&request->wait_event);
drivers/scsi/storvsc_drv.c:	t = wait_for_completion_timeout(&request->wait_event, 5*HZ);
drivers/scsi/scsi_transport_fc.c: * fc_bsg_jobdone - completion routine for bsg requests that the LLD has
drivers/scsi/scsi_transport_fc.c:	 * reformatted as a fc bsg request. And on completion, we have
drivers/scsi/aha152x.c:#include <linux/completion.h>
drivers/scsi/aha152x.c:	struct completion *done;/* semaphore to block on */
drivers/scsi/aha152x.c:static int aha152x_internal_queue(Scsi_Cmnd *SCpnt, struct completion *complete,
drivers/scsi/aha152x.c:		printk(KERN_ERR "aha152x: reset_done w/o completion\n");
drivers/scsi/aha152x.c:	timeleft = wait_for_completion_timeout(&done, 100*HZ);
drivers/scsi/aha152x.c: * Run service completions on the card with interrupts enabled.
drivers/scsi/mac53c94.c:			printk(KERN_DEBUG "got intr %x on completion\n", intr);
drivers/scsi/virtio_scsi.c:	struct completion *comp;
drivers/scsi/virtio_scsi.c: * decrement reqs will be != 0; after the decrement the virtqueue completion
drivers/scsi/virtio_scsi.c:	wait_for_completion(&comp);
drivers/scsi/pm8001/pm8001_hwi.c:			ccb->open_retry = 1; /* Snub completion */
drivers/scsi/pm8001/pm8001_hwi.c: * mpi_ssp_completion- process the event that FW response to the SSP request.
drivers/scsi/pm8001/pm8001_hwi.c:mpi_ssp_completion(struct pm8001_hba_info *pm8001_ha , void *piomb)
drivers/scsi/pm8001/pm8001_hwi.c:	struct ssp_completion_resp *psspPayload;
drivers/scsi/pm8001/pm8001_hwi.c:	psspPayload = (struct ssp_completion_resp *)(piomb + 4);
drivers/scsi/pm8001/pm8001_hwi.c:/*See the comments for mpi_ssp_completion */
drivers/scsi/pm8001/pm8001_hwi.c:/*See the comments for mpi_ssp_completion */
drivers/scsi/pm8001/pm8001_hwi.c:mpi_sata_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)
drivers/scsi/pm8001/pm8001_hwi.c:	struct sata_completion_resp *psataPayload;
drivers/scsi/pm8001/pm8001_hwi.c:	psataPayload = (struct sata_completion_resp *)(piomb + 4);
drivers/scsi/pm8001/pm8001_hwi.c:/*See the comments for mpi_ssp_completion */
drivers/scsi/pm8001/pm8001_hwi.c:/*See the comments for mpi_ssp_completion */
drivers/scsi/pm8001/pm8001_hwi.c:mpi_smp_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)
drivers/scsi/pm8001/pm8001_hwi.c:	struct smp_completion_resp *psmpPayload;
drivers/scsi/pm8001/pm8001_hwi.c:	psmpPayload = (struct smp_completion_resp *)(piomb + 4);
drivers/scsi/pm8001/pm8001_hwi.c:	complete(pm8001_dev->setds_completion);
drivers/scsi/pm8001/pm8001_hwi.c:	complete(pm8001_ha->nvmd_completion);
drivers/scsi/pm8001/pm8001_hwi.c:		complete(pm8001_ha->nvmd_completion);
drivers/scsi/pm8001/pm8001_hwi.c:	complete(pm8001_ha->nvmd_completion);
drivers/scsi/pm8001/pm8001_hwi.c:	complete(pm8001_dev->dcompletion);
drivers/scsi/pm8001/pm8001_hwi.c:	complete(pm8001_ha->nvmd_completion);
drivers/scsi/pm8001/pm8001_hwi.c:				complete(phy->enable_completion);
drivers/scsi/pm8001/pm8001_hwi.c:		mpi_ssp_completion(pm8001_ha, piomb);
drivers/scsi/pm8001/pm8001_hwi.c:		mpi_smp_completion(pm8001_ha, piomb);
drivers/scsi/pm8001/pm8001_hwi.c:		mpi_sata_completion(pm8001_ha, piomb);
drivers/scsi/pm8001/pm8001_sas.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/pm8001/pm8001_sas.c:	pm8001_ha->phy[phy_id].enable_completion = &completion;
drivers/scsi/pm8001/pm8001_sas.c:			wait_for_completion(&completion);
drivers/scsi/pm8001/pm8001_sas.c:			wait_for_completion(&completion);
drivers/scsi/pm8001/pm8001_sas.c:			wait_for_completion(&completion);
drivers/scsi/pm8001/pm8001_sas.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/pm8001/pm8001_sas.c:	pm8001_device->dcompletion = &completion;
drivers/scsi/pm8001/pm8001_sas.c:	wait_for_completion(&completion);
drivers/scsi/pm8001/pm8001_sas.c:	complete(&task->slow_task->completion);
drivers/scsi/pm8001/pm8001_sas.c:	complete(&task->slow_task->completion);
drivers/scsi/pm8001/pm8001_sas.c:	DECLARE_COMPLETION_ONSTACK(completion_setstate);
drivers/scsi/pm8001/pm8001_sas.c:		wait_for_completion(&task->slow_task->completion);
drivers/scsi/pm8001/pm8001_sas.c:			pm8001_dev->setds_completion = &completion_setstate;
drivers/scsi/pm8001/pm8001_sas.c:			wait_for_completion(&completion_setstate);
drivers/scsi/pm8001/pm8001_sas.c:		wait_for_completion(&task->slow_task->completion);
drivers/scsi/pm8001/pm8001_sas.c:* This function handle the IT_NEXUS_XXX event or completion
drivers/scsi/pm8001/pm8001_sas.c:		DECLARE_COMPLETION_ONSTACK(completion_setstate);
drivers/scsi/pm8001/pm8001_sas.c:		pm8001_dev->setds_completion = &completion_setstate;
drivers/scsi/pm8001/pm8001_sas.c:		wait_for_completion(&completion_setstate);
drivers/scsi/pm8001/pm8001_sas.c:	DECLARE_COMPLETION_ONSTACK(completion_setstate);
drivers/scsi/pm8001/pm8001_sas.c:		pm8001_dev->setds_completion = &completion_setstate;
drivers/scsi/pm8001/pm8001_sas.c:		wait_for_completion(&completion_setstate);
drivers/scsi/pm8001/pm8001_hwi.h:	operation completion message */
drivers/scsi/pm8001/pm8001_hwi.h:struct sata_completion_resp {
drivers/scsi/pm8001/pm8001_hwi.h: * use to notify the completion of the device registration  (64 bytes)
drivers/scsi/pm8001/pm8001_hwi.h:struct ssp_completion_resp {
drivers/scsi/pm8001/pm8001_hwi.h:struct smp_completion_resp {
drivers/scsi/pm8001/pm80xx_hwi.h:	operation completion message */
drivers/scsi/pm8001/pm80xx_hwi.h:struct sata_completion_resp {
drivers/scsi/pm8001/pm80xx_hwi.h: * use to notify the completion of the device registration (64 bytes)
drivers/scsi/pm8001/pm80xx_hwi.h: * indicates the completion of PHY_START command (64 bytes)
drivers/scsi/pm8001/pm80xx_hwi.h: * indicates the completion of PHY_STOP command (64 bytes)
drivers/scsi/pm8001/pm80xx_hwi.h:struct ssp_completion_resp {
drivers/scsi/pm8001/pm80xx_hwi.h:struct smp_completion_resp {
drivers/scsi/pm8001/pm8001_sas.h:	struct completion	*enable_completion;
drivers/scsi/pm8001/pm8001_sas.h:	struct completion	*dcompletion;
drivers/scsi/pm8001/pm8001_sas.h:	struct completion	*setds_completion;
drivers/scsi/pm8001/pm8001_sas.h:	struct completion	*nvmd_completion;
drivers/scsi/pm8001/pm8001_init.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/pm8001/pm8001_init.c:	pm8001_ha->nvmd_completion = &completion;
drivers/scsi/pm8001/pm8001_init.c:	wait_for_completion(&completion);
drivers/scsi/pm8001/pm8001_init.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/pm8001/pm8001_init.c:	pm8001_ha->nvmd_completion = &completion;
drivers/scsi/pm8001/pm8001_init.c:	wait_for_completion(&completion);
drivers/scsi/pm8001/pm8001_init.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/pm8001/pm8001_init.c:		pm8001_ha->phy[i].enable_completion = &completion;
drivers/scsi/pm8001/pm8001_init.c:		wait_for_completion(&completion);
drivers/scsi/pm8001/pm80xx_hwi.c: * mpi_ssp_completion- process the event that FW response to the SSP request.
drivers/scsi/pm8001/pm80xx_hwi.c:mpi_ssp_completion(struct pm8001_hba_info *pm8001_ha , void *piomb)
drivers/scsi/pm8001/pm80xx_hwi.c:	struct ssp_completion_resp *psspPayload;
drivers/scsi/pm8001/pm80xx_hwi.c:	psspPayload = (struct ssp_completion_resp *)(piomb + 4);
drivers/scsi/pm8001/pm80xx_hwi.c:/*See the comments for mpi_ssp_completion */
drivers/scsi/pm8001/pm80xx_hwi.c:/*See the comments for mpi_ssp_completion */
drivers/scsi/pm8001/pm80xx_hwi.c:mpi_sata_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)
drivers/scsi/pm8001/pm80xx_hwi.c:	struct sata_completion_resp *psataPayload;
drivers/scsi/pm8001/pm80xx_hwi.c:	psataPayload = (struct sata_completion_resp *)(piomb + 4);
drivers/scsi/pm8001/pm80xx_hwi.c:/*See the comments for mpi_ssp_completion */
drivers/scsi/pm8001/pm80xx_hwi.c:/*See the comments for mpi_ssp_completion */
drivers/scsi/pm8001/pm80xx_hwi.c:mpi_smp_completion(struct pm8001_hba_info *pm8001_ha, void *piomb)
drivers/scsi/pm8001/pm80xx_hwi.c:	struct smp_completion_resp *psmpPayload;
drivers/scsi/pm8001/pm80xx_hwi.c:	psmpPayload = (struct smp_completion_resp *)(piomb + 4);
drivers/scsi/pm8001/pm80xx_hwi.c:			complete(phy->enable_completion);
drivers/scsi/pm8001/pm80xx_hwi.c:		mpi_ssp_completion(pm8001_ha, piomb);
drivers/scsi/pm8001/pm80xx_hwi.c:		mpi_smp_completion(pm8001_ha, piomb);
drivers/scsi/pm8001/pm80xx_hwi.c:		mpi_sata_completion(pm8001_ha, piomb);
drivers/scsi/pm8001/pm8001_ctl.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/pm8001/pm8001_ctl.c:	pm8001_ha->nvmd_completion = &completion;
drivers/scsi/pm8001/pm8001_ctl.c:	wait_for_completion(&completion);
drivers/scsi/pm8001/pm8001_ctl.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/pm8001/pm8001_ctl.c:	pm8001_ha->nvmd_completion = &completion;
drivers/scsi/pm8001/pm8001_ctl.c:	wait_for_completion(&completion);
drivers/scsi/pm8001/pm8001_ctl.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/pm8001/pm8001_ctl.c:		pm8001_ha->nvmd_completion = &completion;
drivers/scsi/pm8001/pm8001_ctl.c:		wait_for_completion(&completion);
drivers/scsi/imm.c:static int imm_completion(struct scsi_cmnd *cmd)
drivers/scsi/imm.c:			retv = imm_completion(cmd);
drivers/scsi/wd719x.c:/* process a SCB-completion interrupt */
drivers/scsi/osst.c:	struct completion *waiting;
drivers/scsi/osst.c:	init_completion(waiting);
drivers/scsi/osst.c:		wait_for_completion(waiting);
drivers/scsi/osst.c:	wait_for_completion(&(STp->wait));
drivers/scsi/osst.c:		 cmd[1] = 1;			/* Don't wait for completion */
drivers/scsi/isci/host.h: * @completion_queue: hw-producer driver-consumer communication ring
drivers/scsi/isci/host.h: * @completion_queue_get: tracks the driver 'head' of the ring to notify hw
drivers/scsi/isci/host.h:	u32 *completion_queue;
drivers/scsi/isci/host.h:	u32 completion_queue_get;
drivers/scsi/isci/host.h:	struct tasklet_struct completion_tasklet;
drivers/scsi/isci/host.h:void isci_host_completion_routine(unsigned long data);
drivers/scsi/isci/scu_completion_codes.h: * This file contains the constants and macros for the SCU hardware completion
drivers/scsi/isci/scu_completion_codes.h: * This macro constructs an SCU completion type
drivers/scsi/isci/scu_completion_codes.h: * These macros contain the SCU completion types SCU_COMPLETION_TYPE
drivers/scsi/isci/scu_completion_codes.h: * an SCU completion code.
drivers/scsi/isci/scu_completion_codes.h: * This macro returns the SCU completion type.
drivers/scsi/isci/scu_completion_codes.h:#define SCU_GET_COMPLETION_TYPE(completion_code) \
drivers/scsi/isci/scu_completion_codes.h:	((completion_code) & SCU_COMPLETION_TYPE_MASK)
drivers/scsi/isci/scu_completion_codes.h: * This macro returns the SCU completion status.
drivers/scsi/isci/scu_completion_codes.h:#define SCU_GET_COMPLETION_STATUS(completion_code) \
drivers/scsi/isci/scu_completion_codes.h:	((completion_code) & SCU_COMPLETION_STATUS_MASK)
drivers/scsi/isci/scu_completion_codes.h: * This macro returns the transport layer completion status.
drivers/scsi/isci/scu_completion_codes.h:#define SCU_GET_COMPLETION_TL_STATUS(completion_code) \
drivers/scsi/isci/scu_completion_codes.h:	((completion_code) & SCU_COMPLETION_TL_STATUS_MASK)
drivers/scsi/isci/scu_completion_codes.h: * This macro takes a completion code and performs the shift and mask
drivers/scsi/isci/scu_completion_codes.h: * operations to turn it into a completion code that can be compared to a
drivers/scsi/isci/scu_completion_codes.h:#define SCU_MAKE_COMPLETION_STATUS(completion_code) \
drivers/scsi/isci/scu_completion_codes.h:	((u32)(completion_code) << SCU_COMPLETION_TL_STATUS_SHIFT)
drivers/scsi/isci/scu_completion_codes.h:#define SCU_NORMALIZE_COMPLETION_STATUS(completion_code) \
drivers/scsi/isci/scu_completion_codes.h:		((completion_code) & SCU_COMPLETION_TL_STATUS_MASK) \
drivers/scsi/isci/scu_completion_codes.h: * This macro returns the SDMA completion status.
drivers/scsi/isci/scu_completion_codes.h:#define SCU_GET_COMPLETION_SDMA_STATUS(completion_code)	\
drivers/scsi/isci/scu_completion_codes.h:	((completion_code) & SCU_COMPLETION_SDMA_STATUS_MASK)
drivers/scsi/isci/scu_completion_codes.h: * This macro returns the Protocol Engine Group from the completion code.
drivers/scsi/isci/scu_completion_codes.h:#define SCU_GET_COMPLETION_PEG(completion_code)	\
drivers/scsi/isci/scu_completion_codes.h:	((completion_code) & SCU_COMPLETION_PEG_MASK)
drivers/scsi/isci/scu_completion_codes.h: * This macro reuturns the logical port index from the completion code.
drivers/scsi/isci/scu_completion_codes.h:#define SCU_GET_COMPLETION_PORT(completion_code) \
drivers/scsi/isci/scu_completion_codes.h:	((completion_code) & SCU_COMPLETION_PORT_MASK)
drivers/scsi/isci/scu_completion_codes.h: * This macro returns the PE index from the completion code.
drivers/scsi/isci/scu_completion_codes.h:#define SCU_GET_PROTOCOL_ENGINE_INDEX(completion_code) \
drivers/scsi/isci/scu_completion_codes.h:	(((completion_code) & SCU_COMPLETION_PE_MASK) >> SCU_COMPLETION_PE_SHIFT)
drivers/scsi/isci/scu_completion_codes.h: * This macro returns the index of the completion which is either a TCi or an
drivers/scsi/isci/scu_completion_codes.h: * RNi depending on the completion type.
drivers/scsi/isci/scu_completion_codes.h:#define SCU_GET_COMPLETION_INDEX(completion_code) \
drivers/scsi/isci/scu_completion_codes.h:	((completion_code) & SCU_COMPLETION_INDEX_MASK)
drivers/scsi/isci/scu_completion_codes.h: * completion.
drivers/scsi/isci/scu_completion_codes.h:#define SCU_GET_FRAME_INDEX(completion_code) \
drivers/scsi/isci/scu_completion_codes.h:		((completion_code) & SCU_UNSOLICITED_FRAME_MASK) \
drivers/scsi/isci/scu_completion_codes.h:#define SCU_GET_FRAME_ERROR(completion_code) \
drivers/scsi/isci/scu_completion_codes.h:	((completion_code) & SCU_UNSOLICITED_FRAME_ERROR_MASK)
drivers/scsi/isci/scu_completion_codes.h: * These constants represent normalized completion codes which must be shifted
drivers/scsi/isci/scu_completion_codes.h: * 18 bits to match it with the hardware completion code. In a 16-bit compiler,
drivers/scsi/isci/remote_device.c:		 * Since the RNC is ready, it's alright to finish completion
drivers/scsi/isci/remote_device.c:	/* Terminate and wait for the completions. */
drivers/scsi/isci/registers.h:	u32 completion_queue_lower;
drivers/scsi/isci/registers.h:	u32 completion_queue_upper;
drivers/scsi/isci/registers.h:	u32 completion_queue_put;
drivers/scsi/isci/registers.h:	u32 completion_queue_get;
drivers/scsi/isci/registers.h:	u32 completion_queue_control;
drivers/scsi/isci/registers.h:struct scu_completion_ram {
drivers/scsi/isci/registers.h:	struct scu_completion_ram cram;
drivers/scsi/isci/init.c:	tasklet_init(&ihost->completion_tasklet,
drivers/scsi/isci/init.c:		     isci_host_completion_routine, (unsigned long)ihost);
drivers/scsi/isci/isci.h:	 * This member indicates successful completion.
drivers/scsi/isci/isci.h:	 *  target device (mode pages, inquiry data, etc.). The completion routine
drivers/scsi/isci/isci.h:	 * of the controller is in a state that prevents successful completion.
drivers/scsi/isci/isci.h: *    completion status values.  Each value in this enumeration maps directly
drivers/scsi/isci/isci.h: *    completion status values.  Each value in this enumeration maps directly
drivers/scsi/isci/remote_node_context.h: * a TC completion where the remote node will be suspended by the hardware.
drivers/scsi/isci/request.c:#include "scu_completion_codes.h"
drivers/scsi/isci/request.c:		      "isci: request completion from wrong state (%s)\n",
drivers/scsi/isci/request.c:			       u32 completion_code)
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:		 * guaranteed to be received before this completion status is
drivers/scsi/isci/request.c:			ireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
drivers/scsi/isci/request.c:			ireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
drivers/scsi/isci/request.c:		ireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
drivers/scsi/isci/request.c:		ireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
drivers/scsi/isci/request.c:	/* In all cases we will treat this as the completion of the IO req. */
drivers/scsi/isci/request.c:				u32 completion_code)
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:		 * TODO: Should there be a state change for this completion?
drivers/scsi/isci/request.c:						       u32 completion_code)
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:			 completion_code);
drivers/scsi/isci/request.c:		 * All other completion status cause the IO to be complete.
drivers/scsi/isci/request.c:		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
drivers/scsi/isci/request.c:				    u32 completion_code)
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:		/* In the AWAIT RESPONSE state, any TC completion is
drivers/scsi/isci/request.c:		 * the connection and set TC completion with one of
drivers/scsi/isci/request.c:		/* All other completion status cause the IO to be complete.  If a NAK
drivers/scsi/isci/request.c:		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
drivers/scsi/isci/request.c:			   u32 completion_code)
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:		/* All other completion status cause the IO to be
drivers/scsi/isci/request.c:		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
drivers/scsi/isci/request.c:					u32 completion_code)
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:		/* All other completion status cause the IO to be
drivers/scsi/isci/request.c:		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
drivers/scsi/isci/request.c:stp_request_pio_await_h2d_completion_tc_event(struct isci_request *ireq,
drivers/scsi/isci/request.c:					      u32 completion_code)
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:		/* All other completion status cause the IO to be
drivers/scsi/isci/request.c:		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
drivers/scsi/isci/request.c:			      u32 completion_code)
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:		 * All other completion status cause the IO to be complete.
drivers/scsi/isci/request.c:		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
drivers/scsi/isci/request.c:						       u32 completion_code)
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:		 * completion.
drivers/scsi/isci/request.c:			/* If we have an error completion status for the
drivers/scsi/isci/request.c:	/* TODO Check to see if any of these completion status need to
drivers/scsi/isci/request.c:		/* All other completion status cause the IO to be complete. */
drivers/scsi/isci/request.c:		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
drivers/scsi/isci/request.c:static enum sci_status atapi_raw_completion(struct isci_request *ireq, u32 completion_code,
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:		/* All other completion status cause the IO to be complete.
drivers/scsi/isci/request.c:		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
drivers/scsi/isci/request.c:static enum sci_status atapi_data_tc_completion_handler(struct isci_request *ireq,
drivers/scsi/isci/request.c:							u32 completion_code)
drivers/scsi/isci/request.c:	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
drivers/scsi/isci/request.c:static int sci_request_smp_completion_status_is_tx_suspend(
drivers/scsi/isci/request.c:	unsigned int completion_status)
drivers/scsi/isci/request.c:	switch (completion_status) {
drivers/scsi/isci/request.c:static int sci_request_smp_completion_status_is_tx_rx_suspend(
drivers/scsi/isci/request.c:	unsigned int completion_status)
drivers/scsi/isci/request.c:static int sci_request_ssp_completion_status_is_tx_suspend(
drivers/scsi/isci/request.c:	unsigned int completion_status)
drivers/scsi/isci/request.c:	switch (completion_status) {
drivers/scsi/isci/request.c:static int sci_request_ssp_completion_status_is_tx_rx_suspend(
drivers/scsi/isci/request.c:	unsigned int completion_status)
drivers/scsi/isci/request.c:static int sci_request_stpsata_completion_status_is_tx_suspend(
drivers/scsi/isci/request.c:	unsigned int completion_status)
drivers/scsi/isci/request.c:	switch (completion_status) {
drivers/scsi/isci/request.c:static int sci_request_stpsata_completion_status_is_tx_rx_suspend(
drivers/scsi/isci/request.c:	unsigned int completion_status)
drivers/scsi/isci/request.c:	switch (completion_status) {
drivers/scsi/isci/request.c:static void sci_request_handle_suspending_completions(
drivers/scsi/isci/request.c:	u32 completion_code)
drivers/scsi/isci/request.c:		is_tx = sci_request_smp_completion_status_is_tx_suspend(
drivers/scsi/isci/request.c:			completion_code);
drivers/scsi/isci/request.c:		is_tx_rx = sci_request_smp_completion_status_is_tx_rx_suspend(
drivers/scsi/isci/request.c:			completion_code);
drivers/scsi/isci/request.c:		is_tx = sci_request_ssp_completion_status_is_tx_suspend(
drivers/scsi/isci/request.c:			completion_code);
drivers/scsi/isci/request.c:		is_tx_rx = sci_request_ssp_completion_status_is_tx_rx_suspend(
drivers/scsi/isci/request.c:			completion_code);
drivers/scsi/isci/request.c:		is_tx = sci_request_stpsata_completion_status_is_tx_suspend(
drivers/scsi/isci/request.c:			completion_code);
drivers/scsi/isci/request.c:			sci_request_stpsata_completion_status_is_tx_rx_suspend(
drivers/scsi/isci/request.c:				completion_code);
drivers/scsi/isci/request.c:sci_io_request_tc_completion(struct isci_request *ireq,
drivers/scsi/isci/request.c:			     u32 completion_code)
drivers/scsi/isci/request.c:	/* Decode those completions that signal upcoming suspension events. */
drivers/scsi/isci/request.c:	sci_request_handle_suspending_completions(
drivers/scsi/isci/request.c:		ireq, SCU_GET_COMPLETION_TL_STATUS(completion_code));
drivers/scsi/isci/request.c:		return request_started_state_tc_event(ireq, completion_code);
drivers/scsi/isci/request.c:						       completion_code);
drivers/scsi/isci/request.c:							   completion_code);
drivers/scsi/isci/request.c:		return smp_request_await_tc_event(ireq, completion_code);
drivers/scsi/isci/request.c:						       completion_code);
drivers/scsi/isci/request.c:							       completion_code);
drivers/scsi/isci/request.c:		return stp_request_pio_await_h2d_completion_tc_event(ireq,
drivers/scsi/isci/request.c:								     completion_code);
drivers/scsi/isci/request.c:		return pio_data_out_tx_done_tc_event(ireq, completion_code);
drivers/scsi/isci/request.c:						       completion_code);
drivers/scsi/isci/request.c:		return atapi_raw_completion(ireq, completion_code,
drivers/scsi/isci/request.c:		return atapi_raw_completion(ireq, completion_code,
drivers/scsi/isci/request.c:		return atapi_data_tc_completion_handler(ireq, completion_code);
drivers/scsi/isci/request.c:			 __func__, completion_code, req_state_name(state));
drivers/scsi/isci/request.c: *    completion for OPEN_REJECT conditions.
drivers/scsi/isci/request.c: *    controller-specific I/O completion error conditions.
drivers/scsi/isci/request.c:	 * Note that there are SCU completion codes being
drivers/scsi/isci/request.c:	 * a controller-specific completion code; these are left
drivers/scsi/isci/request.c:	/* Note that the only open reject completion codes seen here will be
drivers/scsi/isci/request.c:					     enum sci_io_status completion_status)
drivers/scsi/isci/request.c:		"task->data_dir = %d completion_status = 0x%x\n",
drivers/scsi/isci/request.c:		__func__, request, task, task->data_dir, completion_status);
drivers/scsi/isci/request.c:	switch (completion_status) {
drivers/scsi/isci/request.c:		if (completion_status == SCI_IO_SUCCESS_IO_DONE_EARLY) {
drivers/scsi/isci/request.c:		/* This is a special case, in that the I/O completion
drivers/scsi/isci/request.c:			"%s: invalid completion code: 0x%x - "
drivers/scsi/isci/request.c:			__func__, completion_status, request);
drivers/scsi/isci/request.c:static void sci_stp_request_started_non_data_await_h2d_completion_enter(struct sci_base_state_machine *sm)
drivers/scsi/isci/request.c:static void sci_stp_request_started_pio_await_h2d_completion_enter(struct sci_base_state_machine *sm)
drivers/scsi/isci/request.c:		.enter_state = sci_stp_request_started_non_data_await_h2d_completion_enter,
drivers/scsi/isci/request.c:		.enter_state = sci_stp_request_started_pio_await_h2d_completion_enter,
drivers/scsi/isci/request.c: * SCI_SUCCESS on successfull completion, or specific failure code.
drivers/scsi/isci/request.c: * SCI_SUCCESS on successfull completion, or specific failure code.
drivers/scsi/isci/request.c:	ireq->io_request_completion = NULL;
drivers/scsi/isci/port.c: * @completion_status: This parameter specifies the core status for the reset
drivers/scsi/isci/port.c:					  enum sci_status completion_status)
drivers/scsi/isci/port.c:		"%s: isci_port = %p, completion_status=%x\n",
drivers/scsi/isci/port.c:		     __func__, isci_port, completion_status);
drivers/scsi/isci/port.c:	isci_port->hard_reset_status = completion_status;
drivers/scsi/isci/port.c:	if (completion_status != SCI_SUCCESS) {
drivers/scsi/isci/port.c:			"%s: iport = %p; hard reset completion\n",
drivers/scsi/isci/request.h:	/* Note: "io_request_completion" is completed in two different ways
drivers/scsi/isci/request.h:	 * - regular requests are completed in the request completion callback
drivers/scsi/isci/request.h:	 * XXX kill io_request_completion
drivers/scsi/isci/request.h:	struct completion *io_request_completion;
drivers/scsi/isci/request.h:	 * non-NULL the saved frame must be released on IO request completion.
drivers/scsi/isci/request.h: * waiting for the TC completion notification for the H2D Register FIS
drivers/scsi/isci/request.h: * waiting for the TC completion notification for the H2D Register FIS
drivers/scsi/isci/request.h: * after receiving TC completion. While in this state IO request object is
drivers/scsi/isci/request.h: * task context completion after every frame submission, so in the
drivers/scsi/isci/request.h: * non-accelerated case we need to expect the completion for the "cdb" frame.
drivers/scsi/isci/request.h:sci_io_request_tc_completion(struct isci_request *ireq, u32 code);
drivers/scsi/isci/task.c:#include <linux/completion.h>
drivers/scsi/isci/task.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/isci/task.c:	/* Assign the pointer to the TMF's completion kernel wait structure. */
drivers/scsi/isci/task.c:	tmf->complete = &completion;
drivers/scsi/isci/task.c:	timeleft = wait_for_completion_timeout(&completion,
drivers/scsi/isci/task.c:	DECLARE_COMPLETION_ONSTACK(aborted_io_completion);
drivers/scsi/isci/task.c:	 * after completion in the core.
drivers/scsi/isci/task.c: * @completion_status: This parameter specifies the completion status from the
drivers/scsi/isci/task.c:			   enum sci_task_status completion_status)
drivers/scsi/isci/task.c:	struct completion *tmf_complete = NULL;
drivers/scsi/isci/task.c:		__func__, ireq, completion_status);
drivers/scsi/isci/task.c:		tmf->status = completion_status;
drivers/scsi/isci/host.c:#include "scu_completion_codes.h"
drivers/scsi/isci/host.c: * This macro will normalize the completion queue put pointer so its value can
drivers/scsi/isci/host.c: * This macro will normalize the completion queue event entry so its value can
drivers/scsi/isci/host.c: * This macro will normalize the completion queue get pointer so its value can
drivers/scsi/isci/host.c: * This macro will normalize the completion queue cycle pointer so it matches
drivers/scsi/isci/host.c: * the completion queue cycle bit
drivers/scsi/isci/host.c: * This macro will return the cycle bit of the completion queue entry
drivers/scsi/isci/host.c:static bool sci_controller_completion_queue_has_entries(struct isci_host *ihost)
drivers/scsi/isci/host.c:	u32 get_value = ihost->completion_queue_get;
drivers/scsi/isci/host.c:	    COMPLETION_QUEUE_CYCLE_BIT(ihost->completion_queue[get_index]))
drivers/scsi/isci/host.c:	if (sci_controller_completion_queue_has_entries(ihost))
drivers/scsi/isci/host.c:	 * emptied the completion queue from a previous interrupt
drivers/scsi/isci/host.c:	 * notified of an interrupt completion if we do not take this
drivers/scsi/isci/host.c:		tasklet_schedule(&ihost->completion_tasklet);
drivers/scsi/isci/host.c:	 * of an interrupt completion if we do not take this step.  We will mask
drivers/scsi/isci/host.c:static void sci_controller_task_completion(struct isci_host *ihost, u32 ent)
drivers/scsi/isci/host.c:		sci_io_request_tc_completion(ireq, ent);
drivers/scsi/isci/host.c:static void sci_controller_sdma_completion(struct isci_host *ihost, u32 ent)
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s: unknown completion type %x\n",
drivers/scsi/isci/host.c:static void sci_controller_event_completion(struct isci_host *ihost, u32 ent)
drivers/scsi/isci/host.c:static void sci_controller_process_completions(struct isci_host *ihost)
drivers/scsi/isci/host.c:	u32 completion_count = 0;
drivers/scsi/isci/host.c:		"%s: completion queue beginning get:0x%08x\n",
drivers/scsi/isci/host.c:		ihost->completion_queue_get);
drivers/scsi/isci/host.c:	/* Get the component parts of the completion queue */
drivers/scsi/isci/host.c:	get_index = NORMALIZE_GET_POINTER(ihost->completion_queue_get);
drivers/scsi/isci/host.c:	get_cycle = SMU_CQGR_CYCLE_BIT & ihost->completion_queue_get;
drivers/scsi/isci/host.c:	event_get = NORMALIZE_EVENT_POINTER(ihost->completion_queue_get);
drivers/scsi/isci/host.c:	event_cycle = SMU_CQGR_EVENT_CYCLE_BIT & ihost->completion_queue_get;
drivers/scsi/isci/host.c:		== COMPLETION_QUEUE_CYCLE_BIT(ihost->completion_queue[get_index])
drivers/scsi/isci/host.c:		completion_count++;
drivers/scsi/isci/host.c:		ent = ihost->completion_queue[get_index];
drivers/scsi/isci/host.c:			"%s: completion queue entry:0x%08x\n",
drivers/scsi/isci/host.c:			sci_controller_task_completion(ihost, ent);
drivers/scsi/isci/host.c:			sci_controller_sdma_completion(ihost, ent);
drivers/scsi/isci/host.c:			sci_controller_event_completion(ihost, ent);
drivers/scsi/isci/host.c:			sci_controller_event_completion(ihost, ent);
drivers/scsi/isci/host.c:				 "completion type %x\n",
drivers/scsi/isci/host.c:	if (completion_count > 0) {
drivers/scsi/isci/host.c:		ihost->completion_queue_get =
drivers/scsi/isci/host.c:		writel(ihost->completion_queue_get,
drivers/scsi/isci/host.c:		       &ihost->smu_registers->completion_queue_get);
drivers/scsi/isci/host.c:		"%s: completion queue ending get:0x%08x\n",
drivers/scsi/isci/host.c:		ihost->completion_queue_get);
drivers/scsi/isci/host.c:	    sci_controller_completion_queue_has_entries(ihost)) {
drivers/scsi/isci/host.c:		sci_controller_process_completions(ihost);
drivers/scsi/isci/host.c:	/* If we dont process any completions I am not sure that we want to do this.
drivers/scsi/isci/host.c:		tasklet_schedule(&ihost->completion_tasklet);
drivers/scsi/isci/host.c: * @completion_status: This parameter specifies the completion status from the
drivers/scsi/isci/host.c:static void isci_host_start_complete(struct isci_host *ihost, enum sci_status completion_status)
drivers/scsi/isci/host.c:	if (completion_status != SCI_SUCCESS)
drivers/scsi/isci/host.c:static void sci_controller_initialize_completion_queue(struct isci_host *ihost)
drivers/scsi/isci/host.c:	u32 completion_queue_control_value;
drivers/scsi/isci/host.c:	u32 completion_queue_get_value;
drivers/scsi/isci/host.c:	u32 completion_queue_put_value;
drivers/scsi/isci/host.c:	ihost->completion_queue_get = 0;
drivers/scsi/isci/host.c:	completion_queue_control_value =
drivers/scsi/isci/host.c:	writel(completion_queue_control_value,
drivers/scsi/isci/host.c:	       &ihost->smu_registers->completion_queue_control);
drivers/scsi/isci/host.c:	/* Set the completion queue get pointer and enable the queue */
drivers/scsi/isci/host.c:	completion_queue_get_value = (
drivers/scsi/isci/host.c:	writel(completion_queue_get_value,
drivers/scsi/isci/host.c:	       &ihost->smu_registers->completion_queue_get);
drivers/scsi/isci/host.c:	/* Set the completion queue put pointer */
drivers/scsi/isci/host.c:	completion_queue_put_value = (
drivers/scsi/isci/host.c:	writel(completion_queue_put_value,
drivers/scsi/isci/host.c:	       &ihost->smu_registers->completion_queue_put);
drivers/scsi/isci/host.c:	/* Initialize the cycle bit of the completion queue entries */
drivers/scsi/isci/host.c:		 * If get.cycle_bit != completion_queue.cycle_bit
drivers/scsi/isci/host.c:		 * its not a valid completion queue entry
drivers/scsi/isci/host.c:		ihost->completion_queue[index] = 0x80000000;
drivers/scsi/isci/host.c:	/* Now initialize the completion queue */
drivers/scsi/isci/host.c:	sci_controller_initialize_completion_queue(ihost);
drivers/scsi/isci/host.c:static void sci_controller_completion_handler(struct isci_host *ihost)
drivers/scsi/isci/host.c:	/* Empty out the completion queue */
drivers/scsi/isci/host.c:	if (sci_controller_completion_queue_has_entries(ihost))
drivers/scsi/isci/host.c:		sci_controller_process_completions(ihost);
drivers/scsi/isci/host.c: * isci_host_completion_routine() - This function is the delayed service
drivers/scsi/isci/host.c: *    routine that calls the sci core library's completion handler. It's
drivers/scsi/isci/host.c:void isci_host_completion_routine(unsigned long data)
drivers/scsi/isci/host.c:	sci_controller_completion_handler(ihost);
drivers/scsi/isci/host.c: *    completion.  The completion callback is called when the following
drivers/scsi/isci/host.c: *    out.  No IO completions for outstanding devices occur.  Outstanding IO
drivers/scsi/isci/host.c:	writel(0x00000000, &ihost->smu_registers->completion_queue_get);
drivers/scsi/isci/host.c:	if (ihost->completion_queue)
drivers/scsi/isci/host.c:	ihost->completion_queue = dmam_alloc_coherent(dev, size, &ihost->cq_dma,
drivers/scsi/isci/host.c:	if (!ihost->completion_queue)
drivers/scsi/isci/host.c:	writel(lower_32_bits(ihost->cq_dma), &ihost->smu_registers->completion_queue_lower);
drivers/scsi/isci/host.c:	writel(upper_32_bits(ihost->cq_dma), &ihost->smu_registers->completion_queue_upper);
drivers/scsi/isci/host.c: *    completion operations for an IO request.  After this method is invoked,
drivers/scsi/isci/task.h:	struct completion *complete;
drivers/scsi/isci/task.h:	enum sci_task_status completion_status);
drivers/scsi/isci/phy.c:		/* Change state to the final state this substate machine has run to completion */
drivers/scsi/isci/phy.c:		/* Change state to the final state this substate machine has run to completion */
drivers/scsi/isci/phy.c:	 * instead of a SATA PHY. This is done because the completion queue had a SAS
drivers/scsi/isci/phy.c:	 * instead of a SAS PHY.  This is done because the completion queue had a SATA
drivers/scsi/isci/phy.c: *    all protocols upon completion of link training.
drivers/scsi/isci/phy.c:			 * the completion queue while waiting for power
drivers/scsi/isci/phy.c:	/* State machine has run to completion so exit out and change
drivers/scsi/st.h:#include <linux/completion.h>
drivers/scsi/st.h:	struct completion *waiting;
drivers/scsi/st.h:	struct completion wait;	/* For SCSI commands */
drivers/scsi/atp870u.c: *	@done: completion function
drivers/scsi/scsi_dh.c: * @fn   - Function to be called upon completion of the activation.
drivers/scsi/scsi_dh.c: * @data - data passed to the function fn upon completion.
drivers/scsi/fcoe/fcoe.c: * Must be called with fcoe_create_mutex held to single-thread completion.
drivers/scsi/megaraid/megaraid_sas_fusion.c:			dev_dbg(&instance->pdev->dev, "TM completion:"
drivers/scsi/megaraid/megaraid_sas_fusion.c:	 * on completion. For cmds with this flag, don't call
drivers/scsi/megaraid/megaraid_sas_fusion.c:	init_completion(&cmd_fusion->done);
drivers/scsi/megaraid/megaraid_sas_fusion.c:	timeleft = wait_for_completion_timeout(&cmd_fusion->done, 50 * HZ);
drivers/scsi/megaraid/megaraid_sas_fusion.h:	struct completion done;
drivers/scsi/megaraid/mega_common.h: * @status		: completion status
drivers/scsi/megaraid/megaraid_sas.h: * MFI command completion codes
drivers/scsi/megaraid/megaraid_sas.h:	spinlock_t completion_lock;
drivers/scsi/megaraid/megaraid_sas_base.c:	spin_lock_irqsave(&instance->completion_lock, flags);
drivers/scsi/megaraid/megaraid_sas_base.c:	spin_unlock_irqrestore(&instance->completion_lock, flags);
drivers/scsi/megaraid/megaraid_sas_base.c:			 * Call cmd completion routine. Cmd to be
drivers/scsi/megaraid/megaraid_sas_base.c:		 * was via IOCTL, we will send it to internal completion.
drivers/scsi/megaraid/megaraid_sas_base.c: * completion of the internal reset sequence. if the internal reset
drivers/scsi/megaraid/megaraid_sas_base.c:	spin_lock_init(&instance->completion_lock);
drivers/scsi/megaraid/megaraid_mbox.c:	// completion, firmware would write the valid id.
drivers/scsi/am53c974.c:	 * spurious DMA completion interrupts when using
drivers/scsi/sense_codes.h:SENSE_CODE(0x4B0F, "PCIe completion timeout")
drivers/scsi/scsi_error.c: *     only in that the normal completion handling might run, but if the
drivers/scsi/scsi_error.c: *     normal completion function determines that the timer has already
drivers/scsi/scsi_error.c:	scsi_log_completion(scmd, TIMEOUT_ERROR);
drivers/scsi/scsi_error.c:		 * Pass the UA upwards for a determination in the completion
drivers/scsi/scsi_error.c:	struct completion *eh_action;
drivers/scsi/scsi_error.c:		timeleft = wait_for_completion_timeout(&done, timeout);
drivers/scsi/scsi_error.c:	scsi_log_completion(scmd, rtn);
drivers/scsi/scsi_error.c: *    We don't want to use the normal command completion while we are are
drivers/scsi/scsi_error.c: *    keep a list of pending commands for final completion, and once we
drivers/scsi/scsi_error.c: *    are ready to leave error handling we handle completion for real.
drivers/scsi/bnx2fc/bnx2fc_fcoe.c:	init_completion(&hba->stat_req_done);
drivers/scsi/bnx2fc/bnx2fc_fcoe.c:	rc = wait_for_completion_timeout(&hba->stat_req_done, (2 * HZ));
drivers/scsi/bnx2fc/bnx2fc_io.c:	init_completion(&io_req->tm_done);
drivers/scsi/bnx2fc/bnx2fc_io.c:	rc = wait_for_completion_timeout(&io_req->tm_done,
drivers/scsi/bnx2fc/bnx2fc_io.c:		rc = wait_for_completion_timeout(&io_req->tm_done,
drivers/scsi/bnx2fc/bnx2fc_io.c:	wait_for_completion(&io_req->tm_done);
drivers/scsi/bnx2fc/bnx2fc_io.c:	 * as part of task management completion and eh_abort
drivers/scsi/bnx2fc/bnx2fc_io.c:	init_completion(&io_req->tm_done);
drivers/scsi/bnx2fc/bnx2fc_io.c:		wait_for_completion(&io_req->tm_done);
drivers/scsi/bnx2fc/bnx2fc_io.c:	wait_for_completion(&io_req->tm_done);
drivers/scsi/bnx2fc/bnx2fc_io.c:		 * between timeout and abts completion, and abts
drivers/scsi/bnx2fc/bnx2fc_io.c:		 * completion happens just in time.
drivers/scsi/bnx2fc/bnx2fc_io.c:		 * of task management completion, or
drivers/scsi/bnx2fc/bnx2fc_io.c:		 * delayed completion. Ignore completion
drivers/scsi/bnx2fc/bnx2fc_io.c:			/* Good IO completion */
drivers/scsi/bnx2fc/bnx2fc_io.c:	/* Cancel the timeout_work, as we received IO completion */
drivers/scsi/bnx2fc/bnx2fc_io.c:	/* Fetch fcp_rsp from task context and perform cmd completion */
drivers/scsi/bnx2fc/bnx2fc_io.c:		 * between command abort and (late) completion.
drivers/scsi/bnx2fc/bnx2fc_io.c:			/* Good IO completion */
drivers/scsi/bnx2fc/bnx2fc_tgt.c:	/* fake upload completion */
drivers/scsi/bnx2fc/bnx2fc_tgt.c:	 * Upon completion of offload process add
drivers/scsi/bnx2fc/bnx2fc_tgt.c: * This event_callback is called after successful completion of libfc
drivers/scsi/bnx2fc/bnx2fc_tgt.c:			 * In offload/enable completion path, the
drivers/scsi/bnx2fc/bnx2fc_hwi.c:		 * completion with FW error.
drivers/scsi/bnx2fc/bnx2fc_hwi.c:	/* Timestamp IO completion time */
drivers/scsi/bnx2fc/bnx2fc_hwi.c:	/* Process other IO completion types */
drivers/scsi/bnx2fc/bnx2fc_hwi.c:			/* Pending work request completion */
drivers/scsi/bnx2fc/bnx2fc_hwi.c:			/* Pending work request completion */
drivers/scsi/bnx2fc/bnx2fc_hwi.c: * bnx2fc_process_ofld_cmpl - process FCoE session offload completion
drivers/scsi/bnx2fc/bnx2fc_hwi.c: * handle session offload completion, enable the session if offload is
drivers/scsi/bnx2fc/bnx2fc_hwi.c:	if (ofld_kcqe->completion_status) {
drivers/scsi/bnx2fc/bnx2fc_hwi.c:		if (ofld_kcqe->completion_status ==
drivers/scsi/bnx2fc/bnx2fc_hwi.c: * bnx2fc_process_enable_conn_cmpl - process FCoE session enable completion
drivers/scsi/bnx2fc/bnx2fc_hwi.c: * handle session enable completion, mark the rport as ready
drivers/scsi/bnx2fc/bnx2fc_hwi.c:	if (!ofld_kcqe->completion_status)
drivers/scsi/bnx2fc/bnx2fc_hwi.c:	if (disable_kcqe->completion_status) {
drivers/scsi/bnx2fc/bnx2fc_hwi.c:			disable_kcqe->completion_status);
drivers/scsi/bnx2fc/bnx2fc_hwi.c:	if (destroy_kcqe->completion_status) {
drivers/scsi/bnx2fc/bnx2fc_hwi.c:			destroy_kcqe->completion_status);
drivers/scsi/bnx2fc/bnx2fc_hwi.c: * @num_cqe:	Number of completion queue elements
drivers/scsi/bnx2fc/bnx2fc_hwi.c:			if (kcqe->completion_status !=
drivers/scsi/bnx2fc/bnx2fc_hwi.c:						kcqe->completion_status);
drivers/scsi/bnx2fc/bnx2fc_hwi.c:			if (kcqe->completion_status !=
drivers/scsi/bnx2fc/bnx2fc_hwi.c:			if (kcqe->completion_status !=
drivers/scsi/bnx2fc/bnx2fc_els.c:		 * drop the completion. Remove from active_cmd_queue.
drivers/scsi/bnx2fc/bnx2fc_els.c:		 * drop the completion. libfc will handle the els timeout
drivers/scsi/bnx2fc/bnx2fc_els.c:		/* This IO doesn't receive cleanup completion */
drivers/scsi/bnx2fc/bnx2fc.h:	struct completion stat_req_done;
drivers/scsi/bnx2fc/bnx2fc.h:	struct completion tm_done;
drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h:	__le32 completion_status;
drivers/scsi/bnx2fc/bnx2fc_constants.h:/* KCQ (kernel completion queue) response op codes */
drivers/scsi/bnx2fc/bnx2fc_constants.h:/* KCQ (kernel completion queue) completion status */
drivers/scsi/bnx2fc/bnx2fc_constants.h:/* For completion the ABTS task. */
drivers/scsi/bnx2fc/bnx2fc_constants.h:/* Obsolete: Intermediate completion (middle path with local completion) */
drivers/scsi/bnx2fc/bnx2fc_constants.h:/* Special completion indication in case of task was aborted. */
drivers/scsi/bnx2fc/bnx2fc_constants.h:/* FW only: Special completion indication in case of task was cleaned. */
drivers/scsi/bnx2fc/bnx2fc_constants.h:/* Not in used: Special completion indication (in task requested the exchange
drivers/scsi/bnx2fc/bnx2fc_constants.h:/* Special completion indication (in task requested the sequence cleanup) in
drivers/scsi/smartpqi/smartpqi_init.c:		 * returning from the I/O completion callback!
drivers/scsi/smartpqi/smartpqi_init.c:	struct completion *waiting = context;
drivers/scsi/smartpqi/smartpqi_init.c:		wait_for_completion_io(&wait);
drivers/scsi/smartpqi/smartpqi_init.c:		if (!wait_for_completion_io_timeout(&wait,
drivers/scsi/smartpqi/smartpqi_init.c:	struct completion *waiting = context;
drivers/scsi/smartpqi/smartpqi_init.c:static int pqi_wait_for_lun_reset_completion(struct pqi_ctrl_info *ctrl_info,
drivers/scsi/smartpqi/smartpqi_init.c:	struct pqi_scsi_dev *device, struct completion *wait)
drivers/scsi/smartpqi/smartpqi_init.c:		if (wait_for_completion_io_timeout(wait,
drivers/scsi/smartpqi/smartpqi_init.c:	rc = pqi_wait_for_lun_reset_completion(ctrl_info, device, &wait);
drivers/scsi/smartpqi/smartpqi_sis.c:	 * Force the completion of the interrupt mask register write before
drivers/scsi/smartpqi/smartpqi_sis.c:	 * Poll for command completion.  Note that the call to msleep() is at
drivers/scsi/eata.c:	/* Clear the completion flag and cp pointer on the dynamic copy of sp */
drivers/scsi/cxgbi/libcxgbi.h:	SKCBF_TX_FLAG_COMPL,    /* wr completion flag */
drivers/scsi/cxgbi/cxgb3i/cxgb3i.c:static int push_tx_frames(struct cxgbi_sock *csk, int req_completion);
drivers/scsi/cxgbi/cxgb3i/cxgb3i.c:				   int len, int req_completion)
drivers/scsi/cxgbi/cxgb3i/cxgb3i.c:			(req_completion ? F_WR_COMPL : 0));
drivers/scsi/cxgbi/cxgb3i/cxgb3i.c: * @req_completion: request wr_ack or not
drivers/scsi/cxgbi/cxgb3i/cxgb3i.c:static int push_tx_frames(struct cxgbi_sock *csk, int req_completion)
drivers/scsi/cxgbi/cxgb3i/cxgb3i.c:			if ((req_completion &&
drivers/scsi/cxgbi/cxgb3i/cxgb3i.c:				req_completion = 1;
drivers/scsi/cxgbi/cxgb3i/cxgb3i.c:			make_tx_data_wr(csk, skb, len, req_completion);
drivers/scsi/cxgbi/cxgb3i/cxgb3i.c: * Process an acknowledgment of WR completion.  Advance snd_una and send the
drivers/scsi/cxgbi/cxgb4i/cxgb4i.c:static int push_tx_frames(struct cxgbi_sock *csk, int req_completion)
drivers/scsi/cxgbi/cxgb4i/cxgb4i.c:					req_completion);
drivers/scsi/hosts.c:#include <linux/completion.h>
drivers/scsi/aic94xx/aic94xx_sas.h: * _RESP - The completion includes an empty buffer containing status.
drivers/scsi/aic94xx/aic94xx_task.c:		struct completion *completion = ascb->completion;
drivers/scsi/aic94xx/aic94xx_task.c:		if (completion)
drivers/scsi/aic94xx/aic94xx_task.c:			complete(completion);
drivers/scsi/aic94xx/aic94xx_hwi.c:		asd_printk("couldn't disable split completion timer of %s\n",
drivers/scsi/aic94xx/aic94xx_hwi.c:		asd_printk("received split completion error for %s\n",
drivers/scsi/aic94xx/aic94xx_hwi.c:		asd_printk("unexpected split completion for %s\n",
drivers/scsi/aic94xx/aic94xx_hwi.c:		asd_printk("split completion discarded for %s\n",
drivers/scsi/aic94xx/aic94xx_tmf.c:struct tasklet_completion_status {
drivers/scsi/aic94xx/aic94xx_tmf.c:	struct tasklet_completion_status tcs = { \
drivers/scsi/aic94xx/aic94xx_tmf.c:	struct tasklet_completion_status *tcs = ascb->uldd_task;
drivers/scsi/aic94xx/aic94xx_tmf.c:	complete(ascb->completion);
drivers/scsi/aic94xx/aic94xx_tmf.c:	struct tasklet_completion_status *tcs = ascb->uldd_task;
drivers/scsi/aic94xx/aic94xx_tmf.c:	complete(ascb->completion);
drivers/scsi/aic94xx/aic94xx_tmf.c:	DECLARE_COMPLETION_ONSTACK(completion); \
drivers/scsi/aic94xx/aic94xx_tmf.c:	ascb->completion = &completion; \
drivers/scsi/aic94xx/aic94xx_tmf.c:	wait_for_completion(&completion); \
drivers/scsi/aic94xx/aic94xx_tmf.c:	struct tasklet_completion_status *tcs = ascb->uldd_task;
drivers/scsi/aic94xx/aic94xx_tmf.c:	complete(ascb->completion);
drivers/scsi/aic94xx/aic94xx_tmf.c:	struct tasklet_completion_status *tcs;
drivers/scsi/aic94xx/aic94xx_tmf.c:	complete(ascb->completion);
drivers/scsi/aic94xx/aic94xx_tmf.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/aic94xx/aic94xx_tmf.c:	tascb->completion = &completion;
drivers/scsi/aic94xx/aic94xx_tmf.c:	leftover = wait_for_completion_timeout(&completion,
drivers/scsi/aic94xx/aic94xx_tmf.c:	tascb->completion = NULL;
drivers/scsi/aic94xx/aic94xx_tmf.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/aic94xx/aic94xx_tmf.c:	DECLARE_COMPLETION_ONSTACK(tascb_completion);
drivers/scsi/aic94xx/aic94xx_tmf.c:	tascb->completion = &tascb_completion;
drivers/scsi/aic94xx/aic94xx_tmf.c:	ascb->completion = &completion;
drivers/scsi/aic94xx/aic94xx_tmf.c:	wait_for_completion(&completion);
drivers/scsi/aic94xx/aic94xx_tmf.c:				wait_for_completion_timeout(&tascb_completion,
drivers/scsi/aic94xx/aic94xx_tmf.c:	tascb->completion = NULL;
drivers/scsi/aic94xx/aic94xx_tmf.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/scsi/aic94xx/aic94xx_tmf.c:	ascb->completion = &completion;
drivers/scsi/aic94xx/aic94xx_tmf.c:	wait_for_completion(&completion);
drivers/scsi/aic94xx/aic94xx_hwi.h:	struct completion *completion;
drivers/scsi/ips.c:				 * acknowledge completion of the command
drivers/scsi/initio.c: *	be managed by the controller and we will get a completion (or
drivers/scsi/initio.c: *	be managed by the controller and we will get a completion (or
drivers/scsi/megaraid.c:#include <linux/completion.h>
drivers/scsi/megaraid.c:	wait_for_completion(&adapter->int_waitq);
drivers/scsi/megaraid.c:	init_completion(&adapter->int_waitq);
drivers/scsi/wd33c93.h:  /* successful completion interrupts */
drivers/scsi/mvsas/mv_sas.h:	/* RX (completion) DMA ring */
drivers/scsi/mvsas/mv_64xx.h:	MVS_RX_LO		= 0x138, /* RX (completion) ring addr */
drivers/scsi/mvsas/mv_94xx.h:	MVS_RX_LO		= 0x138, /* RX (completion) ring addr */
drivers/scsi/mvsas/mv_defs.h:	CINT_DONE		= (1U << 0),	/* cmd completion */
drivers/scsi/mvsas/mv_defs.h:	/* RX (completion) ring bits */
drivers/scsi/mvsas/mv_94xx.c:	/* enable completion queue interrupt */
drivers/scsi/mvsas/mv_sas.c:				struct completion *completion, int is_tmf,
drivers/scsi/mvsas/mv_sas.c:	complete(&task->slow_task->completion);
drivers/scsi/mvsas/mv_sas.c:	complete(&task->slow_task->completion);
drivers/scsi/mvsas/mv_sas.c:		wait_for_completion(&task->slow_task->completion);
drivers/scsi/mvsas/mv_64xx.c:	/* enable completion queue interrupt */
drivers/scsi/vmw_pvscsi.c:	 * 1-to-1 mapping completions back to requests.
drivers/scsi/vmw_pvscsi.c:	struct completion	*abort_cmp;
drivers/scsi/vmw_pvscsi.c: * Pull a completion descriptor off and pass the completion back
drivers/scsi/vmw_pvscsi.c:	struct completion *abort_cmp;
drivers/scsi/vmw_pvscsi.c:		 * the request completed and swallow the actual cmd completion
drivers/scsi/vmw_pvscsi.c:		 * here. The abort handler will post a completion for this
drivers/scsi/vmw_pvscsi.c:				    "Unknown completion status: 0x%x\n",
drivers/scsi/vmw_pvscsi.c:static void pvscsi_process_completion_ring(struct pvscsi_adapter *adapter)
drivers/scsi/vmw_pvscsi.c:	 * we might not have room on the completion ring for the response.
drivers/scsi/vmw_pvscsi.c:	 * Poll the completion ring first - we might be trying to abort
drivers/scsi/vmw_pvscsi.c:	 * a command that is waiting to be dispatched in the completion ring.
drivers/scsi/vmw_pvscsi.c:	pvscsi_process_completion_ring(adapter);
drivers/scsi/vmw_pvscsi.c:	/* Wait for 2 secs for the completion. */
drivers/scsi/vmw_pvscsi.c:	done = wait_for_completion_timeout(&abort_cmp, msecs_to_jiffies(2000));
drivers/scsi/vmw_pvscsi.c:			    "Failed to get completion for aborted cmd %p\n",
drivers/scsi/vmw_pvscsi.c: * Abort all outstanding requests.  This is only safe to use if the completion
drivers/scsi/vmw_pvscsi.c:	 * up, so stalling new requests until all completions are flushed and
drivers/scsi/vmw_pvscsi.c:	 * Now process any completions.  Note we do this AFTER adapter reset,
drivers/scsi/vmw_pvscsi.c:	 * which is strange, but stops races where completions get posted
drivers/scsi/vmw_pvscsi.c:	 * completion ring state is still valid.
drivers/scsi/vmw_pvscsi.c:	pvscsi_process_completion_ring(adapter);
drivers/scsi/vmw_pvscsi.c:	pvscsi_process_completion_ring(adapter);
drivers/scsi/vmw_pvscsi.c:	pvscsi_process_completion_ring(adapter);
drivers/scsi/vmw_pvscsi.c:		pvscsi_process_completion_ring(adapter);
drivers/scsi/vmw_pvscsi.c:	 * Mark the completion page header with error values. If the device
drivers/scsi/vmw_pvscsi.c:	pvscsi_process_completion_ring(adapter);
drivers/scsi/be2iscsi/be_main.c:		 * We use same freed index as in completion to post so this
drivers/scsi/be2iscsi/be_main.c:	 * There is no completion for CONTEXT_UPDATE. The completion of next
drivers/scsi/be2iscsi/be_main.c:		/* completion of this is ignored */
drivers/scsi/be2iscsi/be_cmds.h: * complete. Upon completion, the MAILBOX will contain a valid completion
drivers/scsi/be2iscsi/be_cmds.h:/*** iSCSI ack/driver message completions ***/
drivers/scsi/be2iscsi/be_cmds.h: * Different types of iSCSI completions to host driver for both initiator
drivers/scsi/be2iscsi/be_cmds.h:						 * completion notify.
drivers/scsi/be2iscsi/be_cmds.h:						 * completion
drivers/scsi/be2iscsi/be_cmds.h:						 * completionnotifify.
drivers/scsi/be2iscsi/be_cmds.c: * beiscsi_mcc_compl_status - Return the status of MCC completion
drivers/scsi/be2iscsi/be_cmds.c: * beiscsi_mccq_compl_wait()- Process completion in MCC CQ
drivers/scsi/be2iscsi/be_cmds.c: * Waits for MBX completion with the passed TAG.
drivers/scsi/be2iscsi/be_cmds.c:	/* wait for the mccq completion */
drivers/scsi/be2iscsi/be_cmds.c:	 * for cmd is not freed until FW returns completion.
drivers/scsi/be2iscsi/be_cmds.c: * beiscsi_process_mbox_compl()- Check the MBX completion status
drivers/scsi/be2iscsi/be_cmds.c: * Check for the MBX completion status when BMBX method used
drivers/scsi/be2iscsi/be_cmds.c:				"BC_%d : BMBX busy, no completion\n");
drivers/scsi/be2iscsi/be_cmds.c:		    "BC_%d : error in cmd completion: Subsystem : %d Opcode : %d status(compl/extd)=%d/%d\n",
drivers/scsi/be2iscsi/be_cmds.c:		/* just check completion status and free wrb */
drivers/scsi/be2iscsi/be_cmds.c:	 * SLI COMMON_FUNCTION_RESET completion is indicated by BMBX RDY bit.
drivers/scsi/be2iscsi/be_mgmt.c:	/* ignore the completion of this mbox command */
drivers/scsi/be2iscsi/be_mgmt.c: * beiscsi_if_set_vlan()- Issue and wait for CMD completion
drivers/scsi/be2iscsi/be_mgmt.c: * Issue the MBX Cmd and wait for the completion of the
drivers/scsi/be2iscsi/be_mgmt.c:	/* clear the tag so no other completion matches this tag */
drivers/scsi/megaraid.h:	struct completion	int_waitq;	/* wait queue for internal
drivers/scsi/ibmvscsi/ibmvscsi.h:#include <linux/completion.h>
drivers/scsi/ibmvscsi/ibmvscsi.h:	struct completion comp;
drivers/scsi/ibmvscsi/ibmvscsi.c: * sync_completion: Signal that a synchronous command has completed
drivers/scsi/ibmvscsi/ibmvscsi.c: * the caller waiting on this completion shouldn't touch the evt_struct
drivers/scsi/ibmvscsi/ibmvscsi.c:static void sync_completion(struct srp_event_struct *evt_struct)
drivers/scsi/ibmvscsi/ibmvscsi.c:				  sync_completion,
drivers/scsi/ibmvscsi/ibmvscsi.c:		init_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvscsi.c:	wait_for_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvscsi.c:				  sync_completion,
drivers/scsi/ibmvscsi/ibmvscsi.c:		init_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvscsi.c:	wait_for_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvfc.c: * ibmvfc_sync_completion - Signal that a synchronous command has completed
drivers/scsi/ibmvscsi/ibmvfc.c:static void ibmvfc_sync_completion(struct ibmvfc_event *evt)
drivers/scsi/ibmvscsi/ibmvfc.c:	ibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_MAD_FORMAT);
drivers/scsi/ibmvscsi/ibmvfc.c:	init_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvfc.c:	wait_for_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvfc.c:	ibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_MAD_FORMAT);
drivers/scsi/ibmvscsi/ibmvfc.c:	init_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvfc.c:	wait_for_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvfc.c:		ibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_CMD_FORMAT);
drivers/scsi/ibmvscsi/ibmvfc.c:		init_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvfc.c:	wait_for_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvfc.c:			timeout = wait_for_completion_timeout(&comp, timeout);
drivers/scsi/ibmvscsi/ibmvfc.c:		ibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_MAD_FORMAT);
drivers/scsi/ibmvscsi/ibmvfc.c:		init_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvfc.c:	wait_for_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvfc.c:		ibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_CMD_FORMAT);
drivers/scsi/ibmvscsi/ibmvfc.c:		init_completion(&evt->comp);
drivers/scsi/ibmvscsi/ibmvfc.c:	timeout = wait_for_completion_timeout(&evt->comp, timeout);
drivers/scsi/ibmvscsi/ibmvfc.c: * the ADISC completion handler. If the ADISC never actually comes
drivers/scsi/ibmvscsi/ibmvfc.h:	struct completion comp;
drivers/scsi/ibmvscsi/ibmvfc.h:	struct completion *eh_comp;
drivers/scsi/pmcraid.h:#include <linux/completion.h>
drivers/scsi/pmcraid.h:	struct completion wait_for_completion;
drivers/scsi/pmcraid.h:	u8 completion_req;		/* for handling internal commands */
drivers/scsi/pmcraid.h:	u8 release;			/* for handling completions */
drivers/scsi/pmcraid.h:	/* Wait Q for  threads to wait for Reset IOA completion */
drivers/scsi/vmw_pvscsi.h: *   completion of the i/o. For guest OSes that use lowest priority message
drivers/scsi/vmw_pvscsi.h: *   completion action to the proper vcpu. For now, we can use the vcpuId of
drivers/scsi/vmw_pvscsi.h: *   that will be waiting for the completion..
drivers/scsi/scsi_priv.h:void scsi_log_completion(struct scsi_cmnd *cmd, int disposition);
drivers/scsi/scsi_priv.h:static inline void scsi_log_completion(struct scsi_cmnd *cmd, int disposition)
drivers/scsi/scsi_priv.h:extern void scsi_io_completion(struct scsi_cmnd *, unsigned int);
drivers/scsi/esp_scsi.h:	struct completion	*eh_done;
drivers/scsi/esp_scsi.h:	struct completion	*eh_reset;
drivers/scsi/qla2xxx/qla_iocb.c:	/* Specify response queue number where completion should happen */
drivers/scsi/qla2xxx/qla_iocb.c:	/* Specify response queue number where completion should happen */
drivers/scsi/qla2xxx/qla_iocb.c:	wait_for_completion(&elsio->u.els_logo.comp);
drivers/scsi/qla2xxx/qla_iocb.c:		 * completion should happen
drivers/scsi/qla2xxx/qla_iocb.c:		 * completion should happen.
drivers/scsi/qla2xxx/qla_def.h:#include <linux/completion.h>
drivers/scsi/qla2xxx/qla_def.h:					     * reset-recovery completion is
drivers/scsi/qla2xxx/qla_def.h:			struct completion comp;
drivers/scsi/qla2xxx/qla_def.h:			struct completion comp;
drivers/scsi/qla2xxx/qla_def.h:			struct completion fxiocb_comp;
drivers/scsi/qla2xxx/qla_def.h:			struct completion comp;
drivers/scsi/qla2xxx/qla_def.h: * Status entry completion status
drivers/scsi/qla2xxx/qla_def.h:	struct completion mbx_cmd_comp; /* Serialize mbx access */
drivers/scsi/qla2xxx/qla_def.h:	struct completion mbx_intr_comp;  /* Used for completion notification */
drivers/scsi/qla2xxx/qla_def.h:	struct completion dcbx_comp;	/* For set port config notification */
drivers/scsi/qla2xxx/qla_def.h:	struct completion lb_portup_comp; /* Used to wait for link up during
drivers/scsi/qla2xxx/qla_mr.c: *	Issue mailbox command and waits for completion.
drivers/scsi/qla2xxx/qla_mr.c:	if (!wait_for_completion_timeout(&ha->mbx_cmd_comp, mcp->tov * HZ)) {
drivers/scsi/qla2xxx/qla_mr.c:	/* Wait for mbx cmd completion until timeout */
drivers/scsi/qla2xxx/qla_mr.c:		wait_for_completion_timeout(&ha->mbx_intr_comp, mcp->tov * HZ);
drivers/scsi/qla2xxx/qla_mr.c:	wait_for_completion(&fdisc->u.fxiocb.fxiocb_comp);
drivers/scsi/qla2xxx/qla_mr.c:	/* Fast path completion. */
drivers/scsi/qla2xxx/qla_mr.c:	/* Setup to process RIO completion. */
drivers/scsi/qla2xxx/qla_mr.c: * qlafx00x_mbx_completion() - Process mailbox command completions.
drivers/scsi/qla2xxx/qla_mr.c:qlafx00_mbx_completion(scsi_qla_host_t *vha, uint32_t mb0)
drivers/scsi/qla2xxx/qla_mr.c:			qlafx00_mbx_completion(vha, mb[0]);
drivers/scsi/qla2xxx/qla_mr.c:	qla2x00_handle_mbx_completion(ha, status);
drivers/scsi/qla2xxx/qla_mr.c:	/* Specify response queue number where completion should happen */
drivers/scsi/qla2xxx/qla_inline.h:		init_completion(&sp->u.iocb_cmd.u.fxiocb.fxiocb_comp);
drivers/scsi/qla2xxx/qla_inline.h:		init_completion(&sp->u.iocb_cmd.u.els_logo.comp);
drivers/scsi/qla2xxx/qla_inline.h:qla2x00_handle_mbx_completion(struct qla_hw_data *ha, int status)
drivers/scsi/qla2xxx/qla_gs.c:			    "%s failed, completion status (%x) on port_id: "
drivers/scsi/qla2xxx/qla_fw.h: * Status entry completion status
drivers/scsi/qla2xxx/qla_nx.c: * qla82xx_mbx_completion() - Process mailbox command completions.
drivers/scsi/qla2xxx/qla_nx.c:qla82xx_mbx_completion(scsi_qla_host_t *vha, uint16_t mb0)
drivers/scsi/qla2xxx/qla_nx.c:				qla82xx_mbx_completion(vha, MSW(stat));
drivers/scsi/qla2xxx/qla_nx.c:	qla2x00_handle_mbx_completion(ha, status);
drivers/scsi/qla2xxx/qla_nx.c:				qla82xx_mbx_completion(vha, MSW(stat));
drivers/scsi/qla2xxx/qla_nx.c:	qla2x00_handle_mbx_completion(ha, status);
drivers/scsi/qla2xxx/qla_nx.c:			qla82xx_mbx_completion(vha, MSW(stat));
drivers/scsi/qla2xxx/qla_nx.c:		    "Doing premature completion of mbx command.\n");
drivers/scsi/qla2xxx/qla_target.h: * Used to mark which completion handles (for RIO Status's) are for CTIO's
drivers/scsi/qla2xxx/qla_target.h: *		The ABTS response with completion status to the ABTS response
drivers/scsi/qla2xxx/qla_target.h:	 * BIT_12 - good completion - qlt_ctio_do_completion -->free_cmd
drivers/scsi/qla2xxx/qla_target.h:	 * BIT_13 - Bad completion -
drivers/scsi/qla2xxx/qla_target.h:	 *	qlt_ctio_do_completion --> qlt_term_ctio_exchange
drivers/scsi/qla2xxx/qla_target.h:	 * BIT_18 - completion w/abort status
drivers/scsi/qla2xxx/qla_target.h:	 * BIT_19 - completion w/unknown status
drivers/scsi/qla2xxx/qla_target.h:extern void qlt_logo_completion_handler(fc_port_t *, int);
drivers/scsi/qla2xxx/qla_mbx.c: *	Issue mailbox command and waits for completion.
drivers/scsi/qla2xxx/qla_mbx.c:	if (!wait_for_completion_timeout(&ha->mbx_cmd_comp, mcp->tov * HZ)) {
drivers/scsi/qla2xxx/qla_mbx.c:	/* Wait for mbx cmd completion until timeout */
drivers/scsi/qla2xxx/qla_mbx.c:		if (!wait_for_completion_timeout(&ha->mbx_intr_comp,
drivers/scsi/qla2xxx/qla_mbx.c:		    "Failed to complete IOCB -- completion  status (%x) "
drivers/scsi/qla2xxx/qla_mbx.c:		 * return ok even when the mailbox completion value is not
drivers/scsi/qla2xxx/qla_mbx.c: 		 * return ok even when the mailbox completion value is not
drivers/scsi/qla2xxx/qla_mbx.c:		    "Failed to complete IOCB -- completion status (%x) "
drivers/scsi/qla2xxx/qla_mbx.c:		    "Failed to complete IOCB -- completion status (%x).\n",
drivers/scsi/qla2xxx/qla_mbx.c:		    "Failed to complete IOCB -- completion status (%x).\n",
drivers/scsi/qla2xxx/qla_mbx.c:		    "Failed to complete IOCB -- completion status (%x).\n",
drivers/scsi/qla2xxx/qla_mbx.c:		    "Failed to complet IOCB -- completion status (%x).\n",
drivers/scsi/qla2xxx/qla_isr.c:static void qla2x00_mbx_completion(scsi_qla_host_t *, uint16_t);
drivers/scsi/qla2xxx/qla_isr.c:				qla2x00_mbx_completion(vha, mb[0]);
drivers/scsi/qla2xxx/qla_isr.c:	qla2x00_handle_mbx_completion(ha, status);
drivers/scsi/qla2xxx/qla_isr.c:			qla2x00_mbx_completion(vha, MSW(stat));
drivers/scsi/qla2xxx/qla_isr.c:	qla2x00_handle_mbx_completion(ha, status);
drivers/scsi/qla2xxx/qla_isr.c: * qla2x00_mbx_completion() - Process mailbox command completions.
drivers/scsi/qla2xxx/qla_isr.c:qla2x00_mbx_completion(scsi_qla_host_t *vha, uint16_t mb0)
drivers/scsi/qla2xxx/qla_isr.c:	/* Handle IDC Error completion case. */
drivers/scsi/qla2xxx/qla_isr.c:	/* Setup to process RIO completion. */
drivers/scsi/qla2xxx/qla_isr.c:		    "[R|Z]IO update completion.\n");
drivers/scsi/qla2xxx/qla_isr.c:		/* Save ISP completion status */
drivers/scsi/qla2xxx/qla_isr.c:		    "Invalid completion handle (%x) -- timed-out.\n", index);
drivers/scsi/qla2xxx/qla_isr.c:		    "Async-%s error - hdl=%x completion status(%x).\n",
drivers/scsi/qla2xxx/qla_isr.c:		    "Invalid SCSI completion handle 0x%x.\n", index);
drivers/scsi/qla2xxx/qla_isr.c:		    "Req:%d: Invalid ISP SCSI completion handle(0x%x)\n",
drivers/scsi/qla2xxx/qla_isr.c:		    "Command completed with completion status=0x%x "
drivers/scsi/qla2xxx/qla_isr.c:	/* Task Management completion. */
drivers/scsi/qla2xxx/qla_isr.c:	/* Fast path completion. */
drivers/scsi/qla2xxx/qla_isr.c: * qla24xx_mbx_completion() - Process mailbox command completions.
drivers/scsi/qla2xxx/qla_isr.c:qla24xx_mbx_completion(scsi_qla_host_t *vha, uint16_t mb0)
drivers/scsi/qla2xxx/qla_isr.c:			qla24xx_mbx_completion(vha, MSW(stat));
drivers/scsi/qla2xxx/qla_isr.c:	qla2x00_handle_mbx_completion(ha, status);
drivers/scsi/qla2xxx/qla_isr.c:			qla24xx_mbx_completion(vha, MSW(stat));
drivers/scsi/qla2xxx/qla_isr.c:	qla2x00_handle_mbx_completion(ha, status);
drivers/scsi/qla2xxx/qla_sup.c:	/* Enable flash write-protection and wait for completion. */
drivers/scsi/qla2xxx/qla_sup.c: * qla2x00_poll_flash() - Polls flash for completion.
drivers/scsi/qla2xxx/qla_os.c:	"Waiting for command completions",
drivers/scsi/qla2xxx/qla_os.c:	init_completion(&ha->mbx_cmd_comp);
drivers/scsi/qla2xxx/qla_os.c:	init_completion(&ha->mbx_intr_comp);
drivers/scsi/qla2xxx/qla_os.c:	init_completion(&ha->dcbx_comp);
drivers/scsi/qla2xxx/qla_os.c:	init_completion(&ha->lb_portup_comp);
drivers/scsi/qla2xxx/qla_init.c:		qlt_logo_completion_handler(fcport, QLA_FUNCTION_TIMEOUT);
drivers/scsi/qla2xxx/qla_init.c:	init_completion(&tm_iocb->u.tmf.comp);
drivers/scsi/qla2xxx/qla_init.c:	wait_for_completion(&tm_iocb->u.tmf.comp);
drivers/scsi/qla2xxx/qla_init.c:	init_completion(&abt_iocb->u.abt.comp);
drivers/scsi/qla2xxx/qla_init.c:	wait_for_completion(&abt_iocb->u.abt.comp);
drivers/scsi/qla2xxx/qla_init.c:	qlt_logo_completion_handler(fcport, data[0]);
drivers/scsi/qla2xxx/qla_init.c:	/* For ISP82XX, driver waits for completion of the commands.
drivers/scsi/qla2xxx/qla_init.c:	 * Driver waits for the completion of the commands.
drivers/scsi/qla2xxx/qla_bsg.c:		if (wait && !wait_for_completion_timeout(&ha->dcbx_comp,
drivers/scsi/qla2xxx/qla_bsg.c:			    "DCBX completion not received.\n");
drivers/scsi/qla2xxx/qla_bsg.c:			    "DCBX completion received.\n");
drivers/scsi/qla2xxx/qla_bsg.c:		    !wait_for_completion_timeout(&ha->lb_portup_comp,
drivers/scsi/qla2xxx/qla_bsg.c:			    "Port up completion not received.\n");
drivers/scsi/qla2xxx/qla_bsg.c:			    "Port up completion received.\n");
drivers/scsi/qla2xxx/qla_bsg.c:		rem_tmo = wait_for_completion_timeout(&ha->dcbx_comp,
drivers/scsi/qla2xxx/qla_bsg.c:		    "DCBX completion not received.\n");
drivers/scsi/qla2xxx/qla_bsg.c:			    "DCBX completion received.\n");
drivers/scsi/qla2xxx/qla_nx2.c:				qla82xx_mbx_completion(vha, MSW(stat));
drivers/scsi/qla2xxx/qla_nx2.c:	qla2x00_handle_mbx_completion(ha, status);
drivers/scsi/qla2xxx/tcm_qla2xxx.h:	struct completion tpg_base_comp;
drivers/scsi/qla2xxx/qla_target.c:	    "s_id %x:%x:%x, confirmed completion %ssupported) added\n",
drivers/scsi/qla2xxx/qla_target.c:		 *  1) XFER Rdy completion + CMD_T_ABORT
drivers/scsi/qla2xxx/qla_target.c:static void qlt_do_ctio_completion(struct scsi_qla_host *vha, uint32_t handle,
drivers/scsi/qla2xxx/qla_target.c:				/* Need to generate a SCSI good completion.
drivers/scsi/qla2xxx/qla_target.c:void qlt_logo_completion_handler(fc_port_t *fcport, int rc)
drivers/scsi/qla2xxx/qla_target.c:		qlt_do_ctio_completion(vha, entry->handle,
drivers/scsi/qla2xxx/qla_target.c:		qlt_do_ctio_completion(vha, entry->handle,
drivers/scsi/qla2xxx/qla_target.c:		qlt_do_ctio_completion(vha, entry->handle,
drivers/scsi/qla2xxx/qla_gbl.h:extern void qla82xx_mbx_completion(scsi_qla_host_t *, uint16_t);
drivers/scsi/qla2xxx/tcm_qla2xxx.c:		wait_for_completion_timeout(&se_cmd->t_transport_stop_comp,
drivers/scsi/qla2xxx/tcm_qla2xxx.c:		 * waiting upon completion in tcm_qla2xxx_write_pending_status()
drivers/scsi/qla2xxx/tcm_qla2xxx.c: * Called from qla_target.c:qlt_do_ctio_completion()
drivers/scsi/qla2xxx/tcm_qla2xxx.c: * Called from qla_target.c:qlt_do_ctio_completion()
drivers/scsi/qla2xxx/tcm_qla2xxx.c:	init_completion(&tpg->tpg_base_comp);
drivers/scsi/qla2xxx/tcm_qla2xxx.c:	wait_for_completion(&tpg->tpg_base_comp);
drivers/scsi/qla1280.c:	- Initialize completion queue to avoid OOPS on probe
drivers/scsi/qla1280.c:    	- use struct list_head for completion queue
drivers/scsi/qla1280.c:	- Delete completion queue from srb if mailbox command failed to
drivers/scsi/qla1280.c:	- Use completion queue for mailbox commands instead of busy wait
drivers/scsi/qla1280.c: * interrupt handler may call this routine as part of request-completion
drivers/scsi/qla1280.c:				 struct completion *wait)
drivers/scsi/qla1280.c:	wait_for_completion_timeout(wait, 4*HZ);
drivers/scsi/qla1280.c:	 * for completion.
drivers/scsi/qla1280.c: *      Issue mailbox command and waits for completion.
drivers/scsi/qla1280.c:	wait_for_completion(&wait);
drivers/scsi/qla1280.c: *      Calls I/O done on command completion.
drivers/scsi/qla1280.c:		case MBA_SCSI_COMPLETION:	/* Response completion */
drivers/scsi/qla1280.c:				"completion\n");
drivers/scsi/qla1280.c:					/* Save ISP completion status */
drivers/scsi/qla1280.c:		/* Save ISP completion status */
drivers/scsi/gdth_proc.h:static void gdth_wait_completion(gdth_ha_str *ha, int busnum, int id);
drivers/scsi/fnic/fnic_stats.h:	atomic64_t io_completions;
drivers/scsi/fnic/fnic_stats.h:	atomic64_t fw_reset_completions;
drivers/scsi/fnic/fnic_stats.h:	atomic64_t fnic_reset_completions;
drivers/scsi/fnic/fnic_scsi.c: * Routine to handle fw reset completion
drivers/scsi/fnic/fnic_scsi.c:	atomic64_inc(&reset_stats->fw_reset_completions);
drivers/scsi/fnic/fnic_scsi.c:		/* Check status of reset completion */
drivers/scsi/fnic/fnic_scsi.c: * Routine to handle flogi register completion
drivers/scsi/fnic/fnic_scsi.c:	/* Update fnic state based on status of flogi reg completion */
drivers/scsi/fnic/fnic_scsi.c:		/* Check flogi registration completion status */
drivers/scsi/fnic/fnic_scsi.c:			      " processing flogi reg completion\n",
drivers/scsi/fnic/fnic_scsi.c: * Routine to handle icmnd completions
drivers/scsi/fnic/fnic_scsi.c:	 * ignore completion of the IO. The abts path will clean it up
drivers/scsi/fnic/fnic_scsi.c:		atomic64_inc(&fnic_stats->io_stats.io_completions);
drivers/scsi/fnic/fnic_scsi.c:	/* Call SCSI completion function to complete the IO */
drivers/scsi/fnic/fnic_scsi.c: * Routine to handle itmf completions
drivers/scsi/fnic/fnic_scsi.c:		/* Abort and terminate completion of device reset req */
drivers/scsi/fnic/fnic_scsi.c:			/* This is a late completion. Ignore it */
drivers/scsi/fnic/fnic_scsi.c:			atomic64_inc(&fnic_stats->io_stats.io_completions);
drivers/scsi/fnic/fnic_scsi.c:		 * signal completion to it. IO will be cleaned in the thread
drivers/scsi/fnic/fnic_scsi.c:			/* Need to wait for terminate completion */
drivers/scsi/fnic/fnic_scsi.c:			      "firmware completion type %d\n",
drivers/scsi/fnic/fnic_scsi.c:			 * without sending completions for outstanding ios.
drivers/scsi/fnic/fnic_scsi.c:			atomic64_inc(&fnic_stats->io_stats.io_completions);
drivers/scsi/fnic/fnic_scsi.c:	 * happened, the completion wont actually complete the command
drivers/scsi/fnic/fnic_scsi.c:	 * the completion wont be done till mid-layer, since abort
drivers/scsi/fnic/fnic_scsi.c:	 * We queued an abort IO, wait for its completion.
drivers/scsi/fnic/fnic_scsi.c:	wait_for_completion_timeout(&tm_done,
drivers/scsi/fnic/fnic_scsi.c:	/* Call SCSI completion function to complete the IO */
drivers/scsi/fnic/fnic_scsi.c:		wait_for_completion_timeout(&tm_done,
drivers/scsi/fnic/fnic_scsi.c:	 * Wait on the local completion for LUN reset.  The io_req may be
drivers/scsi/fnic/fnic_scsi.c:	wait_for_completion_timeout(&tm_done,
drivers/scsi/fnic/fnic_scsi.c:				wait_for_completion_timeout(&tm_done,
drivers/scsi/fnic/fnic_scsi.c:				wait_for_completion_timeout(&tm_done,
drivers/scsi/fnic/fnic_scsi.c:		atomic64_inc(&reset_stats->fnic_reset_completions);
drivers/scsi/fnic/fnic_scsi.c:		/* fw reset is in progress, poll for its completion */
drivers/scsi/fnic/fnic_scsi.c:	wait_for_completion_timeout(&remove_wait,
drivers/scsi/fnic/fnic_scsi.c:		/* fw reset is in progress, poll for its completion */
drivers/scsi/fnic/cq_exch_desc.h:/* Exchange completion queue descriptor: 16B */
drivers/scsi/fnic/fnic_trace.c:		  (u64)atomic64_read(&stats->io_stats.io_completions),
drivers/scsi/fnic/fnic_trace.c:		  (u64)atomic64_read(&stats->reset_stats.fw_reset_completions),
drivers/scsi/fnic/fnic_trace.c:			  &stats->reset_stats.fnic_reset_completions),
drivers/scsi/fnic/cq_enet_desc.h:/* Ethernet completion queue descriptor: 16B */
drivers/scsi/fnic/fnic.h:	struct completion *remove_wait; /* device remove thread blocks */
drivers/scsi/fnic/fnic.h:	/* completion queue cache line section */
drivers/scsi/fnic/cq_desc.h: * All completion queues have this basic layout.  The
drivers/scsi/fnic/cq_desc.h: * type_specfic area is unique for each completion
drivers/scsi/fnic/fnic_io.h:	struct completion *abts_done; /* completion for abts */
drivers/scsi/fnic/fnic_io.h:	struct completion *dr_done; /* completion for device reset */
drivers/scsi/scsi.c:#include <linux/completion.h>
drivers/scsi/scsi.c:	 * 1: nothing (match completion)
drivers/scsi/scsi.c:void scsi_log_completion(struct scsi_cmnd *cmd, int disposition)
drivers/scsi/scsi.c:	 * 2: same as 1 but for all command completions.
drivers/scsi/scsi.c:				"Notifying upper driver of completion "
drivers/scsi/scsi.c:		 * change to the completion length.
drivers/scsi/scsi.c:	scsi_io_completion(cmd, good_bytes);
drivers/scsi/advansys.c: * Send an idle command to the chip and wait for completion.
drivers/scsi/advansys.c: * Command completion is polled for once per microsecond.
drivers/scsi/advansys.c:		/* Poll once each microsecond for command completion. */
drivers/scsi/advansys.c:	 * command completions.
drivers/scsi/wd33c93.c: * is guaranteed to be in response to completion of
drivers/scsi/snic/snic_main.c: * snic_vdev_open_done : polls for svnic_dev_open cmd completion.
drivers/scsi/snic/snic_ctl.c:		wait_for_completion_timeout(&wait, msecs_to_jiffies(2000));
drivers/scsi/snic/snic_scsi.c:	/* Freeing cmd without marking completion, not okay */
drivers/scsi/snic/snic_scsi.c: * Routine to handle icmnd completions
drivers/scsi/snic/snic_scsi.c:	 * ignore completion of the IO. The abts path will clean it up
drivers/scsi/snic/snic_scsi.c: * snic_update_abort_stats : Updates abort stats based on completion status.
drivers/scsi/snic/snic_scsi.c:			/* This is a late completion. Ignore it. */
drivers/scsi/snic/snic_scsi.c:		 * signal completion to it. IO will be cleaned in the thread,
drivers/scsi/snic/snic_scsi.c:		/* Abort and terminate completion of device reset req */
drivers/scsi/snic/snic_scsi.c: * Routine to handle itmf completions.
drivers/scsi/snic/snic_scsi.c:			      "Unknown Firmwqre completion request type %d\n",
drivers/scsi/snic/snic_scsi.c:	 * use try_wait_for_completion and completion_done() to check
drivers/scsi/snic/snic_scsi.c:	 * whether it queues aborts even after completion of abort issued
drivers/scsi/snic/snic_scsi.c:	 * prior.SNIC_BUG_ON(completion_done(&rqi->done));
drivers/scsi/snic/snic_scsi.c:	 * happend, the completion wont actually complete the command
drivers/scsi/snic/snic_scsi.c:	 * the completion won't be done till mid-layer, since abot
drivers/scsi/snic/snic_scsi.c:	 * Queued an abort IO, wait for its completion.
drivers/scsi/snic/snic_scsi.c:	wait_for_completion_timeout(&tm_done, SNIC_ABTS_TIMEOUT);
drivers/scsi/snic/snic_scsi.c:	wait_for_completion_timeout(&tm_done, SNIC_ABTS_TIMEOUT);
drivers/scsi/snic/snic_scsi.c:	wait_for_completion_timeout(&tm_done, SNIC_LUN_RESET_TIMEOUT);
drivers/scsi/snic/snic_scsi.c:	wait_for_completion_timeout(snic->remove_wait,
drivers/scsi/snic/snic_scsi.c:	 * CASE : FW didn't post itmf completion due to PCIe Errors.
drivers/scsi/snic/snic_scsi.c:	 * Marking the abort status as Success to call scsi completion
drivers/scsi/snic/snic_scsi.c:			 * When FW Completes reset w/o sending completions
drivers/scsi/snic/vnic_devcmd.h:	u8  color;              /* 0 or 1 as with completion queues */
drivers/scsi/snic/cq_enet_desc.h:/* Ethernet completion queue descriptor: 16B */
drivers/scsi/snic/snic_stats.h:	atomic64_t hba_reset_cmpl;	/* hba/firmware reset completions */
drivers/scsi/snic/snic_stats.h:	atomic64_t snic_reset_compl;	/* snic reset completions */
drivers/scsi/snic/snic_stats.h:/* Auxillary function to update IO completion counter */
drivers/scsi/snic/snic_io.h:	u32	abts_status;	/* Abort completion status */
drivers/scsi/snic/snic_io.h:	u32	lr_status;	/* device reset completion status */
drivers/scsi/snic/snic_io.h:	struct completion *abts_done;
drivers/scsi/snic/snic_io.h:	struct completion *dr_done;
drivers/scsi/snic/cq_desc.h: * All completion queues have this basic layout.  The
drivers/scsi/snic/cq_desc.h: * type_specific area is unique for each completion
drivers/scsi/snic/snic.h:	struct completion *wait;	/* protected by snic lock*/
drivers/scsi/snic/snic.h:	struct completion *remove_wait;
drivers/scsi/snic/snic.h:	/* completion queue cache line section */
drivers/scsi/esas2r/atvda.h:#define RS_SUCCESS          0x00        /*! successful completion            */
drivers/scsi/esas2r/esas2r.h: * or long completion times.
drivers/scsi/esas2r/esas2r_ioctl.c:	/* Now call the original completion callback. */
drivers/scsi/esas2r/esas2r_ioctl.c:	 * Always usurp the completion callback since the interrupt callback
drivers/scsi/esas2r/esas2r_ioctl.c:	/* Done, call the completion callback. */
drivers/scsi/esas2r/esas2r_ioctl.c:		 * always usurp the completion callback since the interrupt
drivers/scsi/esas2r/esas2r_ioctl.c:/* Callback for the completion of a VDA request. */
drivers/scsi/esas2r/esas2r_ioctl.c:		bool wait_for_completion;
drivers/scsi/esas2r/esas2r_ioctl.c:		wait_for_completion =
drivers/scsi/esas2r/esas2r_ioctl.c:		if (wait_for_completion) {
drivers/scsi/esas2r/esas2r_ioctl.c:/* Callback for the completion of an FS_API request.*/
drivers/scsi/esas2r/esas2r_main.c:	 *       it will check the scsi_stat value in the completion anyway.
drivers/scsi/esas2r/esas2r_flash.c:/* Interrupt callback to process NVRAM completions. */
drivers/scsi/esas2r/esas2r_init.c:			/* override the completion function */
drivers/scsi/esas2r/esas2r_int.c:		/* Get the completion status */
drivers/scsi/esas2r/esas2r_int.c:			 * Copy the outbound completion struct for non-I/O
drivers/scsi/esas2r/esas2r_int.c:		/* Queue the request for completion. */
drivers/scsi/esas2r/esas2r_int.c:	 * callback called.  also set the dummy completion callback in case we
drivers/scsi/hpsa.h:	 * Performant mode completion buffers
drivers/scsi/hpsa.h:/* Maximum time in seconds driver will wait for command completions
drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c:			wait_for_completion(&vscsi->wait_idle);
drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c:	init_completion(&vscsi->wait_idle);
drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.h:	struct completion wait_idle;
drivers/scsi/st.c:	struct completion *waiting;
drivers/scsi/st.c:	init_completion(waiting);
drivers/scsi/st.c:		wait_for_completion(waiting);
drivers/scsi/st.c:/* Handle the write-behind checking (waits for completion). Returns -ENOSPC if
drivers/scsi/st.c:	wait_for_completion(&(STp->wait));
drivers/scsi/st.c:		cmd[1] = 1;	/* Don't wait for completion */
drivers/scsi/st.c:			cmd[1] = 1;	/* Don't wait for completion */
drivers/scsi/st.c:			cmd[1] = 1;	/* Don't wait for completion */
drivers/scsi/st.c:			cmd[1] |= 2;	/* Don't wait for completion */
drivers/scsi/st.c:		scmd[1] |= 1;		/* Don't wait for completion */
drivers/scsi/st.c:		scmd[1] |= 1;		/* Don't wait for completion */
drivers/scsi/hpsa.c:#include <linux/completion.h>
drivers/scsi/hpsa.c:static void process_ioaccel2_completion(struct ctlr_info *h,
drivers/scsi/hpsa.c:		return process_ioaccel2_completion(h, cp, cmd, dev);
drivers/scsi/hpsa.c:		wait_for_completion_io(&wait);
drivers/scsi/hpsa.c:	if (!wait_for_completion_io_timeout(&wait,
drivers/scsi/hpsa.c:	/* Don't wait for completion, the reset won't complete.  Don't free
drivers/scsi/hpsa.c:static inline unsigned long get_next_completion(struct ctlr_info *h, u8 q)
drivers/scsi/hpsa.c:/* process completion of an indexed ("direct lookup") command */
drivers/scsi/hpsa.c: * Only need to check for this in the hpsa_xxx_discard_completions
drivers/scsi/hpsa.c:static irqreturn_t hpsa_intx_discard_completions(int irq, void *queue)
drivers/scsi/hpsa.c:		raw_tag = get_next_completion(h, q);
drivers/scsi/hpsa.c:static irqreturn_t hpsa_msix_discard_completions(int irq, void *queue)
drivers/scsi/hpsa.c:	raw_tag = get_next_completion(h, q);
drivers/scsi/hpsa.c:		raw_tag = get_next_completion(h, q);
drivers/scsi/hpsa.c:	raw_tag = get_next_completion(h, q);
drivers/scsi/hpsa.c:		/* This is kind of gross.  We may or may not get a completion
drivers/scsi/hpsa.c:		 * after the reset throwing away any completions we get during
drivers/scsi/hpsa.c:		 * fake ones to scoop up any residual completions.
drivers/scsi/hpsa.c:		rc = hpsa_request_irqs(h, hpsa_msix_discard_completions,
drivers/scsi/hpsa.c:					hpsa_intx_discard_completions);
drivers/scsi/hpsa.c:			"Waiting for stale completions to drain.\n");
drivers/scsi/osst.h:#include <linux/completion.h>
drivers/scsi/osst.h:  struct completion wait;      /* for SCSI commands */
drivers/scsi/osst.h:	struct completion *waiting;
drivers/scsi/aacraid/dpcsup.c:#include <linux/completion.h>
drivers/scsi/aacraid/dpcsup.c: *	@index: completion reference
drivers/scsi/aacraid/src.c:#include <linux/completion.h>
drivers/scsi/aacraid/src.c: *	for its	completion.
drivers/scsi/aacraid/src.c:	 *	Force the completion of the mask register write before issuing
drivers/scsi/aacraid/sa.c:#include <linux/completion.h>
drivers/scsi/aacraid/sa.c: *	for its	completion.
drivers/scsi/aacraid/aachba.c:#include <linux/completion.h>
drivers/scsi/aacraid/aachba.c: * Handles the completion of a scsi command to a non dasd device
drivers/scsi/aacraid/linit.c:#include <linux/completion.h>
drivers/scsi/aacraid/linit.c: *	@done:		Function to call on command completion
drivers/scsi/aacraid/commsup.c:#include <linux/completion.h>
drivers/scsi/aacraid/commsup.c: *	aac_fib_complete	-	fib completion handler
drivers/scsi/aacraid/comminit.c:#include <linux/completion.h>
drivers/scsi/aacraid/commctrl.c:#include <linux/completion.h>
drivers/scsi/aacraid/rx.c:#include <linux/completion.h>
drivers/scsi/aacraid/rx.c: *	for its	completion.
drivers/scsi/aacraid/rx.c:	 *	Force the completion of the mask register write before issuing
drivers/scsi/bfa/bfa_fcs_lport.c:		/* If vport - send completion call back */
drivers/scsi/bfa/bfa_fcs_lport.c:			/* If vport - send completion call back */
drivers/scsi/bfa/bfa_fcs_lport.c:			/* If vport - send completion call back */
drivers/scsi/bfa/bfa_fcs_lport.c:			/* If vport - send completion call back */
drivers/scsi/bfa/bfa_fcs_lport.c: * bfa_fcs_vport_delete_comp() for vports on completion.
drivers/scsi/bfa/bfa_fcs_lport.c:	BFA_FCS_VPORT_SM_DELCOMP = 11,	/*  lport delete completion */
drivers/scsi/bfa/bfa_fcs_lport.c:	BFA_FCS_VPORT_SM_STOPCOMP = 14,	/* vport delete completion */
drivers/scsi/bfa/bfa_fcs_lport.c: * Vport is being stopped - awaiting lport stop completion to send
drivers/scsi/bfa/bfa_fcs_lport.c: * Vport is being deleted - awaiting lport delete completion to send
drivers/scsi/bfa/bfa_fcs_lport.c: * Stop completion callback from associated lport
drivers/scsi/bfa/bfa_fcs_lport.c: * Delete completion callback from associated lport
drivers/scsi/bfa/bfa_fcs_fcpim.c: * BFA completion callback for bfa_itnim_online().
drivers/scsi/bfa/bfa_fcs_fcpim.c: * BFA completion callback for bfa_itnim_offline().
drivers/scsi/bfa/bfa_fcs_fcpim.c: * Mark the beginning of PATH TOV handling. IO completion callbacks
drivers/scsi/bfa/bfa_defs_fcs.h:	u8 conf_comp;      /*  confirmed completion supp  */
drivers/scsi/bfa/bfa_fcpim.h:	bfa_cb_cbfn_t		io_cbfn;	/*  IO completion handler */
drivers/scsi/bfa/bfa_fcpim.h: * BFA completion callback for bfa_itnim_online().
drivers/scsi/bfa/bfa_fcpim.h: * BFA completion callback for bfa_itnim_offline().
drivers/scsi/bfa/bfa_fcpim.h: * I/O completion notification.
drivers/scsi/bfa/bfa_fcpim.h: * @param[in]		io_status		IO completion status
drivers/scsi/bfa/bfa_fcpim.h: * I/O good completion notification.
drivers/scsi/bfa/bfa_fcpim.h: * I/O abort completion notification
drivers/scsi/bfa/bfa_fcs.c: *   Fabric is being deleted, awaiting vport delete completions.
drivers/scsi/bfa/bfa_fcs.c: * Fabric is being stopped, awaiting vport stop completions.
drivers/scsi/bfa/bfa_fcs.c:		 * before the fabric completion callbk is done.
drivers/scsi/bfa/bfa_fcs.c: * bfa lps login completion callback
drivers/scsi/bfa/bfa_fcs.c: * Stop all vports and wait for vport stop completions.
drivers/scsi/bfa/bfa_fcs.c: * Delete all vports and wait for vport delete completions.
drivers/scsi/bfa/bfa_fcs.c:	 * Initialize fabric delete completion handler. Fabric deletion is
drivers/scsi/bfa/bfa_fcs.c: *   Flogi Acc completion callback.
drivers/scsi/bfa/bfa_modules.h:	struct list_head	comp_q;		/*  pending completions     */
drivers/scsi/bfa/bfad_im.c:			/* Queue depth adjustment for good status completion */
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&bfad->enable_comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&bfad->enable_comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&bfad->disable_comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&bfad->disable_comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&cee_comp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&cee_comp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&cee_comp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&cee_comp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:		wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:		wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:		wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:		wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:		wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:		wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:		wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_bsg.c:	init_completion(&drv_fcxp->comp);
drivers/scsi/bfa/bfad_bsg.c:		wait_for_completion(&drv_fcxp->comp);
drivers/scsi/bfa/bfi_ms.h: *	IO completions.
drivers/scsi/bfa/bfi_ms.h:	u8	io_status;	/*  IO completion status	 */
drivers/scsi/bfa/bfad.c:		init_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:		/* Enable Interrupt and wait bfa_init completion */
drivers/scsi/bfa/bfad.c:		wait_for_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:				init_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:				wait_for_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:	struct completion fcomp;
drivers/scsi/bfa/bfad.c:	init_completion(vport->comp_del);
drivers/scsi/bfa/bfad.c:	wait_for_completion(vport->comp_del);
drivers/scsi/bfa/bfad.c:	init_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:	wait_for_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:	init_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:	wait_for_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:	init_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:	wait_for_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:		init_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:		wait_for_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:	/* Enable Interrupt and wait bfa_init completion */
drivers/scsi/bfa/bfad.c:	init_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:	wait_for_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:	init_completion(&bfad->comp);
drivers/scsi/bfa/bfad.c:	wait_for_completion(&bfad->comp);
drivers/scsi/bfa/bfa_fcs_rport.c: * Rport has sent LOGO. Awaiting FC-4 offline completion callback.
drivers/scsi/bfa/bfa_fcs_rport.c: *		LOGO needs to be sent to rport. Awaiting FC-4 offline completion
drivers/scsi/bfa/bfa_fcs_rport.c: *	Rport is going offline. Awaiting FC-4 offline completion callback.
drivers/scsi/bfa/bfa_ioc.c: * IOC disable completion entry.
drivers/scsi/bfa/bfa_ioc.c: * Notify enable completion callback.
drivers/scsi/bfa/bfa_ioc.c: * IOC disable completion entry.
drivers/scsi/bfa/bfa_ioc.c:	 * just wait for an initialization completion interrupt.
drivers/scsi/bfa/bfa_ioc.c:	 * Provide enable completion callback.
drivers/scsi/bfa/bfa_ioc.c:		 * Queue completion callback.
drivers/scsi/bfa/bfad_attr.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_attr.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_attr.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_attr.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_attr.c:	init_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_attr.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_attr.c:	wait_for_completion(&fcomp.comp);
drivers/scsi/bfa/bfad_attr.c:	struct completion fcomp;
drivers/scsi/bfa/bfad_attr.c:	init_completion(vport->comp_del);
drivers/scsi/bfa/bfad_attr.c:	wait_for_completion(vport->comp_del);
drivers/scsi/bfa/bfa_core.c:	 * acknowledge RME completions and update CI
drivers/scsi/bfa/bfa_core.c:	 * RME completion queue interrupt
drivers/scsi/bfa/bfa_core.c:	 * CPE completion queue interrupt
drivers/scsi/bfa/bfa_core.c:	 * Unconditional RME completion queue interrupt
drivers/scsi/bfa/bfa_core.c:	 * CPE completion queue interrupt
drivers/scsi/bfa/bfa_core.c: * Actions on chip-reset completion.
drivers/scsi/bfa/bfa_fcpim.c:	BFA_ITNIM_SM_CLEANUP = 6,	/*  IO cleanup completion */
drivers/scsi/bfa/bfa_fcpim.c:	BFA_IOIM_SM_ABORT_DONE	= 9,	/*  abort completion from f/w */
drivers/scsi/bfa/bfa_fcpim.c: * task management completion handling
drivers/scsi/bfa/bfa_fcpim.c:	BFA_TSKIM_SM_DONE	= 2,	/*  TM completion		*/
drivers/scsi/bfa/bfa_fcpim.c:	BFA_TSKIM_SM_HCB	= 6,	/*  BFA callback completion	*/
drivers/scsi/bfa/bfa_fcpim.c:	BFA_TSKIM_SM_IOS_DONE	= 7,	/*  IO and sub TM completions	*/
drivers/scsi/bfa/bfa_fcpim.c:	BFA_TSKIM_SM_CLEANUP_DONE = 9,	/*  TM abort completion	*/
drivers/scsi/bfa/bfa_fcpim.c:	BFA_TSKIM_SM_UTAG	= 10,	/*  TM completion unknown tag  */
drivers/scsi/bfa/bfa_fcpim.c: * IO cleanup completion
drivers/scsi/bfa/bfa_fcpim.c: * IO is being aborted, waiting for completion from firmware.
drivers/scsi/bfa/bfa_fcpim.c: * IO is being cleaned up (implicit abort), waiting for completion from
drivers/scsi/bfa/bfa_fcpim.c:		 * setup residue value correctly for normal completions
drivers/scsi/bfa/bfa_fcpim.c: * TM command is active, awaiting completion from firmware to
drivers/scsi/bfa/bfa_fcpim.c: * completion event from firmware.
drivers/scsi/bfa/bfa_fcpim.c:		 * Ignore and wait for ABORT completion from firmware.
drivers/scsi/bfa/bfa_fcpim.c:		 * Notify TM conmpletion on IO cleanup completion.
drivers/scsi/bfa/bfa_fcpim.c: * IO cleanup completion
drivers/scsi/bfa/bfa_fcpim.c: * Notification on completions from related ioim.
drivers/scsi/bfa/bfa_fcpim.c:	 * requests. All other statuses are for normal completions.
drivers/scsi/bfa/bfi.h:	BFI_MC_IOIM_IOCOM	= 17,	/*  good IO completion		    */
drivers/scsi/bfa/bfa_svc.h:	bfa_cb_fcxp_send_t send_cbfn;   /*  send completion callback */
drivers/scsi/bfa/bfad_drv.h:	struct completion *comp_del;
drivers/scsi/bfa/bfad_drv.h:	struct completion comp;
drivers/scsi/bfa/bfad_drv.h:	struct completion suspend;
drivers/scsi/bfa/bfad_drv.h:	struct completion enable_comp;
drivers/scsi/bfa/bfad_drv.h:	struct completion disable_comp;
drivers/scsi/bfa/bfad_drv.h:	struct completion comp;
drivers/scsi/bfa/bfad_drv.h:	struct completion comp;
drivers/scsi/bfa/bfa_fcs.h:	BFA_FCS_FABRIC_SM_STOPCOMP	= 18,	/*  Stop completion	*/
drivers/scsi/bfa/bfa_fcs.h:	BFA_FCS_FABRIC_SM_LOGOCOMP	= 19,	/*  FLOGO completion	*/
drivers/scsi/bfa/bfa_svc.c:	/* discarded fcxp completion */
drivers/scsi/bfa/bfa_svc.c: * Indirect login completion handler for non-fcs
drivers/scsi/bfa/bfa_svc.c: * Login completion handler -- direct call for fcs, queue for others
drivers/scsi/bfa/bfa_svc.c: * Indirect logout completion handler for non-fcs
drivers/scsi/bfa/bfa_svc.c: * Logout completion handler -- direct call for fcs, queue for others
drivers/scsi/bfa/bfa_svc.c: * Clear virtual link completion handler for non-fcs
drivers/scsi/bfa/bfa_svc.c: * No need to wait for any pending login/logout completions.
drivers/scsi/bfa/bfa_defs_svc.h:	bfa_boolean_t	delay_comp;	/* delay completion of failed
drivers/scsi/bfa/bfa_defs_svc.h:	u32	iocomp_ok;		/*  Slowpath IO completions	*/
drivers/scsi/bfa/bfa_defs_svc.h:	u32	iocom_hostabrts;	/*  Host IO abort completions	*/
drivers/scsi/bfa/bfa_defs_svc.h:	u32	iocomp_aborted;		/*  IO abort completions	*/
drivers/scsi/bfa/bfa_defs_svc.h:	u32	tm_io_comps;		/* Abort completion due to TM command */
drivers/scsi/bfa/bfa_defs_svc.h:	u32	create_comps;		/*  IT Nexus FW create completions */
drivers/scsi/bfa/bfa_defs_svc.h:	u32	delete_comps;		/*  IT Nexus FW delete completions */
drivers/scsi/bfa/bfa_defs_svc.h:	u32	cleanup_comps;		/*  IT Nexus cleanup completions    */
drivers/scsi/bfa/bfa_defs_svc.h:	u32	tm_cleanup_comps;	/*  TM cleanup completions	*/
drivers/scsi/bnx2i/bnx2i_init.c:	/* Create percpu kernel threads to handle iSCSI I/O completions */
drivers/scsi/bnx2i/bnx2i_hwi.c:	login_wqe->cq_index = 0; /* CQ# used for completion, 5771x only */
drivers/scsi/bnx2i/bnx2i_hwi.c:	tmfabort_wqe->cq_index = 0; /* CQ# used for completion, 5771x only */
drivers/scsi/bnx2i/bnx2i_hwi.c:	text_wqe->cq_index = 0; /* CQ# used for completion, 5771x only */
drivers/scsi/bnx2i/bnx2i_hwi.c:	scsi_cmd_wqe->cq_index = 0; /* CQ# used for completion, 5771x only */
drivers/scsi/bnx2i/bnx2i_hwi.c:	nopout_wqe->cq_index = 0; /* CQ# used for completion, 5771x only */
drivers/scsi/bnx2i/bnx2i_hwi.c:	logout_wqe->cq_index = 0; /* CQ# used for completion, 5771x only */
drivers/scsi/bnx2i/bnx2i_hwi.c:	cmd_cleanup->cq_index = 0; /* CQ# used for completion, 5771x only */
drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_process_scsi_cmd_resp - this function handles scsi cmd completion.
drivers/scsi/bnx2i/bnx2i_hwi.c: * process iSCSI NOPIN local completion CQE, frees IIT and command structures
drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_process_cmd_cleanup_resp - process scsi command clean-up completion
drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_queue_scsi_cmd_resp - queue cmd completion to the percpu thread
drivers/scsi/bnx2i/bnx2i_hwi.c: * completion CQEs
drivers/scsi/bnx2i/bnx2i_hwi.c: * cpu_id gets recorded upon task_xmit.  No out-of-order completion!
drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_process_update_conn_cmpl - process iscsi conn update completion KCQE
drivers/scsi/bnx2i/bnx2i_hwi.c: * CONN_UPDATE completion handler, this completes iSCSI connection FFP migration
drivers/scsi/bnx2i/bnx2i_hwi.c:	if (update_kcqe->completion_status) {
drivers/scsi/bnx2i/bnx2i_hwi.c:			  iscsi_cid, tcp_err->completion_status);
drivers/scsi/bnx2i/bnx2i_hwi.c:	err_mask64 = (0x1ULL << iscsi_err->completion_status);
drivers/scsi/bnx2i/bnx2i_hwi.c:	switch (iscsi_err->completion_status) {
drivers/scsi/bnx2i/bnx2i_hwi.c:				  iscsi_err->completion_status);
drivers/scsi/bnx2i/bnx2i_hwi.c:		if (!test_and_set_bit(iscsi_err->completion_status,
drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_process_conn_destroy_cmpl - process iscsi conn destroy completion
drivers/scsi/bnx2i/bnx2i_hwi.c: * handles connection destroy completion request.
drivers/scsi/bnx2i/bnx2i_hwi.c:				  "offload request, unexpected completion\n");
drivers/scsi/bnx2i/bnx2i_hwi.c:	if (conn_destroy->completion_status) {
drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_process_ofld_cmpl - process initial iscsi conn offload completion
drivers/scsi/bnx2i/bnx2i_hwi.c: * handles initial connection offload completion, ep_connect() thread is
drivers/scsi/bnx2i/bnx2i_hwi.c:	if (ofld_kcqe->completion_status) {
drivers/scsi/bnx2i/bnx2i_hwi.c:		if (ofld_kcqe->completion_status ==
drivers/scsi/bnx2i/bnx2i_hwi.c:		else if (ofld_kcqe->completion_status ==
drivers/scsi/bnx2i/bnx2i_hwi.c:		else if (ofld_kcqe->completion_status ==
drivers/scsi/bnx2i/bnx2i_hwi.c:				ofld_kcqe->completion_status);
drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_indicate_kcqe - process iscsi conn update completion KCQE
drivers/scsi/bnx2i/bnx2i_hwi.c:			if (ikcqe->completion_status !=
drivers/scsi/bnx2i/bnx2i_hwi.c:							  completion_status);
drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_cm_connect_cmpl - process iscsi conn establishment completion
drivers/scsi/bnx2i/bnx2i_hwi.c: *	indicate completion of option-2 TCP connect request.
drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_cm_close_cmpl - process tcp conn close completion
drivers/scsi/bnx2i/bnx2i_hwi.c: *	indicate completion of option-2 graceful TCP connect shutdown
drivers/scsi/bnx2i/bnx2i_hwi.c: * bnx2i_cm_abort_cmpl - process abortive tcp conn teardown completion
drivers/scsi/bnx2i/bnx2i_hwi.c: *	indicate completion of option-2 abortive TCP connect termination
drivers/scsi/bnx2i/57xx_iscsi_constants.h:/* KCQ (kernel completion queue) response op codes */
drivers/scsi/bnx2i/57xx_iscsi_constants.h:/* KCQ (kernel completion queue) completion status */
drivers/scsi/bnx2i/57xx_iscsi_hsi.h:	u32 completion_status;
drivers/scsi/bnx2i/bnx2i.h:#include <linux/completion.h>
drivers/scsi/bnx2i/bnx2i.h:	struct completion cmd_cleanup_cmpl;
drivers/scsi/bnx2i/bnx2i.h: * @ep_ofld_list:          connection list for pending offload completion
drivers/scsi/bnx2i/bnx2i.h: * @ep_destroy_list:       connection list for pending offload completion
drivers/scsi/bnx2i/bnx2i.h:	/* CQ pending completion counter */
drivers/scsi/bnx2i/bnx2i.h:	/* CQ pending completion ITT array */
drivers/scsi/bnx2i/bnx2i.h: * @cq_virt:            virtual address of completion queue (CQ) region
drivers/scsi/bnx2i/bnx2i.h: *	to send work requests (SQ), receive completion notifications (CQ)
drivers/scsi/bnx2i/bnx2i_iscsi.c: *	completion/interrupt thread using iscsi context ID
drivers/scsi/bnx2i/bnx2i_iscsi.c: * pending conn offload completion queue manager
drivers/scsi/bnx2i/bnx2i_iscsi.c: * pending conn offload completion queue manager
drivers/scsi/bnx2i/bnx2i_iscsi.c:		wait_for_completion_timeout(&bnx2i_conn->cmd_cleanup_cmpl,
drivers/scsi/bnx2i/bnx2i_iscsi.c:	init_completion(&bnx2i_conn->cmd_cleanup_cmpl);
drivers/scsi/gdth.c:		complete((struct completion *)scp->request);
drivers/scsi/gdth.c:    /* use request field to save the ptr. to completion struct. */
drivers/scsi/gdth.c:    wait_for_completion(&wait);
drivers/scsi/gdth.c:                if (!nscp_cmndinfo->wait_for_completion)
drivers/scsi/gdth.c:                    nscp_cmndinfo->wait_for_completion++;
drivers/scsi/gdth.c:            if (!nscp_cmndinfo->wait_for_completion)
drivers/scsi/gdth.c:                nscp_cmndinfo->wait_for_completion++;
drivers/scsi/gdth.c:                    if (!nscp_cmndinfo->wait_for_completion)
drivers/scsi/gdth.c:                        nscp_cmndinfo->wait_for_completion++;
drivers/scsi/gdth.c:                    if (!nscp_cmndinfo->wait_for_completion)
drivers/scsi/gdth.c:                        nscp_cmndinfo->wait_for_completion++;
drivers/scsi/gdth.c:                    if (!nscp_cmndinfo->wait_for_completion)
drivers/scsi/gdth.c:                        nscp_cmndinfo->wait_for_completion++;
drivers/scsi/gdth.c:                if (!nscp_cmndinfo->wait_for_completion)
drivers/scsi/gdth.c:                    nscp_cmndinfo->wait_for_completion++;
drivers/scsi/gdth.c:    if (!cmndinfo->wait_for_completion)
drivers/scsi/gdth.c:        cmndinfo->wait_for_completion++;
drivers/scsi/gdth.c:        if (!cmndinfo->wait_for_completion)
drivers/scsi/gdth.c:            cmndinfo->wait_for_completion++;
drivers/scsi/gdth.c:    cmndinfo->wait_for_completion = 1;
drivers/scsi/gdth.c:            gdth_wait_completion(ha, ha->bus_cnt, j);
drivers/scsi/gdth.c:                    gdth_wait_completion(ha, i, j);
drivers/scsi/ipr.c: * timeout given. The done function is invoked on command completion.
drivers/scsi/ipr.c:		complete(&ipr_cmd->completion);
drivers/scsi/ipr.c: * ipr_send_blocking_cmd - Send command and sleep on its completion.
drivers/scsi/ipr.c:	init_completion(&ipr_cmd->completion);
drivers/scsi/ipr.c:	wait_for_completion(&ipr_cmd->completion);
drivers/scsi/ipr.c:			timeout = wait_for_completion_timeout(&comp, timeout);
drivers/scsi/ipr.c:	if (ipr_cmd->completion.done || ioa_cfg->in_reset_reload) {
drivers/scsi/ipr.c: * ipr_erp_done - Process completion of ERP for a device
drivers/scsi/ipr.c: * ipr_ioa_bringdown_done - IOA bring down completion.
drivers/scsi/ipr.c: * This function processes the completion of an adapter bring down.
drivers/scsi/ipr.c: * ipr_ioa_reset_done - IOA reset completion.
drivers/scsi/ipr.c: * This function processes the completion of an adapter reset.
drivers/scsi/ipr.c: * ipr_reset_ucode_download_done - Microcode download completion
drivers/scsi/ipr.c: * If the caller needs to wait on the completion of the reset,
drivers/scsi/ipr.c: * If the caller needs to wait on the completion of the reset,
drivers/scsi/ipr.c: * If the caller needs to wait on the completion of the reset,
drivers/scsi/ipr.c: * ipr_halt_done - Shutdown prepare completion
drivers/scsi/scsi_lib.c:#include <linux/completion.h>
drivers/scsi/scsi_lib.c: * because it's always called before the completion.  This function is
drivers/scsi/scsi_lib.c: * for a requeue after completion, which should only occur in this
drivers/scsi/scsi_lib.c: * Called for single_lun devices on IO completion. Clear starget_sdev_user,
drivers/scsi/scsi_lib.c: * Notes:	After command completion, there may be blocks left
drivers/scsi/scsi_lib.c: * Function:    scsi_io_completion()
drivers/scsi/scsi_lib.c:void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)
drivers/scsi/scsi_lib.c:			 * in scsi_log_completion(), so avoid duplicate messages
drivers/scsi/scsi_lib.c:	 * SCSI request completion path will do scsi_device_unbusy(),
drivers/scsi/scsi_lib.c:	scsi_log_completion(cmd, disposition);
drivers/scsi/scsi_lib.c: * scsi_done - Invoke completion on finished SCSI command.
drivers/scsi/mesh.c:			dlog(ms, "Selecting phase at command completion",0);
drivers/scsi/device_handler/scsi_dh_emc.c:	 * and completion sequence of all commands for same multipath.
drivers/scsi/device_handler/scsi_dh_emc.c: * assumes serial servicing of commands, both issuance and completion.
drivers/scsi/ufs/ufshcd.h:#include <linux/completion.h>
drivers/scsi/ufs/ufshcd.h: * @done: UIC command completion
drivers/scsi/ufs/ufshcd.h:	struct completion done;
drivers/scsi/ufs/ufshcd.h: * @complete: internal commands completion
drivers/scsi/ufs/ufshcd.h:	struct completion *complete;
drivers/scsi/ufs/ufshcd.h: * completion before gating clocks.
drivers/scsi/ufs/ufshcd.h: * @pwr_done: completion for power mode change
drivers/scsi/ufs/ufshcd.h:	struct completion *uic_async_done;
drivers/scsi/ufs/ufshcd.c: * This function gets the result of UIC command completion
drivers/scsi/ufs/ufshcd.c:	if (wait_for_completion_timeout(&uic_cmd->done,
drivers/scsi/ufs/ufshcd.c: * @completion: initialize the completion only if this is set to true
drivers/scsi/ufs/ufshcd.c:		      bool completion)
drivers/scsi/ufs/ufshcd.c:	if (completion)
drivers/scsi/ufs/ufshcd.c:		init_completion(&uic_cmd->done);
drivers/scsi/ufs/ufshcd.c:	 * updates OCS on command completion, with the command
drivers/scsi/ufs/ufshcd.c:		 * completion.
drivers/scsi/ufs/ufshcd.c: * ufshcd_dev_cmd_completion() - handles device management command responses
drivers/scsi/ufs/ufshcd.c:ufshcd_dev_cmd_completion(struct ufs_hba *hba, struct ufshcd_lrb *lrbp)
drivers/scsi/ufs/ufshcd.c:	time_left = wait_for_completion_timeout(hba->dev_cmd.complete,
drivers/scsi/ufs/ufshcd.c:			err = ufshcd_dev_cmd_completion(hba, lrbp);
drivers/scsi/ufs/ufshcd.c:	struct completion wait;
drivers/scsi/ufs/ufshcd.c:	init_completion(&wait);
drivers/scsi/ufs/ufshcd.c: * and device UniPro link and hence it's final completion would be indicated by
drivers/scsi/ufs/ufshcd.c: * addition to normal UIC command completion Status (UCCS). This function only
drivers/scsi/ufs/ufshcd.c: * returns after the relevant status bits indicate the completion.
drivers/scsi/ufs/ufshcd.c:	struct completion uic_async_done;
drivers/scsi/ufs/ufshcd.c:	init_completion(&uic_async_done);
drivers/scsi/ufs/ufshcd.c:		 * Make sure UIC command completion interrupt is disabled before
drivers/scsi/ufs/ufshcd.c:	if (!wait_for_completion_timeout(hba->uic_async_done,
drivers/scsi/ufs/ufshcd.c:			"pwr ctrl cmd 0x%x with mode 0x%x completion timeout\n",
drivers/scsi/ufs/ufshcd.c: * ufshcd_task_req_compl - handle task management request completion
drivers/scsi/ufs/ufshcd.c: * ufshcd_uic_cmd_compl - handle completion of uic command
drivers/scsi/ufs/ufshcd.c: * __ufshcd_transfer_req_compl - handle SCSI and query command completion
drivers/scsi/ufs/ufshcd.c: * ufshcd_transfer_req_compl - handle SCSI and query command completion
drivers/scsi/ufs/ufshcd.c: * ufshcd_tmc_handler - handle task management function completion
drivers/scsi/ipr.h:#include <linux/completion.h>
drivers/scsi/ipr.h:	struct completion completion;
drivers/scsi/ipr.h:	struct completion *eh_comp;
drivers/scsi/ppa.h: * Add ppa_wait() calls to ppa_completion()
drivers/scsi/ppa.h: * Busy wait for connected status bit in ppa_completion()
drivers/scsi/scsi_debug.c:static atomic_t sdebug_completions;  /* count of deferred completions */
drivers/scsi/scsi_debug.c:static atomic_t sdebug_miss_cpus;    /* submission + completion cpus differ */
drivers/scsi/scsi_debug.c:/* Queued (deferred) command completions converge here. */
drivers/scsi/scsi_debug.c:		atomic_inc(&sdebug_completions);
drivers/scsi/scsi_debug.c:		pr_err("Unexpected completion\n");
drivers/scsi/scsi_debug.c:	atomic_set(&sdebug_completions, 0);
drivers/scsi/scsi_debug.c:	seq_printf(m, "cmnd_count=%d, completions=%d, %s=%d, a_tsf=%d\n",
drivers/scsi/scsi_debug.c:		   atomic_read(&sdebug_completions),
drivers/scsi/sym53c8xx_2/sym_hipd.h:	 *  Command completion queue.
drivers/scsi/sym53c8xx_2/sym_hipd.h:	 *  to the comp_ccbq prior to completion.
drivers/scsi/sym53c8xx_2/sym_glue.c:	struct completion *eh_done;		/* SCSI error handling */
drivers/scsi/sym53c8xx_2/sym_glue.c:	 *  completions being lost when the clearing 
drivers/scsi/sym53c8xx_2/sym_glue.c:	 *  If this ever happen, lost completions will 
drivers/scsi/sym53c8xx_2/sym_glue.c:	struct completion eh_done;
drivers/scsi/sym53c8xx_2/sym_glue.c:		init_completion(&eh_done);
drivers/scsi/sym53c8xx_2/sym_glue.c:			finished_reset = wait_for_completion_timeout
drivers/scsi/sym53c8xx_2/sym_glue.c:	/* This one is queued in some place -> to wait for completion */
drivers/scsi/sym53c8xx_2/sym_glue.c:		init_completion(&eh_done);
drivers/scsi/sym53c8xx_2/sym_glue.c:		if (!wait_for_completion_timeout(&eh_done, 5*HZ)) {
drivers/scsi/sym53c8xx_2/sym_glue.c: * OK to resume normal operation. Use completion to allow
drivers/scsi/sym53c8xx_2/sym_hipd.c: *  device queue and the queue is frozen until a completion.
drivers/scsi/sym53c8xx_2/sym_hipd.c:		 *  The algorithm tries to prevent completion of any 
drivers/scsi/sym53c8xx_2/sym_glue.h:#include <linux/completion.h>
drivers/scsi/sym53c8xx_2/sym_glue.h:	struct completion *io_reset;		/* PCI error handling */
drivers/scsi/sym53c8xx_2/sym_fw2.h:	 *  We donnot want the CPU to deal with completions  
drivers/scsi/sym53c8xx_2/sym_fw2.h:	 *  completions.
drivers/scsi/sym53c8xx_2/sym_fw2.h:	 *  signal completion to the host.
drivers/scsi/sym53c8xx_2/sym_fw1.h:	 *  We donnot want the CPU to deal with completions  
drivers/scsi/sym53c8xx_2/sym_fw1.h:	 *  completions.
drivers/scsi/sym53c8xx_2/sym_fw1.h:	 *  signal completion to the host.
drivers/scsi/hisi_sas/hisi_sas_v2_hw.c:		/* Check for NCQ completion */
drivers/scsi/hisi_sas/hisi_sas_main.c:	complete(&task->slow_task->completion);
drivers/scsi/hisi_sas/hisi_sas_main.c:	complete(&task->slow_task->completion);
drivers/scsi/hisi_sas/hisi_sas_main.c:		wait_for_completion(&task->slow_task->completion);
drivers/scsi/hisi_sas/hisi_sas_main.c:	wait_for_completion(&task->slow_task->completion);
drivers/scsi/hisi_sas/hisi_sas_v1_hw.c:		/* The completion queue and queue slot index are not
drivers/scsi/qlogicpti.c: * request-completion handling).
drivers/scsi/qlogicpti.c:	switch (sts->completion_status) {
drivers/scsi/qlogicpti.c:		printk(KERN_EMERG "qlogicpti%d: unknown completion status 0x%04x\n",
drivers/scsi/qlogicpti.c:		       id, sts->completion_status);
drivers/scsi/qlogicpti.c:		if (sts->completion_status == CS_RESET_OCCURRED ||
drivers/scsi/qlogicpti.c:		    sts->completion_status == CS_ABORTED ||
drivers/scsi/scsi_transport_iscsi.c: * iscsi_session_event - send session destr. completion event
drivers/scsi/dc395x.c: * layer, invoke 'done' on completion
drivers/scsi/dc395x.c: * @done: function pointer to be invoked on completion
drivers/scsi/dc395x.c: * Signal completion to the generic SCSI driver  
drivers/scsi/hpsa_cmd.h:	struct completion *waiting;
drivers/scsi/scsi_scan.c:	struct completion prev_finished;
drivers/scsi/scsi_scan.c:	init_completion(&data->prev_finished);
drivers/scsi/scsi_scan.c:	wait_for_completion(&data->prev_finished);
drivers/scsi/scsi_scan.c:	init_completion(&data->prev_finished);
drivers/scsi/scsi_scan.c:	wait_for_completion(&data->prev_finished);
drivers/scsi/a100u2w.c:	   a completion ? */
drivers/scsi/a100u2w.c: *	Perform completion processing on a control block. Do the conversions
drivers/scsi/53c700.h:	struct completion *eh_complete;
drivers/platform/olpc/olpc-ec.c:#include <linux/completion.h>
drivers/platform/olpc/olpc-ec.c:	struct completion finished;
drivers/platform/olpc/olpc-ec.c:	init_completion(&desc.finished);
drivers/platform/olpc/olpc-ec.c:	wait_for_completion(&desc.finished);
drivers/platform/x86/samsung-laptop.c:			" completion flag 0x%02x and interface data 0x%02x",
drivers/platform/x86/intel_scu_ipc.c:	struct completion cmd_complete;
drivers/platform/x86/intel_scu_ipc.c:		reinit_completion(&scu->cmd_complete);
drivers/platform/x86/intel_scu_ipc.c:	if (!wait_for_completion_timeout(&scu->cmd_complete, 3 * HZ)) {
drivers/platform/x86/intel_scu_ipc.c:	init_completion(&scu->cmd_complete);
drivers/platform/x86/apple-gmux.c:	struct completion powerchange_done;
drivers/platform/x86/apple-gmux.c:	reinit_completion(&gmux_data->powerchange_done);
drivers/platform/x86/apple-gmux.c:	    !wait_for_completion_interruptible_timeout(&gmux_data->powerchange_done,
drivers/platform/x86/apple-gmux.c:	init_completion(&gmux_data->powerchange_done);
drivers/platform/x86/intel_punit_ipc.c:	struct completion cmd_complete;
drivers/platform/x86/intel_punit_ipc.c:		if (!wait_for_completion_timeout(&ipcdev->cmd_complete,
drivers/platform/x86/intel_punit_ipc.c:	reinit_completion(&ipcdev->cmd_complete);
drivers/platform/x86/intel_punit_ipc.c:	reinit_completion(&ipcdev->cmd_complete);
drivers/platform/x86/intel_punit_ipc.c:	init_completion(&punit_ipcdev->cmd_complete);
drivers/platform/x86/intel_pmc_ipc.c:	struct completion cmd_complete;
drivers/platform/x86/intel_pmc_ipc.c:		reinit_completion(&ipcdev.cmd_complete);
drivers/platform/x86/intel_pmc_ipc.c:		if (0 == wait_for_completion_timeout(
drivers/platform/x86/intel_pmc_ipc.c:	init_completion(&ipcdev.cmd_complete);
drivers/platform/x86/intel_pmc_ipc.c:	init_completion(&ipcdev.cmd_complete);
drivers/w1/masters/ds1wm.c:	timeleft = wait_for_completion_timeout(&reset_done, DS1WM_TIMEOUT);
drivers/w1/masters/ds1wm.c:	timeleft = wait_for_completion_timeout(&write_done, DS1WM_TIMEOUT);
drivers/w1/masters/ds1wm.c:	timeleft = wait_for_completion_timeout(&read_done, DS1WM_TIMEOUT);
drivers/w1/w1.h:#include <linux/completion.h>
drivers/vfio/pci/vfio_pci_config.c:	 * signal completion.  If an error occurs above, we assume that not
drivers/infiniband/hw/i40iw/i40iw_puda.h:struct i40iw_puda_completion_info {
drivers/infiniband/hw/i40iw/i40iw_puda.h:	enum puda_rsrc_complete completion;
drivers/infiniband/hw/i40iw/i40iw_puda.h:enum i40iw_status_code i40iw_puda_poll_completion(struct i40iw_sc_dev *dev,
drivers/infiniband/hw/i40iw/i40iw_puda.h:enum i40iw_status_code i40iw_puda_get_tcpip_info(struct i40iw_puda_completion_info *info,
drivers/infiniband/hw/i40iw/i40iw_main.c:		i40iw_pr_err("ceq destroy completion failed %d\n", status);
drivers/infiniband/hw/i40iw/i40iw_main.c: * i40iw_create_ceq - create completion event queue
drivers/infiniband/hw/i40iw/i40iw_main.c: * Allocate a list for all device completion event queues
drivers/infiniband/hw/i40iw/i40iw_main.c:	i40iw_pr_err("status = %d last completion = %d\n", status, iwdev->init_state);
drivers/infiniband/hw/i40iw/i40iw_utils.c: * i40iw_wait_event - wait for completion
drivers/infiniband/hw/i40iw/i40iw_utils.c:		i40iw_pr_err("error cqp command 0x%x completion maj = 0x%x min=0x%x\n",
drivers/infiniband/hw/i40iw/i40iw_utils.c: * i40iw_cqp_manage_hmc_fcn_callback - called function after cqp completion
drivers/infiniband/hw/i40iw/i40iw_utils.c:		i40iw_pr_err("virt channel completion timeout = 0x%x\n", timeout_ret);
drivers/infiniband/hw/i40iw/i40iw_utils.c:enum i40iw_status_code i40iw_puda_get_tcpip_info(struct i40iw_puda_completion_info *info,
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @count: how many times to try for completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @info: completion q entry to return
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @op_code: cqp opcode for completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @info: completion q entry to return
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @poll_registers: flag to poll register for cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * i40iw_sc_manage_hmc_pm_func_table_done - wait for cqp wqe completion for function table
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * i40iw_sc_commit_fpm_values_done - wait for cqp eqe completion for fpm commit
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @wait_type: poll ccq or cqp registers for cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * i40iw_sc_query_fpm_values_done - poll for cqp wqe completion for query fpm
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @wait_type: poll ccq or cqp registers for cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * i40iw_sc_cq_init - initialize completion q
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * i40iw_sc_cq_create - create completion q
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * i40iw_sc_cq_destroy - destroy completion q
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @scratch: u64 saved to be used during cqp completion
drivers/infiniband/hw/i40iw/i40iw_ctrl.c: * @poll_registers: flag to poll register for cqp completion
drivers/infiniband/hw/i40iw/i40iw_osdep.h:struct i40iw_puda_completion_info;
drivers/infiniband/hw/i40iw/i40iw_osdep.h:enum i40iw_status_code i40iw_puda_get_tcpip_info(struct i40iw_puda_completion_info *info,
drivers/infiniband/hw/i40iw/i40iw_vf.c: * @scratch: pointer for completion
drivers/infiniband/hw/i40iw/i40iw_puda.c: * i40iw_puda_poll_info - poll cq for completion
drivers/infiniband/hw/i40iw/i40iw_puda.c: * @info: info return for successful completion
drivers/infiniband/hw/i40iw/i40iw_puda.c:						   struct i40iw_puda_completion_info *info)
drivers/infiniband/hw/i40iw/i40iw_puda.c: * i40iw_puda_poll_completion - processes completion for cq
drivers/infiniband/hw/i40iw/i40iw_puda.c: * @compl_err: return any completion err
drivers/infiniband/hw/i40iw/i40iw_puda.c:enum i40iw_status_code i40iw_puda_poll_completion(struct i40iw_sc_dev *dev,
drivers/infiniband/hw/i40iw/i40iw_puda.c:	struct i40iw_puda_completion_info info;
drivers/infiniband/hw/i40iw/i40iw_puda.c:		i40iw_debug(dev, I40IW_DEBUG_PUDA, "%s RQ completion\n", __func__);
drivers/infiniband/hw/i40iw/i40iw_puda.c:		i40iw_debug(dev, I40IW_DEBUG_PUDA, "%s SQ completion\n", __func__);
drivers/infiniband/hw/i40iw/i40iw_puda.c:	/* if no wqe available or not from a completion and we have
drivers/infiniband/hw/i40iw/i40iw_puda.c:	/* if we are coming from a completion and have pending buffers
drivers/infiniband/hw/i40iw/i40iw_puda.c:	switch (rsrc->completion) {
drivers/infiniband/hw/i40iw/i40iw_puda.c:		rsrc->completion = PUDA_CQ_CREATED;
drivers/infiniband/hw/i40iw/i40iw_puda.c:	rsrc->completion = PUDA_QP_CREATED;
drivers/infiniband/hw/i40iw/i40iw_puda.c:			rsrc->completion = PUDA_HASH_CRC_COMPLETE;
drivers/infiniband/hw/i40iw/i40iw_uk.c:					  enum i40iw_completion_notify cq_notify)
drivers/infiniband/hw/i40iw/i40iw_uk.c: * i40iw_cq_poll_completion - get cq completion info
drivers/infiniband/hw/i40iw/i40iw_uk.c:static enum i40iw_status_code i40iw_cq_poll_completion(struct i40iw_cq_uk *cq,
drivers/infiniband/hw/i40iw/i40iw_uk.c:	i40iw_cq_poll_completion,
drivers/infiniband/hw/i40iw/i40iw_uk.c: * @ queue completion context
drivers/infiniband/hw/i40iw/i40iw_uk.c: * @signaled: flag if signaled for completion
drivers/infiniband/hw/i40iw/i40iw_hw.c: * i40iw_cqp_ce_handler - handle cqp completions
drivers/infiniband/hw/i40iw/i40iw_hw.c: * @arm: flag to arm after completions
drivers/infiniband/hw/i40iw/i40iw_hw.c: * @cq: cq for cqp completions
drivers/infiniband/hw/i40iw/i40iw_hw.c: * i40iw_iwarp_ce_handler - handle iwarp completions
drivers/infiniband/hw/i40iw/i40iw_hw.c: * i40iw_puda_ce_handler - handle puda completion events
drivers/infiniband/hw/i40iw/i40iw_hw.c: * @cq: puda completion q for event
drivers/infiniband/hw/i40iw/i40iw_hw.c:		status = i40iw_puda_poll_completion(dev, cq, &compl_error);
drivers/infiniband/hw/i40iw/i40iw_hw.c: * i40iw_process_ceq - handle ceq for completions
drivers/infiniband/hw/i40iw/i40iw_hw.c: * @ceq: ceq having cq for completion
drivers/infiniband/hw/i40iw/i40iw_hw.c: * @cqp_request: qhash cqp completion
drivers/infiniband/hw/i40iw/i40iw_hw.c: * @wait: wait for completion
drivers/infiniband/hw/i40iw/i40iw_hw.c: * @wait: flag wait for completion
drivers/infiniband/hw/i40iw/i40iw_hw.c: * @wait: flag wait for completion
drivers/infiniband/hw/i40iw/i40iw_verbs.h:	u32 polled_completions;
drivers/infiniband/hw/i40iw/i40iw_verbs.h:	struct completion sq_drained;
drivers/infiniband/hw/i40iw/i40iw_verbs.h:	struct completion rq_drained;
drivers/infiniband/hw/i40iw/i40iw_verbs.c:			   /* let the completion of the qp destroy free the qp */
drivers/infiniband/hw/i40iw/i40iw_verbs.c:	init_completion(&iwqp->sq_drained);
drivers/infiniband/hw/i40iw/i40iw_verbs.c:	init_completion(&iwqp->rq_drained);
drivers/infiniband/hw/i40iw/i40iw_verbs.c: * @wait: flag to wait or not for modify qp completion
drivers/infiniband/hw/i40iw/i40iw_verbs.c:		wait_for_completion(&iwqp->sq_drained);
drivers/infiniband/hw/i40iw/i40iw_verbs.c:		wait_for_completion(&iwqp->rq_drained);
drivers/infiniband/hw/i40iw/i40iw_verbs.c: * i40iw_poll_cq - poll cq for completion (kernel apps)
drivers/infiniband/hw/i40iw/i40iw_verbs.c:		ret = ukcq->ops.iw_cq_poll_completion(ukcq, &cq_poll_info);
drivers/infiniband/hw/i40iw/i40iw_verbs.c:	enum i40iw_completion_notify cq_notify = IW_CQ_COMPL_EVENT;
drivers/infiniband/hw/i40iw/i40iw.h:enum init_completion_state {
drivers/infiniband/hw/i40iw/i40iw.h:	enum init_completion_state init_state;
drivers/infiniband/hw/i40iw/i40iw.h: * to_iwcq - get completion queue
drivers/infiniband/hw/i40iw/i40iw_user.h:enum i40iw_completion_status {
drivers/infiniband/hw/i40iw/i40iw_user.h:enum i40iw_completion_notify {
drivers/infiniband/hw/i40iw/i40iw_user.h:	enum i40iw_completion_status comp_status;
drivers/infiniband/hw/i40iw/i40iw_user.h:					   enum i40iw_completion_notify);
drivers/infiniband/hw/i40iw/i40iw_user.h:	enum i40iw_status_code (*iw_cq_poll_completion)(struct i40iw_cq_uk *,
drivers/infiniband/hw/mthca/mthca_eq.c:			mthca_cq_completion(dev, disarm_cqn);
drivers/infiniband/hw/mthca/mthca_dev.h:void mthca_cq_completion(struct mthca_dev *dev, u32 cqn);
drivers/infiniband/hw/mthca/mthca_cq.c:void mthca_cq_completion(struct mthca_dev *dev, u32 cqn)
drivers/infiniband/hw/mthca/mthca_cq.c:	 * For completions in error, only work request ID, status, vendor error
drivers/infiniband/hw/mthca/mthca_cq.c:		 * WQE addr == base - 1 might be reported in receive completion
drivers/infiniband/hw/mthca/mthca_cmd.c:#include <linux/completion.h>
drivers/infiniband/hw/mthca/mthca_cmd.c:	struct completion done;
drivers/infiniband/hw/mthca/mthca_cmd.c:	init_completion(&context->done);
drivers/infiniband/hw/mthca/mthca_cmd.c:	if (!wait_for_completion_timeout(&context->done, timeout)) {
drivers/infiniband/hw/mthca/mthca_main.c:			  "completion queue table, aborting.\n");
drivers/infiniband/hw/mthca/mthca_provider.h: * completion being polled does not need a reference either.
drivers/infiniband/hw/mthca/mthca_provider.h: * Access because of a completion event should go as follows:
drivers/infiniband/hw/mlx5/cq.c:		pr_warn("unknown completion status\n");
drivers/infiniband/hw/mlx5/cq.c:		pr_err("Got signature completion error with bad syndrome %04x\n",
drivers/infiniband/hw/mlx5/cq.c:		mlx5_ib_dbg(dev, "polled software generated completion on CQ 0x%x\n",
drivers/infiniband/hw/mlx5/mr.c:	init_completion(&context->done);
drivers/infiniband/hw/mlx5/mr.c:		wait_for_completion(&umr_context.done);
drivers/infiniband/hw/mlx5/mr.c:			wait_for_completion(&umr_context.done);
drivers/infiniband/hw/mlx5/mr.c:				mlx5_ib_err(dev, "UMR completion failed, code %d\n",
drivers/infiniband/hw/mlx5/mr.c:		wait_for_completion(&umr_context.done);
drivers/infiniband/hw/mlx5/mr.c:		wait_for_completion(&umr_context.done);
drivers/infiniband/hw/mlx5/gsi.c:static void generate_completions(struct mlx5_ib_gsi_qp *gsi)
drivers/infiniband/hw/mlx5/gsi.c:static void handle_single_completion(struct ib_cq *cq, struct ib_wc *wc)
drivers/infiniband/hw/mlx5/gsi.c:	generate_completions(gsi);
drivers/infiniband/hw/mlx5/gsi.c:	gsi_wr->cqe.done = &handle_single_completion;
drivers/infiniband/hw/mlx5/gsi.c:	generate_completions(gsi);
drivers/infiniband/hw/mlx5/odp.c:			if (!wait_for_completion_timeout(
drivers/infiniband/hw/mlx5/odp.c:					&odp_data->notifier_completion,
drivers/infiniband/hw/mlx5/odp.c:				pr_warn("timeout waiting for mmu notifier completion\n");
drivers/infiniband/hw/mlx5/mlx5_ib.h:	struct completion	done;
drivers/infiniband/hw/qib/qib_verbs.c:		 "Maximum number of completion queue entries to support");
drivers/infiniband/hw/qib/qib_verbs.c:MODULE_PARM_DESC(max_cqs, "Maximum number of completion queues to support");
drivers/infiniband/hw/qib/qib_pcie.c: * Enable PCIe completion and data coalescing, on Intel 5x00 and 7300
drivers/infiniband/hw/qib/qib.h:#include <linux/completion.h>
drivers/infiniband/hw/qib/qib.h:	struct completion    comp;
drivers/infiniband/hw/qib/qib_mad.c: * @in_wc: the work completion entry for this packet
drivers/infiniband/hw/qib/qib_uc.c:		/* Signal completion event if the solicited bit is set. */
drivers/infiniband/hw/qib/qib_iba6120.c:			  "PCIe completion timeout"),
drivers/infiniband/hw/qib/qib_ud.c:	/* Signal completion event if the solicited bit is set. */
drivers/infiniband/hw/qib/qib_ud.c:			 * a completion for the loopback packet since
drivers/infiniband/hw/qib/qib_ud.c:	/* Signal completion event if the solicited bit is set. */
drivers/infiniband/hw/qib/qib_verbs.h:#include <linux/completion.h>
drivers/infiniband/hw/qib/qib_sdma.c:	wait_for_completion(&ss->comp);
drivers/infiniband/hw/qib/qib_sdma.c:	init_completion(&ppd->sdma_state.comp);
drivers/infiniband/hw/qib/qib_ruc.c:	/* Signal solicited completion event. */
drivers/infiniband/hw/qib/qib_ruc.c:	 * completion is generated.
drivers/infiniband/hw/qib/qib_ruc.c:	/* Signal completion event if the solicited bit is set. */
drivers/infiniband/hw/qib/qib_rc.c:		} else /* XXX need to handle delayed completion */
drivers/infiniband/hw/qib/qib_rc.c:		/* Post a send completion queue entry if requested. */
drivers/infiniband/hw/qib/qib_rc.c: * Generate a SWQE completion.
drivers/infiniband/hw/qib/qib_rc.c:static struct rvt_swqe *do_rc_completion(struct rvt_qp *qp,
drivers/infiniband/hw/qib/qib_rc.c:	 * completion if the SWQE is being resent until the send
drivers/infiniband/hw/qib/qib_rc.c:		/* Post a send completion queue entry if requested. */
drivers/infiniband/hw/qib/qib_rc.c:		 * we want to generate completion events for everything
drivers/infiniband/hw/qib/qib_rc.c:		 * the completion for the read.
drivers/infiniband/hw/qib/qib_rc.c:		wqe = do_rc_completion(qp, wqe, ibp);
drivers/infiniband/hw/qib/qib_rc.c:		wqe = do_rc_completion(qp, wqe, ibp);
drivers/infiniband/hw/qib/qib_rc.c:		/* Signal completion event if the solicited bit is set. */
drivers/infiniband/hw/qib/qib_iba7220.c:			  "PCIe completion timeout"),
drivers/infiniband/hw/qib/qib_common.h:#define QIB_CMD_SDMA_COMPLETE   32      /* sdma completion counter request */
drivers/infiniband/hw/qib/qib_common.h:		 * completion counter
drivers/infiniband/hw/cxgb3/cxio_wr.h:/* used for RQ completion processing */
drivers/infiniband/hw/cxgb3/cxio_wr.h:/* used for SQ completion processing */
drivers/infiniband/hw/cxgb3/cxio_hal.c:			PDBG("%s force completion at i %d\n", __func__, i);
drivers/infiniband/hw/cxgb3/cxio_hal.c:	 * Gotta tweak READ completions:
drivers/infiniband/hw/cxgb3/cxio_hal.c:		 * connection setup.  So ignore the completion.
drivers/infiniband/hw/cxgb3/cxio_hal.c:		 * these as work completions.
drivers/infiniband/hw/cxgb3/cxio_hal.c:	 * RECV completion.
drivers/infiniband/hw/cxgb3/cxio_hal.c:	 * If we get here its a send completion.
drivers/infiniband/hw/cxgb3/cxio_hal.c:	 * Handle out of order completion. These get stuffed
drivers/infiniband/hw/cxgb3/cxio_hal.c:	 * now in-order completions into the SW CQ.  This handles
drivers/infiniband/hw/cxgb3/cxio_hal.c:	 *	2) out of order read completions.
drivers/infiniband/hw/cxgb3/cxio_hal.c:		PDBG("%s out of order completion going in swsq at idx %ld\n",
drivers/infiniband/hw/cxgb3/cxio_hal.c:	 * completion.
drivers/infiniband/hw/cxgb3/iwch_ev.c:	 * 1) completion of our sending a TERMINATE.
drivers/infiniband/hw/cxgb3/iwch_ev.c:		 * Confirm the destination entry if this is a RECV completion.
drivers/infiniband/hw/mlx4/mad.c:				pr_debug("received tunnel send completion:"
drivers/infiniband/hw/mlx4/mad.c:			pr_debug("mlx4_ib: completion error in tunnel: %d."
drivers/infiniband/hw/mlx4/mad.c: * IB MAD completion callback for real SQPs
drivers/infiniband/hw/mlx4/mad.c:			pr_debug("mlx4_ib: completion error in tunnel: %d."
drivers/infiniband/hw/mlx4/cq.c:	 * simulated FLUSH_ERR completions
drivers/infiniband/hw/mlx4/qp.c:	 * set NEC bit to avoid getting completions with error for
drivers/infiniband/hw/mlx4/alias_GUID.c:	struct completion	done;
drivers/infiniband/hw/mlx4/alias_GUID.c:	init_completion(&callback_context->done);
drivers/infiniband/hw/mlx4/alias_GUID.c:			wait_for_completion(&cb_ctx->done);
drivers/infiniband/hw/nes/nes_hw.c:	u16 completion_ints = 0;
drivers/infiniband/hw/nes/nes_hw.c:					completion_ints = 1;
drivers/infiniband/hw/nes/nes_hw.c:			if (completion_ints == 0) {
drivers/infiniband/hw/nes/nes_hw.c:		if ( (completion_ints == 1) &&
drivers/infiniband/hw/nes/nes_hw.c:	/* nes_debug(NES_DBG_CQ, "Processing completion event for iWARP CQ%u.\n",
drivers/infiniband/hw/nes/nes_hw.c:	nes_debug(NES_DBG_QP, "Waiting for CQP completion for APBVT.\n");
drivers/infiniband/hw/nes/nes_hw.c:		u32 which_wq, u32 wait_completion)
drivers/infiniband/hw/nes/nes_hw.c:	if (wait_completion) {
drivers/infiniband/hw/nes/nes_hw.c:	if (wait_completion) {
drivers/infiniband/hw/nes/nes_verbs.c:	init_completion(&nesqp->sq_drained);
drivers/infiniband/hw/nes/nes_verbs.c:	init_completion(&nesqp->rq_drained);
drivers/infiniband/hw/nes/nes_verbs.c:		/* Clean any pending completions from the cq(s) */
drivers/infiniband/hw/nes/nes_verbs.c:		u32 next_iwarp_state, u32 termlen, u32 wait_completion)
drivers/infiniband/hw/nes/nes_verbs.c:	if (wait_completion) {
drivers/infiniband/hw/nes/nes_verbs.c:	if (wait_completion) {
drivers/infiniband/hw/nes/nes_verbs.c:		wait_for_completion(&nesqp->sq_drained);
drivers/infiniband/hw/nes/nes_verbs.c:		wait_for_completion(&nesqp->rq_drained);
drivers/infiniband/hw/nes/nes_verbs.c:		/* parse CQE, get completion context from WQE (either rq or sq) */
drivers/infiniband/hw/nes/nes_verbs.c:			nescq->polled_completions++;
drivers/infiniband/hw/nes/nes_verbs.c:			if ((nescq->polled_completions > (cq_size / 2)) ||
drivers/infiniband/hw/nes/nes_verbs.c:					(nescq->polled_completions == 255)) {
drivers/infiniband/hw/nes/nes_verbs.c:					nescq->hw_cq.cq_number, nescq->polled_completions, cq_size);
drivers/infiniband/hw/nes/nes_verbs.c:					nescq->hw_cq.cq_number | (nescq->polled_completions << 16));
drivers/infiniband/hw/nes/nes_verbs.c:				nescq->polled_completions = 0;
drivers/infiniband/hw/nes/nes_verbs.c:	if (nescq->polled_completions) {
drivers/infiniband/hw/nes/nes_verbs.c:				nescq->hw_cq.cq_number | (nescq->polled_completions << 16));
drivers/infiniband/hw/nes/nes_verbs.c:		nescq->polled_completions = 0;
drivers/infiniband/hw/nes/nes_verbs.c:	nes_debug(NES_DBG_CQ, "Reporting %u completions for CQ%u.\n",
drivers/infiniband/hw/nes/nes_mgt.c: * nes_download_callback - handle download completions
drivers/infiniband/hw/nes/nes_mgt.c:	/* Should we handle the bad completion */
drivers/infiniband/hw/nes/nes_mgt.c:		nes_debug(NES_DBG_PAU, "Waiting for CQP completion for adding the quad hash.\n");
drivers/infiniband/hw/nes/nes_mgt.c:	nes_debug(NES_DBG_PAU, "Waiting for CQP completion for deleting the quad hash.\n");
drivers/infiniband/hw/nes/nes_verbs.h:	u32              polled_completions;
drivers/infiniband/hw/nes/nes_verbs.h:	struct completion     sq_drained;
drivers/infiniband/hw/nes/nes_verbs.h:	struct completion     rq_drained;
drivers/infiniband/hw/ocrdma/ocrdma.h:	/* syncronizes cq completion handler invoked from multiple context */
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	/* Alloc completion queue for Mailbox queue */
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:		/* if completion came on sq, rq's cq is buddy cq.
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:		 * if completion came on rq, sq's cq is buddy cq.
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	/* if there is valid buddy cq, look for its completion handler */
drivers/infiniband/hw/qedr/qedr_hsi_rdma.h:/* rdma completion notification queue element */
drivers/infiniband/hw/qedr/qedr_hsi_rdma.h:/* rdma completion queue element */
drivers/infiniband/hw/qedr/qedr.h:	/* Lock to protect completion handler */
drivers/infiniband/hw/hns/hns_roce_main.c:		dev_err(dev, "Failed to init completion queue table.\n");
drivers/infiniband/hw/hns/hns_roce_cmd.c:	init_completion(&context->done);
drivers/infiniband/hw/hns/hns_roce_cmd.c:	* It is timeout when wait_for_completion_timeout return 0
drivers/infiniband/hw/hns/hns_roce_cmd.c:	if (!wait_for_completion_timeout(&context->done,
drivers/infiniband/hw/hns/hns_roce_cmd.c:		dev_err(dev, "[cmd]wait_for_completion_timeout timeout\n");
drivers/infiniband/hw/hns/hns_roce_device.h:	struct completion		free;
drivers/infiniband/hw/hns/hns_roce_device.h:	struct completion	done;
drivers/infiniband/hw/hns/hns_roce_device.h:	struct completion	free;
drivers/infiniband/hw/hns/hns_roce_device.h:void hns_roce_cq_completion(struct hns_roce_dev *hr_dev, u32 cqn);
drivers/infiniband/hw/hns/hns_roce_cq.c:	init_completion(&hr_cq->free);
drivers/infiniband/hw/hns/hns_roce_cq.c:	wait_for_completion(&hr_cq->free);
drivers/infiniband/hw/hns/hns_roce_cq.c:void hns_roce_cq_completion(struct hns_roce_dev *hr_dev, u32 cqn)
drivers/infiniband/hw/hns/hns_roce_qp.c:	init_completion(&hr_qp->free);
drivers/infiniband/hw/hns/hns_roce_qp.c:	init_completion(&hr_qp->free);
drivers/infiniband/hw/hns/hns_roce_qp.c:	wait_for_completion(&hr_qp->free);
drivers/infiniband/hw/hns/hns_roce_eq.c:		hns_roce_cq_completion(hr_dev, cqn);
drivers/infiniband/hw/cxgb4/cq.c: * Deal with out-of-order and/or completions that complete
drivers/infiniband/hw/cxgb4/cq.c:			 * Eat completions for unsignaled read WRs.
drivers/infiniband/hw/cxgb4/cq.c:		/* if its a SQ completion, then do the magic to move all the
drivers/infiniband/hw/cxgb4/cq.c:		 * unsignaled and now in-order completions into the swcq.
drivers/infiniband/hw/cxgb4/cq.c:	 * Gotta tweak READ completions:
drivers/infiniband/hw/cxgb4/cq.c:		 * connection setup.  So ignore the completion.
drivers/infiniband/hw/cxgb4/cq.c:		 * Eat completions for unsignaled read WRs.
drivers/infiniband/hw/cxgb4/cq.c:	 * RECV completion.
drivers/infiniband/hw/cxgb4/cq.c:	 * If we get here its a send completion.
drivers/infiniband/hw/cxgb4/cq.c:	 * Handle out of order completion. These get stuffed
drivers/infiniband/hw/cxgb4/cq.c:	 * now in-order completions into the SW CQ.  This handles
drivers/infiniband/hw/cxgb4/cq.c:	 *	2) out of order read completions.
drivers/infiniband/hw/cxgb4/cq.c:		PDBG("%s out of order completion going in sw_sq at idx %u\n",
drivers/infiniband/hw/cxgb4/cq.c:	 * completion.
drivers/infiniband/hw/cxgb4/cq.c:		* Account for any unsignaled completions completed by
drivers/infiniband/hw/cxgb4/cq.c:		* this signaled completion.  In this case, cidx points
drivers/infiniband/hw/cxgb4/iw_cxgb4.h:#include <linux/completion.h>
drivers/infiniband/hw/cxgb4/iw_cxgb4.h:	struct completion completion;
drivers/infiniband/hw/cxgb4/iw_cxgb4.h:	init_completion(&wr_waitp->completion);
drivers/infiniband/hw/cxgb4/iw_cxgb4.h:	complete(&wr_waitp->completion);
drivers/infiniband/hw/cxgb4/iw_cxgb4.h:	ret = wait_for_completion_timeout(&wr_waitp->completion, C4IW_WR_TO);
drivers/infiniband/hw/cxgb4/iw_cxgb4.h:	struct completion rq_drained;
drivers/infiniband/hw/cxgb4/iw_cxgb4.h:	struct completion sq_drained;
drivers/infiniband/hw/cxgb4/qp.c:	init_completion(&qhp->sq_drained);
drivers/infiniband/hw/cxgb4/qp.c:	init_completion(&qhp->rq_drained);
drivers/infiniband/hw/cxgb4/qp.c:		wait_for_completion(&qp->sq_drained);
drivers/infiniband/hw/cxgb4/qp.c:		wait_for_completion(&qp->rq_drained);
drivers/infiniband/hw/cxgb4/t4.h:/* used for RQ completion processing */
drivers/infiniband/hw/cxgb4/t4.h:/* used for SQ completion processing */
drivers/infiniband/hw/hfi1/rc.c:		} else { /* need to handle delayed completion */
drivers/infiniband/hw/hfi1/rc.c:		/* Post a send completion queue entry if requested. */
drivers/infiniband/hw/hfi1/rc.c: * Generate a SWQE completion.
drivers/infiniband/hw/hfi1/rc.c:static struct rvt_swqe *do_rc_completion(struct rvt_qp *qp,
drivers/infiniband/hw/hfi1/rc.c:	 * completion if the SWQE is being resent until the send
drivers/infiniband/hw/hfi1/rc.c:		/* Post a send completion queue entry if requested. */
drivers/infiniband/hw/hfi1/rc.c:		 * we want to generate completion events for everything
drivers/infiniband/hw/hfi1/rc.c:		 * the completion for the read.
drivers/infiniband/hw/hfi1/rc.c:		wqe = do_rc_completion(qp, wqe, ibp);
drivers/infiniband/hw/hfi1/rc.c:		wqe = do_rc_completion(qp, wqe, ibp);
drivers/infiniband/hw/hfi1/rc.c:		 * work completion only for the UD transport (see section
drivers/infiniband/hw/hfi1/rc.c:		/* Signal completion event if the solicited bit is set. */
drivers/infiniband/hw/hfi1/mad.c: * @in_wc: the work completion entry for this packet
drivers/infiniband/hw/hfi1/chip.c:	/* wait for completion, alternate: interrupt */
drivers/infiniband/hw/hfi1/chip.c:	init_completion(&dd->user_comp);
drivers/infiniband/hw/hfi1/init.c:	wait_for_completion(&dd->user_comp);
drivers/infiniband/hw/hfi1/user_sdma.c:MODULE_PARM_DESC(sdma_comp_size, "Size of User SDMA completion ring. Default: 128");
drivers/infiniband/hw/hfi1/user_sdma.c:	 * will not wait for send completions.
drivers/infiniband/hw/hfi1/user_sdma.c:	/* If tx completion has reported an error, we are done. */
drivers/infiniband/hw/hfi1/user_sdma.c:		 * Check whether any of the completions have come back
drivers/infiniband/hw/hfi1/user_sdma.c: * SDMA tx request completion callback. Called when the SDMA progress
drivers/infiniband/hw/hfi1/user_sdma.c:		SDMA_DBG(req, "SDMA completion with error %d",
drivers/infiniband/hw/hfi1/user_sdma.c:	hfi1_cdbg(SDMA, "[%u:%u:%u:%u] Setting completion status %u %d",
drivers/infiniband/hw/hfi1/user_sdma.c:	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
drivers/infiniband/hw/hfi1/ruc.c:	/* Signal solicited completion event. */
drivers/infiniband/hw/hfi1/ruc.c:	 * completion is generated.
drivers/infiniband/hw/hfi1/ruc.c:	/* Signal completion event if the solicited bit is set. */
drivers/infiniband/hw/hfi1/hfi.h:#include <linux/completion.h>
drivers/infiniband/hw/hfi1/hfi.h:	struct completion user_comp;
drivers/infiniband/hw/hfi1/Kconfig:	sdma completions for unit testing
drivers/infiniband/hw/hfi1/verbs.c:		 "Maximum number of completion queue entries to support");
drivers/infiniband/hw/hfi1/verbs.c:MODULE_PARM_DESC(max_cqs, "Maximum number of completion queues to support");
drivers/infiniband/hw/hfi1/verbs.c:		 * completion event. Only do this for PIO. SDMA has its own
drivers/infiniband/hw/hfi1/uc.c:		 * work completion only for the UD transport (see section
drivers/infiniband/hw/hfi1/uc.c:		/* Signal completion event if the solicited bit is set. */
drivers/infiniband/hw/hfi1/verbs.h:#include <linux/completion.h>
drivers/infiniband/hw/hfi1/sdma.h:	struct completion    comp;
drivers/infiniband/hw/hfi1/sdma.h: * completion is desired as soon as possible.
drivers/infiniband/hw/hfi1/sdma.h: * txreqs by giving a completion routine callback to sdma_txinit() or
drivers/infiniband/hw/hfi1/sdma.h: * completion is desired as soon as possible.
drivers/infiniband/hw/hfi1/sdma.h: * txreqs by giving a completion routine callback to sdma_txinit() or
drivers/infiniband/hw/hfi1/ud.c:	/* Signal completion event if the solicited bit is set. */
drivers/infiniband/hw/hfi1/ud.c:			 * a completion for the loopback packet since
drivers/infiniband/hw/hfi1/ud.c: *     and specifically _not_ the pkey that we attach to the completion,
drivers/infiniband/hw/hfi1/ud.c:	/* Signal completion event if the solicited bit is set. */
drivers/infiniband/hw/hfi1/sdma.c:	wait_for_completion(&ss->comp);
drivers/infiniband/hw/hfi1/sdma.c:		init_completion(&sde->state.comp);
drivers/infiniband/hw/hfi1/trace_tx.h:TRACE_EVENT(hfi1_sdma_user_completion,
drivers/infiniband/hw/hfi1/trace_tx.h:	    TP_printk("[%s:%u:%u:%u] SDMA completion state %s (%d)",
drivers/infiniband/sw/rxe/rxe_req.c:	 * ...Note that if a completion error occurs, a Work Completion
drivers/infiniband/sw/rdmavt/mad.c: * @in_wc: the work completion entry for this packet
drivers/infiniband/sw/rdmavt/cq.c: * rvt_cq_enter - add a new entry to the completion queue
drivers/infiniband/sw/rdmavt/cq.c: * @cq: completion queue
drivers/infiniband/sw/rdmavt/cq.c: * @entry: work completion entry to add
drivers/infiniband/sw/rdmavt/cq.c:	 * The completion handler will most likely rearm the notification
drivers/infiniband/sw/rdmavt/cq.c:	 * and poll for all pending entries.  If a new completion entry
drivers/infiniband/sw/rdmavt/cq.c: * rvt_create_cq - create a completion queue
drivers/infiniband/sw/rdmavt/cq.c: * @ibdev: the device this completion queue is attached to
drivers/infiniband/sw/rdmavt/cq.c: * Return: pointer to the completion queue or negative errno values
drivers/infiniband/sw/rdmavt/cq.c:	/* Allocate the completion queue structure. */
drivers/infiniband/sw/rdmavt/cq.c:	 * Allocate the completion queue entries and head/tail pointers.
drivers/infiniband/sw/rdmavt/cq.c: * rvt_destroy_cq - destroy a completion queue
drivers/infiniband/sw/rdmavt/cq.c: * @ibcq: the completion queue to destroy.
drivers/infiniband/sw/rdmavt/cq.c: * rvt_req_notify_cq - change the notification type for a completion queue
drivers/infiniband/sw/rdmavt/cq.c: * @ibcq: the completion queue
drivers/infiniband/sw/rdmavt/cq.c: * @ibcq: the completion queue
drivers/infiniband/sw/rdmavt/cq.c: * rvt_poll_cq - poll for work completion entries
drivers/infiniband/sw/rdmavt/cq.c: * @ibcq: the completion queue to poll
drivers/infiniband/sw/rdmavt/cq.c: * @entry: pointer to array where work completions are placed
drivers/infiniband/sw/rdmavt/cq.c: * Return: the number of completion entries polled.
drivers/infiniband/sw/rdmavt/cq.c:	/* The kernel can only poll a kernel completion queue */
drivers/infiniband/sw/rdmavt/mr.c:	init_completion(&mr->comp);
drivers/infiniband/sw/rdmavt/mr.c:	rvt_put_mr(&mr->mr); /* will set completion if last */
drivers/infiniband/sw/rdmavt/mr.c:	timeout = wait_for_completion_timeout(&mr->mr.comp, 5 * HZ);
drivers/infiniband/sw/rdmavt/mr.c:	rvt_put_mr(&fmr->mr); /* will set completion if last */
drivers/infiniband/sw/rdmavt/mr.c:	timeout = wait_for_completion_timeout(&fmr->mr.comp, 5 * HZ);
drivers/infiniband/sw/rdmavt/qp.c: * completions as per IB 1.2 C10-96.
drivers/infiniband/sw/rdmavt/qp.c: * @err: the receive completion error to signal if a RWQE is active
drivers/infiniband/sw/rdmavt/qp.c:	 * need to have requests with "completion only" flags set posted
drivers/infiniband/sw/rdmavt/qp.c:	 * to the send queue in order to generate completions.
drivers/infiniband/core/mad_rmpp.c:	struct completion comp;
drivers/infiniband/core/mad_rmpp.c:	wait_for_completion(&rmpp_recv->comp);
drivers/infiniband/core/mad_rmpp.c:	init_completion(&rmpp_recv->comp);
drivers/infiniband/core/rw.c: * @cqe:	completion queue entry for the last WR
drivers/infiniband/core/rw.c: * completion notification.
drivers/infiniband/core/rw.c: * @cqe:	completion queue entry for the last WR
drivers/infiniband/core/rw.c: * is not set @cqe must be set so that the caller gets a completion
drivers/infiniband/core/cma.c:#include <linux/completion.h>
drivers/infiniband/core/cma.c:	struct completion	comp;
drivers/infiniband/core/cma.c:	struct completion		done;
drivers/infiniband/core/cma.c:	struct completion	comp;
drivers/infiniband/core/cma.c:	init_completion(&id_priv->comp);
drivers/infiniband/core/cma.c:	wait_for_completion(&id_priv->comp);
drivers/infiniband/core/cma.c:	init_completion(&cb_ctx->done);
drivers/infiniband/core/cma.c:	wait_for_completion(&cb_ctx->done);
drivers/infiniband/core/cma.c:	init_completion(&cma_dev->comp);
drivers/infiniband/core/cma.c:	wait_for_completion(&cma_dev->comp);
drivers/infiniband/core/mad.c:static void local_completions(struct work_struct *work);
drivers/infiniband/core/mad.c:	INIT_WORK(&mad_agent_priv->local_work, local_completions);
drivers/infiniband/core/mad.c:	init_completion(&mad_agent_priv->comp);
drivers/infiniband/core/mad.c:	init_completion(&mad_snoop_priv->comp);
drivers/infiniband/core/mad.c:	wait_for_completion(&mad_agent_priv->comp);
drivers/infiniband/core/mad.c:	wait_for_completion(&mad_snoop_priv->comp);
drivers/infiniband/core/mad.c:			 * side of local completion handled
drivers/infiniband/core/mad.c:			 * generate send completion.
drivers/infiniband/core/mad.c:	/* Reference MAD agent until send side of local completion handled */
drivers/infiniband/core/mad.c:	/* Queue local completion to local list */
drivers/infiniband/core/mad.c:	list_add_tail(&local->completion_list, &mad_agent_priv->local_list);
drivers/infiniband/core/mad.c:	/* Set WR ID to find mad_send_wr upon completion */
drivers/infiniband/core/mad.c:		 * request associated with the completion
drivers/infiniband/core/mad.c:	/* Setup MAD receive work completion from "normal" work completion */
drivers/infiniband/core/mad.c: * Process a send work completion
drivers/infiniband/core/mad.c:	/* Remove send from MAD agent and notify client of completion */
drivers/infiniband/core/mad.c:static void local_completions(struct work_struct *work)
drivers/infiniband/core/mad.c:				   completion_list);
drivers/infiniband/core/mad.c:		list_del(&local->completion_list);
drivers/infiniband/core/mad.c:					"No receive MAD agent for local completion\n");
drivers/infiniband/core/mad.c:				goto local_send_completion;
drivers/infiniband/core/mad.c:local_send_completion:
drivers/infiniband/core/mad.c:			"Failed to request completion notification: %d\n",
drivers/infiniband/core/cq.c: * context and does not ask for completion interrupts from the HCA.
drivers/infiniband/core/cq.c:static void ib_cq_completion_direct(struct ib_cq *cq, void *private)
drivers/infiniband/core/cq.c:	WARN_ONCE(1, "got unsolicited completion for CQ 0x%p\n", cq);
drivers/infiniband/core/cq.c:static void ib_cq_completion_softirq(struct ib_cq *cq, void *private)
drivers/infiniband/core/cq.c:static void ib_cq_completion_workqueue(struct ib_cq *cq, void *private)
drivers/infiniband/core/cq.c: * ib_alloc_cq - allocate a completion queue
drivers/infiniband/core/cq.c: * @comp_vector:	HCA completion vectors for this CQ
drivers/infiniband/core/cq.c:		cq->comp_handler = ib_cq_completion_direct;
drivers/infiniband/core/cq.c:		cq->comp_handler = ib_cq_completion_softirq;
drivers/infiniband/core/cq.c:		cq->comp_handler = ib_cq_completion_workqueue;
drivers/infiniband/core/cq.c: * ib_free_cq - free a completion queue
drivers/infiniband/core/cq.c: * @cq:		completion queue to free.
drivers/infiniband/core/mad_priv.h:#include <linux/completion.h>
drivers/infiniband/core/mad_priv.h:	struct completion comp;
drivers/infiniband/core/mad_priv.h:	struct completion comp;
drivers/infiniband/core/mad_priv.h:	struct list_head completion_list;
drivers/infiniband/core/iwcm.h:	struct completion destroy_comp;
drivers/infiniband/core/addr.c:	init_completion(&client->comp);
drivers/infiniband/core/addr.c:	wait_for_completion(&client->comp);
drivers/infiniband/core/addr.c:	struct completion comp;
drivers/infiniband/core/addr.c:	init_completion(&ctx.comp);
drivers/infiniband/core/addr.c:	wait_for_completion(&ctx.comp);
drivers/infiniband/core/ucm.c:#include <linux/completion.h>
drivers/infiniband/core/ucm.c:	struct completion   comp;
drivers/infiniband/core/ucm.c:	init_completion(&ctx->comp);
drivers/infiniband/core/ucm.c:	wait_for_completion(&ctx->comp);
drivers/infiniband/core/iwcm.c:#include <linux/completion.h>
drivers/infiniband/core/iwcm.c:	init_completion(&cm_id_priv->destroy_comp);
drivers/infiniband/core/verbs.c:	struct completion done;
drivers/infiniband/core/verbs.c: * Post a WR and block until its completion is reaped for the SQ.
drivers/infiniband/core/verbs.c:	init_completion(&sdrain.done);
drivers/infiniband/core/verbs.c:	wait_for_completion(&sdrain.done);
drivers/infiniband/core/verbs.c: * Post a WR and block until its completion is reaped for the RQ.
drivers/infiniband/core/verbs.c:	init_completion(&rdrain.done);
drivers/infiniband/core/verbs.c:	wait_for_completion(&rdrain.done);
drivers/infiniband/core/verbs.c: * completion.
drivers/infiniband/core/verbs.c: * completion.
drivers/infiniband/core/verbs.c: * and completions.
drivers/infiniband/core/uverbs.h:#include <linux/completion.h>
drivers/infiniband/core/uverbs.h: * and released when that file is closed.  For completion event files,
drivers/infiniband/core/uverbs.h:	struct completion			comp;
drivers/infiniband/core/uverbs_main.c: * Look up a completion event file by FD.  If lookup is successful,
drivers/infiniband/core/uverbs_main.c:	init_completion(&uverbs_dev->comp);
drivers/infiniband/core/uverbs_main.c:	wait_for_completion(&uverbs_dev->comp);
drivers/infiniband/core/uverbs_main.c:		wait_for_completion(&uverbs_dev->comp);
drivers/infiniband/core/multicast.c:#include <linux/completion.h>
drivers/infiniband/core/multicast.c:	struct completion	comp;
drivers/infiniband/core/multicast.c:	struct completion	comp;
drivers/infiniband/core/multicast.c:	init_completion(&member->comp);
drivers/infiniband/core/multicast.c:	wait_for_completion(&member->comp);
drivers/infiniband/core/multicast.c:		init_completion(&port->comp);
drivers/infiniband/core/multicast.c:			wait_for_completion(&port->comp);
drivers/infiniband/core/sa_query.c:	init_completion(&client->comp);
drivers/infiniband/core/sa_query.c:	wait_for_completion(&client->comp);
drivers/infiniband/core/cm.c:#include <linux/completion.h>
drivers/infiniband/core/cm.c:	struct completion comp;
drivers/infiniband/core/cm.c:	init_completion(&cm_id_priv->comp);
drivers/infiniband/core/cm.c:	wait_for_completion(&cm_id_priv->comp);
drivers/infiniband/core/cm.c: * in the work completion.
drivers/infiniband/core/ucma.c:#include <linux/completion.h>
drivers/infiniband/core/ucma.c:	struct completion	comp;
drivers/infiniband/core/ucma.c:	wait_for_completion(&ctx->comp);
drivers/infiniband/core/ucma.c:	init_completion(&ctx->comp);
drivers/infiniband/core/ucma.c:		wait_for_completion(&ctx->comp);
drivers/infiniband/core/umem_odp.c:			/* Initialize the completion object for waiting on
drivers/infiniband/core/umem_odp.c:			reinit_completion(&item->odp_data->notifier_completion);
drivers/infiniband/core/umem_odp.c:			complete_all(&item->odp_data->notifier_completion);
drivers/infiniband/core/umem_odp.c:				complete_all(&odp_data->notifier_completion);
drivers/infiniband/core/umem_odp.c:	complete_all(&item->odp_data->notifier_completion);
drivers/infiniband/core/umem_odp.c:	init_completion(&umem->odp_data->notifier_completion);
drivers/infiniband/core/umem_odp.c:		complete_all(&umem->odp_data->notifier_completion);
drivers/infiniband/core/umem_odp.c:	 * faults from completion. We might be racing with other
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:#include <linux/completion.h>
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:	ipoib_dbg_mcast(priv, "%sjoin completion for %pI6 (status %d)\n",
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:				init_completion(&mcast->done);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:		init_completion(&mcast->done);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:			wait_for_completion(&mcast->done);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:			wait_for_completion(&mcast->done);
drivers/infiniband/ulp/ipoib/ipoib_ib.c:	ipoib_dbg_data(priv, "recv completion: id %d, status: %d\n",
drivers/infiniband/ulp/ipoib/ipoib_ib.c:		ipoib_warn(priv, "recv completion event with wrid %d (> %d)\n",
drivers/infiniband/ulp/ipoib/ipoib_ib.c: * As the result of a completion error the QP Can be transferred to SQE states.
drivers/infiniband/ulp/ipoib/ipoib_ib.c:	ipoib_dbg_data(priv, "send completion: id %d, status: %d\n",
drivers/infiniband/ulp/ipoib/ipoib_ib.c:		ipoib_warn(priv, "send completion event with wrid %d (> %d)\n",
drivers/infiniband/ulp/ipoib/ipoib_ib.c:void ipoib_ib_completion(struct ib_cq *cq, void *dev_ptr)
drivers/infiniband/ulp/ipoib/ipoib_ib.c:	 * because it's entirely possible that the completion handler will
drivers/infiniband/ulp/ipoib/ipoib_ib.c:	 * We call completion handling routines that expect to be
drivers/infiniband/ulp/ipoib/ipoib_ib.c:			 * Convert any successful completions to flush
drivers/infiniband/ulp/ipoib/ipoib_ib.c:	 * We must make sure there are no more (path) completions
drivers/infiniband/ulp/ipoib/ipoib.h:	struct completion done;
drivers/infiniband/ulp/ipoib/ipoib.h: * We use the second option and wait for a completion on the
drivers/infiniband/ulp/ipoib/ipoib.h:	struct completion		flushed;
drivers/infiniband/ulp/ipoib/ipoib.h:	struct completion		deleted;
drivers/infiniband/ulp/ipoib/ipoib.h:	struct completion     done;
drivers/infiniband/ulp/ipoib/ipoib.h:void ipoib_ib_completion(struct ib_cq *cq, void *dev_ptr);
drivers/infiniband/ulp/ipoib/ipoib_main.c:	struct completion	done;
drivers/infiniband/ulp/ipoib/ipoib_main.c:	init_completion(&callback_context->done);
drivers/infiniband/ulp/ipoib/ipoib_main.c:	wait_for_completion(&callback_context->done);
drivers/infiniband/ulp/ipoib/ipoib_main.c:		wait_for_completion(&path->done);
drivers/infiniband/ulp/ipoib/ipoib_main.c:static void path_rec_completion(int status,
drivers/infiniband/ulp/ipoib/ipoib_main.c:	init_completion(&path->done);
drivers/infiniband/ulp/ipoib/ipoib_main.c:				   path_rec_completion,
drivers/infiniband/ulp/ipoib/ipoib_main.c:	init_completion(&priv->ntbl.flushed);
drivers/infiniband/ulp/ipoib/ipoib_main.c:		wait_for_completion(&priv->ntbl.flushed);
drivers/infiniband/ulp/ipoib/ipoib_main.c:	init_completion(&priv->ntbl.deleted);
drivers/infiniband/ulp/ipoib/ipoib_main.c:	wait_for_completion(&priv->ntbl.deleted);
drivers/infiniband/ulp/ipoib/ipoib_verbs.c:	priv->recv_cq = ib_create_cq(priv->ca, ipoib_ib_completion, NULL,
drivers/infiniband/ulp/ipoib/ipoib_cm.c:	 * Current Mellanox HCA firmware won't generate completions
drivers/infiniband/ulp/ipoib/ipoib_cm.c:	ipoib_dbg_data(priv, "cm recv completion: id %d, status: %d\n",
drivers/infiniband/ulp/ipoib/ipoib_cm.c:			ipoib_warn(priv, "cm recv completion event with wrid %d (> %d)\n",
drivers/infiniband/ulp/ipoib/ipoib_cm.c:	 * because it's entirely possible that the completion handler will
drivers/infiniband/ulp/ipoib/ipoib_cm.c:	ipoib_dbg_data(priv, "cm send completion: id %d, status: %d\n",
drivers/infiniband/ulp/ipoib/ipoib_cm.c:		ipoib_warn(priv, "cm send completion event with wrid %d (> %d)\n",
drivers/infiniband/ulp/srp/ib_srp.h:	struct completion	released;
drivers/infiniband/ulp/srp/ib_srp.h:	struct completion	done;
drivers/infiniband/ulp/srp/ib_srp.h:	struct completion	tsk_mgmt_done;
drivers/infiniband/ulp/srp/ib_srp.c:		 "Number of RDMA channels to use for communication with an SRP target. Using more than one channel improves performance if the HCA supports multiple completion vectors. The default value is the minimum of four times the number of online CPU sockets and the number of completion vectors supported by the HCA.");
drivers/infiniband/ulp/srp/ib_srp.c: * completion handler can access the queue pair while it is
drivers/infiniband/ulp/srp/ib_srp.c:static void srp_path_rec_completion(int status,
drivers/infiniband/ulp/srp/ib_srp.c:	init_completion(&ch->done);
drivers/infiniband/ulp/srp/ib_srp.c:					       srp_path_rec_completion,
drivers/infiniband/ulp/srp/ib_srp.c:	ret = wait_for_completion_interruptible(&ch->done);
drivers/infiniband/ulp/srp/ib_srp.c:		init_completion(&ch->done);
drivers/infiniband/ulp/srp/ib_srp.c:		ret = wait_for_completion_interruptible(&ch->done);
drivers/infiniband/ulp/srp/ib_srp.c:		 * QP. This guarantees that all completion callback function
drivers/infiniband/ulp/srp/ib_srp.c:			     PFX "recv completion, opcode 0x%02x\n", opcode);
drivers/infiniband/ulp/srp/ib_srp.c:	 * it can take before an error completion is generated. See also
drivers/infiniband/ulp/srp/ib_srp.c:	init_completion(&ch->tsk_mgmt_done);
drivers/infiniband/ulp/srp/ib_srp.c:	if (!wait_for_completion_timeout(&ch->tsk_mgmt_done,
drivers/infiniband/ulp/srp/ib_srp.c:	init_completion(&host->released);
drivers/infiniband/ulp/srp/ib_srp.c:		wait_for_completion(&host->released);
drivers/infiniband/ulp/iser/iscsi_iser.h: * to have at max for SCSI command. The tx posting & completion handling code  *
drivers/infiniband/ulp/iser/iscsi_iser.h: * @cqe:           completion handler
drivers/infiniband/ulp/iser/iscsi_iser.h: * struct iser_comp - iSER completion context
drivers/infiniband/ulp/iser/iscsi_iser.h: * @cq:         completion queue
drivers/infiniband/ulp/iser/iscsi_iser.h: *              to completion context
drivers/infiniband/ulp/iser/iscsi_iser.h: * @comps_used:    Number of completion contexts used, Min between online
drivers/infiniband/ulp/iser/iscsi_iser.h: *                 cpus and device max completion vectors
drivers/infiniband/ulp/iser/iscsi_iser.h: * @comps:         Dinamically allocated array of completion handlers
drivers/infiniband/ulp/iser/iscsi_iser.h: * @comp:                iser completion context
drivers/infiniband/ulp/iser/iscsi_iser.h: * @stop_completion:  conn_stop completion
drivers/infiniband/ulp/iser/iscsi_iser.h: * @ib_completion:    RDMA cleanup completion
drivers/infiniband/ulp/iser/iscsi_iser.h: * @up_completion:    connection establishment completed
drivers/infiniband/ulp/iser/iscsi_iser.h:	struct completion	     stop_completion;
drivers/infiniband/ulp/iser/iscsi_iser.h:	struct completion	     ib_completion;
drivers/infiniband/ulp/iser/iscsi_iser.h:	struct completion	     up_completion;
drivers/infiniband/ulp/iser/iser_verbs.c:	wait_for_completion(&iser_conn->stop_completion);
drivers/infiniband/ulp/iser/iser_verbs.c:	wait_for_completion(&iser_conn->ib_completion);
drivers/infiniband/ulp/iser/iser_verbs.c:	complete(&iser_conn->up_completion);
drivers/infiniband/ulp/iser/iser_verbs.c:	complete(&iser_conn->ib_completion);
drivers/infiniband/ulp/iser/iser_verbs.c:	init_completion(&iser_conn->stop_completion);
drivers/infiniband/ulp/iser/iser_verbs.c:	init_completion(&iser_conn->ib_completion);
drivers/infiniband/ulp/iser/iser_verbs.c:	init_completion(&iser_conn->up_completion);
drivers/infiniband/ulp/iser/iser_verbs.c:		wait_for_completion_interruptible(&iser_conn->up_completion);
drivers/infiniband/ulp/iser/iscsi_iser.c: * iscsi_iser_recv() - Process a successful recv completion
drivers/infiniband/ulp/iser/iscsi_iser.c: * Notes: In case of data length errors or iscsi PDU completion failures
drivers/infiniband/ulp/iser/iscsi_iser.c:	 * - if no,  the task is recycled at iser_snd_completion
drivers/infiniband/ulp/iser/iscsi_iser.c: * Notes: Here iser intialize (or re-initialize) stop_completion as
drivers/infiniband/ulp/iser/iscsi_iser.c:	reinit_completion(&iser_conn->stop_completion);
drivers/infiniband/ulp/iser/iscsi_iser.c:		complete(&iser_conn->stop_completion);
drivers/infiniband/ulp/iser/iscsi_iser.c: * This routine boils down to waiting for up_completion signaling
drivers/infiniband/ulp/iser/iscsi_iser.c:	rc = wait_for_completion_interruptible_timeout(&iser_conn->up_completion,
drivers/infiniband/ulp/iser/iscsi_iser.c: * completion as we queue a deffered work for iser/RDMA destruction
drivers/infiniband/ulp/iser/iscsi_iser.c:	 * iscsi_conn_stop and flush errors completion before freeing
drivers/infiniband/ulp/isert/ib_isert.c:		isert_err("Unable to allocate completion contexts\n");
drivers/infiniband/ulp/isert/ib_isert.c:	init_completion(&isert_conn->login_comp);
drivers/infiniband/ulp/isert/ib_isert.c:	init_completion(&isert_conn->login_req_comp);
drivers/infiniband/ulp/isert/ib_isert.c:isert_completion_put(struct iser_tx_desc *tx_desc, struct isert_cmd *isert_cmd,
drivers/infiniband/ulp/isert/ib_isert.c:		isert_completion_put(desc, isert_cmd, device->ib_device, true);
drivers/infiniband/ulp/isert/ib_isert.c:		isert_completion_put(desc, isert_cmd, device->ib_device, true);
drivers/infiniband/ulp/isert/ib_isert.c:		isert_completion_put(&isert_cmd->tx_desc, isert_cmd,
drivers/infiniband/ulp/isert/ib_isert.c:		isert_completion_put(tx_desc, isert_cmd, ib_dev, true);
drivers/infiniband/ulp/isert/ib_isert.c:		isert_completion_put(tx_desc, isert_cmd, ib_dev, false);
drivers/infiniband/ulp/isert/ib_isert.c:	ret = wait_for_completion_interruptible(&isert_conn->login_req_comp);
drivers/infiniband/ulp/isert/ib_isert.c:	reinit_completion(&isert_conn->login_req_comp);
drivers/infiniband/ulp/isert/ib_isert.c:	ret = wait_for_completion_interruptible(&isert_conn->login_comp);
drivers/infiniband/ulp/isert/ib_isert.c:		wait_for_completion_timeout(&conn->conn_logout_comp,
drivers/infiniband/ulp/isert/ib_isert.c:	struct completion comp;
drivers/infiniband/ulp/isert/ib_isert.c:	init_completion(&comp);
drivers/infiniband/ulp/isert/ib_isert.c:	wait_for_completion_interruptible(&comp);
drivers/infiniband/ulp/isert/ib_isert.h:	struct completion	login_comp;
drivers/infiniband/ulp/isert/ib_isert.h:	struct completion	login_req_comp;
drivers/infiniband/ulp/isert/ib_isert.h: * struct isert_comp - iSER completion context
drivers/infiniband/ulp/isert/ib_isert.h: * @cq:         completion queue
drivers/infiniband/ulp/isert/ib_isert.h: *              to completion context
drivers/infiniband/ulp/srpt/ib_srpt.c:		/* will destroy_ah & free_send_mad in send completion */
drivers/infiniband/ulp/srpt/ib_srpt.c:	init_completion(&ioctx->tx_done);
drivers/infiniband/ulp/srpt/ib_srpt.c:		 * SRP_RSP sending failed or the SRP_RSP send completion has
drivers/infiniband/ulp/srpt/ib_srpt.c: * This function must be called from the context in which RDMA completions are
drivers/infiniband/ulp/srpt/ib_srpt.c: * makes the initiator send a new request before the send completion for that
drivers/infiniband/ulp/srpt/ib_srpt.c: * if IB retransmission causes generation of the send completion to be
drivers/infiniband/ulp/srpt/ib_srpt.c:		pr_err("IB completion has been received too late for"
drivers/infiniband/ulp/srpt/ib_srpt.c: * srpt_create_ch_ib() - Create receive and send completion queues.
drivers/infiniband/ulp/srpt/ib_srpt.c:	 * completions, and half R/W contexts to actually do the RDMA
drivers/infiniband/ulp/srpt/ib_srpt.c:	 * both both, as RDMA contexts will also post completions for the
drivers/infiniband/ulp/srpt/ib_srpt.c: * invoked on the context of the IB completion handler.
drivers/infiniband/ulp/srpt/ib_srpt.c:	while (wait_for_completion_timeout(&release_done, 180 * HZ) == 0)
drivers/infiniband/ulp/srpt/ib_srpt.h:	struct completion	tx_done;
drivers/infiniband/ulp/srpt/ib_srpt.h: * @CH_DISCONNECTED:  Last completion has been received.
drivers/infiniband/ulp/srpt/ib_srpt.h: * @cq:            IB completion queue for this channel.
drivers/infiniband/ulp/srpt/ib_srpt.h: * @release_done:  Enables waiting for srpt_release_channel() completion.
drivers/infiniband/ulp/srpt/ib_srpt.h:	struct completion	*release_done;
drivers/message/fusion/mptspi.c:	timeleft = wait_for_completion_timeout(&ioc->internal_cmds.done, 10*HZ);
drivers/message/fusion/mptspi.c:	ret = ioc->internal_cmds.completion_code;
drivers/message/fusion/mptbase.h:	struct completion	 done;
drivers/message/fusion/mptbase.h:	int			 completion_code;
drivers/message/fusion/mptbase.h:	 * a split completion for a read data, an internal address pointer incorrectly
drivers/message/fusion/mptbase.h:	u8			 wait_on_reset_completion;
drivers/message/fusion/mptbase.h:	int	completion;
drivers/message/fusion/mptctl.c:	ii = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done, timeout*HZ);
drivers/message/fusion/mptctl.c:	timeleft = wait_for_completion_timeout(&iocp->ioctl_cmds.done, HZ*60);
drivers/message/fusion/mptctl.c:	timeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,
drivers/message/fusion/mptctl.c:	timeleft = wait_for_completion_timeout(&ioc->ioctl_cmds.done,
drivers/message/fusion/mptctl.c:	init_completion(&ioc->ioctl_cmds.done);
drivers/message/fusion/mptscsih.c:static int	mptscsih_get_completion_code(MPT_ADAPTER *ioc,
drivers/message/fusion/mptscsih.c: *	This routine is called from mpt.c::mpt_interrupt() at the completion
drivers/message/fusion/mptscsih.c:		 * completion done. Cannot touch sc struct. Just free mem.
drivers/message/fusion/mptscsih.c:	timeleft = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done,
drivers/message/fusion/mptscsih.c: *	This routine is called from mptbase.c::mpt_interrupt() at the completion
drivers/message/fusion/mptscsih.c: *	This routine is called from mpt.c::mpt_interrupt() at the completion
drivers/message/fusion/mptscsih.c: *	Remark: Sets a completion code and (possibly) saves sense data
drivers/message/fusion/mptscsih.c:	ioc->internal_cmds.completion_code = MPT_SCANDV_GOOD;
drivers/message/fusion/mptscsih.c:	ioc->internal_cmds.completion_code =
drivers/message/fusion/mptscsih.c:	    mptscsih_get_completion_code(ioc, req, reply);
drivers/message/fusion/mptscsih.c: *	mptscsih_get_completion_code - get completion code from MPT request
drivers/message/fusion/mptscsih.c:mptscsih_get_completion_code(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,
drivers/message/fusion/mptscsih.c:	int		 completion_code;
drivers/message/fusion/mptscsih.c:		completion_code = MPT_SCANDV_SELECTION_TIMEOUT;
drivers/message/fusion/mptscsih.c:		completion_code = MPT_SCANDV_DID_RESET;
drivers/message/fusion/mptscsih.c:		completion_code = MPT_SCANDV_BUSY;
drivers/message/fusion/mptscsih.c:			completion_code = MPT_SCANDV_GOOD;
drivers/message/fusion/mptscsih.c:				completion_code = MPT_SCANDV_GOOD;
drivers/message/fusion/mptscsih.c:				completion_code = MPT_SCANDV_SOME_ERROR;
drivers/message/fusion/mptscsih.c:			completion_code = MPT_SCANDV_SENSE;
drivers/message/fusion/mptscsih.c:				completion_code = MPT_SCANDV_ISSUE_SENSE;
drivers/message/fusion/mptscsih.c:				completion_code = MPT_SCANDV_DID_RESET;
drivers/message/fusion/mptscsih.c:			completion_code = MPT_SCANDV_DID_RESET;
drivers/message/fusion/mptscsih.c:			completion_code = MPT_SCANDV_DID_RESET;
drivers/message/fusion/mptscsih.c:			completion_code = MPT_SCANDV_BUSY;
drivers/message/fusion/mptscsih.c:			completion_code = MPT_SCANDV_GOOD;
drivers/message/fusion/mptscsih.c:			completion_code = MPT_SCANDV_DID_RESET;
drivers/message/fusion/mptscsih.c:			completion_code = MPT_SCANDV_SOME_ERROR;
drivers/message/fusion/mptscsih.c:		completion_code = MPT_SCANDV_SOME_ERROR;
drivers/message/fusion/mptscsih.c:	    "  completionCode set to %08xh\n", ioc->name, completion_code));
drivers/message/fusion/mptscsih.c:	return completion_code;
drivers/message/fusion/mptscsih.c: *		 > 0 if command complete but some type of completion error.
drivers/message/fusion/mptscsih.c:	timeleft = wait_for_completion_timeout(&ioc->internal_cmds.done,
drivers/message/fusion/mptscsih.c:	ret = ioc->internal_cmds.completion_code;
drivers/message/fusion/mptsas.c: * try to send next target reset. This will be called from completion
drivers/message/fusion/mptsas.c:	timeleft = wait_for_completion_timeout(&ioc->sas_mgmt.done,
drivers/message/fusion/mptsas.c:	timeleft = wait_for_completion_timeout(&ioc->sas_mgmt.done, 10 * HZ);
drivers/message/fusion/mptsas.c:	timeleft = wait_for_completion_timeout(&ioc->sas_mgmt.done, 10 * HZ);
drivers/message/fusion/mptsas.c:	timeleft = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done,
drivers/message/fusion/mptsas.c:	init_completion(&ioc->sas_mgmt.done);
drivers/message/fusion/lsi/mpi_ioc.h: *                      Change Event data to indicate completion of internally
drivers/message/fusion/lsi/mpi_history.txt: *                      Change Event data to indicate completion of internally
drivers/message/fusion/lsi/mpi_history.txt: *  09-16-02  01.02.07  Added flags for confirmed completion.
drivers/message/fusion/lsi/mpi_targ.h: *  09-16-02  01.02.07  Added flags for confirmed completion.
drivers/message/fusion/mptbase.c: *	the protocol-specific details of the MPT request completion.
drivers/message/fusion/mptbase.c:	init_completion(&ioc->internal_cmds.done);
drivers/message/fusion/mptbase.c:	init_completion(&ioc->mptbase_cmds.done);
drivers/message/fusion/mptbase.c:	init_completion(&ioc->taskmgmt_cmds.done);
drivers/message/fusion/mptbase.c: *	upon successful completion.
drivers/message/fusion/mptbase.c:		 * Wait for completion of doorbell handshake reply from the IOC
drivers/message/fusion/mptbase.c:	timeleft = wait_for_completion_timeout(&ioc->mptbase_cmds.done, 10*HZ);
drivers/message/fusion/mptbase.c:	timeleft = wait_for_completion_timeout(&ioc->mptbase_cmds.done,
drivers/message/fusion/mptbase.c:		ioc->wait_on_reset_completion = 1;
drivers/message/fusion/mptbase.c:		ioc->wait_on_reset_completion = 0;
drivers/message/fusion/mptbase.c:	if (ioc->wait_on_reset_completion) {
drivers/memstick/host/rtsx_usb_ms.c:#include <linux/completion.h>
drivers/memstick/host/rtsx_usb_ms.c:	struct completion	detect_ms_exit;
drivers/memstick/host/rtsx_usb_ms.c:	init_completion(&host->detect_ms_exit);
drivers/memstick/host/rtsx_usb_ms.c:	wait_for_completion(&host->detect_ms_exit);
drivers/memstick/host/r592.c:	reinit_completion(&dev->dma_done);
drivers/memstick/host/r592.c:	/* Wait for DMA completion */
drivers/memstick/host/r592.c:	if (!wait_for_completion_timeout(
drivers/memstick/host/r592.c:	/* Wait for TPC completion */
drivers/memstick/host/r592.c:	init_completion(&dev->dma_done);
drivers/memstick/host/r592.h:	struct completion dma_done;
drivers/memstick/core/mspro_block.c:		wait_for_completion(&card->mrq_complete);
drivers/memstick/core/mspro_block.c:	wait_for_completion(&card->mrq_complete);
drivers/memstick/core/mspro_block.c:	wait_for_completion(&card->mrq_complete);
drivers/memstick/core/mspro_block.c:	wait_for_completion(&card->mrq_complete);
drivers/memstick/core/mspro_block.c:	wait_for_completion(&card->mrq_complete);
drivers/memstick/core/mspro_block.c:		wait_for_completion(&card->mrq_complete);
drivers/memstick/core/mspro_block.c:	wait_for_completion(&card->mrq_complete);
drivers/memstick/core/ms_block.c:	wait_for_completion(&card->mrq_complete);
drivers/memstick/core/memstick.c:		reinit_completion(&host->card->mrq_complete);
drivers/memstick/core/memstick.c:	wait_for_completion(&card->mrq_complete);
drivers/memstick/core/memstick.c:		init_completion(&card->mrq_complete);
drivers/memstick/core/memstick.c:		wait_for_completion(&card->mrq_complete);
drivers/dma/k3dma.c:			/* descriptor asks for TC2 interrupt on completion */
drivers/dma/virt-dma.c: * This tasklet handles the completion of a DMA descriptor by
drivers/dma/qcom/hidma.h:	u8 err_code;			/* completion code		    */
drivers/dma/qcom/hidma_ll.c:		dev_warn(lldev->dev, "tre count mismatch on completion");
drivers/dma/qcom/hidma_ll.c:static int hidma_handle_tre_completion(struct hidma_lldev *lldev)
drivers/dma/qcom/hidma_ll.c:		hidma_handle_tre_completion(lldev);
drivers/dma/ioat/dma.c:static u64 ioat_get_current_completion(struct ioatdma_chan *ioat_chan)
drivers/dma/ioat/dma.c:	u64 completion;
drivers/dma/ioat/dma.c:	completion = *ioat_chan->completion;
drivers/dma/ioat/dma.c:	phys_complete = ioat_chansts_to_addr(completion);
drivers/dma/ioat/dma.c:	*phys_complete = ioat_get_current_completion(ioat_chan);
drivers/dma/ioat/dma.c:	if (*phys_complete == ioat_chan->last_completion)
drivers/dma/ioat/dma.c:	 * At restart of the channel, the completion address and the
drivers/dma/ioat/dma.c:	/* no active descs have written a completion? */
drivers/dma/ioat/dma.c:	ioat_chan->last_completion = phys_complete;
drivers/dma/ioat/dma.c:		dev_dbg(to_dev(ioat_chan), "%s: cancel completion timeout\n",
drivers/dma/ioat/dma.c:	if (is_ioat_halted(*ioat_chan->completion)) {
drivers/dma/ioat/dma.c:	ioat_chan->last_completion = *ioat_chan->completion = desc->txd.phys;
drivers/dma/ioat/dma.c:	*ioat_chan->completion = desc->txd.phys;
drivers/dma/ioat/dma.c:	 * programming errors before advancing the completion state
drivers/dma/ioat/dma.c:	 * acknowledged a pending completion once, then be more
drivers/dma/ioat/prep.c:	/* completion writes from the raid engine may pass completion
drivers/dma/ioat/prep.c:	 * (legacy) descriptor to ensure all completion writes arrive in
drivers/dma/ioat/prep.c:	/* completion descriptor carries interrupt bit */
drivers/dma/ioat/prep.c:	/* completion writes from the raid engine may pass completion
drivers/dma/ioat/prep.c:	 * (legacy) descriptor to ensure all completion writes arrive in
drivers/dma/ioat/prep.c:		/* completion descriptor carries interrupt bit */
drivers/dma/ioat/prep.c:	 * 16 source pq is only available on cb3.3 and has no completion
drivers/dma/ioat/prep.c:	/* with cb3.3 we should be able to do completion w/o a null desc */
drivers/dma/ioat/init.c:	struct completion *cmp = dma_async_param;
drivers/dma/ioat/init.c:	struct completion cmp;
drivers/dma/ioat/init.c:	init_completion(&cmp);
drivers/dma/ioat/init.c:	tmo = wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000));
drivers/dma/ioat/init.c:	ioat_dma->completion_pool = dma_pool_create("completion_pool", dev,
drivers/dma/ioat/init.c:	if (!ioat_dma->completion_pool) {
drivers/dma/ioat/init.c:	dma_pool_destroy(ioat_dma->completion_pool);
drivers/dma/ioat/init.c:		dma_pool_destroy(ioat_dma->completion_pool);
drivers/dma/ioat/init.c:	dma_pool_destroy(ioat_dma->completion_pool);
drivers/dma/ioat/init.c:	dma_pool_free(ioat_dma->completion_pool, ioat_chan->completion,
drivers/dma/ioat/init.c:		      ioat_chan->completion_dma);
drivers/dma/ioat/init.c:	ioat_chan->last_completion = 0;
drivers/dma/ioat/init.c:	ioat_chan->completion_dma = 0;
drivers/dma/ioat/init.c:	/* Setup register to interrupt and write completion status on error */
drivers/dma/ioat/init.c:	/* allocate a completion writeback area */
drivers/dma/ioat/init.c:	ioat_chan->completion =
drivers/dma/ioat/init.c:		dma_pool_zalloc(ioat_chan->ioat_dma->completion_pool,
drivers/dma/ioat/init.c:				GFP_KERNEL, &ioat_chan->completion_dma);
drivers/dma/ioat/init.c:	if (!ioat_chan->completion)
drivers/dma/ioat/init.c:	writel(((u64)ioat_chan->completion_dma) & 0x00000000FFFFFFFF,
drivers/dma/ioat/init.c:	writel(((u64)ioat_chan->completion_dma) >> 32,
drivers/dma/ioat/init.c:	struct completion cmp;
drivers/dma/ioat/init.c:	init_completion(&cmp);
drivers/dma/ioat/init.c:	tmo = wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000));
drivers/dma/ioat/init.c:	init_completion(&cmp);
drivers/dma/ioat/init.c:	tmo = wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000));
drivers/dma/ioat/init.c:	init_completion(&cmp);
drivers/dma/ioat/init.c:	tmo = wait_for_completion_timeout(&cmp, msecs_to_jiffies(3000));
drivers/dma/ioat/dma.h: * @completion_pool: DMA buffers for completion ops
drivers/dma/ioat/dma.h:	struct dma_pool *completion_pool;
drivers/dma/ioat/dma.h:	dma_addr_t last_completion;
drivers/dma/ioat/dma.h:	dma_addr_t completion_dma;
drivers/dma/ioat/dma.h:	u64 *completion;
drivers/dma/mxs-dma.c:	/* completion status */
drivers/dma/mxs-dma.c:	 * When both completion and error of termination bits set at the
drivers/dma/mxs-dma.c:	 * error or a termination error with no completion. 0x01 is termination
drivers/dma/pxa_dma.c:	 * completion, so that a curr inside a status updater
drivers/dma/ppc4xx/adma.c:static struct completion ppc440spe_r6_test_comp;
drivers/dma/ppc4xx/adma.c:		/* Enable interrupt on completion */
drivers/dma/ppc4xx/adma.c:		/* Enable interrupt on completion */
drivers/dma/ppc4xx/adma.c: * upon completion
drivers/dma/ppc4xx/adma.c:					/* Should wait for ZeroSum completion */
drivers/dma/ppc4xx/adma.c:		} else if (slots_per_op) /* wait for group completion */
drivers/dma/ppc4xx/adma.c:	init_completion(&ppc440spe_r6_test_comp);
drivers/dma/ppc4xx/adma.c:	wait_for_completion(&ppc440spe_r6_test_comp);
drivers/dma/img-mdc-dma.c:	 * didn't miss a command completion.
drivers/dma/iop-adma.c:		} else if (slots_per_op) /* wait for group completion */
drivers/dma/mic_x100_dma.h: * DSTAT - 16:0 h/w completion count; 31:28 dma engine status
drivers/dma/edma.c:	 * completion callback.
drivers/dma/edma.c:	/* clear possibly pending completion interrupt */
drivers/dma/edma.c:			/* Enable completion interrupt */
drivers/dma/edma.c:			 * Enable early completion interrupt for the
drivers/dma/edma.c:static void edma_completion_handler(struct edma_chan *echan)
drivers/dma/edma.c:			edma_completion_handler(&ecc->slave_chans[channel]);
drivers/dma/edma.c:/* Check request completion status */
drivers/dma/dmaengine.h: * repeated completions.
drivers/dma/pl330.c:	/* Schedule desc completion */
drivers/dma/virt-dma.h: * vchan_cookie_complete - report completion of a descriptor
drivers/dma/virt-dma.h: * vchan_cyclic_callback - report the completion of a period
drivers/dma/txx9dmac.c:		/* Make chain-completion interrupt happen */
drivers/dma/txx9dmac.c:		 * calling of callback on the completion will be more
drivers/dma/xilinx/xilinx_dma.c: * xilinx_dma_do_tasklet - Schedule completion tasklet
drivers/dma/xilinx/zynqmp_dma.c: * zynqmp_dma_do_tasklet - Schedule completion tasklet
drivers/dma/ste_dma40_ll.c:	 * Relink happens after transfer completion.
drivers/dma/sirf-dma.c:/* Check request completion status */
drivers/dma/sh/rcar-dmac.c:		 * and the transfer completion interrupt.
drivers/dma/coh901318.c:	 * cohc->active and run to completion, that is why we're
drivers/dma/dma-jz4780.c:			 * completion of processing the previous descriptor.
drivers/dma/mpc512x_dma.c:/* Check request completion status */
drivers/dma/dmatest.c:/* poor man's completion - we want to use wait_event_freezable() on it */
drivers/dma/dmatest.c:			       "completion error status" :
drivers/dma/dmatest.c:			       "completion busy status", total_tests, src_off,
drivers/dma/at_hdmac_regs.h:	/* enable interrupts on buffer transfer completion & error */
drivers/dma/at_xdmac.c:		/* Wait for transfer completion, except in cyclic case. */
drivers/dma/at_hdmac.c: * atc_tx_status - poll for transaction completion
drivers/dma/at_hdmac.c:		/* wait for transaction completion (except in cyclic case) */
drivers/dma/xgene-dma.c: *	execution, but still waiting for completion,
drivers/dma/amba-pl08x.c: * If slaves are relying on interrupts to signal completion this function
drivers/dma/mic_x100_dma.c:	/* finish all completion callbacks before incrementing tail */
drivers/dma/s3c24xx-dma.c:	 * Interrupts happen to notify the completion of a transfer and the
drivers/vme/bridges/vme_tsi148.c:		"completion reg: %08x\n",
drivers/vme/bridges/vme_tsi148.h:#define TSI148_PCFS_PCIXSTAT_SCD       (1<<18)	/* Split completion discard */
drivers/nvdimm/pmem.c:	 * the successful completion case.  Otherwise, we'll see crashes
drivers/nvdimm/pmem.c:	 * caused by double completion.
drivers/firmware/raspberrypi.c:	struct completion c;
drivers/firmware/raspberrypi.c:	reinit_completion(&fw->c);
drivers/firmware/raspberrypi.c:		wait_for_completion(&fw->c);
drivers/firmware/raspberrypi.c:	init_completion(&fw->c);
drivers/firmware/arm_scpi.c:	struct completion done;
drivers/firmware/arm_scpi.c:	/* check if wait_for_completion is in progress or timed-out */
drivers/firmware/arm_scpi.c:	if (match && !completion_done(&match->done)) {
drivers/firmware/arm_scpi.c:	init_completion(&msg->done);
drivers/firmware/arm_scpi.c:	if (!wait_for_completion_timeout(&msg->done, MAX_RX_TIMEOUT))
drivers/phy/phy-xgene.c:	/* Poll the PLL calibration completion status for at least 1 ms */
drivers/phy/phy-spear1340-miphy.c:	/* Wait for SATA reset de-assert completion */
drivers/phy/phy-spear1340-miphy.c:	/* Wait for SATA reset assert completion */
drivers/md/dm-rq.c: * Partial completion handling for request-based dm
drivers/md/dm-rq.c:	 * Notice the data completion to the upper layer.
drivers/md/dm-rq.c:		DMERR("bio completion is going in the middle of the request");
drivers/md/dm-rq.c: * Request completion handler for request-based dm
drivers/md/dm-rq.c:	 * Actual request completion is done in a softirq context which doesn't
drivers/md/dm-rq.c:	 *       of the stacking during the completion
drivers/md/dm-rq.c:	 * because the device may be closed during the request completion
drivers/md/dm-crypt.c:#include <linux/completion.h>
drivers/md/dm-crypt.c:	struct completion restart;
drivers/md/dm-crypt.c:	init_completion(&ctx->restart);
drivers/md/dm-crypt.c:			wait_for_completion(&ctx->restart);
drivers/md/dm-crypt.c:			reinit_completion(&ctx->restart);
drivers/md/dm-crypt.c:		 * completion function kcryptd_async_done() will be called.
drivers/md/dm-crypt.c: * One of the bios was finished. Check for completion of
drivers/md/dm-crypt.c:	 * finish the completion and continue in crypt_convert().
drivers/md/dm-log-userspace-transfer.c:	struct completion complete;
drivers/md/dm-log-userspace-transfer.c:	init_completion(&pkg.complete);
drivers/md/dm-log-userspace-transfer.c:	tmo = wait_for_completion_timeout(&(pkg.complete), DM_ULOG_RETRY_TIMEOUT);
drivers/md/dm.h:#include <linux/completion.h>
drivers/md/raid5.h: *  Want  -> Clean  - on successful completion of read request
drivers/md/raid5.h: *  Dirty -> Clean  - on successful completion of write request
drivers/md/dm-bufio.c: * dm-io completion routine. It just calls b->bio.bi_end_io, pretending
drivers/md/dm-mpath.c:	wait_queue_head_t pg_init_wait;	/* Wait for pg_init completion */
drivers/md/dm-mpath.c:static void multipath_wait_for_pg_init_completion(struct multipath *m)
drivers/md/dm-mpath.c:	multipath_wait_for_pg_init_completion(m);
drivers/md/dm-bufio.h: * Initiate writing of dirty buffers, without waiting for completion.
drivers/md/raid1.c: * Update disk head position estimator based on IRQ completion info.
drivers/md/raid1.c: * completion handlers update this position correctly. If there is no
drivers/md/dm-builtin.c: *  4. dm_sysfs_exit waits on the completion
drivers/md/dm-builtin.c:	complete(dm_get_completion_from_kobject(kobj));
drivers/md/dm-core.h:	struct completion completion;
drivers/md/dm-core.h:	/* kobject and completion */
drivers/md/dm-core.h:static inline struct completion *dm_get_completion_from_kobject(struct kobject *kobj)
drivers/md/dm-core.h:	return &container_of(kobj, struct dm_kobject_holder, kobj)->completion;
drivers/md/dm.c:	init_completion(&md->kobj_holder.completion);
drivers/md/dm.c:static int dm_wait_for_completion(struct mapped_device *md, long task_state)
drivers/md/dm.c:	 * We call dm_wait_for_completion to wait for all existing requests
drivers/md/dm.c:	r = dm_wait_for_completion(md, task_state);
drivers/md/dm.c:	dm_wait_for_completion(md, TASK_UNINTERRUPTIBLE);
drivers/md/dm-io.c:#include <linux/completion.h>
drivers/md/dm-io.c:	struct completion wait;
drivers/md/dm-io.c:	init_completion(&sio.wait);
drivers/md/dm-io.c:	wait_for_completion_io(&sio.wait);
drivers/md/dm-kcopyd.c: * completion notification.
drivers/md/dm-kcopyd.c:		 * Queue the completion callback to the kcopyd thread.
drivers/md/dm-kcopyd.c:		 * Some callers assume that all the completions are called
drivers/md/dm-kcopyd.c:	/* Wait for completion of all jobs submitted by this client. */
drivers/md/dm-table.c:	 * (e.g. request completion process for partial completion.)
drivers/md/raid5.c:		/* acknowledge completion of a biofill operation */
drivers/md/raid5.c:		break; /* we will be called again upon completion */
drivers/md/raid5.c:		break; /* we will be called again upon completion */
drivers/md/md-cluster.c:	struct completion completion;
drivers/md/md-cluster.c:	struct completion newdisk_completion;
drivers/md/md-cluster.c:		 * cancel the request and reset completion
drivers/md/md-cluster.c:	/* completion is only need to be complete when node join cluster,
drivers/md/md-cluster.c:		complete(&cinfo->completion);
drivers/md/md-cluster.c:	init_completion(&cinfo->newdisk_completion);
drivers/md/md-cluster.c:	wait_for_completion_timeout(&cinfo->newdisk_completion,
drivers/md/md-cluster.c:	init_completion(&cinfo->completion);
drivers/md/md-cluster.c:	wait_for_completion(&cinfo->completion);
drivers/md/md-cluster.c:	complete(&cinfo->newdisk_completion);
drivers/md/raid10.c: * Update disk head position estimator based on IRQ completion info.
drivers/md/raid10.c: * completion handlers update this position correctly. If there is no
drivers/md/md.c:	 * and decrement it on completion, waking up sb_wait
drivers/md/dm-sysfs.c:	wait_for_completion(dm_get_completion_from_kobject(kobj));
drivers/md/dm-era-target.c:	struct completion complete;
drivers/md/dm-era-target.c:	init_completion(&rpc->complete);
drivers/md/dm-era-target.c:	wait_for_completion(&rpc->complete);
drivers/md/dm-snap.c:	/* A sequence number, it is used for in-order completion. */
drivers/md/dm-snap.c:		 * completion of this exception, and start this one last,
drivers/md/dm-log-writes.c: * order of completion along with the normal writes.  If we didn't do it this
drivers/md/dm-thin.c:	struct completion can_destroy;
drivers/md/dm-thin.c:	 * will prevent completion until the sub range discards have
drivers/md/dm-thin.c:	struct completion complete;
drivers/md/dm-thin.c:	init_completion(&pw->complete);
drivers/md/dm-thin.c:	wait_for_completion(&pw->complete);
drivers/md/dm-thin.c:	wait_for_completion(&tc->can_destroy);
drivers/md/dm-thin.c:	init_completion(&tc->can_destroy);
drivers/target/target_core_alua.c:		wait_for_completion(&wait);
drivers/target/target_core_alua.c:		wait_for_completion(&wait);
drivers/target/target_core_device.c:	init_completion(&new->pr_comp);
drivers/target/target_core_device.c:		wait_for_completion(&orig->pr_comp);
drivers/target/target_core_device.c:	wait_for_completion(&orig->pr_comp);
drivers/target/target_core_device.c:	init_completion(&xcopy_lun->lun_ref_comp);
drivers/target/target_core_pr.c:			 * completion of adding ALL_TG_PT=1 registrations in
drivers/target/target_core_user.c:static void tcmu_handle_completion(struct tcmu_cmd *cmd, struct tcmu_cmd_entry *entry)
drivers/target/target_core_user.c:static unsigned int tcmu_handle_completions(struct tcmu_dev *udev)
drivers/target/target_core_user.c:		pr_err("ring broken, not handling completions\n");
drivers/target/target_core_user.c:		tcmu_handle_completion(cmd, entry);
drivers/target/target_core_user.c:	handled = tcmu_handle_completions(udev);
drivers/target/target_core_user.c:	pr_warn("%d completions handled from timeout\n", handled);
drivers/target/target_core_user.c:	tcmu_handle_completions(tcmu_dev);
drivers/target/target_core_transport.c:static struct workqueue_struct *target_completion_wq;
drivers/target/target_core_transport.c:	target_completion_wq = alloc_workqueue("target_completion",
drivers/target/target_core_transport.c:	if (!target_completion_wq)
drivers/target/target_core_transport.c:	destroy_workqueue(target_completion_wq);
drivers/target/target_core_transport.c:	 * and transport_wait_for_tasks() will be waiting for completion..
drivers/target/target_core_transport.c:		queue_work_on(cmd->cpuid, target_completion_wq, &cmd->work);
drivers/target/target_core_transport.c:		queue_work(target_completion_wq, &cmd->work);
drivers/target/target_core_transport.c:	init_completion(&cmd->t_transport_stop_comp);
drivers/target/target_core_transport.c:	init_completion(&cmd->cmd_wait_comp);
drivers/target/target_core_transport.c: * Called from I/O completion to determine which dormant/delayed
drivers/target/target_core_transport.c:		wait_for_completion(&cmd->cmd_wait_comp);
drivers/target/target_core_transport.c:		wait_for_completion(&se_cmd->cmd_wait_comp);
drivers/target/target_core_transport.c:	wait_for_completion(&lun->lun_ref_comp);
drivers/target/target_core_transport.c:	wait_for_completion(&cmd->t_transport_stop_comp);
drivers/target/target_core_transport.c:	pr_debug("wait_for_tasks: Stopped wait_for_completion(&cmd->"
drivers/target/target_core_transport.c: * transport_wait_for_tasks - wait for completion to occur
drivers/target/target_core_sbc.c:	 * upon MISCOMPARE, or in compare_and_write_done() upon completion
drivers/target/target_core_sbc.c:		 * Setup BIDI XOR callback to be run after I/O completion.
drivers/target/target_core_sbc.c:			 * completion.
drivers/target/target_core_xcopy.c:	struct completion xpt_passthrough_sem;
drivers/target/target_core_xcopy.c:	wait_for_completion_interruptible(&xpt_cmd->xpt_passthrough_sem);
drivers/target/target_core_xcopy.c:	init_completion(&xpt_cmd->xpt_passthrough_sem);
drivers/target/target_core_xcopy.c:	init_completion(&xpt_cmd->xpt_passthrough_sem);
drivers/target/target_core_tpg.c:	init_completion(&acl->acl_free_comp);
drivers/target/target_core_tpg.c:	wait_for_completion(&acl->acl_free_comp);
drivers/target/target_core_tpg.c:	init_completion(&lun->lun_ref_comp);
drivers/target/iscsi/iscsi_target_erl1.c:		" completion of %sDataOUT Sequence Offset: %u, Length: %u\n",
drivers/target/iscsi/iscsi_target_tpg.c:	init_completion(&tpg_np->tpg_np_comp);
drivers/target/iscsi/iscsi_target_erl0.c:	wait_for_completion(&conn->conn_wait_rcfr_comp);
drivers/target/iscsi/iscsi_target_erl0.c:	wait_for_completion(&conn->conn_wait_comp);
drivers/target/iscsi/iscsi_target.c:#include <linux/completion.h>
drivers/target/iscsi/iscsi_target.c:	init_completion(&np->np_restart_comp);
drivers/target/iscsi/iscsi_target.c:		wait_for_completion(&np->np_restart_comp);
drivers/target/iscsi/iscsi_target.c:		wait_for_completion(&tpg_np->tpg_np_comp);
drivers/target/iscsi/iscsi_target.c:		wait_for_completion_interruptible_timeout(
drivers/target/iscsi/iscsi_target.c:		wait_for_completion_interruptible_timeout(
drivers/target/iscsi/iscsi_target.c:			wait_for_completion_timeout(&conn->conn_logout_comp,
drivers/target/iscsi/iscsi_target.c:	rc = wait_for_completion_interruptible(&conn->rx_login_comp);
drivers/target/iscsi/iscsi_target.c:	 * to signal logout response TX interrupt completion.  Go ahead and skip
drivers/target/iscsi/iscsi_target.c:		wait_for_completion(&conn->conn_post_wait_comp);
drivers/target/iscsi/iscsi_target.c:		wait_for_completion(&conn->conn_post_wait_comp);
drivers/target/iscsi/iscsi_target.c:		wait_for_completion(&sess->session_wait_comp);
drivers/target/iscsi/iscsi_target.c:		wait_for_completion(&sess->session_wait_comp);
drivers/target/iscsi/iscsi_target_util.c:		wait_for_completion(&sess->session_waiting_on_uc_comp);
drivers/target/iscsi/iscsi_target_util.c:		wait_for_completion(&conn->conn_waiting_on_uc_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&conn->conn_post_wait_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&conn->conn_wait_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&conn->conn_wait_rcfr_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&conn->conn_waiting_on_uc_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&conn->conn_logout_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&conn->rx_half_close_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&conn->tx_half_close_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&conn->rx_login_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&sess->async_msg_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&sess->reinstatement_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&sess->session_wait_comp);
drivers/target/iscsi/iscsi_target_login.c:	init_completion(&sess->session_waiting_on_uc_comp);
drivers/target/iscsi/cxgbit/cxgbit.h:#include <linux/completion.h>
drivers/target/iscsi/cxgbit/cxgbit.h:	SKCBF_TX_FLAG_COMPL	= (1 << 1), /* wr completion flag */
drivers/target/iscsi/cxgbit/cxgbit.h:	struct completion completion;
drivers/target/iscsi/cxgbit/cxgbit.h:	struct completion accept_comp;
drivers/target/iscsi/cxgbit/cxgbit_target.c:			wait_for_completion_timeout(&conn->conn_logout_comp,
drivers/target/iscsi/cxgbit/cxgbit_cm.c:	reinit_completion(&wr_waitp->completion);
drivers/target/iscsi/cxgbit/cxgbit_cm.c:	complete(&wr_waitp->completion);
drivers/target/iscsi/cxgbit/cxgbit_cm.c:	ret = wait_for_completion_timeout(&wr_waitp->completion, timeout * HZ);
drivers/target/iscsi/cxgbit/cxgbit_cm.c:	init_completion(&cnp->com.wr_wait.completion);
drivers/target/iscsi/cxgbit/cxgbit_cm.c:	init_completion(&cnp->accept_comp);
drivers/target/iscsi/cxgbit/cxgbit_cm.c:	ret = wait_for_completion_interruptible(&cnp->accept_comp);
drivers/target/iscsi/cxgbit/cxgbit_cm.c:	init_completion(&csk->com.wr_wait.completion);
drivers/spi/spi-dln2.c:		u8 wait_for_completion;
drivers/spi/spi-dln2.c:		len -= sizeof(tx.wait_for_completion);
drivers/spi/spi-dln2.c:		tx.wait_for_completion = DLN2_TRANSFERS_WAIT_COMPLETE;
drivers/spi/spi-bfin5xx.c:		   checking SPIF or TXS may not guarantee transfer completion */
drivers/spi/spi-bfin5xx.c:		   checking SPIF or TXS may not guarantee transfer completion */
drivers/spi/spi-bfin5xx.c:		/* poll for SPI completion before start */
drivers/spi/spi-ti-qspi.c:	struct completion	transfer_complete;
drivers/spi/spi-ti-qspi.c:	ret = wait_for_completion_timeout(&qspi->transfer_complete,
drivers/spi/spi-ti-qspi.c:		dev_err(qspi->dev, "DMA wait_for_completion_timeout\n");
drivers/spi/spi-ti-qspi.c:	init_completion(&qspi->transfer_complete);
drivers/spi/spi-s3c64xx.c: * @xfer_completion: To indicate completion of xfer task.
drivers/spi/spi-s3c64xx.c:	struct completion               xfer_completion;
drivers/spi/spi-s3c64xx.c:			complete(&sdd->xfer_completion);
drivers/spi/spi-s3c64xx.c:			complete(&sdd->xfer_completion);
drivers/spi/spi-s3c64xx.c:	val = wait_for_completion_timeout(&sdd->xfer_completion, val);
drivers/spi/spi-s3c64xx.c:	reinit_completion(&sdd->xfer_completion);
drivers/spi/spi-s3c64xx.c:	init_completion(&sdd->xfer_completion);
drivers/spi/spi-tegra114.c:#include <linux/completion.h>
drivers/spi/spi-tegra114.c:	struct completion			rx_dma_complete;
drivers/spi/spi-tegra114.c:	struct completion			tx_dma_complete;
drivers/spi/spi-tegra114.c:	struct completion			xfer_completion;
drivers/spi/spi-tegra114.c:	struct completion *dma_complete = args;
drivers/spi/spi-tegra114.c:	reinit_completion(&tspi->tx_dma_complete);
drivers/spi/spi-tegra114.c:	reinit_completion(&tspi->rx_dma_complete);
drivers/spi/spi-tegra114.c:		reinit_completion(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:		ret = wait_for_completion_timeout(&tspi->xfer_completion,
drivers/spi/spi-tegra114.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:			wait_status = wait_for_completion_interruptible_timeout(
drivers/spi/spi-tegra114.c:			wait_status = wait_for_completion_interruptible_timeout(
drivers/spi/spi-tegra114.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:	init_completion(&tspi->tx_dma_complete);
drivers/spi/spi-tegra114.c:	init_completion(&tspi->rx_dma_complete);
drivers/spi/spi-tegra114.c:	init_completion(&tspi->xfer_completion);
drivers/spi/spi-bcm63xx.c:#include <linux/completion.h>
drivers/spi/spi-bcm63xx.c:	struct completion	done;
drivers/spi/spi-bcm63xx.c:	reinit_completion(&bs->done);
drivers/spi/spi-bcm63xx.c:	timeout = wait_for_completion_timeout(&bs->done, HZ);
drivers/spi/spi-bcm63xx.c:	init_completion(&bs->done);
drivers/spi/spi-sirf.c:#include <linux/completion.h>
drivers/spi/spi-sirf.c:	struct completion rx_done;
drivers/spi/spi-sirf.c:	struct completion tx_done;
drivers/spi/spi-sirf.c:	struct completion *dma_complete = data;
drivers/spi/spi-sirf.c:	if (wait_for_completion_timeout(&sspi->tx_done, timeout) == 0) {
drivers/spi/spi-sirf.c:	if (wait_for_completion_timeout(&sspi->rx_done, timeout) == 0) {
drivers/spi/spi-sirf.c:	if (wait_for_completion_timeout(&sspi->tx_done, timeout) == 0) {
drivers/spi/spi-sirf.c:		if (!wait_for_completion_timeout(&sspi->tx_done, timeout) ||
drivers/spi/spi-sirf.c:			!wait_for_completion_timeout(&sspi->rx_done, timeout)) {
drivers/spi/spi-sirf.c:	reinit_completion(&sspi->rx_done);
drivers/spi/spi-sirf.c:	reinit_completion(&sspi->tx_done);
drivers/spi/spi-sirf.c:	 * completion.
drivers/spi/spi-sirf.c:	init_completion(&sspi->rx_done);
drivers/spi/spi-sirf.c:	init_completion(&sspi->tx_done);
drivers/spi/spi-fsl-lib.c:	init_completion(&mpc8xxx_spi->done);
drivers/spi/spi-omap2-mcspi.c:	struct completion dma_tx_completion;
drivers/spi/spi-omap2-mcspi.c:	struct completion dma_rx_completion;
drivers/spi/spi-omap2-mcspi.c:	complete(&mcspi_dma->dma_rx_completion);
drivers/spi/spi-omap2-mcspi.c:	complete(&mcspi_dma->dma_tx_completion);
drivers/spi/spi-omap2-mcspi.c:	wait_for_completion(&mcspi_dma->dma_rx_completion);
drivers/spi/spi-omap2-mcspi.c:		wait_for_completion(&mcspi_dma->dma_tx_completion);
drivers/spi/spi-omap2-mcspi.c:	init_completion(&mcspi_dma->dma_rx_completion);
drivers/spi/spi-omap2-mcspi.c:	init_completion(&mcspi_dma->dma_tx_completion);
drivers/spi/spi-s3c24xx.c:	struct completion	 done;
drivers/spi/spi-s3c24xx.c:	init_completion(&hw->done);
drivers/spi/spi-s3c24xx.c:	wait_for_completion(&hw->done);
drivers/spi/spi-s3c24xx.c:	init_completion(&hw->done);
drivers/spi/spi-qup.c:	struct completion	done;
drivers/spi/spi-qup.c:	reinit_completion(&controller->done);
drivers/spi/spi-qup.c:	if (!wait_for_completion_timeout(&controller->done, timeout))
drivers/spi/spi-qup.c:	init_completion(&controller->done);
drivers/spi/spi-mpc52xx.c:#define FSM_POLL	1	/* need to poll for completion, an IRQ is */
drivers/spi/spi-ep93xx.c:	struct completion		wait;
drivers/spi/spi-ep93xx.c:		wait_for_completion(&espi->wait);
drivers/spi/spi-ep93xx.c:	wait_for_completion(&espi->wait);
drivers/spi/spi-ep93xx.c:	init_completion(&espi->wait);
drivers/spi/spi-atmel.c:	struct completion	xfer_completion;
drivers/spi/spi-atmel.c:	complete(&as->xfer_completion);
drivers/spi/spi-atmel.c:	 * transfer completion.
drivers/spi/spi-atmel.c:		complete(&as->xfer_completion);
drivers/spi/spi-atmel.c:			complete(&as->xfer_completion);
drivers/spi/spi-atmel.c:		complete(&as->xfer_completion);
drivers/spi/spi-atmel.c:		complete(&as->xfer_completion);
drivers/spi/spi-atmel.c:		reinit_completion(&as->xfer_completion);
drivers/spi/spi-atmel.c:		dma_timeout = wait_for_completion_timeout(&as->xfer_completion,
drivers/spi/spi-atmel.c:	init_completion(&as->xfer_completion);
drivers/spi/spi-fsl-spi.c:	reinit_completion(&mpc8xxx_spi->done);
drivers/spi/spi-fsl-spi.c:	wait_for_completion(&mpc8xxx_spi->done);
drivers/spi/spi-altera.c:	struct completion done;
drivers/spi/spi-altera.c:		wait_for_completion(&hw->done);
drivers/spi/spi-altera.c:		init_completion(&hw->done);
drivers/spi/spi-au1550.c:#include <linux/completion.h>
drivers/spi/spi-au1550.c:	struct completion master_done;
drivers/spi/spi-au1550.c:	wait_for_completion(&hw->master_done);
drivers/spi/spi-au1550.c:	wait_for_completion(&hw->master_done);
drivers/spi/spi-au1550.c:	init_completion(&hw->master_done);
drivers/spi/spi-pic32.c:	struct completion	xfer_done;
drivers/spi/spi-pic32.c:	reinit_completion(&pic32s->xfer_done);
drivers/spi/spi-pic32.c:	/* wait for completion */
drivers/spi/spi-pic32.c:	timeout = wait_for_completion_timeout(&pic32s->xfer_done, 2 * HZ);
drivers/spi/spi-pic32.c:	 * completion of the ongoing transfer. This might result into
drivers/spi/spi-pic32.c:	init_completion(&pic32s->xfer_done);
drivers/spi/spi-imx.c:#include <linux/completion.h>
drivers/spi/spi-imx.c:	struct completion xfer_done;
drivers/spi/spi-imx.c:	struct completion dma_rx_completion;
drivers/spi/spi-imx.c:	struct completion dma_tx_completion;
drivers/spi/spi-imx.c:	init_completion(&spi_imx->dma_rx_completion);
drivers/spi/spi-imx.c:	init_completion(&spi_imx->dma_tx_completion);
drivers/spi/spi-imx.c:	complete(&spi_imx->dma_rx_completion);
drivers/spi/spi-imx.c:	complete(&spi_imx->dma_tx_completion);
drivers/spi/spi-imx.c:	reinit_completion(&spi_imx->dma_rx_completion);
drivers/spi/spi-imx.c:	reinit_completion(&spi_imx->dma_tx_completion);
drivers/spi/spi-imx.c:	timeout = wait_for_completion_timeout(&spi_imx->dma_tx_completion,
drivers/spi/spi-imx.c:	timeout = wait_for_completion_timeout(&spi_imx->dma_rx_completion,
drivers/spi/spi-imx.c:	reinit_completion(&spi_imx->xfer_done);
drivers/spi/spi-imx.c:	timeout = wait_for_completion_timeout(&spi_imx->xfer_done,
drivers/spi/spi-imx.c:	init_completion(&spi_imx->xfer_done);
drivers/spi/spi.c:			reinit_completion(&master->xfer_completion);
drivers/spi/spi.c:				ms = wait_for_completion_timeout(&master->xfer_completion,
drivers/spi/spi.c: * spi_finalize_current_transfer - report completion of a transfer
drivers/spi/spi.c: * @master: the master reporting completion
drivers/spi/spi.c:	complete(&master->xfer_completion);
drivers/spi/spi.c:	init_completion(&master->xfer_completion);
drivers/spi/spi.c: * @message: describes the data transfers, including completion callback
drivers/spi/spi.c: * The completion callback is invoked in a context which can't sleep.
drivers/spi/spi.c: * Until returning from the associated message completion callback,
drivers/spi/spi.c: * @message: describes the data transfers, including completion callback
drivers/spi/spi.c: * The completion callback is invoked in a context which can't sleep.
drivers/spi/spi.c: * Until returning from the associated message completion callback,
drivers/spi/spi.c:		wait_for_completion(&done);
drivers/spi/spi-pic32-sqi.c:	struct completion	xfer_done;
drivers/spi/spi-pic32-sqi.c:	reinit_completion(&sqi->xfer_done);
drivers/spi/spi-pic32-sqi.c:	/* wait for xfer completion */
drivers/spi/spi-pic32-sqi.c:	timeout = wait_for_completion_timeout(&sqi->xfer_done, 5 * HZ);
drivers/spi/spi-pic32-sqi.c:	init_completion(&sqi->xfer_done);
drivers/spi/spi-fsl-lib.h:	struct completion done;
drivers/spi/spi-tegra20-sflash.c:#include <linux/completion.h>
drivers/spi/spi-tegra20-sflash.c:	struct completion			xfer_completion;
drivers/spi/spi-tegra20-sflash.c:		reinit_completion(&tsd->xfer_completion);
drivers/spi/spi-tegra20-sflash.c:		ret = wait_for_completion_timeout(&tsd->xfer_completion,
drivers/spi/spi-tegra20-sflash.c:		complete(&tsd->xfer_completion);
drivers/spi/spi-tegra20-sflash.c:		complete(&tsd->xfer_completion);
drivers/spi/spi-tegra20-sflash.c:	init_completion(&tsd->xfer_completion);
drivers/spi/spi-pxa2xx-dma.c:	 * just gets DMA completion. Calling pump_transfers() twice for the
drivers/spi/spi-bcm-qspi.c:	struct completion mspi_done;
drivers/spi/spi-bcm-qspi.c:	struct completion bspi_done;
drivers/spi/spi-bcm-qspi.c:	reinit_completion(&qspi->bspi_done);
drivers/spi/spi-bcm-qspi.c:	if (!wait_for_completion_timeout(&qspi->bspi_done, timeo)) {
drivers/spi/spi-bcm-qspi.c:		reinit_completion(&qspi->mspi_done);
drivers/spi/spi-bcm-qspi.c:		if (!wait_for_completion_timeout(&qspi->mspi_done, timeo)) {
drivers/spi/spi-bcm-qspi.c:	init_completion(&qspi->mspi_done);
drivers/spi/spi-bcm-qspi.c:	init_completion(&qspi->bspi_done);
drivers/spi/spi-xilinx.c:	struct completion done;
drivers/spi/spi-xilinx.c:		reinit_completion(&xspi->done);
drivers/spi/spi-xilinx.c:			wait_for_completion(&xspi->done);
drivers/spi/spi-xilinx.c:	init_completion(&xspi->done);
drivers/spi/spi-sun4i.c:	struct completion	done;
drivers/spi/spi-sun4i.c:	reinit_completion(&sspi->done);
drivers/spi/spi-sun4i.c:	timeout = wait_for_completion_timeout(&sspi->done,
drivers/spi/spi-sun4i.c:	init_completion(&sspi->done);
drivers/spi/spi-mxs.c:#include <linux/completion.h>
drivers/spi/spi-mxs.c:	struct completion	c;
drivers/spi/spi-mxs.c:	reinit_completion(&spi->c);
drivers/spi/spi-mxs.c:	if (!wait_for_completion_timeout(&spi->c,
drivers/spi/spi-mxs.c:	init_completion(&spi->c);
drivers/spi/spi-bcm2835aux.c:#include <linux/completion.h>
drivers/spi/spi-bcm2835aux.c:	/* and if rx_len is 0 then disable interrupts and wake up completion */
drivers/spi/spi-bcm2835aux.c:		complete(&master->xfer_completion);
drivers/spi/spi-bcm2835aux.c:	/* and return without waiting for completion */
drivers/spi/spi-nuc900.c:	struct completion	 done;
drivers/spi/spi-nuc900.c:	wait_for_completion(&hw->done);
drivers/spi/spi-nuc900.c:	init_completion(&hw->done);
drivers/spi/spi-sun6i.c:	struct completion	done;
drivers/spi/spi-sun6i.c:	reinit_completion(&sspi->done);
drivers/spi/spi-sun6i.c:	timeout = wait_for_completion_timeout(&sspi->done,
drivers/spi/spi-sun6i.c:	init_completion(&sspi->done);
drivers/spi/spi-xlp.c:	struct completion	done;		/* completion notification */
drivers/spi/spi-xlp.c:	timeout = wait_for_completion_timeout(&xs->done,
drivers/spi/spi-xlp.c:	init_completion(&xspi->done);
drivers/spi/spi-mpc512x-psc.c:#include <linux/completion.h>
drivers/spi/spi-mpc512x-psc.c:	struct completion txisrdone;
drivers/spi/spi-mpc512x-psc.c:			reinit_completion(&mps->txisrdone);
drivers/spi/spi-mpc512x-psc.c:			wait_for_completion(&mps->txisrdone);
drivers/spi/spi-mpc512x-psc.c:	init_completion(&mps->txisrdone);
drivers/spi/spi-oc-tiny.c:	struct completion done;
drivers/spi/spi-oc-tiny.c:		wait_for_completion(&hw->done);
drivers/spi/spi-oc-tiny.c:		init_completion(&hw->done);
drivers/spi/spi-sh-msiof.c:#include <linux/completion.h>
drivers/spi/spi-sh-msiof.c:	struct completion done;
drivers/spi/spi-sh-msiof.c:	reinit_completion(&p->done);
drivers/spi/spi-sh-msiof.c:	if (!wait_for_completion_timeout(&p->done, HZ)) {
drivers/spi/spi-sh-msiof.c:	reinit_completion(&p->done);
drivers/spi/spi-sh-msiof.c:	if (!wait_for_completion_timeout(&p->done, HZ)) {
drivers/spi/spi-sh-msiof.c:	init_completion(&p->done);
drivers/spi/spi-bcm2835.c:#include <linux/completion.h>
drivers/spi/spi-bcm2835.c:		complete(&master->xfer_completion);
drivers/spi/spi-bcm2835.c:	/* signal that we need to wait for completion */
drivers/spi/spi-bcm2835.c:	complete(&master->xfer_completion);
drivers/spi/spi-bcm2835.c:	/* and return without waiting for completion */
drivers/spi/spi-mpc52xx-psc.c:#include <linux/completion.h>
drivers/spi/spi-mpc52xx-psc.c:	struct completion done;
drivers/spi/spi-mpc52xx-psc.c:		wait_for_completion(&mps->done);
drivers/spi/spi-mpc52xx-psc.c:	init_completion(&mps->done);
drivers/spi/spi-bcm63xx-hsspi.c:	struct completion done;
drivers/spi/spi-bcm63xx-hsspi.c:		reinit_completion(&bs->done);
drivers/spi/spi-bcm63xx-hsspi.c:		if (wait_for_completion_timeout(&bs->done, HZ) == 0) {
drivers/spi/spi-bcm63xx-hsspi.c:	init_completion(&bs->done);
drivers/spi/spi-ppc4xx.c:	struct completion done;
drivers/spi/spi-ppc4xx.c:	wait_for_completion(&hw->done);
drivers/spi/spi-ppc4xx.c:	init_completion(&hw->done);
drivers/spi/spi-cadence.c: * returns a positive transfer count so that core will wait for completion.
drivers/spi/spi-davinci.c:	struct completion	done;
drivers/spi/spi-davinci.c: * of SPI controller and then wait until the completion will be marked
drivers/spi/spi-davinci.c:	reinit_completion(&dspi->done);
drivers/spi/spi-davinci.c:		if (wait_for_completion_timeout(&dspi->done, HZ) == 0)
drivers/spi/spi-davinci.c:	init_completion(&dspi->done);
drivers/spi/spi-efm32.c:	struct completion done;
drivers/spi/spi-efm32.c:	reinit_completion(&ddata->done);
drivers/spi/spi-efm32.c:	wait_for_completion(&ddata->done);
drivers/spi/spi-efm32.c:	init_completion(&ddata->done);
drivers/spi/spi-st-ssc4.c:	struct completion	done;
drivers/spi/spi-st-ssc4.c:	reinit_completion(&spi_st->done);
drivers/spi/spi-st-ssc4.c:	wait_for_completion(&spi_st->done);
drivers/spi/spi-st-ssc4.c:	init_completion(&spi_st->done);
drivers/spi/spi-tegra20-slink.c:#include <linux/completion.h>
drivers/spi/spi-tegra20-slink.c:	struct completion			rx_dma_complete;
drivers/spi/spi-tegra20-slink.c:	struct completion			tx_dma_complete;
drivers/spi/spi-tegra20-slink.c:	struct completion			xfer_completion;
drivers/spi/spi-tegra20-slink.c:	struct completion *dma_complete = args;
drivers/spi/spi-tegra20-slink.c:	reinit_completion(&tspi->tx_dma_complete);
drivers/spi/spi-tegra20-slink.c:	reinit_completion(&tspi->rx_dma_complete);
drivers/spi/spi-tegra20-slink.c:	reinit_completion(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:	ret = wait_for_completion_timeout(&tspi->xfer_completion,
drivers/spi/spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:			wait_status = wait_for_completion_interruptible_timeout(
drivers/spi/spi-tegra20-slink.c:			wait_status = wait_for_completion_interruptible_timeout(
drivers/spi/spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:	init_completion(&tspi->tx_dma_complete);
drivers/spi/spi-tegra20-slink.c:	init_completion(&tspi->rx_dma_complete);
drivers/spi/spi-tegra20-slink.c:	init_completion(&tspi->xfer_completion);
drivers/spi/spi-fsl-espi.c:	reinit_completion(&mpc8xxx_spi->done);
drivers/spi/spi-fsl-espi.c:	ret = wait_for_completion_timeout(&mpc8xxx_spi->done, 2 * HZ);
drivers/power/supply/jz4740-battery.c:	struct completion read_completion;
drivers/power/supply/jz4740-battery.c:	complete(&battery->read_completion);
drivers/power/supply/jz4740-battery.c:	reinit_completion(&battery->read_completion);
drivers/power/supply/jz4740-battery.c:	t = wait_for_completion_interruptible_timeout(&battery->read_completion,
drivers/power/supply/jz4740-battery.c:	init_completion(&jz_battery->read_completion);
drivers/power/supply/abx500_chargalg.c:#include <linux/completion.h>
drivers/power/supply/ab8500_btemp.c:#include <linux/completion.h>
drivers/power/supply/ab8500_charger.c:#include <linux/completion.h>
drivers/power/supply/ab8500_fg.c:#include <linux/completion.h>
drivers/power/supply/ab8500_fg.c:	struct completion ab8500_fg_started;
drivers/power/supply/ab8500_fg.c:	struct completion ab8500_fg_complete;
drivers/power/supply/ab8500_fg.c:	reinit_completion(&di->ab8500_fg_started);
drivers/power/supply/ab8500_fg.c:	reinit_completion(&di->ab8500_fg_complete);
drivers/power/supply/ab8500_fg.c:	return completion_done(&di->ab8500_fg_started);
drivers/power/supply/ab8500_fg.c:	return completion_done(&di->ab8500_fg_complete);
drivers/power/supply/ab8500_fg.c:	if (!completion_done(&di->ab8500_fg_complete)) {
drivers/power/supply/ab8500_fg.c:		timeout = wait_for_completion_timeout(
drivers/power/supply/ab8500_fg.c:			dev_err(di->dev, "completion timed out [%d]\n",
drivers/power/supply/ab8500_fg.c:	if (!completion_done(&di->ab8500_fg_started)) {
drivers/power/supply/ab8500_fg.c:		timeout = wait_for_completion_timeout(
drivers/power/supply/ab8500_fg.c:			dev_err(di->dev, "completion timed out [%d]\n",
drivers/power/supply/ab8500_fg.c:	 * Initialize completion used to notify completion and start
drivers/power/supply/ab8500_fg.c:	init_completion(&di->ab8500_fg_started);
drivers/power/supply/ab8500_fg.c:	init_completion(&di->ab8500_fg_complete);
drivers/nfc/s3fwrn5/firmware.h:	struct completion completion;
drivers/nfc/s3fwrn5/nci.c:#include <linux/completion.h>
drivers/nfc/s3fwrn5/firmware.c:#include <linux/completion.h>
drivers/nfc/s3fwrn5/firmware.c:	reinit_completion(&fw_info->completion);
drivers/nfc/s3fwrn5/firmware.c:	ret = wait_for_completion_interruptible_timeout(
drivers/nfc/s3fwrn5/firmware.c:		&fw_info->completion, msecs_to_jiffies(1000));
drivers/nfc/s3fwrn5/firmware.c:	init_completion(&fw_info->completion);
drivers/nfc/s3fwrn5/firmware.c:	complete(&fw_info->completion);
drivers/nfc/port100.c:	struct completion cmd_cancel_done;
drivers/nfc/port100.c:	init_completion(&dev->cmd_cancel_done);
drivers/nfc/port100.c:	 * submitted. It will be reset by the out URB completion callback
drivers/nfc/port100.c:		wait_for_completion(&dev->cmd_cancel_done);
drivers/nfc/port100.c:	struct completion done;
drivers/nfc/port100.c:	init_completion(&arg.done);
drivers/nfc/port100.c:	wait_for_completion(&arg.done);
drivers/nfc/st95hf/core.c:	init_completion(&spicontext->done);
drivers/nfc/st95hf/spi.c:		reinit_completion(&spicontext->done);
drivers/nfc/st95hf/spi.c:	result = wait_for_completion_timeout(&spicontext->done,
drivers/nfc/st95hf/spi.h: * @done: completion structure to wait for st95hf response
drivers/nfc/st95hf/spi.h:	struct completion done;
drivers/nfc/nfcwilink.c:	struct completion		completed;
drivers/nfc/nfcwilink.c:	comp_ret = wait_for_completion_timeout(&drv->completed,
drivers/nfc/nfcwilink.c:	dev_dbg(&drv->pdev->dev, "wait_for_completion_timeout returned %ld\n",
drivers/nfc/nfcwilink.c:			"timeout on wait_for_completion_timeout\n");
drivers/nfc/nfcwilink.c:	comp_ret = wait_for_completion_timeout(&drv->completed,
drivers/nfc/nfcwilink.c:	dev_dbg(&drv->pdev->dev, "wait_for_completion_timeout returned %ld\n",
drivers/nfc/nfcwilink.c:			"timeout on wait_for_completion_timeout\n");
drivers/nfc/nfcwilink.c:	init_completion(&drv->completed);
drivers/nfc/nfcwilink.c:			comp_ret = wait_for_completion_timeout(
drivers/nfc/nfcwilink.c:				"wait_for_completion_timeout returned %ld\n",
drivers/nfc/nfcmrvl/spi.c:	struct completion handshake_completion;
drivers/nfc/nfcmrvl/spi.c:		complete(&drv_data->handshake_completion);
drivers/nfc/nfcmrvl/spi.c:	/* Reinit completion for slave handshake */
drivers/nfc/nfcmrvl/spi.c:	reinit_completion(&drv_data->handshake_completion);
drivers/nfc/nfcmrvl/spi.c:	err = nci_spi_send(drv_data->nci_spi, &drv_data->handshake_completion,
drivers/nfc/nfcmrvl/spi.c:	/* Init completion for slave handshake */
drivers/nfc/nfcmrvl/spi.c:	init_completion(&drv_data->handshake_completion);
drivers/nfc/nxp-nci/nxp-nci.h:#include <linux/completion.h>
drivers/nfc/nxp-nci/nxp-nci.h:	struct completion cmd_completion;
drivers/nfc/nxp-nci/core.c:	init_completion(&info->fw_info.cmd_completion);
drivers/nfc/nxp-nci/firmware.c:#include <linux/completion.h>
drivers/nfc/nxp-nci/firmware.c:	long completion_rc;
drivers/nfc/nxp-nci/firmware.c:	reinit_completion(&fw_info->cmd_completion);
drivers/nfc/nxp-nci/firmware.c:		completion_rc = wait_for_completion_interruptible_timeout(
drivers/nfc/nxp-nci/firmware.c:			&fw_info->cmd_completion, NXP_NCI_FW_ANSWER_TIMEOUT);
drivers/nfc/nxp-nci/firmware.c:		if (completion_rc == 0)
drivers/nfc/nxp-nci/firmware.c:	complete(&fw_info->cmd_completion);
drivers/nfc/mei_phy.h: * @send_wq: send completion wait queue
drivers/nfc/st-nci/st-nci.h:	struct completion req_completion;
drivers/nfc/st-nci/se.c:				complete(&info->se_info.req_completion);
drivers/nfc/st-nci/se.c:			complete(&info->se_info.req_completion);
drivers/nfc/st-nci/se.c:	reinit_completion(&info->se_info.req_completion);
drivers/nfc/st-nci/se.c:	wait_for_completion_interruptible(&info->se_info.req_completion);
drivers/nfc/st-nci/se.c:	complete(&info->se_info.req_completion);
drivers/nfc/st-nci/se.c:	init_completion(&info->se_info.req_completion);
drivers/nfc/pn533/pn533.c:	struct completion done;
drivers/nfc/pn533/pn533.c:	init_completion(&arg.done);
drivers/nfc/pn533/pn533.c:	wait_for_completion(&arg.done);
drivers/nfc/pn533/usb.c:	struct completion done;
drivers/nfc/pn533/usb.c:	init_completion(&arg.done);
drivers/nfc/pn533/usb.c:	wait_for_completion(&arg.done);
drivers/nfc/st21nfca/vendor_cmds.c:	complete(&info->vendor_info.req_completion);
drivers/nfc/st21nfca/vendor_cmds.c:	reinit_completion(&info->vendor_info.req_completion);
drivers/nfc/st21nfca/vendor_cmds.c:	wait_for_completion_interruptible(&info->vendor_info.req_completion);
drivers/nfc/st21nfca/vendor_cmds.c:	init_completion(&info->vendor_info.req_completion);
drivers/nfc/st21nfca/st21nfca.h:	struct completion req_completion;
drivers/nfc/st21nfca/st21nfca.h:	struct completion req_completion;
drivers/nfc/st21nfca/core.c:			complete(&info->se_info.req_completion);
drivers/nfc/st21nfca/core.c:				complete(&info->se_info.req_completion);
drivers/nfc/st21nfca/se.c:	reinit_completion(&info->se_info.req_completion);
drivers/nfc/st21nfca/se.c:	wait_for_completion_interruptible(&info->se_info.req_completion);
drivers/nfc/st21nfca/se.c:	complete(&info->se_info.req_completion);
drivers/nfc/st21nfca/se.c:	init_completion(&info->se_info.req_completion);
drivers/media/dvb-frontends/mt352.c:	 * completion of the read operation is indicated by bit-5 of the
drivers/media/dvb-frontends/drxk_hard.h:	struct completion fw_wait_load;
drivers/media/dvb-frontends/stv0367.c:	/*wait for counting completion*/
drivers/media/dvb-frontends/stv0367.c:	/*wait for counting completion*/
drivers/media/tuners/tda18271-common.c:	msleep(30); /* image low optimization completion */
drivers/media/tuners/tda18271-common.c:	msleep(30); /* image mid optimization completion */
drivers/media/tuners/tda18271-common.c:	msleep(30); /* image high optimization completion */
drivers/media/tuners/tda18271-fe.c:	msleep(60); /* RF tracking filter calibration completion */
drivers/media/pci/bt8xx/bttv-input.c:		/* set timer_end for code completion */
drivers/media/pci/saa7134/saa7134-input.c:		/* set timer_end for code completion */
drivers/media/pci/cx18/cx23418.h:/* The MSB of the command code indicates that this is the completion of a
drivers/media/pci/mantis/mantis_i2c.c:		/* wait for xfer completion */
drivers/media/pci/mantis/mantis_i2c.c:		/* wait for xfer completion */
drivers/media/pci/mantis/mantis_i2c.c:		/* wait for xfer completion */
drivers/media/pci/mantis/mantis_i2c.c:		/* wait for xfer completion */
drivers/media/pci/mantis/mantis_i2c.c:			/* wait for xfer completion */
drivers/media/pci/mantis/mantis_i2c.c:			/* check for xfer completion */
drivers/media/pci/ddbridge/ddbridge-regs.h:#define DMA_DIAG_RECHECKCOUNTER         (0x30)  /* 76  ( Split completions on read ) */
drivers/media/pci/netup_unidvb/netup_unidvb_core.c:	/* Adjust PCIe completion timeout. */
drivers/media/pci/solo6x10/solo6x10-p2m.c:	reinit_completion(&p2m_dev->completion);
drivers/media/pci/solo6x10/solo6x10-p2m.c:	timeout = wait_for_completion_timeout(&p2m_dev->completion,
drivers/media/pci/solo6x10/solo6x10-p2m.c:		complete(&p2m_dev->completion);
drivers/media/pci/solo6x10/solo6x10-p2m.c:		complete(&p2m_dev->completion);
drivers/media/pci/solo6x10/solo6x10-p2m.c:		init_completion(&p2m_dev->completion);
drivers/media/pci/solo6x10/solo6x10.h:	struct completion	completion;
drivers/media/i2c/m5mols/m5mols_capture.c:		/* Wait for the capture completion interrupt */
drivers/media/i2c/soc_camera/ov2640.c:#define VHYX        0x55 /* Offset and size completion */
drivers/media/i2c/soc_camera/ov2640.c:#define TEST        0x57 /* Horizontal size completion */
drivers/media/i2c/soc_camera/ov2640.c:#define ZMHH        0x5C /* Zoom: Speed and H&W completion */
drivers/media/platform/ti-vpe/vpdma.c: * submit a list of DMA descriptors to the VPE VPDMA, do not wait for completion
drivers/media/platform/blackfin/bfin_capture.c:#include <linux/completion.h>
drivers/media/platform/blackfin/bfin_capture.c:	struct completion comp;
drivers/media/platform/blackfin/bfin_capture.c:	reinit_completion(&bcap_dev->comp);
drivers/media/platform/blackfin/bfin_capture.c:	wait_for_completion(&bcap_dev->comp);
drivers/media/platform/blackfin/bfin_capture.c:	init_completion(&bcap_dev->comp);
drivers/media/platform/soc_camera/atmel-isi.c:#include <linux/completion.h>
drivers/media/platform/soc_camera/atmel-isi.c:	struct completion		complete;
drivers/media/platform/soc_camera/atmel-isi.c:	init_completion(&isi->complete);
drivers/media/platform/soc_camera/atmel-isi.c:	timeout = wait_for_completion_timeout(&isi->complete,
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:#include <linux/completion.h>
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	struct completion complete;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	ret = wait_for_completion_interruptible(&pcdev->complete);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	struct completion	completion;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		wait_for_completion(&wait->completion);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		.completion = COMPLETION_INITIALIZER_ONSTACK(wait.completion),
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	init_completion(&pcdev->complete);
drivers/media/platform/coda/coda.h:	struct completion		completion;
drivers/media/platform/coda/coda-bit.c:	complete(&ctx->completion);
drivers/media/platform/coda/coda-common.c:	if (!wait_for_completion_timeout(&ctx->completion,
drivers/media/platform/coda/coda-common.c:	init_completion(&ctx->completion);
drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c:#include <linux/completion.h>
drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c:		/* wait for idle irq handler to signal completion */
drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c:		ret = wait_for_completion_timeout(&channel->idle_completion,
drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c:		reinit_completion(&channel->idle_completion);
drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c:	/* signal idle completion */
drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c:			complete(&chan->idle_completion);
drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c:	init_completion(&tsin->idle_completion);
drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c:	wait_for_completion(&fei->fw_ack);
drivers/media/platform/sti/c8sectpfe/c8sectpfe-common.c:#include <linux/completion.h>
drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.h:	struct completion idle_completion;
drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.h:	struct completion fw_ack;
drivers/media/platform/sti/c8sectpfe/c8sectpfe-dvb.c:#include <linux/completion.h>
drivers/media/platform/sti/hva/hva-hw.c: * NO_INT_COMPLETION: Time-out on interrupt completion
drivers/media/platform/sti/hva/hva-hw.c:	/* initialise completion signal */
drivers/media/platform/sti/hva/hva-hw.c:	init_completion(&hva->interrupt);
drivers/media/platform/sti/hva/hva-hw.c:	if (!wait_for_completion_timeout(&hva->interrupt,
drivers/media/platform/sti/hva/hva-hw.c:		dev_err(dev, "%s     %s: time out on completion\n", ctx->name,
drivers/media/platform/sti/hva/hva.h: * @interrupt:           completion interrupt
drivers/media/platform/sti/hva/hva.h:	struct completion	interrupt;
drivers/media/platform/atmel/atmel-isc.c:	struct completion	comp;
drivers/media/platform/atmel/atmel-isc.c:	reinit_completion(&isc->comp);
drivers/media/platform/atmel/atmel-isc.c:	if (isc->cur_frm && !wait_for_completion_timeout(&isc->comp, 5 * HZ))
drivers/media/platform/atmel/atmel-isc.c:	init_completion(&isc->comp);
drivers/media/platform/rcar_jpu.c:		/* ...enable interrupts on transfer completion and d-g error */
drivers/media/platform/rcar_jpu.c:	/* ...reset JPU after completion */
drivers/media/platform/s5p-mfc/s5p_mfc_intr.c: * This file contains functions used to wait for command completion.
drivers/media/platform/s5p-mfc/s5p_mfc_common.h: * @queue:		waitqueue for waiting for completion of device commands
drivers/media/platform/s5p-mfc/s5p_mfc_ctrl.c:	mfc_debug(2, "Will now wait for completion of firmware transfer\n");
drivers/media/platform/s5p-mfc/s5p_mfc_ctrl.c:	mfc_debug(2, "Ok, now will wait for completion of hardware init\n");
drivers/media/platform/s5p-mfc/s5p_mfc_ctrl.c:	/* 3. Send MFC wakeup command and wait for completion*/
drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h: * @queue: waitqueue for waiting for completion of device commands
drivers/media/platform/vsp1/vsp1_pipe.h: * @wq: wait queue to wait for state change completion
drivers/media/platform/marvell-ccic/mcam-core.c: * Frame completion handling.
drivers/media/platform/marvell-ccic/mcam-core.c: * Frame completion with S/G is trickier.  We can't muck with
drivers/media/platform/marvell-ccic/mcam-core.c: * buffer exists at frame completion, the controller is left stopped;
drivers/media/platform/marvell-ccic/mcam-core.c:	 * Handle any frame completions.  There really should
drivers/media/radio/si470x/radio-si470x-i2c.c:		complete(&radio->completion);
drivers/media/radio/si470x/radio-si470x-i2c.c:	init_completion(&radio->completion);
drivers/media/radio/si470x/radio-si470x.h:	struct completion completion;
drivers/media/radio/si470x/radio-si470x-usb.c:		complete(&radio->completion);
drivers/media/radio/si470x/radio-si470x-usb.c:	init_completion(&radio->completion);
drivers/media/radio/si470x/radio-si470x-common.c:	reinit_completion(&radio->completion);
drivers/media/radio/si470x/radio-si470x-common.c:	time_left = wait_for_completion_timeout(&radio->completion,
drivers/media/radio/si470x/radio-si470x-common.c:	reinit_completion(&radio->completion);
drivers/media/radio/si470x/radio-si470x-common.c:	time_left = wait_for_completion_timeout(&radio->completion,
drivers/media/radio/wl128x/fmdrv_tx.c:	init_completion(&fmdev->maintask_comp);
drivers/media/radio/wl128x/fmdrv_tx.c:	timeleft = wait_for_completion_timeout(&fmdev->maintask_comp,
drivers/media/radio/wl128x/fmdrv_rx.c:	init_completion(&fmdev->maintask_comp);
drivers/media/radio/wl128x/fmdrv_rx.c:	timeleft = wait_for_completion_timeout(&fmdev->maintask_comp,
drivers/media/radio/wl128x/fmdrv_rx.c:	init_completion(&fmdev->maintask_comp);
drivers/media/radio/wl128x/fmdrv_rx.c:	timeleft = wait_for_completion_timeout(&fmdev->maintask_comp,
drivers/media/radio/wl128x/fmdrv_common.c:static struct completion wait_for_fmdrv_reg_comp;
drivers/media/radio/wl128x/fmdrv_common.c:	       fm_cb(skb)->completion ? " " : "*", cmd_hdr->hdr,
drivers/media/radio/wl128x/fmdrv_common.c:		/* Anyone waiting for this with completion handler? */
drivers/media/radio/wl128x/fmdrv_common.c:		fmerr("Response completion handler is not NULL\n");
drivers/media/radio/wl128x/fmdrv_common.c:	fmdev->resp_comp = fm_cb(skb)->completion;
drivers/media/radio/wl128x/fmdrv_common.c:		int payload_len, struct completion *wait_completion)
drivers/media/radio/wl128x/fmdrv_common.c:	fm_cb(skb)->completion = wait_completion;
drivers/media/radio/wl128x/fmdrv_common.c:	init_completion(&fmdev->maintask_comp);
drivers/media/radio/wl128x/fmdrv_common.c:	if (!wait_for_completion_timeout(&fmdev->maintask_comp,
drivers/media/radio/wl128x/fmdrv_common.c:			   "completion signal from RX tasklet\n",
drivers/media/radio/wl128x/fmdrv_common.c: * Called by ST layer to indicate protocol registration completion
drivers/media/radio/wl128x/fmdrv_common.c:		init_completion(&wait_for_fmdrv_reg_comp);
drivers/media/radio/wl128x/fmdrv_common.c:		fmdbg("%s waiting for ST reg completion signal\n", __func__);
drivers/media/radio/wl128x/fmdrv_common.c:		if (!wait_for_completion_timeout(&wait_for_fmdrv_reg_comp,
drivers/media/radio/wl128x/fmdrv_common.c:					"completion signal from ST\n",
drivers/media/radio/wl128x/fmdrv.h:	/* Main task completion handler */
drivers/media/radio/wl128x/fmdrv.h:	struct completion maintask_comp;
drivers/media/radio/wl128x/fmdrv.h:	struct completion *resp_comp;
drivers/media/radio/wl128x/fmdrv_common.h:	struct completion *completion;
drivers/media/radio/si4713/si4713.c:#include <linux/completion.h>
drivers/media/radio/si4713/si4713.c:			"%s: sending signal to completion work.\n", __func__);
drivers/media/radio/si4713/si4713.c:		if (!wait_for_completion_timeout(&sdev->work,
drivers/media/radio/si4713/si4713.c:	    !wait_for_completion_timeout(&sdev->work, usecs_to_jiffies(usecs) + 1))
drivers/media/radio/si4713/si4713.c:	init_completion(&sdev->work);
drivers/media/radio/si4713/si4713.h:	struct completion work;
drivers/media/radio/radio-wl1273.c:	struct completion busy;
drivers/media/radio/radio-wl1273.c:	reinit_completion(&radio->busy);
drivers/media/radio/radio-wl1273.c:	t = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
drivers/media/radio/radio-wl1273.c:	reinit_completion(&radio->busy);
drivers/media/radio/radio-wl1273.c:	t = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
drivers/media/radio/radio-wl1273.c:	reinit_completion(&radio->busy);
drivers/media/radio/radio-wl1273.c:	t = wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(2000));
drivers/media/radio/radio-wl1273.c:	reinit_completion(&radio->busy);
drivers/media/radio/radio-wl1273.c:	wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000));
drivers/media/radio/radio-wl1273.c:	reinit_completion(&radio->busy);
drivers/media/radio/radio-wl1273.c:	if (!wait_for_completion_timeout(&radio->busy, msecs_to_jiffies(1000)))
drivers/media/radio/radio-wl1273.c:	init_completion(&radio->busy);
drivers/media/rc/imon.c:		struct completion finished;	/* wait for write to finish */
drivers/media/rc/imon.c:		int status;			/* status of tx completion */
drivers/media/rc/imon.c:	init_completion(&ictx->tx.finished);
drivers/media/rc/imon.c:		retval = wait_for_completion_interruptible(
drivers/media/rc/iguanair.c:#include <linux/completion.h>
drivers/media/rc/iguanair.c:	struct completion completion;
drivers/media/rc/iguanair.c:				complete(&ir->completion);
drivers/media/rc/iguanair.c:				complete(&ir->completion);
drivers/media/rc/iguanair.c:				complete(&ir->completion);
drivers/media/rc/iguanair.c:			complete(&ir->completion);
drivers/media/rc/iguanair.c:		complete(&ir->completion);
drivers/media/rc/iguanair.c:	reinit_completion(&ir->completion);
drivers/media/rc/iguanair.c:	if (wait_for_completion_timeout(&ir->completion, TIMEOUT) == 0)
drivers/media/rc/iguanair.c:	init_completion(&ir->completion);
drivers/media/rc/ene_ir.h:	struct completion tx_complete;		/* TX completion */
drivers/media/rc/ene_ir.c:	if (wait_for_completion_timeout(&dev->tx_complete, 2 * HZ) == 0) {
drivers/media/rc/ene_ir.c:		init_completion(&dev->tx_complete);
drivers/media/rc/lirc_dev.c:#include <linux/completion.h>
drivers/media/common/saa7146/saa7146_core.c:			DEB_S("%s: %s timed out while waiting for transfer completion\n",
drivers/media/common/saa7146/saa7146_core.c:			DEB_S("%s: %s timed out while waiting for transfer completion\n",
drivers/media/common/siano/smscoreapi.c:	/* init completion events */
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->version_ex_done);
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->data_download_done);
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->data_validity_done);
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->trigger_done);
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->init_device_done);
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->reload_start_done);
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->resume_done);
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->gpio_configuration_done);
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->gpio_set_level_done);
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->gpio_get_level_done);
drivers/media/common/siano/smscoreapi.c:	init_completion(&dev->ir_init_done);
drivers/media/common/siano/smscoreapi.c:		void *buffer, size_t size, struct completion *completion) {
drivers/media/common/siano/smscoreapi.c:	if (completion == NULL)
drivers/media/common/siano/smscoreapi.c:	init_completion(completion);
drivers/media/common/siano/smscoreapi.c:	return wait_for_completion_timeout(completion,
drivers/media/common/siano/smscoreapi.c:		if (wait_for_completion_timeout(&coredev->resume_done,
drivers/media/common/siano/smsdvb-main.c:					struct completion *completion)
drivers/media/common/siano/smsdvb-main.c:	return wait_for_completion_timeout(completion,
drivers/media/common/siano/smsdvb-main.c:	init_completion(&client->tune_done);
drivers/media/common/siano/smsdvb-main.c:	init_completion(&client->stats_done);
drivers/media/common/siano/smscoreapi.h:	struct completion version_ex_done, data_download_done, trigger_done;
drivers/media/common/siano/smscoreapi.h:	struct completion data_validity_done, device_ready_done;
drivers/media/common/siano/smscoreapi.h:	struct completion init_device_done, reload_start_done, resume_done;
drivers/media/common/siano/smscoreapi.h:	struct completion gpio_configuration_done, gpio_set_level_done;
drivers/media/common/siano/smscoreapi.h:	struct completion gpio_get_level_done, ir_init_done;
drivers/media/common/siano/smsdvb.h:	struct completion       tune_done;
drivers/media/common/siano/smsdvb.h:	struct completion       stats_done;
drivers/media/usb/au0828/au0828-dvb.c:static void urb_completion(struct urb *purb)
drivers/media/usb/au0828/au0828-dvb.c:				  urb_completion,
drivers/media/usb/dvb-usb/dib0700_core.c:static void dib0700_rc_urb_completion(struct urb *purb)
drivers/media/usb/dvb-usb/dib0700_core.c:					  dib0700_rc_urb_completion, d);
drivers/media/usb/dvb-usb/dib0700_core.c:					  dib0700_rc_urb_completion, d, 1);
drivers/media/usb/dvb-usb/dib0700_devices.c: * at dib0700_rc_urb_completion()
drivers/media/usb/dvb-usb/dib0700_devices.c:		   in the bulk URB completion handler. */
drivers/media/usb/s2255/s2255drv.c:static void read_pipe_completion(struct urb *purb)
drivers/media/usb/s2255/s2255drv.c:			  read_pipe_completion, pipe_info);
drivers/media/usb/s2255/s2255drv.c:			  read_pipe_completion, pipe_info);
drivers/media/usb/tm6000/tm6000-video.c:		tm6000_err("urb completion error %d.\n", urb->status);
drivers/media/usb/zr364xx/zr364xx.c:static void read_pipe_completion(struct urb *purb)
drivers/media/usb/zr364xx/zr364xx.c:			  read_pipe_completion, pipe_info);
drivers/media/usb/zr364xx/zr364xx.c:			  read_pipe_completion, pipe_info);
drivers/media/usb/uvc/uvc_video.c:			"completion handler.\n", urb->status);
drivers/media/usb/uvc/uvc_video.c: * completion handler won't try to cancel the queue when we kill the URBs.
drivers/media/usb/uvc/uvc_status.c:			"completion handler.\n", urb->status);
drivers/media/usb/uvc/uvcvideo.h:	/* Context data used by the bulk completion handler. */
drivers/media/usb/gspca/conex.c:	/* wait for completion */
drivers/media/usb/cx231xx/cx231xx-core.c:		cx231xx_isocdbg("urb completion error %d.\n", urb->status);
drivers/media/usb/cx231xx/cx231xx-core.c:		cx231xx_isocdbg("urb completion error - device is stalled.\n");
drivers/media/usb/cx231xx/cx231xx-core.c:		cx231xx_isocdbg("urb completion error %d.\n", urb->status);
drivers/media/usb/pvrusb2/pvrusb2-io.h:/* Retrieve completion code for given ready buffer */
drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h:	struct completion ctl_done;
drivers/media/usb/pvrusb2/pvrusb2-io.c:		   completion callback may happen on this buffer.  But it's
drivers/media/usb/pvrusb2/pvrusb2-hdw.c:	init_completion(&hdw->ctl_done);
drivers/media/usb/pvrusb2/pvrusb2-hdw.c:		wait_for_completion(&hdw->ctl_done);
drivers/media/usb/em28xx/em28xx-i2c.c:	/* wait for completion */
drivers/media/usb/em28xx/em28xx-i2c.c:	/* wait for completion */
drivers/media/usb/em28xx/em28xx-i2c.c:	/* wait for completion */
drivers/media/usb/em28xx/em28xx-core.c: * URB completion handler for isoc/bulk transfers
drivers/media/usb/cpia2/cpia2_usb.c:	/* Queue the ISO urbs, and resubmit in the completion handler */
drivers/usb/image/microtek.h:	u8 *scsi_status; /* status returned from ep_response after command completion */
drivers/usb/storage/transport.c: * This is the completion handler which will wake us up when an URB
drivers/usb/storage/transport.c:static void usb_stor_blocking_completion(struct urb *urb)
drivers/usb/storage/transport.c:	struct completion *urb_done_ptr = urb->context;
drivers/usb/storage/transport.c:	struct completion urb_done;
drivers/usb/storage/transport.c:	init_completion(&urb_done);
drivers/usb/storage/transport.c:	/* wait for the completion of the URB */
drivers/usb/storage/transport.c:	timeleft = wait_for_completion_interruptible_timeout(
drivers/usb/storage/transport.c:			 usb_stor_blocking_completion, NULL);
drivers/usb/storage/transport.c:			 usb_stor_blocking_completion, NULL);
drivers/usb/storage/transport.c:			maxp, usb_stor_blocking_completion, NULL,
drivers/usb/storage/transport.c:		      usb_stor_blocking_completion, NULL);
drivers/usb/storage/transport.c:	/* wait for the completion of the transfer */
drivers/usb/storage/usb.h:#include <linux/completion.h>
drivers/usb/storage/usb.h:	struct completion	cmnd_ready;	 /* to sleep thread on	    */
drivers/usb/storage/usb.h:	struct completion	notify;		 /* thread begin/end	    */
drivers/usb/storage/scsiglue.c:	wait_for_completion(&us->notify);
drivers/usb/storage/usb.c:		if (wait_for_completion_interruptible(&us->cmnd_ready))
drivers/usb/storage/usb.c:	init_completion(&us->cmnd_ready);
drivers/usb/storage/usb.c:	init_completion(&(us->notify));
drivers/usb/renesas_usbhs/mod_host.c:	struct completion	setup_ack_done;
drivers/usb/renesas_usbhs/mod_host.c:	init_completion(&hpriv->setup_ack_done);
drivers/usb/renesas_usbhs/mod_host.c:	wait_for_completion(&hpriv->setup_ack_done);
drivers/usb/wusbcore/wa-hc.h:#include <linux/completion.h>
drivers/usb/wusbcore/wa-xfer.c:static void wa_xfer_completion(struct wa_xfer *xfer)
drivers/usb/wusbcore/wa-xfer.c:				wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c:		wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c:			wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c: * segment done and try completion.
drivers/usb/wusbcore/wa-xfer.c:			wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c:				 * DTO completion routine, if needed.
drivers/usb/wusbcore/wa-xfer.c:				wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c: * wa_urb_enqueue_b() will execute the completion path
drivers/usb/wusbcore/wa-xfer.c: * and if so, we run the completion procedure. However, if we are not
drivers/usb/wusbcore/wa-xfer.c: * yet done, we do nothing and wait for the completion handlers from
drivers/usb/wusbcore/wa-xfer.c:	 * this is basically wa_xfer_completion() broken up wa_xfer_giveback()
drivers/usb/wusbcore/wa-xfer.c:		wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c:	/* return success since the completion routine will run. */
drivers/usb/wusbcore/wa-xfer.c:		wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c: * Dequeue a URB and make sure uwb_hcd_giveback_urb() [completion
drivers/usb/wusbcore/wa-xfer.c: * needs to be dequeued with completion calling; when stuck in delayed
drivers/usb/wusbcore/wa-xfer.c: * or before wa_xfer_setup() is called, we need to do completion.
drivers/usb/wusbcore/wa-xfer.c:		wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c: * Process a xfer result completion message
drivers/usb/wusbcore/wa-xfer.c:		wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c:			wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c:	/* nothing to do, as the aborter did the completion */
drivers/usb/wusbcore/wa-xfer.c:		wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c: * error, mark this segment done and try completion.
drivers/usb/wusbcore/wa-xfer.c:			wa_xfer_completion(xfer);
drivers/usb/wusbcore/wa-xfer.c:		 * successful completion of the previous buf_in_urb.
drivers/usb/wusbcore/wa-xfer.c:			wa_xfer_completion(xfer);
drivers/usb/c67x00/c67x00-ll-hpi.c:	res = wait_for_completion_timeout(&dev->hpi.lcp.msg_received, 5 * HZ);
drivers/usb/c67x00/c67x00-ll-hpi.c:	init_completion(&dev->hpi.lcp.msg_received);
drivers/usb/c67x00/c67x00-hcd.h:	struct completion endpoint_disable;
drivers/usb/c67x00/c67x00-sched.c:		/* it could happen that we reinitialize this completion, while
drivers/usb/c67x00/c67x00-sched.c:		 * somebody was waiting for that completion.  The timeout and
drivers/usb/c67x00/c67x00-sched.c:		reinit_completion(&c67x00->endpoint_disable);
drivers/usb/c67x00/c67x00-sched.c:		wait_for_completion_timeout(&c67x00->endpoint_disable, 1 * HZ);
drivers/usb/c67x00/c67x00.h:#include <linux/completion.h>
drivers/usb/c67x00/c67x00.h:	struct completion msg_received;
drivers/usb/c67x00/c67x00-hcd.c:	init_completion(&c67x00->endpoint_disable);
drivers/usb/serial/keyspan_usa26msg.h:	completion of transmit; 0x00 otherwise), followed by data:
drivers/usb/serial/io_ti.c:			 * Save the LSR event for bulk read completion routine
drivers/usb/serial/io_ti.c:	 * The bulkreadcompletion routine will check
drivers/usb/serial/mos7720.c:	struct completion       syncmsg_compl; /* usb sync call completed */
drivers/usb/serial/mos7720.c:	reinit_completion(&mos_parport->syncmsg_compl);
drivers/usb/serial/mos7720.c:	init_completion(&mos_parport->syncmsg_compl);
drivers/usb/serial/mos7720.c:			wait_for_completion_timeout(&mos_parport->syncmsg_compl,
drivers/usb/serial/keyspan_usa67msg.h:	completion of transmit; 0x00 otherwise), followed by data:
drivers/usb/serial/mos7840.c:		/* the completion handler for the control urb will resubmit */
drivers/usb/serial/keyspan_usa28msg.h:	completion of transmit; 0x00 otherwise), followed by data.
drivers/usb/serial/keyspan_usa49msg.h:	completion of transmit; 0x00 otherwise), followed by data:
drivers/usb/chipidea/ci.h: * @setaddr: if we should set the address on status completion
drivers/usb/host/ehci-hub.c:static void usb_ehset_completion(struct urb *urb)
drivers/usb/host/ehci-hub.c:	struct completion  *done = urb->context;
drivers/usb/host/ehci-hub.c:	struct completion	*done
drivers/usb/host/ehci-hub.c:	urb->complete = usb_ehset_completion;
drivers/usb/host/ehci-hub.c:	if (!wait_for_completion_timeout(&done, msecs_to_jiffies(2000))) {
drivers/usb/host/ehci-hub.c:	if (!retval && !wait_for_completion_timeout(&done,
drivers/usb/host/ehci-hcd.c: * it calls driver completion functions, after dropping ehci->lock.
drivers/usb/host/ehci-hcd.c:	 * it reports urb completions.  this flag guards against bogus
drivers/usb/host/ehci-hcd.c:	/* normal [4.15.1.2] or error [4.15.1.1] completion */
drivers/usb/host/ehci-hcd.c:		/* Handle completions when the controller stops */
drivers/usb/host/ehci-hcd.c:		/* qh_completions() code doesn't handle all the fault cases
drivers/usb/host/ehci-hcd.c: * completions normally happen asynchronously
drivers/usb/host/ehci-hcd.c:			qh_completions(ehci, qh);
drivers/usb/host/ehci-hcd.c:	 * accelerate iso completions ... so spin a while.
drivers/usb/host/uhci-hub.c:		 * we'll poll for completion. */
drivers/usb/host/oxu210hp-hcd.c: * Chases up to qh->hw_current.  Returns number of completions called,
drivers/usb/host/oxu210hp-hcd.c:static unsigned qh_completions(struct oxu_hcd *oxu, struct ehci_qh *qh)
drivers/usb/host/oxu210hp-hcd.c:	/* completions (or tasks on other cpus) must never clobber HALT
drivers/usb/host/oxu210hp-hcd.c:		/* ignore urbs submitted during completions we reported */
drivers/usb/host/oxu210hp-hcd.c:			 * patch the qh later and so that completions can't
drivers/usb/host/oxu210hp-hcd.c:	/* last urb's completion might still need calling */
drivers/usb/host/oxu210hp-hcd.c:	/* by default, enable interrupt on urb completion */
drivers/usb/host/oxu210hp-hcd.c:	/* qtd completions reported later by interrupt */
drivers/usb/host/oxu210hp-hcd.c:	qh_completions(oxu, qh);
drivers/usb/host/oxu210hp-hcd.c:				/* unlinks could happen here; completion
drivers/usb/host/oxu210hp-hcd.c:				temp = qh_completions(oxu, qh);
drivers/usb/host/oxu210hp-hcd.c:		/* scan each element in frame's queue for completions */
drivers/usb/host/oxu210hp-hcd.c:				/* handle any completions */
drivers/usb/host/oxu210hp-hcd.c:				modified = qh_completions(oxu, temp.qh);
drivers/usb/host/oxu210hp-hcd.c:			/* assume completion callbacks modify the queue */
drivers/usb/host/oxu210hp-hcd.c: * It calls driver completion functions, after dropping oxu->lock.
drivers/usb/host/oxu210hp-hcd.c:	 * it reports urb completions.  this flag guards against bogus
drivers/usb/host/oxu210hp-hcd.c:	/* normal [4.15.1.2] or error [4.15.1.1] completion */
drivers/usb/host/oxu210hp-hcd.c:			qh_completions(oxu, qh);
drivers/usb/host/oxu210hp-hcd.c:	 * accelerate iso completions ... so spin a while.
drivers/usb/host/isp1362-hcd.c: * completion.
drivers/usb/host/xhci-mem.c:	init_completion(&dev->cmd_completion);
drivers/usb/host/xhci-mem.c:		bool allocate_in_ctx, bool allocate_completion,
drivers/usb/host/xhci-mem.c:	if (allocate_completion) {
drivers/usb/host/xhci-mem.c:		command->completion =
drivers/usb/host/xhci-mem.c:			kzalloc(sizeof(struct completion), mem_flags);
drivers/usb/host/xhci-mem.c:		if (!command->completion) {
drivers/usb/host/xhci-mem.c:		init_completion(command->completion);
drivers/usb/host/xhci-mem.c:	kfree(command->completion);
drivers/usb/host/xhci-mem.c:	init_completion(&xhci->cmd_ring_stop_completion);
drivers/usb/host/xhci-mem.c:	init_completion(&xhci->addr_dev);
drivers/usb/host/xhci-mem.c:		/* Only the USB 2.0 completions will ever be used. */
drivers/usb/host/xhci-mem.c:		init_completion(&xhci->bus_state[1].rexit_done[i]);
drivers/usb/host/fhci-sched.c: * Process normal completions(error or success) and clean the schedule.
drivers/usb/host/xhci.h:/* stop ring operation after completion of the currently executing command */
drivers/usb/host/xhci.h:	/* If completion is null, no one is waiting on this command
drivers/usb/host/xhci.h:	struct completion		*completion;
drivers/usb/host/xhci.h:	struct completion		cmd_completion;
drivers/usb/host/xhci.h:/* Command completion event TRB */
drivers/usb/host/xhci.h:/* Interrupter Target - which MSI-X vector to target the completion event at */
drivers/usb/host/xhci.h:/* Interrupt on completion */
drivers/usb/host/xhci.h:/* Nec vendor-specific command completion event. */
drivers/usb/host/xhci.h:	struct completion	rexit_done[USB_MAXCHILDREN];
drivers/usb/host/xhci.h:	struct completion	cmd_ring_stop_completion;
drivers/usb/host/xhci.h:	struct completion	addr_dev;
drivers/usb/host/xhci.h:		bool allocate_in_ctx, bool allocate_completion,
drivers/usb/host/xhci.c:		kfree(command->completion);
drivers/usb/host/xhci.c:		xhci_err(xhci, "ERROR: unexpected command completion code 0x%x.\n",
drivers/usb/host/xhci.c:		xhci_err(xhci, "ERROR: unexpected command completion code 0x%x.\n",
drivers/usb/host/xhci.c:	wait_for_completion(command->completion);
drivers/usb/host/xhci.c:	kfree(command->completion);
drivers/usb/host/xhci.c:		 * reset endpoint completion!
drivers/usb/host/xhci.c:	/* Allocate the command structure that holds the struct completion.
drivers/usb/host/xhci.c:	wait_for_completion(reset_device_cmd->completion);
drivers/usb/host/xhci.c:	case COMP_EBADSLT: /* 0.95 completion code for bad slot ID */
drivers/usb/host/xhci.c:	case COMP_CTX_STATE: /* 0.96 completion code for same thing */
drivers/usb/host/xhci.c:		xhci_warn(xhci, "Unknown completion code %u for "
drivers/usb/host/xhci.c:	 * Event command completion handler will free any data structures
drivers/usb/host/xhci.c:	command->completion = &xhci->addr_dev;
drivers/usb/host/xhci.c:	wait_for_completion(command->completion);
drivers/usb/host/xhci.c:	command->completion = NULL;
drivers/usb/host/xhci.c:	command->completion = &xhci->addr_dev;
drivers/usb/host/xhci.c:	wait_for_completion(command->completion);
drivers/usb/host/xhci.c:			 "ERROR: unexpected setup %s command completion code 0x%x.\n",
drivers/usb/host/uhci-hcd.h: * advance on an error completion status, which makes them totally
drivers/usb/host/uhci-hcd.c:	 * Some architectures require a full mb() to enforce completion of
drivers/usb/host/ehci-q.c:	 * qtd is updated in qh_completions(). Update the QH
drivers/usb/host/ehci-q.c:qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
drivers/usb/host/ehci-q.c:	/* completions (or tasks on other cpus) must never clobber HALT
drivers/usb/host/ehci-q.c:		/* ignore urbs submitted during completions we reported */
drivers/usb/host/ehci-q.c:		/* remove qtd; it's recycled after possible urb completion */
drivers/usb/host/ehci-q.c:	/* last urb's completion might still need calling */
drivers/usb/host/ehci-q.c:	/* by default, enable interrupt on urb completion */
drivers/usb/host/ehci-q.c:	/* qtd completions reported later by interrupt */
drivers/usb/host/ehci-q.c:	/* by default, enable interrupt on urb completion */
drivers/usb/host/ehci-q.c:			qh_completions(ehci, qh);
drivers/usb/host/ehci-q.c:			 * Unlinks could happen here; completion reporting
drivers/usb/host/ehci-q.c:			temp = qh_completions(ehci, qh);
drivers/usb/host/whci/whci-hc.h:	struct completion remove_complete;
drivers/usb/host/whci/qset.c:	init_completion(&qset->remove_complete);
drivers/usb/host/whci/qset.c:	wait_for_completion(&qset->remove_complete);
drivers/usb/host/ehci-sched.c:		qh_completions(ehci, qh);
drivers/usb/host/ehci-sched.c:			 * Unlinks could happen here; completion reporting
drivers/usb/host/ehci-sched.c:			temp = qh_completions(ehci, qh);
drivers/usb/host/ehci-sched.c:	if (unlikely(empty && !hcd_periodic_completion_in_progress(
drivers/usb/host/ehci-sched.c: * and hence its completion callback probably added things to the hardware
drivers/usb/host/ehci-sched.c: * completion callback runs, so that it won't be reused quickly.  That is,
drivers/usb/host/ehci-sched.c: * (b) only this endpoint's completions submit URBs.  It seems some silicon
drivers/usb/host/ehci-sched.c:	/* handle completion now? */
drivers/usb/host/ehci-sched.c:	/* give urb back to the driver; completion often (re)submits */
drivers/usb/host/ehci-sched.c: * and hence its completion callback probably added things to the hardware
drivers/usb/host/ehci-sched.c: * completion callback runs, so that it won't be reused quickly.  That is,
drivers/usb/host/ehci-sched.c: * (b) only this endpoint's completions submit URBs.  It seems some silicon
drivers/usb/host/ehci-sched.c:	/* handle completion now? */
drivers/usb/host/ehci-sched.c:	/* give urb back to the driver; completion often (re)submits */
drivers/usb/host/ehci-sched.c:	/* Scan each element in frame's queue for completions */
drivers/usb/host/ehci-sched.c:			 * URB completion.  HC won't cache the
drivers/usb/host/ehci-sched.c:			 * URB completion.
drivers/usb/host/ehci-sched.c:		/* Assume completion callbacks modify the queue */
drivers/usb/host/ehci.h:#define	SITD_IOC	(1 << 31)	/* interrupt on completion */
drivers/usb/host/ehci.h: * makes the HC jump (back) to a QH to scan for fs/ls QH completions until
drivers/usb/host/xhci-trace.h:DEFINE_EVENT(xhci_log_event, xhci_cmd_completion,
drivers/usb/host/max3421-hcd.c:			/* BUSEVENT due to completion of Bus Reset */
drivers/usb/host/max3421-hcd.c:			/* BUSEVENT due to completion of Bus Resume */
drivers/usb/host/uhci-q.c:	/* Set the interrupt-on-completion flag on the last packet.
drivers/usb/host/uhci-q.c:	/* Set the interrupt-on-completion flag on the last packet. */
drivers/usb/host/uhci-q.c:		 * completion before reactivating the QH. */
drivers/usb/host/uhci-q.c:		 * completion.  That way we'll know as soon as the queue
drivers/usb/host/xhci-hub.c:	wait_for_completion(cmd->completion);
drivers/usb/host/xhci-hub.c:			time_left = wait_for_completion_timeout(
drivers/usb/host/xhci-ring.c:		 * caller waiting for completion is called when command
drivers/usb/host/xhci-ring.c:		 *  completion event is received for these no-op commands
drivers/usb/host/xhci-ring.c:	reinit_completion(&xhci->cmd_ring_stop_completion);
drivers/usb/host/xhci-ring.c:	 * time the completion od all xHCI commands, including
drivers/usb/host/xhci-ring.c:	 * Writing the CMD_RING_ABORT bit should cause a cmd completion event,
drivers/usb/host/xhci-ring.c:	 * but the completion event in never sent. Wait 2 secs (arbitrary
drivers/usb/host/xhci-ring.c:	ret = wait_for_completion_timeout(&xhci->cmd_ring_stop_completion,
drivers/usb/host/xhci-ring.c: * When we get a command completion for a Stop Endpoint Command, we need to
drivers/usb/host/xhci-ring.c:				"completion for disabled slot %u\n",
drivers/usb/host/xhci-ring.c:			 * ignore the completion event for that TD, since it was
drivers/usb/host/xhci-ring.c:		 * The event handler won't see a completion for this TD anymore,
drivers/usb/host/xhci-ring.c:		 * the cancelled TD list for URB completion later.
drivers/usb/host/xhci-ring.c: * command, and the stop endpoint command completion handler cannot delete the
drivers/usb/host/xhci-ring.c:static void update_ring_for_set_deq_completion(struct xhci_hcd *xhci,
drivers/usb/host/xhci-ring.c: * When we get a completion for a Set Transfer Ring Dequeue Pointer command,
drivers/usb/host/xhci-ring.c:			xhci_warn(xhci, "WARN Set TR Deq Ptr cmd with unknown completion code of %u.\n",
drivers/usb/host/xhci-ring.c:			update_ring_for_set_deq_completion(xhci, dev,
drivers/usb/host/xhci-ring.c:		"Ignoring reset ep completion code of %u", cmd_comp_code);
drivers/usb/host/xhci-ring.c:		xhci_warn(xhci, "Reset device command completion "
drivers/usb/host/xhci-ring.c:	if (cmd->completion) {
drivers/usb/host/xhci-ring.c:		complete(cmd->completion);
drivers/usb/host/xhci-ring.c:	 * raced with command completion. Command is handled so just return.
drivers/usb/host/xhci-ring.c:static void handle_cmd_completion(struct xhci_hcd *xhci,
drivers/usb/host/xhci-ring.c:	trace_xhci_cmd_completion(cmd_trb, (struct xhci_generic_trb *) event);
drivers/usb/host/xhci-ring.c:		complete_all(&xhci->cmd_ring_stop_completion);
drivers/usb/host/xhci-ring.c:			 "Command completion event does not match command\n");
drivers/usb/host/xhci-ring.c:		if (!cmd->completion)
drivers/usb/host/xhci-ring.c:		/* SLOT_ID field in reset device cmd completion event TRB is 0.
drivers/usb/host/xhci-ring.c:		handle_cmd_completion(xhci, &event->event_cmd);
drivers/usb/host/xhci-ring.c:	/* Port status change events always have a successful completion code */
drivers/usb/host/xhci-ring.c:	/* TRB completion codes that may require a manual halt cleanup */
drivers/usb/host/xhci-ring.c:		/* Vendor defined "informational" completion code,
drivers/usb/host/xhci-ring.c:		xhci_dbg(xhci, "Vendor defined info completion code %u\n",
drivers/usb/host/xhci-ring.c:		/* The Endpoint Stop Command completion will take care of any
drivers/usb/host/xhci-ring.c:	/* handle completion code */
drivers/usb/host/xhci-ring.c:			xhci_warn(xhci, "WARN Successful completion "
drivers/usb/host/xhci-ring.c:	/* Stopped - short packet completion */
drivers/usb/host/xhci-ring.c:			/* Ignore a short packet completion if the
drivers/usb/host/xhci-ring.c:					"WARN Successful completion on short TX: needs XHCI_TRUST_TX_LENGTH quirk?\n");
drivers/usb/host/xhci-ring.c:			 * A stopped endpoint may generate an extra completion
drivers/usb/host/xhci-ring.c:		 * last TRB of the previous TD. The command completion handle
drivers/usb/host/xhci-ring.c:		handle_cmd_completion(xhci, &event->event_cmd);
drivers/usb/host/xhci-ring.c:			/* Event on completion */
drivers/usb/host/fotg210-hcd.c:		 * qtd is updated in qh_completions(). Update the QH
drivers/usb/host/fotg210-hcd.c: * Chases up to qh->hw_current.  Returns number of completions called,
drivers/usb/host/fotg210-hcd.c:static unsigned qh_completions(struct fotg210_hcd *fotg210,
drivers/usb/host/fotg210-hcd.c:	/* completions (or tasks on other cpus) must never clobber HALT
drivers/usb/host/fotg210-hcd.c:		/* ignore urbs submitted during completions we reported */
drivers/usb/host/fotg210-hcd.c:		/* remove qtd; it's recycled after possible urb completion */
drivers/usb/host/fotg210-hcd.c:	/* last urb's completion might still need calling */
drivers/usb/host/fotg210-hcd.c:	/* by default, enable interrupt on urb completion */
drivers/usb/host/fotg210-hcd.c:	/* qtd completions reported later by interrupt */
drivers/usb/host/fotg210-hcd.c:		qh_completions(fotg210, qh);
drivers/usb/host/fotg210-hcd.c:	 * qh_completions() has to deal with it.
drivers/usb/host/fotg210-hcd.c:			 * Unlinks could happen here; completion reporting
drivers/usb/host/fotg210-hcd.c:			temp = qh_completions(fotg210, qh);
drivers/usb/host/fotg210-hcd.c:	 * qh_completions() has to deal with it.
drivers/usb/host/fotg210-hcd.c:	qh_completions(fotg210, qh);
drivers/usb/host/fotg210-hcd.c:			 * Unlinks could happen here; completion reporting
drivers/usb/host/fotg210-hcd.c:			temp = qh_completions(fotg210, qh);
drivers/usb/host/fotg210-hcd.c: * and hence its completion callback probably added things to the hardware
drivers/usb/host/fotg210-hcd.c: * completion callback runs, so that it won't be reused quickly.  That is,
drivers/usb/host/fotg210-hcd.c: * (b) only this endpoint's completions submit URBs.  It seems some silicon
drivers/usb/host/fotg210-hcd.c:	/* handle completion now? */
drivers/usb/host/fotg210-hcd.c:	/* give urb back to the driver; completion often (re)submits */
drivers/usb/host/fotg210-hcd.c:	/* scan each element in frame's queue for completions */
drivers/usb/host/fotg210-hcd.c:			 * URB completion.  HC won't cache the
drivers/usb/host/fotg210-hcd.c:		/* assume completion callbacks modify the queue */
drivers/usb/host/fotg210-hcd.c: * it calls driver completion functions, after dropping fotg210->lock.
drivers/usb/host/fotg210-hcd.c:	 * it reports urb completions.  this flag guards against bogus
drivers/usb/host/fotg210-hcd.c:	/* normal [4.15.1.2] or error [4.15.1.1] completion */
drivers/usb/host/fotg210-hcd.c:		/* Handle completions when the controller stops */
drivers/usb/host/fotg210-hcd.c:		/* qh_completions() code doesn't handle all the fault cases
drivers/usb/host/fotg210-hcd.c: * completions normally happen asynchronously
drivers/usb/host/fotg210-hcd.c:			qh_completions(fotg210, qh);
drivers/usb/host/fotg210-hcd.c:			qh_completions(fotg210, qh);
drivers/usb/host/fotg210-hcd.c:		/* wait till next completion, do it then. */
drivers/usb/host/fotg210-hcd.c:		/* completion irqs can wait up to 1024 msec, */
drivers/usb/host/fotg210-hcd.c:	 * accelerate iso completions ... so spin a while.
drivers/usb/host/fotg210.h:#define STS_ERR		(1<<1)		/* "error" completion (overflow, ...) */
drivers/usb/host/fotg210.h:#define STS_INT		(1<<0)		/* "normal" completion (short, ...) */
drivers/usb/host/fotg210.h:	u8			c_usecs;	/* ... split completion bw */
drivers/usb/host/fotg210.h: * makes the HC jump (back) to a QH to scan for fs/ls QH completions until
drivers/usb/host/fhci-tds.c:#define TD_I		0x1000 /* interrupt on completion */
drivers/usb/host/oxu210hp.h:#define STS_ERR		(1<<1)		/* "error" completion (overflow, ...) */
drivers/usb/host/oxu210hp.h:#define STS_INT		(1<<0)		/* "normal" completion (short, ...) */
drivers/usb/host/oxu210hp.h:	u8			c_usecs;	/* ... split completion bw */
drivers/usb/host/sl811-hcd.c: * and may start I/O.  Endpoint queues are scanned during completion irq
drivers/usb/host/hwa-hc.c:#include <linux/completion.h>
drivers/usb/host/ohci-q.c:		 * we call a completion since it might have unlinked
drivers/usb/host/ohci-q.c: * Process normal completions (error or success) and clean the schedules.
drivers/usb/misc/uss720.c:#include <linux/completion.h>
drivers/usb/misc/uss720.c:	struct completion compl;
drivers/usb/misc/uss720.c:	init_completion(&rq->compl);
drivers/usb/misc/uss720.c:	if (wait_for_completion_timeout(&rq->compl, HZ)) {
drivers/usb/misc/idmouse.c:#include <linux/completion.h>
drivers/usb/misc/isight_firmware.c:		printk(KERN_ERR "isight firmware loading completion failed\n");
drivers/usb/misc/legousbtower.c: *   - wait for completion of write urb in release (needed for remotecontrol)
drivers/usb/misc/legousbtower.c:#include <linux/completion.h>
drivers/usb/misc/ftdi-elan.c:	struct completion wait_completion;
drivers/usb/misc/ftdi-elan.c:static void ftdi_elan_abandon_completions(struct usb_ftdi *ftdi)
drivers/usb/misc/ftdi-elan.c:		complete(&respond->wait_completion);
drivers/usb/misc/ftdi-elan.c:			ftdi_elan_abandon_completions(ftdi);
drivers/usb/misc/ftdi-elan.c:			complete(&respond->wait_completion);
drivers/usb/misc/ftdi-elan.c:			init_completion(&respond->wait_completion);
drivers/usb/misc/ftdi-elan.c:			wait_for_completion(&respond->wait_completion);
drivers/usb/misc/ftdi-elan.c:			init_completion(&respond->wait_completion);
drivers/usb/misc/ftdi-elan.c:			wait_for_completion(&respond->wait_completion);
drivers/usb/misc/ftdi-elan.c:			init_completion(&respond->wait_completion);
drivers/usb/misc/ftdi-elan.c:			wait_for_completion(&respond->wait_completion);
drivers/usb/misc/ftdi-elan.c:		ftdi_elan_abandon_completions(ftdi);
drivers/usb/misc/sisusbvga/sisusb.c:/* completion callback */
drivers/usb/misc/sisusbvga/sisusb.c:	/* If OK, and if timeout > 0, wait for completion */
drivers/usb/misc/sisusbvga/sisusb.c:/* completion callback */
drivers/usb/misc/sisusbvga/sisusb.c: * completion of the previous URB.
drivers/usb/misc/ucsi.c:	struct completion complete;
drivers/usb/misc/ucsi.c:	ret = wait_for_completion_timeout(&ucsi->complete,
drivers/usb/misc/ucsi.c:	ret = wait_for_completion_timeout(&ucsi->complete,
drivers/usb/misc/ucsi.c:		ret = wait_for_completion_timeout(&ucsi->complete,
drivers/usb/misc/ucsi.c:	init_completion(&ucsi->complete);
drivers/usb/misc/usbtest.c:	struct completion	completion;
drivers/usb/misc/usbtest.c:	urb->context = &completion;
drivers/usb/misc/usbtest.c:		init_completion(&completion);
drivers/usb/misc/usbtest.c:		if (!wait_for_completion_timeout(&completion, expire)) {
drivers/usb/misc/usbtest.c:	struct completion	complete;
drivers/usb/misc/usbtest.c:	/* signal completion when nothing's queued */
drivers/usb/misc/usbtest.c:	init_completion(&context.complete);
drivers/usb/misc/usbtest.c:		wait_for_completion(&context.complete);
drivers/usb/misc/usbtest.c:	struct completion	completion;
drivers/usb/misc/usbtest.c:	init_completion(&completion);
drivers/usb/misc/usbtest.c:	urb->context = &completion;
drivers/usb/misc/usbtest.c:		while (!completion_done(&completion)) {
drivers/usb/misc/usbtest.c:	wait_for_completion(&completion);
drivers/usb/misc/usbtest.c:	struct completion	complete;
drivers/usb/misc/usbtest.c:	init_completion(&ctx.complete);
drivers/usb/misc/usbtest.c:	wait_for_completion(&ctx.complete);
drivers/usb/misc/usbtest.c:	struct completion	done;
drivers/usb/misc/usbtest.c:	init_completion(&context.done);
drivers/usb/misc/usbtest.c:	wait_for_completion(&context.done);
drivers/usb/misc/usbtest.c: * threads and request completion.  But the only way to know that for sure
drivers/usb/atm/usbatm.h:#include <linux/completion.h>
drivers/usb/atm/usbatm.h:	struct completion thread_started;
drivers/usb/atm/usbatm.h:	struct completion thread_exited;
drivers/usb/atm/usbatm.c:	wait_for_completion(&instance->thread_started);
drivers/usb/atm/usbatm.c:	init_completion(&instance->thread_started);
drivers/usb/atm/usbatm.c:	init_completion(&instance->thread_exited);
drivers/usb/atm/usbatm.c:	wait_for_completion(&instance->thread_exited);
drivers/usb/atm/cxacru.c:	struct completion rcv_done;
drivers/usb/atm/cxacru.c:	struct completion snd_done;
drivers/usb/atm/cxacru.c:static void cxacru_blocking_completion(struct urb *urb)
drivers/usb/atm/cxacru.c:static int cxacru_start_wait_urb(struct urb *urb, struct completion *done,
drivers/usb/atm/cxacru.c:	wait_for_completion(done);
drivers/usb/atm/cxacru.c:	return urb->status; /* must read status after completion */
drivers/usb/atm/cxacru.c:	init_completion(&instance->rcv_done);
drivers/usb/atm/cxacru.c:	init_completion(&instance->snd_done);
drivers/usb/atm/cxacru.c:			cxacru_blocking_completion, &instance->rcv_done, 1);
drivers/usb/atm/cxacru.c:			cxacru_blocking_completion, &instance->snd_done, 4);
drivers/usb/atm/cxacru.c:			cxacru_blocking_completion, &instance->rcv_done);
drivers/usb/atm/cxacru.c:			cxacru_blocking_completion, &instance->snd_done);
drivers/usb/gadget/function/f_fs.c:	complete_all(&ffs->ep0req_completion);
drivers/usb/gadget/function/f_fs.c:	reinit_completion(&ffs->ep0req_completion);
drivers/usb/gadget/function/f_fs.c:	ret = wait_for_completion_interruptible(&ffs->ep0req_completion);
drivers/usb/gadget/function/f_fs.c:		if (unlikely(wait_for_completion_interruptible(&done))) {
drivers/usb/gadget/function/f_fs.c:		       waitqueue_active(&ffs->ep0req_completion.wait));
drivers/usb/gadget/function/f_fs.c:	init_completion(&ffs->ep0req_completion);
drivers/usb/gadget/function/f_mass_storage.c: * completion notifications, endpoint-0 events, and disconnect events.
drivers/usb/gadget/function/f_mass_storage.c: * finally marked EMPTY again (possibly by a completion routine).
drivers/usb/gadget/function/f_mass_storage.c: * driver should not notify the host about completion of the original
drivers/usb/gadget/function/f_mass_storage.c:#include <linux/completion.h>
drivers/usb/gadget/function/f_mass_storage.c:	struct completion	thread_notifier;
drivers/usb/gadget/function/f_mass_storage.c:	init_completion(&common->thread_notifier);
drivers/usb/gadget/function/f_mass_storage.c:		wait_for_completion(&common->thread_notifier);
drivers/usb/gadget/function/f_mass_storage.c:		wait_for_completion(&fsg->common->thread_notifier);
drivers/usb/gadget/function/f_printer.c:	/* normal completion */
drivers/usb/gadget/function/uvc_video.c: * - USB request completion: the completion handler will resubmit the request
drivers/usb/gadget/function/uvc_video.c: * The USB request completion handler will get the buffer at the irqqueue head
drivers/usb/gadget/function/uvc_video.c:	/* FIXME TODO Race between uvcg_video_pump and requests completion
drivers/usb/gadget/function/u_serial.c:		/* Drop lock while we call out of driver; completions
drivers/usb/gadget/function/u_serial.c:			/* normal completion */
drivers/usb/gadget/function/u_serial.c:		/* normal completion */
drivers/usb/gadget/function/u_serial.c:		/* normal completion */
drivers/usb/gadget/function/u_ether.c:	/* normal completion */
drivers/usb/gadget/function/u_ether.c:	/* disable endpoints, forcing (synchronous) completion
drivers/usb/gadget/function/f_sourcesink.c:	case 0:				/* normal completion? */
drivers/usb/gadget/function/uvc.h:	/* Context data used by the completion handler */
drivers/usb/gadget/function/f_loopback.c:	case 0:				/* normal completion? */
drivers/usb/gadget/function/f_uac2.c:	/* pre-calculated values for playback iso completion */
drivers/usb/gadget/function/f_uac1.c:	case 0:				/* normal completion? */
drivers/usb/gadget/function/f_midi.c:	case 0:			 /* normal completion */
drivers/usb/gadget/function/f_midi.c:	 * just disable endpoints, forcing completion of pending i/o.
drivers/usb/gadget/function/f_midi.c:	 * all our completion handlers free their requests in this case.
drivers/usb/gadget/function/f_tcm.c:	init_completion(&cmd->write_complete);
drivers/usb/gadget/function/f_tcm.c:	wait_for_completion(&cmd->write_complete);
drivers/usb/gadget/function/f_tcm.c:	init_completion(&cmd->write_complete);
drivers/usb/gadget/function/f_tcm.c:	wait_for_completion(&cmd->write_complete);
drivers/usb/gadget/function/u_fs.h:	struct completion		ep0req_completion;	/* P: mutex */
drivers/usb/gadget/function/f_acm.c:		dev_dbg(&cdev->gadget->dev, "acm ttyGS%d completion, err %d\n",
drivers/usb/gadget/function/f_acm.c:	/* normal completion */
drivers/usb/gadget/function/f_ncm.c:	 * completion callback can be called right after the call,
drivers/usb/gadget/function/tcm.h:	struct completion write_complete;
drivers/usb/gadget/composite.c:	 * gadget might need to intercept e.g. a control-OUT completion
drivers/usb/gadget/legacy/inode.c:	complete ((struct completion *)req->context);
drivers/usb/gadget/udc/m66592-udc.c:			/* Wait for the completion of status stage */
drivers/usb/gadget/udc/m66592-udc.c:static void nop_completion(struct usb_ep *ep, struct usb_request *r)
drivers/usb/gadget/udc/m66592-udc.c:	m66592->ep0_req->complete = nop_completion;
drivers/usb/gadget/udc/dummy_hcd.c:		 * (so completion handlers can clean up the queue) but we don't
drivers/usb/gadget/udc/dummy_hcd.c:		/* device side completion --> continuable */
drivers/usb/gadget/udc/dummy_hcd.c:		/* host side completion --> terminate */
drivers/usb/gadget/udc/omap_udc.h:	struct completion		*done;
drivers/usb/gadget/udc/mv_u3d_core.c:		/* remove req out of ep request list after completion */
drivers/usb/gadget/udc/mv_u3d_core.c:			/* ep0 request completion */
drivers/usb/gadget/udc/goku_udc.c:	/* don't modify queue heads during completion callback */
drivers/usb/gadget/udc/goku_udc.c:		/* completion */
drivers/usb/gadget/udc/goku_udc.c:	/* normal hw dma completion (not abort) */
drivers/usb/gadget/udc/goku_udc.c:		/* dma:  done after dma completion IRQ (or error)
drivers/usb/gadget/udc/goku_udc.c:	/* dma completion */
drivers/usb/gadget/udc/omap_udc.c:	/* don't modify queue heads during completion callback */
drivers/usb/gadget/udc/omap_udc.c: * When DMA completion isn't request completion, the UDC continues with
drivers/usb/gadget/udc/omap_udc.c:	/* tx completion */
drivers/usb/gadget/udc/omap_udc.c:	/* rx completion */
drivers/usb/gadget/udc/omap_udc.c:	 * requests is during their request completion callback.
drivers/usb/gadget/udc/omap_udc.c:	/* DMA transfer completion */
drivers/usb/gadget/udc/omap_udc.c:	wait_for_completion(&done);
drivers/usb/gadget/udc/gr_udc.c: * Frees allocated resources and calls the appropriate completion function/setup
drivers/usb/gadget/udc/mv_udc_core.c:			/* ep0 request completion */
drivers/usb/gadget/udc/mv_udc_core.c:	wait_for_completion(udc->done);
drivers/usb/gadget/udc/pxa25x_udc.c:	/* don't modify queue heads during completion callback */
drivers/usb/gadget/udc/pxa25x_udc.c:		/* completion */
drivers/usb/gadget/udc/pxa25x_udc.c:	/* completion */
drivers/usb/gadget/udc/mv_u3d.h:	struct completion		*done;
drivers/usb/gadget/udc/net2272.c:	/* don't modify queue heads during completion callback */
drivers/usb/gadget/udc/net2272.c:		/* completion */
drivers/usb/gadget/udc/net2272.c:/* handle ep-a/ep-b dma completions */
drivers/usb/gadget/udc/fsl_qe_udc.h:	struct completion *done;	/* to make sure release() is done */
drivers/usb/gadget/udc/fsl_qe_udc.h:#define T_I           0x10000000         /* interrupt on completion */
drivers/usb/gadget/udc/udc-xilinx.c:/* Buffers  completion Mask */
drivers/usb/gadget/udc/udc-xilinx.c:/* Mask for buffer 0 and buffer 1 completion for all Endpoints */
drivers/usb/gadget/udc/udc-xilinx.c: * DMA transfer completion.
drivers/usb/gadget/udc/udc-xilinx.c: * xudc_done - Exeutes the endpoint data transfer completion tasks.
drivers/usb/gadget/udc/udc-xilinx.c: * Deletes the message from the queue and updates data transfer completion
drivers/usb/gadget/udc/udc-xilinx.c:		/* completion */
drivers/usb/gadget/udc/udc-xilinx.c:	/* Enable buffer completion interrupts for endpoint */
drivers/usb/gadget/udc/udc-xilinx.c: * Processes the buffer completion interrupts.
drivers/usb/gadget/udc/udc-xilinx.c:	/* Check the buffer completion interrupts */
drivers/usb/gadget/udc/mv_udc.h:	struct completion		*done;
drivers/usb/gadget/udc/core.c: * completion callback.  Free requests with usb_ep_free_request(), when
drivers/usb/gadget/udc/core.c: * including being canceled by usb_ep_dequeue(), the request's completion
drivers/usb/gadget/udc/core.c: * is given back to that driver through the completion callback.
drivers/usb/gadget/udc/core.c: * data stage is over, that is, from within the response's completion
drivers/usb/gadget/udc/core.c: * completion routine is called (with status -ECONNRESET); else a negative
drivers/usb/gadget/udc/core.c: * completion).  The gadget driver may not have collected all the data
drivers/usb/gadget/udc/fotg210-udc.c:	/* don't modify queue heads during completion callback */
drivers/usb/gadget/udc/net2280.h: *  - This state indicates workaround completion. Workarounds no longer
drivers/usb/gadget/udc/amd5536udc.c:				 * called by gadget drivers completion
drivers/usb/gadget/udc/amd5536udc.c:	/* DMA completion */
drivers/usb/gadget/udc/amd5536udc.c:		VDBG(dev, "TDC set- completion\n");
drivers/usb/gadget/udc/amd5536udc.c:	/* DMA completion */
drivers/usb/gadget/udc/amd5536udc.c:		wait_for_completion(&on_exit);
drivers/usb/gadget/udc/amd5536udc.c:		wait_for_completion(&on_pollstall_exit);
drivers/usb/gadget/udc/atmel_usba_udc.c:	 * completion function returns.
drivers/usb/gadget/udc/bdc/bdc_cmd.c:/* Issues a cmd to cmd processor and waits for cmd completion */
drivers/usb/gadget/udc/bdc/bdc_cmd.c:		dev_dbg(bdc->dev, "Unknown command completion code:%x\n", ret);
drivers/usb/gadget/udc/bdc/bdc.h:/* CMD completion status */
drivers/usb/gadget/udc/bdc/bdc_ep.c:/* xfr completion status report handler */
drivers/usb/gadget/udc/s3c-hsudc.c: * @status: Transfer completion status for the transfer request.
drivers/usb/gadget/udc/s3c-hsudc.c: * @status: Transfer completion status for the transfer request.
drivers/usb/gadget/udc/fsl_qe_udc.c:	/* don't modify queue heads during completion callback */
drivers/usb/gadget/udc/fsl_qe_udc.c:	wait_for_completion(&done);
drivers/usb/gadget/udc/net2280.c:		tmp = BIT((8 + ep->num));	/* completion */
drivers/usb/gadget/udc/net2280.c:		/* for short OUT transfers, dma completions can't
drivers/usb/gadget/udc/net2280.c:		tmp &= ~BIT((8 + ep->num));	/* completion */
drivers/usb/gadget/udc/net2280.c:			tmp &= ~BIT((8 + ep->num));	/* completion */
drivers/usb/gadget/udc/net2280.c:	/* don't modify queue heads during completion callback */
drivers/usb/gadget/udc/net2280.c:static int scan_dma_completions(struct net2280_ep *ep)
drivers/usb/gadget/udc/net2280.c:		 * all non-abort DMA completions.
drivers/usb/gadget/udc/net2280.c:	scan_dma_completions(ep);
drivers/usb/gadget/udc/net2280.c:		scan_dma_completions(ep);
drivers/usb/gadget/udc/net2280.c:				num_completed = scan_dma_completions(ep);
drivers/usb/gadget/udc/net2280.c:		/* stream endpoints often resubmit/unlink in completion */
drivers/usb/gadget/udc/net2280.c:		scan_dma_completions(ep);
drivers/usb/gadget/udc/fsl_usb2_udc.h:	struct completion *done;	/* to make sure release() is done */
drivers/usb/gadget/udc/lpc32xx_udc.c:#define DD_STATUS_STS_NC	0x04 /* Normal completion */
drivers/usb/gadget/udc/lpc32xx_udc.c: * Handle EP completion for ZLP
drivers/usb/gadget/udc/lpc32xx_udc.c:/* DMA end of transfer completion */
drivers/usb/gadget/udc/lpc32xx_udc.c:		ep_err(ep, "DMA critical EP error: EOT prior to service completion (0x%x)!\n",
drivers/usb/gadget/udc/lpc32xx_udc.c:	/* Re-enable after completion */
drivers/usb/gadget/udc/bcm63xx_udc.c: * iudma_read - Check for IUDMA buffer completion.
drivers/usb/gadget/udc/bcm63xx_udc.c: * bcm63xx_ep0_complete - Set completion status and "stage" the callback.
drivers/usb/gadget/udc/bcm63xx_udc.c:		 * completion to the gadget driver, then REQUEUE->IDLE.
drivers/usb/gadget/udc/bcm63xx_udc.c:		 * calling the completion, because it originated from this
drivers/usb/gadget/udc/bcm63xx_udc.c: * or invoke the completion callback (complete transactions).
drivers/usb/gadget/udc/pch_udc.c: * @status:	Indicates the success/failure of completion
drivers/usb/gadget/udc/fusb300_udc.c:	/* don't modify queue heads during completion callback */
drivers/usb/gadget/udc/pxa27x_udc.c:		/* completion */
drivers/usb/gadget/udc/pxa27x_udc.c:		 * All the following endpoints are only for completion.  They
drivers/usb/gadget/udc/fsl_udc_core.c:/* Process a DTD completion interrupt */
drivers/usb/gadget/udc/fsl_udc_core.c:		/* completion of dtd */
drivers/usb/gadget/udc/fsl_udc_core.c:	wait_for_completion(&done);
drivers/usb/gadget/udc/renesas_usb3.c:static void usb3_pipe0_get_status_completion(struct usb_ep *ep,
drivers/usb/gadget/udc/renesas_usb3.c:					 usb3_pipe0_get_status_completion);
drivers/usb/gadget/udc/renesas_usb3.c:static void usb3_pipe0_set_sel_completion(struct usb_ep *ep,
drivers/usb/gadget/udc/renesas_usb3.c:	usb3_pipe0_internal_xfer(usb3, NULL, 6, usb3_pipe0_set_sel_completion);
drivers/usb/gadget/udc/r8a66597-udc.c:			/* Wait for the completion of status stage */
drivers/usb/gadget/udc/r8a66597-udc.c:static void nop_completion(struct usb_ep *ep, struct usb_request *r)
drivers/usb/gadget/udc/r8a66597-udc.c:	r8a66597->ep0_req->complete = nop_completion;
drivers/usb/class/cdc-wdm.c:		 * against the completion handler
drivers/usb/core/devio.c:			spin_unlock(&ps->lock);		/* Allow completions */
drivers/usb/core/devio.c:		/* drop the spinlock so the completion handler can run */
drivers/usb/core/urb.c: * describing that request to the USB subsystem.  Request completion will
drivers/usb/core/urb.c: * be indicated later, asynchronously, by calling the completion handler.
drivers/usb/core/urb.c: * The three types of completion are success, error, and unlink
drivers/usb/core/urb.c: * (HCD) are finished with the URB.  When the completion function is called,
drivers/usb/core/urb.c: * request.  The completion handler may then immediately free or reuse that
drivers/usb/core/urb.c: * completion processing for earlier (successful) requests.
drivers/usb/core/urb.c: * periods during completion callbacks).  When there is no longer an urb
drivers/usb/core/urb.c: * drivers can use their completion handlers to ensure they keep bandwidth
drivers/usb/core/urb.c: *   (a) you are inside a completion handler, an interrupt, bottom half,
drivers/usb/core/urb.c: * and the completion handler will be called with a status code
drivers/usb/core/urb.c: * must not hold any locks that may be taken by the completion function.
drivers/usb/core/urb.c: * eventually called, the completion function will see @urb->status ==
drivers/usb/core/urb.c: * finished with it), even if the completion handler has not yet run.
drivers/usb/core/urb.c: * completion handler cannot deallocate the URB.
drivers/usb/core/urb.c: * completion routine returns.  It is guaranteed that a stopped queue
drivers/usb/core/urb.c: * with their completion routines run, even if that's not until some time
drivers/usb/core/urb.c: * after the original completion handler returns.  The same behavior and
drivers/usb/core/urb.c: * upon return all completion handlers will have finished and the URB
drivers/usb/core/urb.c: * the completion handler will see urb->status == -ENOENT.
drivers/usb/core/urb.c: * with error -EPERM.  Thus even if the URB's completion handler always
drivers/usb/core/urb.c: * completion handler cannot deallocate the URB.
drivers/usb/core/urb.c: * half or a completion handler), or when holding a spinlock, or in other
drivers/usb/core/urb.c: * upon return all completion handlers will have finished and the URB
drivers/usb/core/urb.c: * the completion handler will see urb->status == -ENOENT.
drivers/usb/core/urb.c: * with error -EPERM.  Thus even if the URB's completion handler always
drivers/usb/core/urb.c: * completion handler cannot deallocate the URB.
drivers/usb/core/urb.c: * half or a completion handler), or when holding a spinlock, or in other
drivers/usb/core/urb.c: * with error -EPERM.  Thus even if the URB's completion handler always
drivers/usb/core/urb.c: * completion handler cannot deallocate the URB.
drivers/usb/core/urb.c: * back path to delay waking up until after the completion handler has run.
drivers/usb/core/driver.c: * Typically a driver would call this routine during an URB's completion
drivers/usb/core/usb.c: * hardware during URB completion/resubmit.  The implementation varies between
drivers/usb/core/hub.c:#include <linux/completion.h>
drivers/usb/core/hub.c:/* completion function, fires on port status changes and various faults */
drivers/usb/core/hub.c:	/* info for completion callback */
drivers/usb/core/message.c:	struct completion	done;
drivers/usb/core/message.c:static void usb_api_blocking_completion(struct urb *urb)
drivers/usb/core/message.c: * Starts urb and waits for completion or timeout. Note that this call
drivers/usb/core/message.c:	init_completion(&ctx.done);
drivers/usb/core/message.c:	if (!wait_for_completion_timeout(&ctx.done, expire)) {
drivers/usb/core/message.c:			     len, usb_api_blocking_completion, NULL);
drivers/usb/core/message.c: * usb_control_msg - Builds a control urb, sends it off and waits for completion
drivers/usb/core/message.c: * usb_interrupt_msg - Builds an interrupt urb, sends it off and waits for completion
drivers/usb/core/message.c: * usb_bulk_msg - Builds a bulk urb, sends it off and waits for completion
drivers/usb/core/message.c:				usb_api_blocking_completion, NULL,
drivers/usb/core/message.c:				usb_api_blocking_completion, NULL);
drivers/usb/core/message.c:	 * reports, until the completion callback (this!) returns.  That lets
drivers/usb/core/message.c:	/* on the last completion, signal usb_sg_wait() */
drivers/usb/core/message.c:	init_completion(&io->complete);
drivers/usb/core/message.c: * There are three kinds of completion for this function.
drivers/usb/core/message.c:	wait_for_completion(&io->complete);
drivers/usb/core/message.c: * as reported by URB completion status.  Endpoints that are halted are
drivers/usb/core/message.c: * underlying call that failed.  On successful completion, each interface
drivers/usb/core/hcd.c:#include <linux/completion.h>
drivers/usb/core/hcd.c:	/* any errors get returned through the urb completion */
drivers/usb/core/hcd.c: *		The completion function may not have been called yet.
drivers/usb/core/hcd.c: * for URB completion.
drivers/usb/core/hcd.c: * and the urb's completion function return
drivers/usb/core/hcd.c:	/* pass ownership to the completion handler */
drivers/usb/core/hcd.c: * @status: completion status code for the URB.
drivers/usb/core/hcd.c: * completion function.  The HCD has freed all per-urb resources
drivers/usb/core/devices.c: * file_offset - the offset into the devices file on completion
drivers/usb/musb/tusb6010.c:					musb_dma_completion(musb, i, 1);
drivers/usb/musb/musb_dma.h:extern void musb_dma_completion(struct musb *musb, u8 epnum, u8 transmit);
drivers/usb/musb/ux500_dma.c:	musb_dma_completion(musb, hw_ep->epnum, ux500_channel->is_tx);
drivers/usb/musb/musbhsdma.c:				musb_dma_completion(musb, musb_channel->epnum,
drivers/usb/musb/musb_cppi41.c:		musb_dma_completion(musb, hw_ep->epnum, cppi41_channel->is_tx);
drivers/usb/musb/tusb6010_omap.c: * See also musb_dma_completion in plat_uds.c and musb_g_[tx|rx]() in
drivers/usb/musb/tusb6010_omap.c:		musb_dma_completion(musb, chdat->epnum, chdat->tx);
drivers/usb/musb/musb_host.c:	/* call completion handler if done */
drivers/usb/musb/musb_host.c:/* Service a Tx-Available or dma completion irq for the endpoint */
drivers/usb/musb/musb_host.c:		 * We may get here from a DMA completion or TXPKTRDY interrupt.
drivers/usb/musb/musb_host.c:	 * while processing this irq for earlier completions.
drivers/usb/musb/musb_gadget.c:			 * On DMA completion, FIFO may not be
drivers/usb/musb/musb_gadget.c:	 * completion. We only get interrupts from DMA controller.
drivers/usb/musb/musb_gadget.c:	 * we don't get DMA completion interrupt for short packets.
drivers/usb/musb/musb_core.c:void musb_dma_completion(struct musb *musb, u8 epnum, u8 transmit)
drivers/usb/musb/musb_core.c:EXPORT_SYMBOL_GPL(musb_dma_completion);
drivers/usb/musb/cppi_dma.c:	/* bufferCount must be at least 3, and zeroes on completion
drivers/usb/musb/cppi_dma.c:		 * matching irq by writing that BD as the completion pointer.
drivers/usb/musb/cppi_dma.c:			/* write completion register to acknowledge
drivers/usb/musb/cppi_dma.c:			/* transfer more, or report completion */
drivers/usb/musb/cppi_dma.c:				musb_dma_completion(musb, index + 1, 1);
drivers/usb/musb/cppi_dma.c:			musb_dma_completion(musb, index + 1, 0);
drivers/usb/musb/cppi_dma.c:		 * the completion routine should get called with
drivers/usb/musb/cppi_dma.c:		 * 1. Write to completion Ptr value 0x1(bit 0 set)
drivers/usb/musb/musb_gadget_ep0.c:	/* report completions as soon as the fifo's loaded; there's no
drivers/usb/musb/musb_gadget_ep0.c:		/* NOTE:  request may need completion */
drivers/usb/phy/phy-isp1301-omap.c:	/* ugly -- i2c hijacks our memory hook to wait_for_completion() */
drivers/usb/phy/phy-msm-usb.c:	/* wait for completion */
drivers/usb/phy/phy-msm-usb.c:	/* wait for completion */
drivers/usb/usbip/vudc_dev.c:		usbip_stop_eh(&udc->ud); /* Wait for eh completion */
drivers/usb/usbip/stub.h:	 *	priv_tx  : linked to this after the completion of a urb.
drivers/usb/usbip/vudc_transfer.c:		 * (so completion handlers can clean up the queue) but we don't
drivers/usb/usbip/vudc_transfer.c:		/* device side completion --> continuable */
drivers/usb/usbip/vudc_transfer.c:		/* host side completion --> terminate */
drivers/usb/usbip/stub_tx.c: * stub_complete - completion handler of a usbip urb
drivers/usb/usbip/stub_tx.c:			 "urb completion with non-zero status %d\n",
drivers/usb/usbip/stub_tx.c:		 * looks at only priv_init queue. If the completion of a URB is
drivers/usb/usbip/stub_tx.c:		 * completion of the unlink request. The request of the
drivers/usb/usbip/usbip_event.c:		usbip_dbg_eh("usbip_eh waiting completion %lx\n", pending);
drivers/usb/usbip/stub_rx.c: * process coming urbs.  Even if the urb is unlinked, its completion
drivers/usb/usbip/vhci_hcd.c: * not important, but the calling to its completion handler is important; the
drivers/usb/usbip/vhci_hcd.c: * completion of unlinking is notified by the completion handler.
drivers/usb/isp1760/isp1760-hcd.c: * Sometimes interrupts are not generated when ATL (not INT?) completion occurs.
drivers/usb/isp1760/isp1760-hcd.c: * If we use SOF interrupts only, we get latency between ptd completion and the
drivers/usb/dwc2/hcd_ddma.c:		 * Pass error code to completion routine as well, to update
drivers/usb/dwc2/hcd_ddma.c: * status and calls completion routine for the URB if it's done. Called from
drivers/usb/dwc2/hcd_ddma.c:			 * completion
drivers/usb/dwc2/gadget.c: * This is the reverse of dwc2_hsotg_map_dma(), called for the completion
drivers/usb/dwc2/gadget.c: * cleanup on completion.
drivers/usb/dwc2/gadget.c: * dwc2_hsotg_complete_oursetup - setup completion callback
drivers/usb/dwc2/gadget.c: * Called on completion of any requests the driver itself
drivers/usb/dwc2/gadget.c: * dwc2_hsotg_complete_setup - completion of a setup transfer
drivers/usb/dwc2/gadget.c: * Called on completion of any requests the driver itself submitted for
drivers/usb/dwc2/gadget.c: * The given request has finished, so call the necessary completion
drivers/usb/dwc2/gadget.c:	 * Look to see if there is anything else to do. Note, the completion
drivers/usb/dwc2/gadget.c: * on the completion interrupts to get notifications of transfer completion.
drivers/usb/dwc2/gadget.c: * call the relevant completion routines.
drivers/usb/dwc2/hcd_intr.c:		 * halted before its normal completion. (Can't use the
drivers/usb/dwc2/hcd.c:/* Handles hub TT buffer clear completions */
drivers/firewire/core-iso.c:int fw_iso_context_flush_completions(struct fw_iso_context *ctx)
drivers/firewire/core-iso.c:	return ctx->card->driver->flush_iso_completions(ctx);
drivers/firewire/core-iso.c:EXPORT_SYMBOL(fw_iso_context_flush_completions);
drivers/firewire/ohci.c:	unsigned long flushing_completions;
drivers/firewire/ohci.c:static void flush_iso_completions(struct iso_context *ctx)
drivers/firewire/ohci.c:		flush_iso_completions(ctx);
drivers/firewire/ohci.c:		flush_iso_completions(ctx);
drivers/firewire/ohci.c:		flush_iso_completions(ctx);
drivers/firewire/ohci.c:		flush_iso_completions(ctx);
drivers/firewire/ohci.c:static int ohci_flush_iso_completions(struct fw_iso_context *base)
drivers/firewire/ohci.c:	if (!test_and_set_bit_lock(0, &ctx->flushing_completions)) {
drivers/firewire/ohci.c:				flush_iso_completions(ctx);
drivers/firewire/ohci.c:		clear_bit_unlock(0, &ctx->flushing_completions);
drivers/firewire/ohci.c:	.flush_iso_completions	= ohci_flush_iso_completions,
drivers/firewire/core-card.c:#include <linux/completion.h>
drivers/firewire/core-card.c:	init_completion(&card->done);
drivers/firewire/core-card.c:static int dummy_flush_iso_completions(struct fw_iso_context *ctx)
drivers/firewire/core-card.c:	.flush_iso_completions	= dummy_flush_iso_completions,
drivers/firewire/core-card.c:	wait_for_completion(&card->done);
drivers/firewire/core-transaction.c:#include <linux/completion.h>
drivers/firewire/core-transaction.c: * @callback_data:	data to be passed to the transaction completion callback
drivers/firewire/core-transaction.c: * transaction completion and hence execution of @callback may happen even
drivers/firewire/core-transaction.c:	struct completion done;
drivers/firewire/core-transaction.c:	init_completion(&d.done);
drivers/firewire/core-transaction.c:	wait_for_completion(&d.done);
drivers/firewire/core-transaction.c:	reinit_completion(&phy_config_done);
drivers/firewire/core-transaction.c:	wait_for_completion_timeout(&phy_config_done, timeout);
drivers/firewire/sbp2.c:#include <linux/completion.h>
drivers/firewire/sbp2.c:	struct completion done;
drivers/firewire/sbp2.c:	init_completion(&orb->done);
drivers/firewire/sbp2.c:	wait_for_completion_timeout(&orb->done, msecs_to_jiffies(timeout));
drivers/firewire/core-cdev.c:	return fw_iso_context_flush_completions(client->iso_context);
drivers/firewire/core.h:	int (*flush_iso_completions)(struct fw_iso_context *ctx);
drivers/mtd/onenand/onenand_base.c:	wait_for_completion(&this->complete);
drivers/mtd/onenand/onenand_base.c:	remain = wait_for_completion_timeout(&this->complete, timeout);
drivers/mtd/onenand/onenand_base.c:	init_completion(&this->complete);
drivers/mtd/onenand/omap2.c:	struct completion irq_done;
drivers/mtd/onenand/omap2.c:	struct completion dma_done;
drivers/mtd/onenand/omap2.c:		reinit_completion(&c->irq_done);
drivers/mtd/onenand/omap2.c:			result = wait_for_completion_timeout(&c->irq_done,
drivers/mtd/onenand/omap2.c:	reinit_completion(&c->dma_done);
drivers/mtd/onenand/omap2.c:	reinit_completion(&c->dma_done);
drivers/mtd/onenand/omap2.c:	reinit_completion(&c->dma_done);
drivers/mtd/onenand/omap2.c:	wait_for_completion(&c->dma_done);
drivers/mtd/onenand/omap2.c:	reinit_completion(&c->dma_done);
drivers/mtd/onenand/omap2.c:	wait_for_completion(&c->dma_done);
drivers/mtd/onenand/omap2.c:	init_completion(&c->irq_done);
drivers/mtd/onenand/omap2.c:	init_completion(&c->dma_done);
drivers/mtd/onenand/samsung.c:	struct completion	complete;
drivers/mtd/onenand/samsung.c:	wait_for_completion_timeout(&onenand->complete, msecs_to_jiffies(20));
drivers/mtd/onenand/samsung.c:			init_completion(&onenand->complete);
drivers/mtd/devices/docg3.c: * doc_write_erase_wait_status - wait for write or erase completion
drivers/mtd/devices/st_spi_fsm.c:	dev_err(fsm->dev, "timeout on sequence completion\n");
drivers/mtd/devices/st_spi_fsm.c:	/* Wait for completion */
drivers/mtd/devices/st_spi_fsm.c:	/* Wait for completion */
drivers/mtd/devices/spear_smi.c:/* timeout for command completion */
drivers/mtd/devices/spear_smi.c: * @cmd_complete: queue to wait for command completion of NOR-flash.
drivers/mtd/devices/spear_smi.c:	/* send the completion */
drivers/mtd/chips/cfi_cmdset_0001.c:		/* force the completion of any ongoing operation
drivers/mtd/sm_ftl.h:#include <linux/completion.h>
drivers/mtd/sm_ftl.h:	struct completion erase_completion;
drivers/mtd/sm_ftl.c:		wait_for_completion(&ftl->erase_completion);
drivers/mtd/sm_ftl.c:	complete(&ftl->erase_completion);
drivers/mtd/sm_ftl.c:	init_completion(&ftl->erase_completion);
drivers/mtd/spi-nor/atmel-quadspi.c:	struct completion	cmd_completion;
drivers/mtd/spi-nor/atmel-quadspi.c:	reinit_completion(&aq->cmd_completion);
drivers/mtd/spi-nor/atmel-quadspi.c:	if (!wait_for_completion_timeout(&aq->cmd_completion,
drivers/mtd/spi-nor/atmel-quadspi.c:		complete(&aq->cmd_completion);
drivers/mtd/spi-nor/atmel-quadspi.c:	init_completion(&aq->cmd_completion);
drivers/mtd/spi-nor/fsl-quadspi.c:#include <linux/completion.h>
drivers/mtd/spi-nor/fsl-quadspi.c:	struct completion c;
drivers/mtd/spi-nor/fsl-quadspi.c:	init_completion(&q->c);
drivers/mtd/spi-nor/fsl-quadspi.c:	if (!wait_for_completion_timeout(&q->c, msecs_to_jiffies(1000))) {
drivers/mtd/spi-nor/cadence-quadspi.c:#include <linux/completion.h>
drivers/mtd/spi-nor/cadence-quadspi.c:	struct completion	transfer_complete;
drivers/mtd/spi-nor/cadence-quadspi.c:	/* Polling for completion. */
drivers/mtd/spi-nor/cadence-quadspi.c:	reinit_completion(&cqspi->transfer_complete);
drivers/mtd/spi-nor/cadence-quadspi.c:		ret = wait_for_completion_timeout(&cqspi->transfer_complete,
drivers/mtd/spi-nor/cadence-quadspi.c:			reinit_completion(&cqspi->transfer_complete);
drivers/mtd/spi-nor/cadence-quadspi.c:			"Indirect read completion error (%i)\n", ret);
drivers/mtd/spi-nor/cadence-quadspi.c:	/* Clear indirect completion status */
drivers/mtd/spi-nor/cadence-quadspi.c:	reinit_completion(&cqspi->transfer_complete);
drivers/mtd/spi-nor/cadence-quadspi.c:		ret = wait_for_completion_timeout(&cqspi->transfer_complete,
drivers/mtd/spi-nor/cadence-quadspi.c:			reinit_completion(&cqspi->transfer_complete);
drivers/mtd/spi-nor/cadence-quadspi.c:			"Indirect write completion error (%i)\n", ret);
drivers/mtd/spi-nor/cadence-quadspi.c:	/* Clear indirect completion status */
drivers/mtd/spi-nor/cadence-quadspi.c:	init_completion(&cqspi->transfer_complete);
drivers/mtd/nand/r852.h:#include <linux/completion.h>
drivers/mtd/nand/r852.h:	struct completion dma_done;	/* data transfer done */
drivers/mtd/nand/mtk_ecc.c:	struct completion done;
drivers/mtd/nand/mtk_ecc.c:	init_completion(&ecc->done);
drivers/mtd/nand/mtk_ecc.c:	ret = wait_for_completion_timeout(&ecc->done, msecs_to_jiffies(500));
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	struct completion *dma_c = &this->dma_done;
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	struct completion *dma_c = &this->dma_done;
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	init_completion(dma_c);
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	timeout = wait_for_completion_timeout(dma_c, msecs_to_jiffies(1000));
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	struct completion *bch_c = &this->bch_done;
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	init_completion(bch_c);
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	timeout = wait_for_completion_timeout(bch_c, msecs_to_jiffies(1000));
drivers/mtd/nand/gpmi-nand/gpmi-nand.h:	struct completion	bch_done;
drivers/mtd/nand/gpmi-nand/gpmi-nand.h:	struct completion	dma_done;
drivers/mtd/nand/lpc32xx_slc.c:	struct completion	comp;
drivers/mtd/nand/lpc32xx_slc.c:static void lpc32xx_dma_complete_func(void *completion)
drivers/mtd/nand/lpc32xx_slc.c:	complete(completion);
drivers/mtd/nand/lpc32xx_slc.c:	init_completion(&host->comp);
drivers/mtd/nand/lpc32xx_slc.c:	wait_for_completion_timeout(&host->comp, msecs_to_jiffies(1000));
drivers/mtd/nand/mtk_nand.c:	struct completion done;
drivers/mtd/nand/mtk_nand.c:	init_completion(&nfc->done);
drivers/mtd/nand/mtk_nand.c:	ret = wait_for_completion_timeout(&nfc->done, msecs_to_jiffies(500));
drivers/mtd/nand/mtk_nand.c:	init_completion(&nfc->done);
drivers/mtd/nand/mtk_nand.c:	rc = wait_for_completion_timeout(&nfc->done, msecs_to_jiffies(500));
drivers/mtd/nand/atmel_nand.c:	struct completion	comp_ready;
drivers/mtd/nand/atmel_nand.c:	struct completion	comp_cmd_done;
drivers/mtd/nand/atmel_nand.c:	struct completion	comp_xfer_done;
drivers/mtd/nand/atmel_nand.c:	struct completion	comp;
drivers/mtd/nand/atmel_nand.c:static void dma_complete_func(void *completion)
drivers/mtd/nand/atmel_nand.c:	complete(completion);
drivers/mtd/nand/atmel_nand.c:	init_completion(&host->comp);
drivers/mtd/nand/atmel_nand.c:	wait_for_completion(&host->comp);
drivers/mtd/nand/atmel_nand.c:		init_completion(&host->nfc->comp_xfer_done);
drivers/mtd/nand/atmel_nand.c:		init_completion(&host->nfc->comp_ready);
drivers/mtd/nand/atmel_nand.c:		init_completion(&host->nfc->comp_cmd_done);
drivers/mtd/nand/atmel_nand.c:	struct completion *comp[3];	/* Support 3 interrupt completion */
drivers/mtd/nand/atmel_nand.c:		if (wait_for_completion_timeout(comp[i],
drivers/mtd/nand/atmel_nand.c:			continue;	/* wait for next completion */
drivers/mtd/nand/pxa3xx_nand.c:	struct completion	cmd_complete, dev_ready;
drivers/mtd/nand/pxa3xx_nand.c:		init_completion(&info->cmd_complete);
drivers/mtd/nand/pxa3xx_nand.c:		init_completion(&info->dev_ready);
drivers/mtd/nand/pxa3xx_nand.c:		if (!wait_for_completion_timeout(&info->cmd_complete,
drivers/mtd/nand/pxa3xx_nand.c:	 * Prepare the "is ready" completion before starting a command
drivers/mtd/nand/pxa3xx_nand.c:	 * completion will be completed, see below.
drivers/mtd/nand/pxa3xx_nand.c:	init_completion(&info->dev_ready);
drivers/mtd/nand/pxa3xx_nand.c:		init_completion(&info->cmd_complete);
drivers/mtd/nand/pxa3xx_nand.c:		if (!wait_for_completion_timeout(&info->cmd_complete,
drivers/mtd/nand/pxa3xx_nand.c:		if (!wait_for_completion_timeout(&info->dev_ready,
drivers/mtd/nand/sunxi_nand.c: * @complete:		a completion object used to wait for NAND
drivers/mtd/nand/sunxi_nand.c:	struct completion complete;
drivers/mtd/nand/sunxi_nand.c:		init_completion(&nfc->complete);
drivers/mtd/nand/sunxi_nand.c:		ret = wait_for_completion_timeout(&nfc->complete,
drivers/mtd/nand/hisi504_nand.c:	struct completion       cmd_complete;
drivers/mtd/nand/hisi504_nand.c:	init_completion(&host->cmd_complete);
drivers/mtd/nand/hisi504_nand.c:	ret = wait_for_completion_timeout(&host->cmd_complete,
drivers/mtd/nand/r852.c:	long timeout = wait_for_completion_timeout(&dev->dma_done,
drivers/mtd/nand/r852.c:	reinit_completion(&dev->dma_done);
drivers/mtd/nand/r852.c:	init_completion(&dev->dma_done);
drivers/mtd/nand/omap_elm.c:	struct completion elm_completion;
drivers/mtd/nand/omap_elm.c: * On completion of processing by elm module, error location status
drivers/mtd/nand/omap_elm.c:	wait_for_completion(&info->elm_completion);
drivers/mtd/nand/omap_elm.c:		complete(&info->elm_completion);
drivers/mtd/nand/omap_elm.c:	init_completion(&info->elm_completion);
drivers/mtd/nand/denali.h:	struct completion complete;
drivers/mtd/nand/denali.c:			wait_for_completion_timeout(&denali->complete, timeout);
drivers/mtd/nand/denali.c:	 * the completion object will be used to notify
drivers/mtd/nand/denali.c:	init_completion(&denali->complete);
drivers/mtd/nand/mxc_nand.c:#include <linux/completion.h>
drivers/mtd/nand/mxc_nand.c:	struct completion	op_completion;
drivers/mtd/nand/mxc_nand.c:	complete(&host->op_completion);
drivers/mtd/nand/mxc_nand.c:		reinit_completion(&host->op_completion);
drivers/mtd/nand/mxc_nand.c:		timeout = wait_for_completion_timeout(&host->op_completion, HZ);
drivers/mtd/nand/mxc_nand.c:			dev_dbg(host->dev, "timeout polling for completion\n");
drivers/mtd/nand/mxc_nand.c: * waits for completion. */
drivers/mtd/nand/mxc_nand.c:		/* Reset completion is indicated by NFC_CONFIG2 */
drivers/mtd/nand/mxc_nand.c:	init_completion(&host->op_completion);
drivers/mtd/nand/fsmc_nand.c:#include <linux/completion.h>
drivers/mtd/nand/fsmc_nand.c:	struct completion	dma_access_complete;
drivers/mtd/nand/fsmc_nand.c:	wait_for_completion_timeout(&host->dma_access_complete,
drivers/mtd/nand/fsmc_nand.c:		dev_err(host->dev, "wait_for_completion_timeout\n");
drivers/mtd/nand/fsmc_nand.c:		init_completion(&host->dma_access_complete);
drivers/mtd/nand/brcmnand/brcmnand.c:#include <linux/completion.h>
drivers/mtd/nand/brcmnand/brcmnand.c:	struct completion	done;
drivers/mtd/nand/brcmnand/brcmnand.c:	struct completion	dma_done;
drivers/mtd/nand/brcmnand/brcmnand.c:			wait_for_completion_timeout(&ctrl->done, timeo) <= 0) {
drivers/mtd/nand/brcmnand/brcmnand.c:	if (wait_for_completion_timeout(&ctrl->dma_done, timeo) <= 0) {
drivers/mtd/nand/brcmnand/brcmnand.c:	init_completion(&ctrl->done);
drivers/mtd/nand/brcmnand/brcmnand.c:	init_completion(&ctrl->dma_done);
drivers/mtd/nand/omap2.c:	struct completion		comp;
drivers/mtd/nand/omap2.c: * omap_nand_dma_callback: callback on the completion of dma transfer
drivers/mtd/nand/omap2.c: * @data: pointer to completion data structure
drivers/mtd/nand/omap2.c:	complete((struct completion *) data);
drivers/mtd/nand/omap2.c:	init_completion(&info->comp);
drivers/mtd/nand/omap2.c:	wait_for_completion(&info->comp);
drivers/mtd/nand/omap2.c:	init_completion(&info->comp);
drivers/mtd/nand/omap2.c:	wait_for_completion(&info->comp);
drivers/mtd/nand/omap2.c:	init_completion(&info->comp);
drivers/mtd/nand/omap2.c:	wait_for_completion(&info->comp);
drivers/mtd/nand/nandsim.c:/* Good operation completion status */
drivers/mtd/nand/nandsim.c:/* Operation failed completion status */
drivers/mtd/nand/vf610_nfc.c:	struct completion cmd_done;
drivers/mtd/nand/vf610_nfc.c:	if (!wait_for_completion_timeout(&nfc->cmd_done, timeout))
drivers/mtd/nand/vf610_nfc.c:	init_completion(&nfc->cmd_done);
drivers/mtd/nand/bf5xx_nand.c:	struct completion		dma_completion;
drivers/mtd/nand/bf5xx_nand.c:	complete(&info->dma_completion);
drivers/mtd/nand/bf5xx_nand.c:	wait_for_completion(&info->dma_completion);
drivers/mtd/nand/bf5xx_nand.c:	init_completion(&info->dma_completion);
drivers/mtd/nand/lpc32xx_mlc.c:#include <linux/completion.h>
drivers/mtd/nand/lpc32xx_mlc.c:	struct completion       comp_nand;
drivers/mtd/nand/lpc32xx_mlc.c:	struct completion       comp_controller;
drivers/mtd/nand/lpc32xx_mlc.c:	struct completion	comp_dma;
drivers/mtd/nand/lpc32xx_mlc.c: * wait_for_completion() (DMA setup _not_ included).
drivers/mtd/nand/lpc32xx_mlc.c:	wait_for_completion(&host->comp_nand);
drivers/mtd/nand/lpc32xx_mlc.c:	wait_for_completion(&host->comp_controller);
drivers/mtd/nand/lpc32xx_mlc.c:static void lpc32xx_dma_complete_func(void *completion)
drivers/mtd/nand/lpc32xx_mlc.c:	complete(completion);
drivers/mtd/nand/lpc32xx_mlc.c:	init_completion(&host->comp_dma);
drivers/mtd/nand/lpc32xx_mlc.c:	wait_for_completion_timeout(&host->comp_dma, msecs_to_jiffies(1000));
drivers/mtd/nand/lpc32xx_mlc.c:	init_completion(&host->comp_nand);
drivers/mtd/nand/lpc32xx_mlc.c:	init_completion(&host->comp_controller);
drivers/mtd/nand/sh_flctl.c:#include <linux/completion.h>
drivers/mtd/nand/sh_flctl.c:static void wait_completion(struct sh_flctl *flctl)
drivers/mtd/nand/sh_flctl.c:	init_completion(&flctl->dma_complete);
drivers/mtd/nand/sh_flctl.c:	wait_for_completion_timeout(&flctl->dma_complete,
drivers/mtd/nand/sh_flctl.c:		dev_err(&flctl->pdev->dev, "wait_for_completion_timeout\n");
drivers/mtd/nand/sh_flctl.c:	wait_completion(flctl);
drivers/mtd/nand/sh_flctl.c:	wait_completion(flctl);
drivers/mtd/nand/sh_flctl.c:		wait_completion(flctl);
drivers/mtd/nand/sh_flctl.c:	wait_completion(flctl);
drivers/mtd/nand/sh_flctl.c:		wait_completion(flctl);
drivers/mtd/nand/sh_flctl.c:		wait_completion(flctl);
drivers/mtd/nand/sh_flctl.c:		wait_completion(flctl);
drivers/mtd/nand/sh_flctl.c:			wait_completion(flctl);
drivers/mtd/nand/sh_flctl.c:		wait_completion(flctl);
drivers/mtd/nand/sh_flctl.c:		wait_completion(flctl);
drivers/mtd/nand/sh_flctl.c:	wait_completion(flctl);
drivers/acpi/sbshc.c:	 * Wait for completion. Save the status code, data size,
drivers/acpi/sbshc.c:	/* Check if it is only a completion notify */
drivers/acpi/property.c:		wait_for_completion(&dn->kobj_done);
drivers/acpi/cppc_acpi.c:		 * platform and should have set the command completion bit when
drivers/acpi/cppc_acpi.c:		 * before write completion, so first send a WRITE command to
drivers/acpi/cppc_acpi.c:	 * "The minimum amount of time that OSPM must wait after the completion
drivers/acpi/cppc_acpi.c:	/* wait for completion and check for PCC errro bit */
drivers/acpi/cppc_acpi.c:	 *              completion of a command before issuing the next command,
drivers/acpi/device_sysfs.c:		init_completion(&dn->kobj_done);
drivers/acpi/acpica/dbxface.c:		/* Notify the completion of the command */
drivers/acpi/acpica/dbinput.c:	{1, "  Go", "Allow method to run to completion\n"},
drivers/acpi/acpica/dbinput.c:		/* Notify the completion of the command */
drivers/acpi/acpica/psargs.c: * RETURN:      Decoded package length. On completion, the AML pointer points
drivers/acpi/acpica/dbexec.c:	/* Signal our completion */
drivers/acpi/acpica/dswexec.c:			 * object is temporary and will be deleted upon completion of
drivers/acpi/acpica/aclocal.h:#define ACPI_EXT_INTERNAL_PATH_ALLOCATED    0x04	/* Deallocate internal path on completion */
drivers/acpi/acpica/psparse.c: * DESCRIPTION: Perform any cleanup at the completion of an Op.
drivers/acpi/nfit/core.c:	struct completion cmp;
drivers/acpi/nfit/core.c:	return wait_for_completion_interruptible(&flush.cmp);
drivers/acpi/ec.c:	 * Note that successful completion of the query causes the ACPI_EC_SCI
drivers/acpi/acpi_ipmi.c:	struct completion tx_complete;
drivers/acpi/acpi_ipmi.c:	init_completion(&ipmi_msg->tx_complete);
drivers/acpi/acpi_ipmi.c:	wait_for_completion(&tx_msg->tx_complete);
drivers/hwmon/ibmpex.c:	struct completion	read_complete;
drivers/hwmon/ibmpex.c:	wait_for_completion(&data->read_complete);
drivers/hwmon/ibmpex.c:	wait_for_completion(&data->read_complete);
drivers/hwmon/ibmpex.c:	wait_for_completion(&data->read_complete);
drivers/hwmon/ibmpex.c:	wait_for_completion(&data->read_complete);
drivers/hwmon/ibmpex.c:	wait_for_completion(&data->read_complete);
drivers/hwmon/ibmpex.c:	init_completion(&data->read_complete);
drivers/hwmon/ibmaem.c:	struct completion	read_complete;
drivers/hwmon/ibmaem.c:	init_completion(&data->read_complete);
drivers/hwmon/ibmaem.c:	res = wait_for_completion_timeout(&ipmi->read_complete, IPMI_TIMEOUT);
drivers/hwmon/ibmaem.c:	res = wait_for_completion_timeout(&data->read_complete, IPMI_TIMEOUT);
drivers/hwmon/ibmaem.c:	res = wait_for_completion_timeout(&data->read_complete, IPMI_TIMEOUT);
drivers/hwmon/xgene-hwmon.c:	struct completion	rd_complete;
drivers/hwmon/xgene-hwmon.c:	init_completion(&ctx->rd_complete);
drivers/hwmon/xgene-hwmon.c:	if (!wait_for_completion_timeout(&ctx->rd_complete,
drivers/hwmon/xgene-hwmon.c:	init_completion(&ctx->rd_complete);
drivers/hwmon/xgene-hwmon.c:	if (!wait_for_completion_timeout(&ctx->rd_complete,
drivers/hwmon/jz4740-hwmon.c:#include <linux/completion.h>
drivers/hwmon/jz4740-hwmon.c:	struct completion read_completion;
drivers/hwmon/jz4740-hwmon.c:	complete(&hwmon->read_completion);
drivers/hwmon/jz4740-hwmon.c:	struct completion *completion = &hwmon->read_completion;
drivers/hwmon/jz4740-hwmon.c:	reinit_completion(completion);
drivers/hwmon/jz4740-hwmon.c:	t = wait_for_completion_interruptible_timeout(completion, HZ);
drivers/hwmon/jz4740-hwmon.c:	init_completion(&hwmon->read_completion);
drivers/hwmon/da9055-hwmon.c:#include <linux/completion.h>
drivers/hwmon/da9055-hwmon.c:	struct completion done;
drivers/hwmon/da9055-hwmon.c:	if (!wait_for_completion_timeout(&hwmon->done,
drivers/hwmon/da9055-hwmon.c:	init_completion(&hwmon->done);
drivers/rapidio/devices/rio_mport_cdev.c:	struct completion comp;
drivers/rapidio/devices/rio_mport_cdev.c:	struct completion	comp;
drivers/rapidio/devices/rio_mport_cdev.c:	struct completion req_comp;
drivers/rapidio/devices/rio_mport_cdev.c:		init_completion(&priv->comp);
drivers/rapidio/devices/rio_mport_cdev.c:	init_completion(&req->req_comp);
drivers/rapidio/devices/rio_mport_cdev.c:	wret = wait_for_completion_interruptible_timeout(&req->req_comp, tmo);
drivers/rapidio/devices/rio_mport_cdev.c:		/* Wait_for_completion was interrupted by a signal but DMA may
drivers/rapidio/devices/rio_mport_cdev.c:		/* DMA transaction completion was signaled with error */
drivers/rapidio/devices/rio_mport_cdev.c:	wret = wait_for_completion_interruptible_timeout(&req->req_comp, tmo);
drivers/rapidio/devices/rio_mport_cdev.c:		/* Wait_for_completion was interrupted by a signal but DMA may
drivers/rapidio/devices/rio_mport_cdev.c:		/* DMA transaction completion signaled with transfer error */
drivers/rapidio/devices/rio_mport_cdev.c:		rmcd_error("%s(%d) ASYNC DMA_%s completion with status %d",
drivers/rapidio/devices/rio_mport_cdev.c:				   completion_done(&req->req_comp)?"yes":"no");
drivers/rapidio/devices/rio_mport_cdev.c:				   completion_done(&req->req_comp)?"yes":"no");
drivers/rapidio/devices/rio_mport_cdev.c:	wret = wait_for_completion_interruptible_timeout(&priv->comp, tmo);
drivers/rapidio/devices/tsi721.c:		/* Inform upper layer about transfer completion */
drivers/rapidio/devices/tsi721.c:	/* Adjust PCIe completion timeout. */
drivers/rapidio/rio_cm.c:	struct completion	comp;
drivers/rapidio/rio_cm.c:	struct completion	comp_close;
drivers/rapidio/rio_cm.c: * rio_txcq_handler - TX completion handler
drivers/rapidio/rio_cm.c: * TX completion handler also ensures that pending request packets are placed
drivers/rapidio/rio_cm.c:	/* ATTN: Add TX completion notification if/when direct buffer
drivers/rapidio/rio_cm.c:	wret = wait_for_completion_interruptible_timeout(&ch->comp, timeout);
drivers/rapidio/rio_cm.c:	wret = wait_for_completion_interruptible_timeout(&ch->comp,
drivers/rapidio/rio_cm.c:		if (!try_wait_for_completion(&ch->comp)) {
drivers/rapidio/rio_cm.c:		wret = wait_for_completion_interruptible_timeout(&ch->comp,
drivers/rapidio/rio_cm.c:		riocm_debug(WAIT, "on %d accept_queue is empty on completion",
drivers/rapidio/rio_cm.c:	init_completion(&ch->comp);
drivers/rapidio/rio_cm.c:	init_completion(&ch->comp_close);
drivers/rapidio/rio_cm.c:	wret = wait_for_completion_interruptible_timeout(&ch->comp_close, tmo);
drivers/rapidio/rio_cm.c:		/* Wait_for_completion was interrupted by a signal */
drivers/rapidio/rio-scan.c: * When enumeration completion is signaled, start recursive
drivers/xen/xenbus/xenbus_probe.c:	timeout = wait_for_completion_timeout(&dev->down, timeout);
drivers/xen/xenbus/xenbus_probe.c:	init_completion(&xendev->down);
drivers/xen/grant-table.c:	struct completion completion;
drivers/xen/grant-table.c:	rmb();	/* Read the frame number /after/ reading completion status. */
drivers/xen/grant-table.c:	complete(&d->completion);
drivers/xen/grant-table.c:	init_completion(&data.completion);
drivers/xen/grant-table.c:	wait_for_completion(&data.completion);
drivers/iommu/msm_iommu.c:	 * completion of the tlb sync operation is implicitly
drivers/iommu/amd_iommu.c:					     PPR completions */
drivers/iommu/amd_iommu.c:static void build_completion_wait(struct iommu_cmd *cmd, u64 address)
drivers/iommu/amd_iommu.c:		build_completion_wait(&sync_cmd, (u64)&iommu->cmd_sem);
drivers/iommu/amd_iommu.c: * This function queues a completion wait command into the command
drivers/iommu/amd_iommu.c:static int iommu_completion_wait(struct amd_iommu *iommu)
drivers/iommu/amd_iommu.c:	build_completion_wait(&cmd, (u64)&iommu->cmd_sem);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:		 * We need to wait for completion of all commands.
drivers/iommu/amd_iommu.c:		iommu_completion_wait(amd_iommus[i]);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu.c:	iommu_completion_wait(iommu);
drivers/iommu/amd_iommu_types.h:	/* if one, we need to send a completion wait command */
drivers/iommu/iommu.c: * requester ID, requests and completions cannot be redirected, and all
drivers/iommu/dmar.c: * hardware unit and wait for its completion.
drivers/iommu/dmar.c:		 * and waiting for completion on this cpu. This is to avoid
drivers/extcon/extcon-axp288.c:	/* Check charger detection completion status */
drivers/ntb/ntb.c:	init_completion(&ntb->released);
drivers/ntb/ntb.c:	wait_for_completion(&ntb->released);
drivers/ntb/ntb_transport.c:	 * cases, there is nothing to add to the completion queue.
drivers/char/mbcs.c: * mbcs_completion_intr_handler - Primary completion handler.
drivers/char/mbcs.c:mbcs_completion_intr_handler(int irq, void *arg)
drivers/char/mbcs.c:			(void *)mbcs_completion_intr_handler, IRQF_SHARED,
drivers/char/mbcs.c:			(void *)mbcs_completion_intr_handler, IRQF_SHARED,
drivers/char/mbcs.c:			(void *)mbcs_completion_intr_handler, IRQF_SHARED,
drivers/char/pcmcia/synclink_cs.c:	/* wait for command completion */
drivers/char/pcmcia/synclink_cs.c: * update stats and do tx completion processing
drivers/char/tpm/xen-tpmfront.c:	/* Wait for completion of any existing command or cancellation */
drivers/char/ipmi/ipmi_msghandler.c:	 * run_to_completion duplicate of smb_info, smi_info
drivers/char/ipmi/ipmi_msghandler.c:	int run_to_completion;
drivers/char/ipmi/ipmi_msghandler.c:	int run_to_completion = intf->run_to_completion;
drivers/char/ipmi/ipmi_msghandler.c:	if (run_to_completion) {
drivers/char/ipmi/ipmi_msghandler.c:	 * completion code.
drivers/char/ipmi/ipmi_msghandler.c:	 * completion code.
drivers/char/ipmi/ipmi_msghandler.c:	int                  run_to_completion = intf->run_to_completion;
drivers/char/ipmi/ipmi_msghandler.c:	if (!run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:		if (!run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:		if (!run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:	if (!run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:	int run_to_completion = intf->run_to_completion;
drivers/char/ipmi/ipmi_msghandler.c:	if (!run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:	if (!run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:	int run_to_completion = intf->run_to_completion;
drivers/char/ipmi/ipmi_msghandler.c:		if (!run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:		if (!run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:	if (!run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:	if (!run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:	if (run_to_completion)
drivers/char/ipmi/ipmi_msghandler.c:	/* For every registered interface, set it to run to completion. */
drivers/char/ipmi/ipmi_msghandler.c:		intf->run_to_completion = 1;
drivers/char/ipmi/ipmi_msghandler.c:		intf->handlers->set_run_to_completion(intf->send_info, 1);
drivers/char/ipmi/ipmi_bt_sm.c:#include <linux/ipmi_msgdefs.h>		/* for completion codes */
drivers/char/ipmi/ipmi_bt_sm.c:/* Jam a completion code (probably an error) into a response */
drivers/char/ipmi/ipmi_bt_sm.c:static void force_result(struct si_sm_data *bt, unsigned char completion_code)
drivers/char/ipmi/ipmi_bt_sm.c:	bt->read_data[4] = completion_code;
drivers/char/ipmi/ipmi_bt_sm.c:/* Restart if retries are left, or return an error completion code */
drivers/char/ipmi/ipmi_ssif.c:	 * Used to perform timer operations when run-to-completion
drivers/char/ipmi/ipmi_ssif.c:	struct completion wake_thread;
drivers/char/ipmi/ipmi_ssif.c:		result = wait_for_completion_interruptible(
drivers/char/ipmi/ipmi_ssif.c:		init_completion(&ssif_info->wake_thread);
drivers/char/ipmi/ipmi_ssif.c:		init_completion(&ssif_info->wake_thread);
drivers/char/ipmi/ipmi_powernv.c:		struct ipmi_smi_msg *msg, u8 completion_code)
drivers/char/ipmi/ipmi_powernv.c:	msg->rsp[2] = completion_code;
drivers/char/ipmi/ipmi_powernv.c:static void ipmi_powernv_set_run_to_completion(void *send_info,
drivers/char/ipmi/ipmi_powernv.c:		bool run_to_completion)
drivers/char/ipmi/ipmi_powernv.c:	.set_run_to_completion	= ipmi_powernv_set_run_to_completion,
drivers/char/ipmi/ipmi_poweroff.c:#include <linux/completion.h>
drivers/char/ipmi/ipmi_poweroff.c:	struct completion *comp = recv_msg->user_msg_data;
drivers/char/ipmi/ipmi_poweroff.c:	struct completion comp;
drivers/char/ipmi/ipmi_poweroff.c:	init_completion(&comp);
drivers/char/ipmi/ipmi_poweroff.c:	wait_for_completion(&comp);
drivers/char/ipmi/ipmi_poweroff.c:	/* Use run-to-completion mode, since interrupts may be off. */
drivers/char/ipmi/ipmi_watchdog.c:#include <linux/completion.h>
drivers/char/ipmi/ipmi_watchdog.c:	wait_for_completion(&set_timeout_wait);
drivers/char/ipmi/ipmi_watchdog.c: * at panic or halt time, in run-to-completion mode, when the caller
drivers/char/ipmi/ipmi_watchdog.c:	wait_for_completion(&heartbeat_wait);
drivers/char/ipmi/ipmi_si_intf.c:	 * If true, run the state machine to completion on every send
drivers/char/ipmi/ipmi_si_intf.c:	bool                run_to_completion;
drivers/char/ipmi/ipmi_si_intf.c:	 * Currently, this function is called only in run-to-completion
drivers/char/ipmi/ipmi_si_intf.c:	if (smi_info->run_to_completion) {
drivers/char/ipmi/ipmi_si_intf.c:		 * If we are running to completion, start it.  Upper
drivers/char/ipmi/ipmi_si_intf.c:static void set_run_to_completion(void *send_info, bool i_run_to_completion)
drivers/char/ipmi/ipmi_si_intf.c:	smi_info->run_to_completion = i_run_to_completion;
drivers/char/ipmi/ipmi_si_intf.c:	if (i_run_to_completion)
drivers/char/ipmi/ipmi_si_intf.c:	bool run_to_completion = smi_info->run_to_completion;
drivers/char/ipmi/ipmi_si_intf.c:	if (!run_to_completion)
drivers/char/ipmi/ipmi_si_intf.c:	if (!run_to_completion)
drivers/char/ipmi/ipmi_si_intf.c:	.set_run_to_completion  = set_run_to_completion,
drivers/char/ipmi/ipmi_si_intf.c:	new_smi->run_to_completion = false;
drivers/char/ipmi/ipmi_kcs_sm.c:#include <linux/ipmi_msgdefs.h>		/* for completion codes */
drivers/char/ipmi/ipmi_smic_sm.c:#include <linux/ipmi_msgdefs.h>		/* for completion codes */
drivers/char/mmtimer.c:	u64 *set_completion_time)
drivers/char/mmtimer.c:	*set_completion_time = rtc_time();
drivers/char/mmtimer.c:	if (*set_completion_time <= expires)
drivers/char/mmtimer.c:	u64 expires, exp, set_completion_time;
drivers/char/mmtimer.c:					&set_completion_time)) {
drivers/char/mmtimer.c:				&set_completion_time)) {
drivers/char/mmtimer.c:		expires = set_completion_time +
drivers/char/apm-emulation.c:#include <linux/completion.h>
drivers/char/virtio_console.c:#include <linux/completion.h>
drivers/char/virtio_console.c:		wait_for_completion(&early_console_added);
drivers/char/xillybus/xillybus_core.c:		 * If partial completion is disallowed, there is no point in
drivers/char/random.c:#include <linux/completion.h>
drivers/char/hw_random/timeriomem-rng.c:#include <linux/completion.h>
drivers/char/hw_random/timeriomem-rng.c:	struct completion	completion;
drivers/char/hw_random/timeriomem-rng.c:	wait_for_completion(&priv->completion);
drivers/char/hw_random/timeriomem-rng.c:	reinit_completion(&priv->completion);
drivers/char/hw_random/timeriomem-rng.c:	complete(&priv->completion);
drivers/char/hw_random/timeriomem-rng.c:	init_completion(&priv->completion);
drivers/char/hw_random/timeriomem-rng.c:	complete(&priv->completion);
drivers/char/hw_random/core.c:	reinit_completion(&rng->cleanup_done);
drivers/char/hw_random/core.c:	init_completion(&rng->cleanup_done);
drivers/char/hw_random/core.c:	wait_for_completion(&rng->cleanup_done);
drivers/char/hw_random/virtio-rng.c:	struct completion have_data;
drivers/char/hw_random/virtio-rng.c:		init_completion(&vi->have_data);
drivers/char/hw_random/virtio-rng.c:	ret = wait_for_completion_killable(&vi->have_data);
drivers/char/hw_random/virtio-rng.c:		wait_for_completion(&vi->have_data);
drivers/char/hw_random/virtio-rng.c:	init_completion(&vi->have_data);
drivers/bus/sunxi-rsb.c:	struct completion complete;
drivers/bus/sunxi-rsb.c:	reinit_completion(&rsb->complete);
drivers/bus/sunxi-rsb.c:	if (!wait_for_completion_io_timeout(&rsb->complete,
drivers/bus/sunxi-rsb.c:	init_completion(&rsb->complete);
drivers/bus/arm-cci.c:	/* poll the status reg for completion */
drivers/input/serio/libps2.c: * completion.
drivers/input/serio/libps2.c: * waiting for completion of the command.
drivers/input/serio/hyperv-keyboard.c:#include <linux/completion.h>
drivers/input/serio/hyperv-keyboard.c:	struct completion wait_event;
drivers/input/serio/hyperv-keyboard.c:	if (!wait_for_completion_timeout(&kbd_dev->wait_event, 10 * HZ))
drivers/input/serio/hyperv-keyboard.c:	init_completion(&kbd_dev->wait_event);
drivers/input/serio/i8042.c:static struct completion i8042_aux_irq_delivered __initdata;
drivers/input/serio/i8042.c:	init_completion(&i8042_aux_irq_delivered);
drivers/input/serio/i8042.c:	if (wait_for_completion_timeout(&i8042_aux_irq_delivered,
drivers/input/keyboard/hil_kbd.c:#include <linux/completion.h>
drivers/input/keyboard/hil_kbd.c:	struct completion cmd_done;
drivers/input/keyboard/hil_kbd.c:	init_completion(&dev->cmd_done);
drivers/input/keyboard/hil_kbd.c:	error = wait_for_completion_killable(&dev->cmd_done);
drivers/input/keyboard/hil_kbd.c:	reinit_completion(&dev->cmd_done);
drivers/input/keyboard/hil_kbd.c:	error = wait_for_completion_killable(&dev->cmd_done);
drivers/input/keyboard/hil_kbd.c:	reinit_completion(&dev->cmd_done);
drivers/input/keyboard/hil_kbd.c:	error = wait_for_completion_killable(&dev->cmd_done);
drivers/input/keyboard/hil_kbd.c:	reinit_completion(&dev->cmd_done);
drivers/input/keyboard/hil_kbd.c:	error = wait_for_completion_killable(&dev->cmd_done);
drivers/input/keyboard/hil_kbd.c:		/* No need to wait for completion */
drivers/input/touchscreen/ucb1400_ts.c: * access completion and uses semaphores for access control to the
drivers/input/touchscreen/goodix.c:	struct completion firmware_loading_complete;
drivers/input/touchscreen/goodix.c:	init_completion(&ts->firmware_loading_complete);
drivers/input/touchscreen/goodix.c:		wait_for_completion(&ts->firmware_loading_complete);
drivers/input/touchscreen/goodix.c:	wait_for_completion(&ts->firmware_loading_complete);
drivers/input/touchscreen/wacom_w8001.c:	struct completion cmd_done;
drivers/input/touchscreen/wacom_w8001.c:	init_completion(&w8001->cmd_done);
drivers/input/touchscreen/wacom_w8001.c:		wait_for_completion_timeout(&w8001->cmd_done, HZ);
drivers/input/touchscreen/wacom_w8001.c:	init_completion(&w8001->cmd_done);
drivers/input/touchscreen/zforce_ts.c: * @command_done	completion to wait for the command result
drivers/input/touchscreen/zforce_ts.c:	struct completion	command_done;
drivers/input/touchscreen/zforce_ts.c:	if (wait_for_completion_timeout(&ts->command_done, WAIT_TIMEOUT) == 0) {
drivers/input/touchscreen/zforce_ts.c:	init_completion(&ts->command_done);
drivers/input/touchscreen/zforce_ts.c:	if (wait_for_completion_timeout(&ts->command_done, WAIT_TIMEOUT) == 0)
drivers/input/touchscreen/wm831x-ts.c:	/* Make sure the IRQ completion work is quiesced */
drivers/input/touchscreen/elants_i2c.c:	struct completion cmd_done;
drivers/input/touchscreen/elants_i2c.c:	reinit_completion(&ts->cmd_done);
drivers/input/touchscreen/elants_i2c.c:	ret = wait_for_completion_interruptible_timeout(&ts->cmd_done,
drivers/input/touchscreen/elants_i2c.c:	init_completion(&ts->cmd_done);
drivers/input/touchscreen/elo.c:	struct completion cmd_done;
drivers/input/touchscreen/elo.c:	init_completion(&elo->cmd_done);
drivers/input/touchscreen/elo.c:	wait_for_completion_timeout(&elo->cmd_done, HZ);
drivers/input/touchscreen/elo.c:	init_completion(&elo->cmd_done);
drivers/input/touchscreen/cyttsp_core.c:	/* wait for interrupt to set ready completion */
drivers/input/touchscreen/cyttsp_core.c:	reinit_completion(&ts->bl_ready);
drivers/input/touchscreen/cyttsp_core.c:	timeout = wait_for_completion_timeout(&ts->bl_ready,
drivers/input/touchscreen/cyttsp_core.c:	init_completion(&ts->bl_ready);
drivers/input/touchscreen/atmel_mxt_ts.c:#include <linux/completion.h>
drivers/input/touchscreen/atmel_mxt_ts.c:	struct completion bl_completion;
drivers/input/touchscreen/atmel_mxt_ts.c:	struct completion reset_completion;
drivers/input/touchscreen/atmel_mxt_ts.c:	struct completion crc_completion;
drivers/input/touchscreen/atmel_mxt_ts.c:static int mxt_wait_for_completion(struct mxt_data *data,
drivers/input/touchscreen/atmel_mxt_ts.c:				   struct completion *comp,
drivers/input/touchscreen/atmel_mxt_ts.c:	ret = wait_for_completion_interruptible_timeout(comp, timeout);
drivers/input/touchscreen/atmel_mxt_ts.c:		dev_err(dev, "Wait for completion timed out.\n");
drivers/input/touchscreen/atmel_mxt_ts.c:		ret = mxt_wait_for_completion(data, &data->bl_completion,
drivers/input/touchscreen/atmel_mxt_ts.c:	complete(&data->crc_completion);
drivers/input/touchscreen/atmel_mxt_ts.c:		complete(&data->reset_completion);
drivers/input/touchscreen/atmel_mxt_ts.c:		/* bootloader state transition completion */
drivers/input/touchscreen/atmel_mxt_ts.c:		complete(&data->bl_completion);
drivers/input/touchscreen/atmel_mxt_ts.c:	reinit_completion(&data->reset_completion);
drivers/input/touchscreen/atmel_mxt_ts.c:	ret = mxt_wait_for_completion(data, &data->reset_completion,
drivers/input/touchscreen/atmel_mxt_ts.c:	reinit_completion(&data->crc_completion);
drivers/input/touchscreen/atmel_mxt_ts.c:	mxt_wait_for_completion(data, &data->crc_completion, MXT_CRC_TIMEOUT);
drivers/input/touchscreen/atmel_mxt_ts.c:	reinit_completion(&data->bl_completion);
drivers/input/touchscreen/atmel_mxt_ts.c:	ret = mxt_wait_for_completion(data, &data->bl_completion,
drivers/input/touchscreen/atmel_mxt_ts.c:	mxt_wait_for_completion(data, &data->bl_completion, MXT_FW_RESET_TIME);
drivers/input/touchscreen/atmel_mxt_ts.c:	init_completion(&data->bl_completion);
drivers/input/touchscreen/atmel_mxt_ts.c:	init_completion(&data->reset_completion);
drivers/input/touchscreen/atmel_mxt_ts.c:	init_completion(&data->crc_completion);
drivers/input/touchscreen/cyttsp_core.h:	struct completion bl_ready;
drivers/input/touchscreen/imx6ul_tsc.c:#include <linux/completion.h>
drivers/input/touchscreen/imx6ul_tsc.c:	struct completion completion;
drivers/input/touchscreen/imx6ul_tsc.c:	reinit_completion(&tsc->completion);
drivers/input/touchscreen/imx6ul_tsc.c:	timeout = wait_for_completion_timeout
drivers/input/touchscreen/imx6ul_tsc.c:			(&tsc->completion, ADC_TIMEOUT);
drivers/input/touchscreen/imx6ul_tsc.c:		complete(&tsc->completion);
drivers/input/touchscreen/imx6ul_tsc.c:	init_completion(&tsc->completion);
drivers/input/touchscreen/sur40.c:#include <linux/completion.h>
drivers/input/misc/cm109.c:		/* URB completion will resubmit */
drivers/input/misc/ims-pcu.c:#include <linux/completion.h>
drivers/input/misc/ims-pcu.c:	struct completion cmd_done;
drivers/input/misc/ims-pcu.c:	struct completion async_firmware_done;
drivers/input/misc/ims-pcu.c:		 * See if we got command completion.
drivers/input/misc/ims-pcu.c:		 * the data and signal completion.
drivers/input/misc/ims-pcu.c:	init_completion(&pcu->cmd_done);
drivers/input/misc/ims-pcu.c:	    !wait_for_completion_timeout(&pcu->cmd_done,
drivers/input/misc/ims-pcu.c:	wait_for_completion(&pcu->async_firmware_done);
drivers/input/misc/ims-pcu.c:	init_completion(&pcu->cmd_done);
drivers/input/misc/ims-pcu.c:	init_completion(&pcu->async_firmware_done);
drivers/input/misc/uinput.c:	init_completion(&request->done);
drivers/input/misc/uinput.c:	wait_for_completion(&request->done);
drivers/input/joystick/iforce/iforce-usb.c:	 * As long as the urb completion handler is not called, the transmiting
drivers/input/mouse/elan_i2c_smbus.c:				       struct completion *fw_completion)
drivers/input/mouse/cyapa_gen6.c:#include <linux/completion.h>
drivers/input/mouse/cyapa.h:	struct completion cmd_ready;
drivers/input/mouse/cyapa_gen5.c:#include <linux/completion.h>
drivers/input/mouse/cyapa_gen5.c:	init_completion(&pip->cmd_ready);
drivers/input/mouse/cyapa_gen5.c:	/* Wait for interrupt to set ready completion */
drivers/input/mouse/cyapa_gen5.c:	init_completion(&pip->cmd_ready);
drivers/input/mouse/cyapa_gen5.c:	timeout = wait_for_completion_timeout(&pip->cmd_ready,
drivers/input/mouse/elan_i2c.h:struct completion;
drivers/input/mouse/elan_i2c.h:				struct completion *reset_done);
drivers/input/mouse/elan_i2c_core.c:#include <linux/completion.h>
drivers/input/mouse/elan_i2c_core.c:	struct completion	fw_completion;
drivers/input/mouse/elan_i2c_core.c:	error = data->ops->finish_fw_update(client, &data->fw_completion);
drivers/input/mouse/elan_i2c_core.c:		complete(&data->fw_completion);
drivers/input/mouse/elan_i2c_core.c:	init_completion(&data->fw_completion);
drivers/input/mouse/elan_i2c_i2c.c:#include <linux/completion.h>
drivers/input/mouse/elan_i2c_i2c.c:				     struct completion *completion)
drivers/input/mouse/elan_i2c_i2c.c:	reinit_completion(completion);
drivers/input/mouse/elan_i2c_i2c.c:		ret = wait_for_completion_interruptible_timeout(completion,
drivers/input/rmi4/rmi_f54.c:	struct completion cmd_done;
drivers/input/rmi4/rmi_f54.c:	init_completion(&f54->cmd_done);
drivers/input/rmi4/rmi_f54.c:		if (!wait_for_completion_timeout(&f54->cmd_done,
drivers/input/tablet/wacom_serial4.c:#include <linux/completion.h>
drivers/input/tablet/wacom_serial4.c:	struct completion cmd_done;
drivers/input/tablet/wacom_serial4.c:	init_completion(&wacom->cmd_done);
drivers/input/tablet/wacom_serial4.c:	u = wait_for_completion_timeout(&wacom->cmd_done, HZ);
drivers/mfd/pcf50633-adc.c:#include <linux/completion.h>
drivers/mfd/pcf50633-adc.c:	struct completion completion;
drivers/mfd/pcf50633-adc.c:	complete(&req->completion);
drivers/mfd/pcf50633-adc.c:	init_completion(&req.completion);
drivers/mfd/pcf50633-adc.c:	wait_for_completion(&req.completion);
drivers/mfd/mc13xxx-core.c:	struct completion done;
drivers/mfd/mc13xxx-core.c:	init_completion(&adcdone_data.done);
drivers/mfd/mc13xxx-core.c:	ret = wait_for_completion_interruptible_timeout(&adcdone_data.done, HZ);
drivers/mfd/twl4030-irq.c: * completion, potentially including some re-ordering, of these requests.
drivers/mfd/rtsx_pcr.c:	struct completion trans_done;
drivers/mfd/rtsx_pcr.c:	init_completion(&trans_done);
drivers/mfd/rtsx_pcr.c:	timeleft = wait_for_completion_interruptible_timeout(
drivers/mfd/rtsx_pcr.c:	struct completion trans_done;
drivers/mfd/rtsx_pcr.c:	init_completion(&trans_done);
drivers/mfd/rtsx_pcr.c:	timeleft = wait_for_completion_interruptible_timeout(
drivers/mfd/rtsx_pcr.c:	struct completion finish;
drivers/mfd/rtsx_pcr.c:	init_completion(&finish);
drivers/mfd/rtsx_pcr.c:	wait_for_completion_interruptible_timeout(&finish,
drivers/mfd/ezx-pcap.c:	struct completion completion;
drivers/mfd/ezx-pcap.c:	complete(&req->completion);
drivers/mfd/ezx-pcap.c:	init_completion(&sync_data.completion);
drivers/mfd/ezx-pcap.c:	wait_for_completion(&sync_data.completion);
drivers/mfd/wm831x-auxadc.c:	struct completion done;
drivers/mfd/wm831x-auxadc.c:	init_completion(&req->done);
drivers/mfd/wm831x-auxadc.c:	wait_for_completion_timeout(&req->done, msecs_to_jiffies(500));
drivers/mfd/qcom_rpm.c:	struct completion ack;
drivers/mfd/qcom_rpm.c:	reinit_completion(&rpm->ack);
drivers/mfd/qcom_rpm.c:	left = wait_for_completion_timeout(&rpm->ack, RPM_REQUEST_TIMEOUT);
drivers/mfd/qcom_rpm.c:	init_completion(&rpm->ack);
drivers/mfd/twl6040.c:	time_left = wait_for_completion_timeout(&twl6040->ready,
drivers/mfd/twl6040.c:	init_completion(&twl6040->ready);
drivers/mfd/dln2.c:	/* completion used to wait for a response */
drivers/mfd/dln2.c:	struct completion done;
drivers/mfd/dln2.c:	reinit_completion(&rxc->done);
drivers/mfd/dln2.c:	ret = wait_for_completion_interruptible_timeout(&rxc->done, timeout);
drivers/mfd/dln2.c:			init_completion(&dln2->mod_rx_slots[i].slots[j].done);
drivers/mfd/wm8350-core.c:	/* If a late IRQ left the completion signalled then consume
drivers/mfd/wm8350-core.c:	 * the completion. */
drivers/mfd/wm8350-core.c:	try_wait_for_completion(&wm8350->auxadc_done);
drivers/mfd/wm8350-core.c:	/* We ignore the result of the completion and just check for a
drivers/mfd/wm8350-core.c:	wait_for_completion_timeout(&wm8350->auxadc_done, msecs_to_jiffies(5));
drivers/mfd/wm8350-core.c:	init_completion(&wm8350->auxadc_done);
drivers/mfd/ucb1x00-ts.c:#include <linux/completion.h>
drivers/mfd/da9052-core.c:	if (!wait_for_completion_timeout(&da9052->done,
drivers/mfd/da9052-core.c:	init_completion(&da9052->done);
drivers/mfd/ab8500-gpadc.c:#include <linux/completion.h>
drivers/mfd/ab8500-gpadc.c: * @ab8500_gpadc_complete:	pointer to the struct completion, to indicate
drivers/mfd/ab8500-gpadc.c: *				the completion of gpadc conversion
drivers/mfd/ab8500-gpadc.c:	struct completion ab8500_gpadc_complete;
drivers/mfd/ab8500-gpadc.c:	unsigned long completion_timeout;
drivers/mfd/ab8500-gpadc.c:		completion_timeout = 2 * HZ;
drivers/mfd/ab8500-gpadc.c:		completion_timeout = msecs_to_jiffies(CONVERSION_TIME);
drivers/mfd/ab8500-gpadc.c:	/* wait for completion of conversion */
drivers/mfd/ab8500-gpadc.c:	if (!wait_for_completion_timeout(&gpadc->ab8500_gpadc_complete,
drivers/mfd/ab8500-gpadc.c:			completion_timeout)) {
drivers/mfd/ab8500-gpadc.c:	 * GPADC status register to go low. In V1.1 there wait_for_completion
drivers/mfd/ab8500-gpadc.c: * ab8500_bm_gpadcconvend_handler() - isr for gpadc conversion completion
drivers/mfd/ab8500-gpadc.c: * This is a interrupt service routine for gpadc conversion completion.
drivers/mfd/ab8500-gpadc.c: * Notifies the gpadc completion is completed and the converted raw value
drivers/mfd/ab8500-gpadc.c:	/* Initialize completion used to notify completion of conversion */
drivers/mfd/ab8500-gpadc.c:	init_completion(&gpadc->ab8500_gpadc_complete);
drivers/mfd/ab8500-gpadc.c:	/* remove interrupt  - completion of Sw ADC conversion */
drivers/mfd/db8500-prcmu.c:#include <linux/completion.h>
drivers/mfd/db8500-prcmu.c:	struct completion ac_wake_work;
drivers/mfd/db8500-prcmu.c: * @work:	The transaction completion structure.
drivers/mfd/db8500-prcmu.c:	struct completion work;
drivers/mfd/db8500-prcmu.c: * @work:            The transaction completion structure.
drivers/mfd/db8500-prcmu.c:	struct completion work;
drivers/mfd/db8500-prcmu.c:	struct completion sysclk_work;
drivers/mfd/db8500-prcmu.c: * @work:	The transaction completion structure.
drivers/mfd/db8500-prcmu.c:	struct completion work;
drivers/mfd/db8500-prcmu.c: * @work:	The transaction completion structure.
drivers/mfd/db8500-prcmu.c:	struct completion work;
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb1_transfer.work);
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb1_transfer.work);
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb1_transfer.work);
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb1_transfer.work);
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb1_transfer.work);
drivers/mfd/db8500-prcmu.c:	if (!wait_for_completion_timeout(&mb2_transfer.work,
drivers/mfd/db8500-prcmu.c:	if (enable && !wait_for_completion_timeout(&mb3_transfer.sysclk_work,
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb4_transfer.work);
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb4_transfer.work);
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb4_transfer.work);
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb4_transfer.work);
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb4_transfer.work);
drivers/mfd/db8500-prcmu.c:	if (!wait_for_completion_timeout(&mb5_transfer.work,
drivers/mfd/db8500-prcmu.c:	if (!wait_for_completion_timeout(&mb5_transfer.work,
drivers/mfd/db8500-prcmu.c:	if (!wait_for_completion_timeout(&mb0_transfer.ac_wake_work,
drivers/mfd/db8500-prcmu.c:	if (!wait_for_completion_timeout(&mb0_transfer.ac_wake_work,
drivers/mfd/db8500-prcmu.c:	wait_for_completion(&mb1_transfer.work);
drivers/mfd/db8500-prcmu.c:	init_completion(&mb0_transfer.ac_wake_work);
drivers/mfd/db8500-prcmu.c:	init_completion(&mb1_transfer.work);
drivers/mfd/db8500-prcmu.c:	init_completion(&mb2_transfer.work);
drivers/mfd/db8500-prcmu.c:	init_completion(&mb3_transfer.sysclk_work);
drivers/mfd/db8500-prcmu.c:	init_completion(&mb4_transfer.work);
drivers/mfd/db8500-prcmu.c:	init_completion(&mb5_transfer.work);
drivers/mfd/si476x-i2c.c: * si476x_core_report_drainer_stop() - mark the completion of the RDS
drivers/mfd/si476x-i2c.c:		/* Unfortunately completions could not be used for
drivers/mfd/si476x-cmd.c:#include <linux/completion.h>
drivers/macintosh/ams/ams-pmu.c:	complete((struct completion *)req->arg);
drivers/macintosh/ams/ams-pmu.c:	wait_for_completion(&req_complete);
drivers/macintosh/ams/ams-pmu.c:	wait_for_completion(&req_complete);
drivers/macintosh/via-pmu.c:	/* Wait for completion of async requests */
drivers/macintosh/adb.c:#include <linux/completion.h>
drivers/macintosh/adb.c:	struct completion *comp = req->arg;
drivers/macintosh/adb.c:	struct completion comp;
drivers/macintosh/adb.c:	/* Synchronous requests block using an on-stack completion */
drivers/macintosh/adb.c:		init_completion(&comp);
drivers/macintosh/adb.c:		wait_for_completion(&comp);
drivers/macintosh/windfarm_smu_controls.c:#include <linux/completion.h>
drivers/macintosh/windfarm_smu_controls.c:	wait_for_completion(&comp);
drivers/macintosh/windfarm_smu_sensors.c:#include <linux/completion.h>
drivers/macintosh/windfarm_smu_sensors.c:	wait_for_completion(&comp);
drivers/macintosh/smu.c:#include <linux/completion.h>
drivers/macintosh/smu.c:	/* Call command completion handler if any */
drivers/macintosh/smu.c:	struct completion *comp = misc;
drivers/macintosh/smu.c:	/* Call command completion handler if any */
drivers/macintosh/smu.c:static void smu_i2c_low_completion(struct smu_cmd *scmd, void *misc)
drivers/macintosh/smu.c:	cmd->scmd.done = smu_i2c_low_completion;
drivers/macintosh/smu.c:		wait_for_completion(&comp);
drivers/macintosh/smu.c:	wait_for_completion(&comp);
drivers/mailbox/mailbox.c:		ret = wait_for_completion_timeout(&chan->tx_complete, wait);
drivers/mailbox/mailbox.c:	init_completion(&chan->tx_complete);
drivers/mailbox/pl320-ipc.c:#include <linux/completion.h>
drivers/mailbox/pl320-ipc.c:static DECLARE_COMPLETION(ipc_completion);
drivers/mailbox/pl320-ipc.c:	init_completion(&ipc_completion);
drivers/mailbox/pl320-ipc.c:	ret = wait_for_completion_timeout(&ipc_completion,
drivers/mailbox/pl320-ipc.c:		complete(&ipc_completion);
drivers/mailbox/omap-mailbox.c:	init_completion(&chan->tx_complete);
drivers/mailbox/pcc.c:	init_completion(&chan->tx_complete);
drivers/gpu/drm/i915/i915_sw_fence.h:struct completion;
drivers/gpu/drm/i915/i915_irq.c:	 * Notify all waiters for GPU completion events that reset state has
drivers/gpu/drm/i915/i915_irq.c:	 * releasing their locks and then wait for the reset completion.
drivers/gpu/drm/i915/intel_breadcrumbs.c:		 * completion check.
drivers/gpu/drm/i915/intel_breadcrumbs.c:			 * exception rather than a seqno completion.
drivers/gpu/drm/i915/intel_frontbuffer.c: * frontbuffer flushing will be delayed until completion is signalled with
drivers/gpu/drm/i915/i915_gem_fence.c: * fences used to track command completion but hardware detiler objects which
drivers/gpu/drm/i915/i915_gem_fence.c:	/* Wait for completion of pending flips which consume fences */
drivers/gpu/drm/i915/i915_gem_request.c:	 * completion order.
drivers/gpu/drm/i915/i915_gem_request.c: * request is not being tracked for completion but the work itself is
drivers/gpu/drm/i915/i915_gem_request.c:	 * rate. By busywaiting on the request completion for a short while we
drivers/gpu/drm/i915/i915_gem_request.c:		 * and then check for completion. On a full reset, the engine's
drivers/gpu/drm/i915/i915_gem_userptr.c:	 * the vma between us binding this page into the GTT and completion
drivers/gpu/drm/i915/intel_ringbuffer.c:		/* Would completion of this request free enough space? */
drivers/gpu/drm/i915/i915_gem_request.h: * signal its completion to the owner through a callback as well as mark
drivers/gpu/drm/i915/i915_gem_request.h: * after completion, the optional callback @func is invoked.
drivers/gpu/drm/i915/i915_gem_request.h: * i915_gem_active_set() watches the given @request for completion. Whilst
drivers/gpu/drm/i915/intel_display.c:	/* Unmask the flip-done completion message. Note that the bspec says that
drivers/gpu/drm/i915/intel_display.c:	 * flip-done completion events and that unmasking all planes at once
drivers/gpu/drm/i915/intel_guc_loader.c: * the value matches either of two values representing completion
drivers/gpu/drm/i915/intel_guc_loader.c:	 * NB: Docs recommend not using the interrupt for completion.
drivers/gpu/drm/i915/i915_gem_evict.c:		/* If we still have pending pageflip completions, drop
drivers/gpu/drm/rcar-du/rcar_du_crtc.h: * @flip_wait: wait queue used to signal page flip completion
drivers/gpu/drm/rcar-du/rcar_du_crtc.c:	 * for page flip completion before stopping the CRTC as userspace
drivers/gpu/drm/rcar-du/rcar_du_plane.c: * updates from .atomic_check() up to completion (when swapping the states if
drivers/gpu/drm/drm_crtc_helper.c:	 * are later needed by vblank and swap-completion
drivers/gpu/drm/msm/edp/edp_aux.c:	struct completion msg_comp;
drivers/gpu/drm/msm/edp/edp_aux.c:	reinit_completion(&aux->msg_comp);
drivers/gpu/drm/msm/edp/edp_aux.c:	DBG("wait_for_completion");
drivers/gpu/drm/msm/edp/edp_aux.c:	time_left = wait_for_completion_timeout(&aux->msg_comp,
drivers/gpu/drm/msm/edp/edp_aux.c:	DBG("completion");
drivers/gpu/drm/msm/edp/edp_aux.c:	init_completion(&aux->msg_comp);
drivers/gpu/drm/msm/edp/edp_ctrl.c:	/* completion and mutex */
drivers/gpu/drm/msm/edp/edp_ctrl.c:	struct completion idle_comp;
drivers/gpu/drm/msm/edp/edp_ctrl.c:	reinit_completion(&ctrl->idle_comp);
drivers/gpu/drm/msm/edp/edp_ctrl.c:	time_left = wait_for_completion_timeout(&ctrl->idle_comp,
drivers/gpu/drm/msm/edp/edp_ctrl.c:	init_completion(&ctrl->idle_comp);
drivers/gpu/drm/msm/dsi/dsi_host.c:	struct completion dma_comp;
drivers/gpu/drm/msm/dsi/dsi_host.c:	struct completion video_comp;
drivers/gpu/drm/msm/dsi/dsi_host.c:	reinit_completion(&msm_host->video_comp);
drivers/gpu/drm/msm/dsi/dsi_host.c:	wait_for_completion_timeout(&msm_host->video_comp,
drivers/gpu/drm/msm/dsi/dsi_host.c:	reinit_completion(&msm_host->dma_comp);
drivers/gpu/drm/msm/dsi/dsi_host.c:		ret = wait_for_completion_timeout(&msm_host->dma_comp,
drivers/gpu/drm/msm/dsi/dsi_host.c:	init_completion(&msm_host->dma_comp);
drivers/gpu/drm/msm/dsi/dsi_host.c:	init_completion(&msm_host->video_comp);
drivers/gpu/drm/msm/mdp/mdp5/mdp5_crtc.c:	struct completion pp_completion;
drivers/gpu/drm/msm/mdp/mdp5/mdp5_crtc.c:	reinit_completion(&mdp5_crtc->pp_completion);
drivers/gpu/drm/msm/mdp/mdp5/mdp5_crtc.c:	complete(&mdp5_crtc->pp_completion);
drivers/gpu/drm/msm/mdp/mdp5/mdp5_crtc.c:	ret = wait_for_completion_timeout(&mdp5_crtc->pp_completion,
drivers/gpu/drm/msm/mdp/mdp5/mdp5_crtc.c:	init_completion(&mdp5_crtc->pp_completion);
drivers/gpu/drm/msm/hdmi/hdmi_hdcp.c:	/* Check if need to wait for HW completion */
drivers/gpu/drm/msm/msm_atomic.c:	 * checked in parallel to the asynchronous completion of the previous
drivers/gpu/drm/drm_dp_mst_topology.c: * Check the payload status bits in the DPCD for ACT handled completion.
drivers/gpu/drm/tilcdc/tilcdc_drv.c:	 * checked in parallel to the asynchronous completion of the previous
drivers/gpu/drm/udl/udl_main.c:void udl_urb_completion(struct urb *urb)
drivers/gpu/drm/udl/udl_main.c:			buf, size, udl_urb_completion, unode);
drivers/gpu/drm/udl/udl_main.c:		udl_urb_completion(urb); /* because no one else will */
drivers/gpu/drm/udl/udl_drv.h:void udl_urb_completion(struct urb *urb);
drivers/gpu/drm/udl/udl_fb.c:		udl_urb_completion(urb);
drivers/gpu/drm/amd/amdgpu/amdgpu_fence.c:			amdgpu_fence_driver_force_completion(adev);
drivers/gpu/drm/amd/amdgpu/amdgpu_fence.c:			amdgpu_fence_driver_force_completion(adev);
drivers/gpu/drm/amd/amdgpu/amdgpu_fence.c: * amdgpu_fence_driver_force_completion - force all fence waiter to complete
drivers/gpu/drm/amd/amdgpu/amdgpu_fence.c:void amdgpu_fence_driver_force_completion(struct amdgpu_device *adev)
drivers/gpu/drm/amd/amdgpu/amdgpu.h:void amdgpu_fence_driver_force_completion(struct amdgpu_device *adev);
drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h:	int deferred_flip_completion;
drivers/gpu/drm/amd/amdgpu/amdgpu_device.c:	/* after all hw jobs are reset, hw fence is meaningless, so force_completion */
drivers/gpu/drm/amd/amdgpu/amdgpu_device.c:	amdgpu_fence_driver_force_completion(adev);
drivers/gpu/drm/amd/amdkfd/kfd_packet_manager.c:			interrupt_sel__mes_query_status__completion_status;
drivers/gpu/drm/amd/amdkfd/kfd_pm4_headers.h:	interrupt_sel__mes_query_status__completion_status = 0,
drivers/gpu/drm/amd/amdkfd/kfd_pm4_headers_vi.h:	interrupt_sel__mes_query_status__completion_status = 0,
drivers/gpu/drm/vgem/vgem_fence.c: * completion. Note that if a conflicting fence is already on the dma-buf (i.e.
drivers/gpu/drm/sti/sti_drv.c:	 * checked in parallel to the asynchronous completion of the previous
drivers/gpu/drm/etnaviv/etnaviv_gpu.c:	init_completion(&gpu->event_free);
drivers/gpu/drm/etnaviv/etnaviv_gpu.c:	ret = wait_for_completion_timeout(&gpu->event_free,
drivers/gpu/drm/etnaviv/etnaviv_gpu.c:		dev_err(gpu->dev, "wait_for_completion_timeout failed");
drivers/gpu/drm/etnaviv/etnaviv_gpu.c:		/* No timeout was requested: just test for completion */
drivers/gpu/drm/etnaviv/etnaviv_gpu.h:	struct completion event_free;
drivers/gpu/drm/rockchip/inno_hdmi.c:	struct completion cmp;
drivers/gpu/drm/rockchip/inno_hdmi.c:	ret = wait_for_completion_timeout(&hdmi->i2c->cmp, HZ / 10);
drivers/gpu/drm/rockchip/inno_hdmi.c:	reinit_completion(&hdmi->i2c->cmp);
drivers/gpu/drm/rockchip/inno_hdmi.c:	init_completion(&i2c->cmp);
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:	struct completion dsp_hold_completion;
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:	struct completion line_flag_completion;
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:	reinit_completion(&vop->dsp_hold_completion);
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:	wait_for_completion(&vop->dsp_hold_completion);
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:		reinit_completion(&vop->dsp_hold_completion);
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:		wait_for_completion(&vop->dsp_hold_completion);
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:	 * signalling flip completion we need to wait for it to finish.
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:		complete(&vop->dsp_hold_completion);
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:		complete(&vop->line_flag_completion);
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:	init_completion(&vop->dsp_hold_completion);
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:	init_completion(&vop->line_flag_completion);
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:	reinit_completion(&vop->line_flag_completion);
drivers/gpu/drm/rockchip/rockchip_drm_vop.c:	jiffies_left = wait_for_completion_timeout(&vop->line_flag_completion,
drivers/gpu/drm/vc4/vc4_kms.c:	 * checked in parallel to the asynchronous completion of the previous
drivers/gpu/drm/drm_irq.c: * needed by vblank and swap-completion timestamping, e.g,
drivers/gpu/drm/drm_irq.c: * commit sequence has run to completion. If the hardware does not have such a
drivers/gpu/drm/tegra/drm.c:	 * checked in parallel to the asynchronous completion of the previous
drivers/gpu/drm/tegra/dpaux.c:	struct completion complete;
drivers/gpu/drm/tegra/dpaux.c:	status = wait_for_completion_timeout(&dpaux->complete, timeout);
drivers/gpu/drm/tegra/dpaux.c:	init_completion(&dpaux->complete);
drivers/gpu/drm/drm_atomic_helper.c:	 * checked in parallel to the asynchronous completion of the previous
drivers/gpu/drm/drm_atomic_helper.c:			completed = try_wait_for_completion(&commit->flip_done);
drivers/gpu/drm/drm_atomic_helper.c:	ret = wait_for_completion_interruptible_timeout(&stall_commit->cleanup_done,
drivers/gpu/drm/drm_atomic_helper.c:		init_completion(&commit->flip_done);
drivers/gpu/drm/drm_atomic_helper.c:		init_completion(&commit->hw_done);
drivers/gpu/drm/drm_atomic_helper.c:		init_completion(&commit->cleanup_done);
drivers/gpu/drm/drm_atomic_helper.c:		crtc_state->event->base.completion = &commit->flip_done;
drivers/gpu/drm/drm_atomic_helper.c:		ret = wait_for_completion_timeout(&commit->hw_done,
drivers/gpu/drm/drm_atomic_helper.c:		ret = wait_for_completion_timeout(&commit->flip_done,
drivers/gpu/drm/drm_atomic_helper.c: * This function is used to signal completion of the hardware commit step. After
drivers/gpu/drm/drm_atomic_helper.c: * drm_atomic_helper_commit_cleanup_done - signal completion of commit
drivers/gpu/drm/drm_atomic_helper.c: * This signals completion of the atomic update @state, including any cleanup
drivers/gpu/drm/drm_atomic_helper.c:		WARN_ON(!try_wait_for_completion(&commit->hw_done));
drivers/gpu/drm/drm_atomic_helper.c:		if (try_wait_for_completion(&commit->flip_done))
drivers/gpu/drm/drm_atomic_helper.c:		/* We must wait for the vblank event to signal our completion
drivers/gpu/drm/drm_atomic_helper.c:		ret = wait_for_completion_timeout(&commit->flip_done,
drivers/gpu/drm/drm_atomic_helper.c:			ret = wait_for_completion_timeout(&commit->hw_done,
drivers/gpu/drm/drm_atomic_helper.c: * @event: optional DRM event to signal upon completion
drivers/gpu/drm/gma500/psb_reg.h: * Scheduler completion actions.
drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c:	struct completion complete;
drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c:	reinit_completion(&i2c_dev->complete);
drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c:		wait_for_completion_interruptible_timeout(&i2c_dev->complete,
drivers/gpu/drm/gma500/oaktrail_hdmi_i2c.c:	init_completion(&i2c_dev->complete);
drivers/gpu/drm/omapdrm/omap_dmm_priv.h:	struct completion compl;
drivers/gpu/drm/omapdrm/displays/encoder-tpd12s015.c:#include <linux/completion.h>
drivers/gpu/drm/omapdrm/omap_dmm_tiler.c:#include <linux/completion.h>
drivers/gpu/drm/omapdrm/omap_dmm_tiler.c:	reinit_completion(&engine->compl);
drivers/gpu/drm/omapdrm/omap_dmm_tiler.c:	/* verify that the irq handler sees the 'async' and completion value */
drivers/gpu/drm/omapdrm/omap_dmm_tiler.c:		if (!wait_for_completion_timeout(&engine->compl,
drivers/gpu/drm/omapdrm/omap_dmm_tiler.c:		init_completion(&omap_dmm->engines[i].compl);
drivers/gpu/drm/omapdrm/omap_drv.c:static void omap_atomic_wait_for_completion(struct drm_device *dev,
drivers/gpu/drm/omapdrm/omap_drv.c:	omap_atomic_wait_for_completion(dev, old_state);
drivers/gpu/drm/omapdrm/dss/venc.c:#include <linux/completion.h>
drivers/gpu/drm/omapdrm/dss/dsi.c:	struct completion *completion;
drivers/gpu/drm/omapdrm/dss/dsi.c:static void dsi_completion_handler(void *data, u32 mask)
drivers/gpu/drm/omapdrm/dss/dsi.c:	complete((struct completion *)data);
drivers/gpu/drm/omapdrm/dss/dsi.c:		complete(vp_data->completion);
drivers/gpu/drm/omapdrm/dss/dsi.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/gpu/drm/omapdrm/dss/dsi.c:		.completion = &completion
drivers/gpu/drm/omapdrm/dss/dsi.c:	/* Wait for completion only if TE_EN/TE_START is still set */
drivers/gpu/drm/omapdrm/dss/dsi.c:		if (wait_for_completion_timeout(&completion,
drivers/gpu/drm/omapdrm/dss/dsi.c:		complete(l4_data->completion);
drivers/gpu/drm/omapdrm/dss/dsi.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/gpu/drm/omapdrm/dss/dsi.c:		.completion = &completion
drivers/gpu/drm/omapdrm/dss/dsi.c:	/* Wait for completion only if TX_FIFO_NOT_EMPTY is still set */
drivers/gpu/drm/omapdrm/dss/dsi.c:		if (wait_for_completion_timeout(&completion,
drivers/gpu/drm/omapdrm/dss/dsi.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/gpu/drm/omapdrm/dss/dsi.c:	r = dsi_register_isr_vc(dsidev, channel, dsi_completion_handler,
drivers/gpu/drm/omapdrm/dss/dsi.c:			&completion, DSI_VC_IRQ_BTA);
drivers/gpu/drm/omapdrm/dss/dsi.c:	r = dsi_register_isr(dsidev, dsi_completion_handler, &completion,
drivers/gpu/drm/omapdrm/dss/dsi.c:	if (wait_for_completion_timeout(&completion,
drivers/gpu/drm/omapdrm/dss/dsi.c:	dsi_unregister_isr(dsidev, dsi_completion_handler, &completion,
drivers/gpu/drm/omapdrm/dss/dsi.c:	dsi_unregister_isr_vc(dsidev, channel, dsi_completion_handler,
drivers/gpu/drm/omapdrm/dss/dsi.c:			&completion, DSI_VC_IRQ_BTA);
drivers/gpu/drm/omapdrm/dss/dsi.c:	DECLARE_COMPLETION_ONSTACK(completion);
drivers/gpu/drm/omapdrm/dss/dsi.c:	r = dsi_register_isr_cio(dsidev, dsi_completion_handler, &completion,
drivers/gpu/drm/omapdrm/dss/dsi.c:	if (wait_for_completion_timeout(&completion,
drivers/gpu/drm/omapdrm/dss/dsi.c:	dsi_unregister_isr_cio(dsidev, dsi_completion_handler, &completion,
drivers/gpu/drm/omapdrm/dss/dsi.c:	dsi_unregister_isr_cio(dsidev, dsi_completion_handler, &completion,
drivers/gpu/drm/drm_fops.c: * page flip completions by the KMS API. But drivers can also use it for their
drivers/gpu/drm/drm_fops.c: * own needs, e.g. to signal completion of rendering.
drivers/gpu/drm/drm_fops.c: * Since events are used by the KMS API for vblank and page flip completion this
drivers/gpu/drm/drm_fops.c: * Since events are used by the KMS API for vblank and page flip completion this
drivers/gpu/drm/drm_fops.c: * using drm_send_event() or drm_send_event_locked() to signal completion of the
drivers/gpu/drm/drm_fops.c: * using drm_send_event() or drm_send_event_locked() to signal completion of the
drivers/gpu/drm/drm_fops.c: * completion of the asynchronous work unconditionally.
drivers/gpu/drm/drm_fops.c:	if (e->completion) {
drivers/gpu/drm/drm_fops.c:		/* ->completion might disappear as soon as it signalled. */
drivers/gpu/drm/drm_fops.c:		complete_all(e->completion);
drivers/gpu/drm/drm_fops.c:		e->completion = NULL;
drivers/gpu/drm/drm_fops.c: * completion of the asynchronous work unconditionally.
drivers/gpu/drm/nouveau/nvkm/engine/disp/dport.c:	/* signal completion and enable link interrupt handling */
drivers/gpu/drm/nouveau/nvkm/engine/disp/piocgf119.c:	/* disable error reporting and completion notification */
drivers/gpu/drm/nouveau/nvkm/engine/disp/dmacgf119.c:	/* disable error reporting and completion notification */
drivers/gpu/drm/nouveau/nvkm/engine/disp/dmacnv50.c:	/* disable error reporting and completion notifications */
drivers/gpu/drm/nouveau/nvkm/engine/disp/corenv50.c:	/* disable error reporting and completion notifications */
drivers/gpu/drm/nouveau/nvkm/engine/disp/coregf119.c:	/* disable error reporting and completion notification */
drivers/gpu/drm/nouveau/nvkm/engine/gr/fuc/hub.fuc:// fall through to main loop after completion.
drivers/gpu/drm/nouveau/nvkm/engine/gr/fuc/hub.fuc://	     31:31: set to signal completion
drivers/gpu/drm/nouveau/nvkm/engine/gr/fuc/gpc.fuc:// fall through to main loop after completion.
drivers/gpu/drm/nouveau/nvkm/engine/gr/fuc/gpc.fuc://	     31:31: set to signal completion
drivers/gpu/drm/nouveau/nvkm/engine/gr/fuc/gpc.fuc:// Set this GPC's bit in HUB_BAR, used to signal completion of various
drivers/gpu/drm/nouveau/nvkm/engine/gr/fuc/gpc.fuc:	// mark completion in HUB's barrier
drivers/gpu/drm/nouveau/nvkm/subdev/clk/gm20b.c:	 * wait for completion, and use results along with default slope to
drivers/gpu/drm/nouveau/nvkm/subdev/pmu/fuc/memx.fuc:	// send completion reply
drivers/gpu/drm/nouveau/nouveau_display.c:	/* enable flip completion events */
drivers/gpu/drm/nouveau/nouveau_display.c:	/* disable flip completion events */
drivers/gpu/drm/nouveau/nouveau_drv.h: *      - fixes multiple bugs in flip completion events and timestamping
drivers/gpu/drm/radeon/radeon_display.c:	/* Skip the pageflip completion check below (based on polling) on
drivers/gpu/drm/radeon/radeon_display.c:	 * asics which reliably support hw pageflip completion irqs. pflip
drivers/gpu/drm/radeon/radeon_display.c:	 * completion detection. A use_pflipirq module parameter < 2 allows
drivers/gpu/drm/radeon/radeon_display.c:	 * Note that this method of completion handling is still not 100% race
drivers/gpu/drm/radeon/radeon_display.c:	 * vblank, leading to a delayed emission of the flip completion event.
drivers/gpu/drm/radeon/radeon_display.c:	 * flip completion handling from vblank irq, as these old asics don't
drivers/gpu/drm/radeon/radeon_display.c:	 * have reliable pageflip completion interrupts.
drivers/gpu/drm/radeon/radeon_drv.c:MODULE_PARM_DESC(use_pflipirq, "Pflip irqs for pageflip completion (0 = disable, 1 = as fallback, 2 = exclusive (default))");
drivers/gpu/drm/radeon/radeon_device.c:			radeon_fence_driver_force_completion(rdev, i);
drivers/gpu/drm/radeon/radeon_device.c:			radeon_fence_driver_force_completion(rdev, i);
drivers/gpu/drm/radeon/radeon_ib.c:			radeon_fence_driver_force_completion(rdev, i);
drivers/gpu/drm/radeon/radeon_dp_auxch.c:		DRM_ERROR("auxch hw never signalled completion, error %08x\n", tmp);
drivers/gpu/drm/radeon/radeon_fence.c:			radeon_fence_driver_force_completion(rdev, ring);
drivers/gpu/drm/radeon/radeon_fence.c: * radeon_fence_driver_force_completion - force all fence waiter to complete
drivers/gpu/drm/radeon/radeon_fence.c:void radeon_fence_driver_force_completion(struct radeon_device *rdev, int ring)
drivers/gpu/drm/radeon/radeon.h:void radeon_fence_driver_force_completion(struct radeon_device *rdev, int ring);
drivers/gpu/drm/exynos/exynos_drm_ipp.h: * @start_complete: completion of start of command.
drivers/gpu/drm/exynos/exynos_drm_ipp.h: * @stop_complete: completion of stop of command.
drivers/gpu/drm/exynos/exynos_drm_ipp.h:	struct completion	start_complete;
drivers/gpu/drm/exynos/exynos_drm_ipp.h:	struct completion	stop_complete;
drivers/gpu/drm/exynos/exynos_drm_g2d.c:	struct completion	complete;
drivers/gpu/drm/exynos/exynos_drm_g2d.c:			 * pool to be released after the dma access completion.
drivers/gpu/drm/exynos/exynos_drm_g2d.c:	 * The engine is busy and the completion of the current node is going
drivers/gpu/drm/exynos/exynos_drm_g2d.c:	init_completion(&runqueue_node->complete);
drivers/gpu/drm/exynos/exynos_drm_g2d.c:	wait_for_completion(&runqueue_node->complete);
drivers/gpu/drm/exynos/exynos_drm_ipp.c:	init_completion(&c_node->start_complete);
drivers/gpu/drm/exynos/exynos_drm_ipp.c:	init_completion(&c_node->stop_complete);
drivers/gpu/drm/exynos/exynos_drm_ipp.c:		if (!wait_for_completion_timeout(&c_node->stop_complete,
drivers/gpu/drm/exynos/exynos_drm_ipp.c:		if (!wait_for_completion_timeout(&c_node->stop_complete,
drivers/gpu/drm/exynos/exynos_drm_ipp.c:		 * M2M case supports wait_completion of transfer.
drivers/gpu/drm/exynos/exynos_drm_ipp.c:		 * M2M need to wait completion of data transfer.
drivers/gpu/drm/exynos/exynos_drm_ipp.c:			if (!wait_for_completion_timeout
drivers/gpu/drm/exynos/exynos_drm_ipp.c:		goto err_completion;
drivers/gpu/drm/exynos/exynos_drm_ipp.c:		goto err_completion;
drivers/gpu/drm/exynos/exynos_drm_ipp.c:err_completion:
drivers/gpu/drm/exynos/exynos_drm_dsi.c:	struct completion completed;
drivers/gpu/drm/exynos/exynos_drm_dsi.c:	struct completion completed;
drivers/gpu/drm/exynos/exynos_drm_dsi.c:	if (wait_for_completion_timeout(&dsi->completed, msecs_to_jiffies(300)))
drivers/gpu/drm/exynos/exynos_drm_dsi.c:	reinit_completion(&dsi->completed);
drivers/gpu/drm/exynos/exynos_drm_dsi.c:	init_completion(&xfer->completed);
drivers/gpu/drm/exynos/exynos_drm_dsi.c:	wait_for_completion_timeout(&xfer->completed,
drivers/gpu/drm/exynos/exynos_drm_dsi.c:	init_completion(&dsi->completed);
drivers/gpu/drm/mediatek/mtk_disp_ovl.c:	/* Clear frame completion interrupt */
drivers/gpu/drm/mediatek/mtk_disp_rdma.c:	/* Clear frame completion interrupt */
drivers/gpu/drm/vmwgfx/vmwgfx_surface.c: * The backup buffer will be fenced or idle upon successful completion,
drivers/gpu/host1x/cdma.h:	struct host1x_syncpt *syncpt;	/* buffer completion syncpt */
drivers/gpu/ipu-v3/ipu-image-convert.c:	struct completion aborted;
drivers/gpu/ipu-v3/ipu-image-convert.c:		/* call the completion callback and free the run */
drivers/gpu/ipu-v3/ipu-image-convert.c: * completion handler for each.
drivers/gpu/ipu-v3/ipu-image-convert.c: * try to force the completion of runs for this ctx. Called when
drivers/gpu/ipu-v3/ipu-image-convert.c:	init_completion(&ctx->aborted);
drivers/gpu/ipu-v3/ipu-image-convert.c:	reinit_completion(&ctx->aborted);
drivers/gpu/ipu-v3/ipu-image-convert.c:		"%s: task %u: wait for completion: %d runs, active run %p\n",
drivers/gpu/ipu-v3/ipu-image-convert.c:	ret = wait_for_completion_timeout(&ctx->aborted,
drivers/gpu/ipu-v3/ipu-image-convert.c:	struct completion *comp = data;
drivers/gpu/ipu-v3/ipu-image-convert.c:	struct completion comp;
drivers/gpu/ipu-v3/ipu-image-convert.c:	init_completion(&comp);
drivers/gpu/ipu-v3/ipu-image-convert.c:	ret = wait_for_completion_timeout(&comp, msecs_to_jiffies(10000));
drivers/gpu/ipu-v3/ipu-dc.c:	struct completion	comp;
drivers/gpu/ipu-v3/ipu-dc.c:	init_completion(&priv->comp);
drivers/gpu/ipu-v3/ipu-dc.c:	ret = wait_for_completion_timeout(&priv->comp, msecs_to_jiffies(50));
drivers/remoteproc/qcom_wcnss.c:	struct completion start_done;
drivers/remoteproc/qcom_wcnss.c:	struct completion stop_done;
drivers/remoteproc/qcom_wcnss.c:	ret = wait_for_completion_timeout(&wcnss->start_done,
drivers/remoteproc/qcom_wcnss.c:		ret = wait_for_completion_timeout(&wcnss->stop_done,
drivers/remoteproc/qcom_wcnss.c:	init_completion(&wcnss->start_done);
drivers/remoteproc/qcom_wcnss.c:	init_completion(&wcnss->stop_done);
drivers/remoteproc/remoteproc_core.c:	init_completion(&rproc->firmware_loading_complete);
drivers/remoteproc/remoteproc_core.c:	init_completion(&rproc->crash_comp);
drivers/remoteproc/remoteproc_core.c:	wait_for_completion(&rproc->crash_comp);
drivers/remoteproc/remoteproc_core.c: * @wait: wait for rproc registration completion
drivers/remoteproc/remoteproc_core.c:		wait_for_completion(&rproc->firmware_loading_complete);
drivers/remoteproc/remoteproc_core.c: * Same as rproc_boot() but don't wait for rproc registration completion
drivers/remoteproc/remoteproc_core.c:	init_completion(&rproc->crash_comp);
drivers/remoteproc/remoteproc_core.c:	wait_for_completion(&rproc->firmware_loading_complete);
drivers/remoteproc/qcom_q6v5_pil.c:	struct completion start_done;
drivers/remoteproc/qcom_q6v5_pil.c:	struct completion stop_done;
drivers/remoteproc/qcom_q6v5_pil.c:	ret = wait_for_completion_timeout(&qproc->start_done,
drivers/remoteproc/qcom_q6v5_pil.c:	ret = wait_for_completion_timeout(&qproc->stop_done,
drivers/remoteproc/qcom_q6v5_pil.c:	init_completion(&qproc->start_done);
drivers/remoteproc/qcom_q6v5_pil.c:	init_completion(&qproc->stop_done);
drivers/thunderbolt/nhi_regs.h:	RING_DESC_INTERRUPT = 0x8, /* request an interrupt on completion */
drivers/thunderbolt/ctl.c:	struct completion response_ready;
drivers/thunderbolt/ctl.c:	if (!wait_for_completion_timeout(&ctl->response_ready,
drivers/thunderbolt/ctl.c:	init_completion(&ctl->response_ready);
drivers/block/paride/pcd.c:	1.02    GRG 1998.05.06  Changes to pcd_completion, ready_wait,
drivers/block/paride/pcd.c:				pcd_completion, use HZ in loop timing
drivers/block/paride/pcd.c:static int pcd_completion(struct pcd_unit *cd, char *buf, char *fun)
drivers/block/paride/pcd.c:		      fun, "completion")) {
drivers/block/paride/pcd.c:			     "completion")) {
drivers/block/paride/pcd.c:		pcd_completion(cd, buf, "Request sense");
drivers/block/paride/pcd.c:		r = pcd_completion(cd, buf, fun);
drivers/block/paride/pcd.c:	if (pcd_completion(pcd_current, pcd_buffer, "read block")) {
drivers/block/paride/pg.c:static int pg_completion(struct pg *dev, char *buf, unsigned long tmo)
drivers/block/paride/pg.c:		    tmo, "completion");
drivers/block/paride/pg.c:			    tmo, "completion");
drivers/block/paride/pg.c:	s = pg_completion(dev, buf, jiffies + PG_TMO);
drivers/block/paride/pg.c:	if (pg_completion(dev, dev->bufptr, dev->timeout))
drivers/block/paride/pf.c:				Small change in pf_completion to round
drivers/block/paride/pf.c:static int pf_completion(struct pf_unit *pf, char *buf, char *fun)
drivers/block/paride/pf.c:		    fun, "completion");
drivers/block/paride/pf.c:		pf_completion(pf, buf, "Request sense");
drivers/block/paride/pf.c:		r = pf_completion(pf, buf, fun);
drivers/block/paride/pf.c:			    "read block", "completion") & STAT_ERR) {
drivers/block/paride/pt.c:static int pt_completion(struct pt_unit *tape, char *buf, char *fun)
drivers/block/paride/pt.c:		    fun, "completion");
drivers/block/paride/pt.c:		pt_completion(tape, buf, "Request sense");
drivers/block/paride/pt.c:		r = pt_completion(tape, buf, fun);
drivers/block/loop.c:#include <linux/completion.h>
drivers/block/loop.c:	struct completion wait;
drivers/block/loop.c: * Do the actual switch; called from the BIO completion routine
drivers/block/loop.c: * BIO down the pipe. The completion of this BIO does the actual switch.
drivers/block/loop.c:	/* freeze queue and wait for completion of scheduled requests */
drivers/block/ataflop.c:#include <linux/completion.h>
drivers/block/ataflop.c:	wait_for_completion(&format_wait);
drivers/block/amiflop.c:static DECLARE_COMPLETION(motor_on_completion);
drivers/block/amiflop.c:static DECLARE_COMPLETION(ms_wait_completion);
drivers/block/amiflop.c:	complete(&ms_wait_completion);
drivers/block/amiflop.c:		wait_for_completion(&ms_wait_completion);
drivers/block/amiflop.c:		complete_all(&motor_on_completion);
drivers/block/amiflop.c:		reinit_completion(&motor_on_completion);
drivers/block/amiflop.c:		wait_for_completion(&motor_on_completion);
drivers/block/xen-blkfront.c:	 * completion more easy to handle even if the block I/O request is
drivers/block/xen-blkfront.c:static bool blkif_completion(unsigned long *id,
drivers/block/xen-blkfront.c:		 * to make the completion code simpler.
drivers/block/xen-blkfront.c:			if (!blkif_completion(&id, rinfo, bret))
drivers/block/xsysace.c:	struct completion id_completion;	/* used when id req finishes */
drivers/block/xsysace.c:			complete(&ace->id_completion);
drivers/block/xsysace.c:			complete(&ace->id_completion);
drivers/block/xsysace.c:		wait_for_completion(&ace->id_completion);
drivers/block/xsysace.c:	init_completion(&ace->id_completion);
drivers/block/skd_main.c:#include <linux/completion.h>
drivers/block/skd_main.c:	struct fit_completion_entry_v1 completion;
drivers/block/skd_main.c:	struct fit_completion_entry_v1 *skcomp_table;
drivers/block/skd_main.c:	struct work_struct completion_worker;
drivers/block/skd_main.c:		 * going to get anymore completions, so recover requests now
drivers/block/skd_main.c:				 volatile struct fit_completion_entry_v1
drivers/block/skd_main.c:	pr_debug("%s:%s:%d %s:  completion rc %d\n",
drivers/block/skd_main.c:		/* For a timeout, we must fabricate completion and sense
drivers/block/skd_main.c:		sksgio->skspcl->req.completion.status =
drivers/block/skd_main.c:	u32 nb = be32_to_cpu(skspcl->req.completion.num_returned_bytes);
drivers/block/skd_main.c:	sgp->status = skspcl->req.completion.status;
drivers/block/skd_main.c:				  volatile struct fit_completion_entry_v1
drivers/block/skd_main.c:	skspcl->req.completion = *skcomp;
drivers/block/skd_main.c:	status = skspcl->req.completion.status;
drivers/block/skd_main.c:			       volatile struct fit_completion_entry_v1 *skcomp,
drivers/block/skd_main.c:	u8 cmp_status = skreq->completion.status;
drivers/block/skd_main.c:			       volatile struct fit_completion_entry_v1 *skcomp,
drivers/block/skd_main.c:			       volatile struct fit_completion_entry_v1 *skcomp,
drivers/block/skd_main.c:			      volatile struct fit_completion_entry_v1 *skcomp,
drivers/block/skd_main.c:				 volatile struct fit_completion_entry_v1
drivers/block/skd_main.c:static int skd_isr_completion_posted(struct skd_device *skdev,
drivers/block/skd_main.c:	volatile struct fit_completion_entry_v1 *skcmp = NULL;
drivers/block/skd_main.c:			pr_debug("%s:%s:%d end of completions\n",
drivers/block/skd_main.c:		 * Update the completion queue head index and possibly
drivers/block/skd_main.c:		 * the completion cycle count. 8-bit wrap-around.
drivers/block/skd_main.c:			 * This is not a completion for a r/w request.
drivers/block/skd_main.c:		skreq->completion = *skcmp;
drivers/block/skd_main.c:			       volatile struct fit_completion_entry_v1 *skcomp,
drivers/block/skd_main.c:	 * Based on the request id, determine how to dispatch this completion.
drivers/block/skd_main.c:	 * completion entry. Errors are reported below the switch.
drivers/block/skd_main.c:		 * The caller, skd_completion_posted_isr() above,
drivers/block/skd_main.c:		 * These id's should never appear in a completion record.
drivers/block/skd_main.c:				 volatile struct fit_completion_entry_v1
drivers/block/skd_main.c:	skspcl->req.completion = *skcomp;
drivers/block/skd_main.c:	skd_log_check_status(skdev, skspcl->req.completion.status, skerr->key,
drivers/block/skd_main.c:	struct fit_completion_entry_v1 *skcomp;
drivers/block/skd_main.c:static void skd_completion_worker(struct work_struct *work)
drivers/block/skd_main.c:		container_of(work, struct skd_device, completion_worker);
drivers/block/skd_main.c:	skd_isr_completion_posted(skdev, 0, &flush_enqueued);
drivers/block/skd_main.c:		 * done any processing, call completion handler?
drivers/block/skd_main.c:			/* No interrupts on device, but run the completion
drivers/block/skd_main.c:				 * If we have already deferred completion
drivers/block/skd_main.c:						skd_isr_completion_posted(skdev,
drivers/block/skd_main.c:		schedule_work(&skdev->completion_worker);
drivers/block/skd_main.c:		 * a completion that didn't come, and now it will never come)
drivers/block/skd_main.c:	deferred = skd_isr_completion_posted(skdev, skd_isr_comp_limit,
drivers/block/skd_main.c:		schedule_work(&skdev->completion_worker);
drivers/block/skd_main.c:	struct fit_completion_entry_v1 *skcomp;
drivers/block/skd_main.c:	INIT_WORK(&skdev->completion_worker, skd_completion_worker);
drivers/block/skd_main.c:		/* MSIX completion handler is being used for coredump */
drivers/block/cciss.h:	struct completion scan_wait;
drivers/block/cciss.h:	 * Performant mode completion buffer
drivers/block/skd_s1120.h: * Used to set completion queue address (FIT_MTD_SET_COMPQ_ADDR)
drivers/block/skd_s1120.h: * Format of a completion entry. The completion queue is circular
drivers/block/skd_s1120.h: * infer the presence of new completion records.
drivers/block/skd_s1120.h: * the cycle value to expect is 1. When completions are added
drivers/block/skd_s1120.h: *  Protocol major version 1 completion entry.
drivers/block/skd_s1120.h:struct fit_completion_entry_v1 {
drivers/block/DAC960.c:#include <linux/completion.h>
drivers/block/DAC960.c:  DAC960_ExecuteCommand executes Command and waits for completion.
drivers/block/DAC960.c:  wait_for_completion(&Completion);
drivers/block/DAC960.c:  Command and waits for completion.  It returns true on success and false
drivers/block/DAC960.c:  Command and waits for completion.  It returns true on success and false
drivers/block/DAC960.c:  Command and waits for completion.  It returns true on success and false
drivers/block/DAC960.c:  Reading IOCTL Command and waits for completion.  It returns true on success
drivers/block/DAC960.c:  Information Reading IOCTL Command and waits for completion.  It returns
drivers/block/DAC960.c:  Device Information Reading IOCTL Command and waits for completion.  It
drivers/block/DAC960.c:  Physical Device Information" IOCTL Command and waits for completion.  It
drivers/block/DAC960.c:  Target id, Logical Unit Number.  This function Waits for completion
drivers/block/DAC960.c:  Operation IOCTL Command and waits for completion.  It returns true on
drivers/block/DAC960.c:  struct completion Completions[DAC960_V1_MaxChannels];
drivers/block/DAC960.c:          struct completion *Completion = &Completions[Channel];
drivers/block/DAC960.c:	  init_completion(Completion);
drivers/block/DAC960.c:          struct completion *Completion = &Completions[Channel];
drivers/block/DAC960.c:	  wait_for_completion(Completion);
drivers/block/DAC960.c:	  wait_for_completion(Completion);
drivers/block/DAC960.c:  DAC960_ProcessCompletedBuffer performs completion processing for an
drivers/block/DAC960.c:  DAC960_V1_ProcessCompletedCommand performs completion processing for Command
drivers/block/DAC960.c:      bool normal_completion;
drivers/block/DAC960.c:        Perform completion processing for the portion that was
drivers/block/DAC960.c:      normal_completion = true;
drivers/block/DAC960.c:        normal_completion = false;
drivers/block/DAC960.c:	      normal_completion = false;
drivers/block/DAC960.c:      if (!DAC960_ProcessCompletedRequest(Command, normal_completion)) {
drivers/block/DAC960.c:  DAC960_V2_ProcessCompletedCommand performs completion processing for Command
drivers/block/DAC960.c:	    Perform completion processing for all buffers in this I/O Request.
drivers/block/DAC960.c:      bool normal_completion;
drivers/block/DAC960.c:        Perform completion processing for the portion that was
drivers/block/DAC960.c:      normal_completion = true;
drivers/block/DAC960.c:	normal_completion = false;
drivers/block/DAC960.c:	      normal_completion = false;
drivers/block/DAC960.c:      if (!DAC960_ProcessCompletedRequest(Command, normal_completion)) {
drivers/block/DAC960.h:  struct completion *Completion;
drivers/block/rbd.c:	OBJ_REQ_DONE,		/* completion flag: not done = 0, done = 1 */
drivers/block/rbd.c:	struct completion	completion;
drivers/block/rbd.c:	spinlock_t		completion_lock;/* protects next_completion */
drivers/block/rbd.c:	u32			next_completion;
drivers/block/rbd.c:	ret = wait_for_completion_interruptible_timeout(
drivers/block/rbd.c:					&obj_request->completion,
drivers/block/rbd.c:		complete_all(&obj_request->completion);
drivers/block/rbd.c:	init_completion(&obj_request->completion);
drivers/block/rbd.c:	spin_lock_init(&img_request->completion_lock);
drivers/block/rbd.c:	img_request->next_completion = 0;
drivers/block/rbd.c:	spin_lock_irq(&img_request->completion_lock);
drivers/block/rbd.c:	if (which != img_request->next_completion)
drivers/block/rbd.c:	img_request->next_completion = which;
drivers/block/rbd.c:	spin_unlock_irq(&img_request->completion_lock);
drivers/block/xen-blkback/xenbus.c:	init_completion(&blkif->drain_complete);
drivers/block/xen-blkback/blkback.c:		wait_for_completion_interruptible_timeout(
drivers/block/xen-blkback/common.h:	struct completion	drain_complete;
drivers/block/cciss_scsi.c:#include <linux/completion.h>
drivers/block/cciss_scsi.c:	wait_for_completion(&wait);
drivers/block/cciss_scsi.c:	cmd->scsi_done = done;    // save this for use by completion code 
drivers/block/aoe/aoe.h:	struct completion rendez;
drivers/block/aoe/aoechr.c:#include <linux/completion.h>
drivers/block/aoe/aoechr.c:static struct completion emsgs_comp;
drivers/block/aoe/aoechr.c:		n = wait_for_completion_interruptible(&emsgs_comp);
drivers/block/aoe/aoechr.c:	init_completion(&emsgs_comp);
drivers/block/aoe/aoecmd.c: * doing I/O completion.  It is not important that the cap equal the
drivers/block/aoe/aoecmd.c:/* io completion queue */
drivers/block/aoe/aoecmd.c:	wait_for_completion(&k->rendez);
drivers/block/aoe/aoecmd.c:	init_completion(&k->rendez);
drivers/block/aoe/aoecmd.c:	wait_for_completion(&k->rendez); /* allow kthread to start */
drivers/block/aoe/aoecmd.c:	init_completion(&k->rendez);	/* for waiting for exit later */
drivers/block/sunvdc.c:#include <linux/completion.h>
drivers/block/sunvdc.c:	struct vdc_completion	*cmp;
drivers/block/sunvdc.c:	struct vio_completion comp;
drivers/block/sunvdc.c:	init_completion(&comp.com);
drivers/block/sunvdc.c:		wait_for_completion(&comp.com);
drivers/block/sunvdc.c:	struct vio_completion comp;
drivers/block/sunvdc.c:	init_completion(&comp.com);
drivers/block/sunvdc.c:	wait_for_completion(&comp.com);
drivers/block/sx8.c:#include <linux/completion.h>
drivers/block/sx8.c:	struct completion		probe_comp;
drivers/block/sx8.c:	init_completion(&host->probe_comp);
drivers/block/sx8.c:	wait_for_completion(&host->probe_comp);
drivers/block/ps3vram.c:#define NOTIFIER 7	/* notifier used for completion report */
drivers/block/cciss_cmd.h:  struct completion *waiting;
drivers/block/mtip32xx/mtip32xx.c: * IO completion function.
drivers/block/mtip32xx/mtip32xx.c: * This completion function is called by the driver ISR when a
drivers/block/mtip32xx/mtip32xx.c: * asynchronous completion function which normally calls back into the block
drivers/block/mtip32xx/mtip32xx.c: * Internal command completion callback function.
drivers/block/mtip32xx/mtip32xx.c: * command completed. This function signals the command completion by
drivers/block/mtip32xx/mtip32xx.c: * @data   Pointer to a completion structure.
drivers/block/mtip32xx/mtip32xx.c:static void mtip_completion(struct mtip_port *port,
drivers/block/mtip32xx/mtip32xx.c:	struct completion *waiting = command->comp_data;
drivers/block/mtip32xx/mtip32xx.c:static void mtip_null_completion(struct mtip_port *port,
drivers/block/mtip32xx/mtip32xx.c:					"Missing completion func for tag %d",
drivers/block/mtip32xx/mtip32xx.c:					"Bad completion for tag %d\n",
drivers/block/mtip32xx/mtip32xx.c:					"Null completion for tag %d",
drivers/block/mtip32xx/mtip32xx.c: * Execute an internal command and wait for the completion.
drivers/block/mtip32xx/mtip32xx.c:		/* Set the completion function and data for the command. */
drivers/block/mtip32xx/mtip32xx.c:		int_cmd->comp_func = mtip_completion;
drivers/block/mtip32xx/mtip32xx.c:		/* Clear completion - we're going to poll */
drivers/block/mtip32xx/mtip32xx.c:		int_cmd->comp_func = mtip_null_completion;
drivers/block/mtip32xx/mtip32xx.c:		if ((rv = wait_for_completion_interruptible_timeout(
drivers/block/mtip32xx/mtip32xx.c: * return value -EFAULT An error occurred while copying the completion
drivers/block/mtip32xx/mtip32xx.c:	/* Collect the completion status. */
drivers/block/mtip32xx/mtip32xx.c: * to the device. Upon completion, the callback function will
drivers/block/mtip32xx/mtip32xx.c:	 * Set the completion function and data for the command
drivers/block/mtip32xx/mtip32xx.c:		"FTL rebuild in progress. Polling for completion.\n");
drivers/block/mtip32xx/mtip32xx.h:	void *comp_data; /* data passed to completion function comp_func() */
drivers/block/mtip32xx/mtip32xx.h:	 * Completion function called by the ISR upon completion of
drivers/block/floppy.c:#include <linux/completion.h>
drivers/block/floppy.c:static int fd_wait_for_completion(unsigned long expires,
drivers/block/floppy.c:	return fd_wait_for_completion(jiffies + 2UL * HZ / 100, floppy_ready);
drivers/block/floppy.c:		 * again just before spinup completion. Beware that
drivers/block/floppy.c:		if (fd_wait_for_completion(ready_date, function))
drivers/block/floppy.c:	/* wait_for_completion also schedules reset if needed. */
drivers/block/floppy.c:	return fd_wait_for_completion(DRS->select_date + DP->select_delay,
drivers/block/floppy.c:	struct completion complete;
drivers/block/floppy.c:	init_completion(&cbdata.complete);
drivers/block/floppy.c:	wait_for_completion(&cbdata.complete);
drivers/block/pktcdvd.c: * wait for completion.
drivers/block/cciss_scsi.h:for command completion because they might get commands from the
drivers/block/rsxx/cregs.c:#include <linux/completion.h>
drivers/block/rsxx/cregs.c:struct creg_completion {
drivers/block/rsxx/cregs.c:	struct completion	*cmd_done;
drivers/block/rsxx/cregs.c:	struct creg_completion *cmd_completion;
drivers/block/rsxx/cregs.c:	cmd_completion = cmd->cb_private;
drivers/block/rsxx/cregs.c:	BUG_ON(!cmd_completion);
drivers/block/rsxx/cregs.c:	cmd_completion->st = st;
drivers/block/rsxx/cregs.c:	cmd_completion->creg_status = cmd->status;
drivers/block/rsxx/cregs.c:	complete(cmd_completion->cmd_done);
drivers/block/rsxx/cregs.c:	struct creg_completion completion;
drivers/block/rsxx/cregs.c:	completion.cmd_done = &cmd_done;
drivers/block/rsxx/cregs.c:	completion.st = 0;
drivers/block/rsxx/cregs.c:	completion.creg_status = 0;
drivers/block/rsxx/cregs.c:			    &completion);
drivers/block/rsxx/cregs.c:	st = wait_for_completion_timeout(completion.cmd_done, timeout);
drivers/block/rsxx/cregs.c:	*hw_stat = completion.creg_status;
drivers/block/rsxx/cregs.c:	if (completion.st) {
drivers/block/rsxx/cregs.c:			completion.st, addr);
drivers/block/rsxx/cregs.c:		return completion.st;
drivers/block/null_blk.c:MODULE_PARM_DESC(irqmode, "IRQ completion handler. 0-none, 1-softirq, 2-timer");
drivers/block/null_blk.c:static unsigned long completion_nsec = 10000;
drivers/block/null_blk.c:module_param(completion_nsec, ulong, S_IRUGO);
drivers/block/null_blk.c:MODULE_PARM_DESC(completion_nsec, "Time in ns to complete a request in hardware. Default: 10,000ns");
drivers/block/null_blk.c:	ktime_t kt = ktime_set(0, completion_nsec);
drivers/block/drbd/drbd_receiver.c:	struct completion door_bell;
drivers/block/drbd/drbd_receiver.c:	err = wait_for_completion_interruptible_timeout(&ad->door_bell, timeo);
drivers/block/drbd/drbd_receiver.c: * then wait for all completions.
drivers/block/drbd/drbd_receiver.c:	struct completion done;
drivers/block/drbd/drbd_receiver.c:		init_completion(&ctx.done);
drivers/block/drbd/drbd_receiver.c:			wait_for_completion(&ctx.done);
drivers/block/drbd/drbd_receiver.c:		/* wait for all pending IO completions, before we start
drivers/block/drbd/drbd_debugfs.c:			req = list_first_entry_or_null(&device->pending_master_completion[1],
drivers/block/drbd/drbd_debugfs.c:				struct drbd_request, req_pending_master_completion);
drivers/block/drbd/drbd_debugfs.c:		r1 = list_first_entry_or_null(&device->pending_master_completion[i],
drivers/block/drbd/drbd_debugfs.c:			struct drbd_request, req_pending_master_completion);
drivers/block/drbd/drbd_debugfs.c:		r2 = list_first_entry_or_null(&device->pending_completion[i],
drivers/block/drbd/drbd_state.h:					  struct completion *done);
drivers/block/drbd/drbd_int.h:	struct completion stop;
drivers/block/drbd/drbd_int.h:	 * or, after local IO completion, the ERR_PTR(error).
drivers/block/drbd/drbd_int.h:	/* epoch: used to check on "completion" whether this req was in
drivers/block/drbd/drbd_int.h:	struct list_head req_pending_master_completion;
drivers/block/drbd/drbd_int.h:	 *  master_completion_jif
drivers/block/drbd/drbd_int.h:	 *  local_completion_jif
drivers/block/drbd/drbd_int.h:	atomic_t completion_ref;
drivers/block/drbd/drbd_int.h:	atomic_t local_cnt;	 /* Waiting for local completion */
drivers/block/drbd/drbd_int.h:	struct list_head pending_master_completion[2];
drivers/block/drbd/drbd_int.h:	struct list_head pending_completion[2];
drivers/block/drbd/drbd_int.h: * drbd_chk_io_error: Handle the on_io_error setting, should be called from all io completion handlers
drivers/block/drbd/drbd_int.h: * @error:	 Error code passed to the IO completion callback
drivers/block/drbd/drbd_req.h: *    and completion will be signalled to the originator,
drivers/block/drbd/drbd_req.h:	 *    UNUSED, we could map: 011: submitted, completion still pending
drivers/block/drbd/drbd_req.h:	 * 1001: Aborted (before completion)
drivers/block/drbd/drbd_req.h:/* completion of master bio is outside of our spinlock.
drivers/block/drbd/drbd_req.h: * of the lower level driver completion callback, so we need to
drivers/block/drbd/drbd_state.c:	struct completion *done;
drivers/block/drbd/drbd_state.c:	struct completion done;
drivers/block/drbd/drbd_state.c:	init_completion(&done);
drivers/block/drbd/drbd_state.c:		wait_for_completion(&done);
drivers/block/drbd/drbd_state.c: * @done:	Optional completion, that will get completed after the after_state_ch() finished
drivers/block/drbd/drbd_state.c:	        enum chg_state_flags flags, struct completion *done)
drivers/block/drbd/drbd_state.c:			/* Immediately allow completion of all application IO,
drivers/block/drbd/drbd_state.c:			 * that waits for completion from the local disk,
drivers/block/drbd/drbd_nl.c:	 * wait_on_completion_killable(), will mistake our pending signal
drivers/block/drbd/drbd_worker.c:	 * If this io completion runs after that timeout expired, this
drivers/block/drbd/drbd_worker.c:	 * completion, or we may (in drbd_al_read_log()) cycle so fast into the
drivers/block/drbd/drbd_worker.c:void drbd_panic_after_delayed_completion_of_aborted_request(struct drbd_device *device)
drivers/block/drbd/drbd_worker.c:	panic("drbd%u %s/%u potential random memory corruption caused by delayed completion of aborted local request\n",
drivers/block/drbd/drbd_worker.c:	 * complete requests at all, not even do error completions.  In this
drivers/block/drbd/drbd_worker.c:	 * By "aborting", basically faking a local error-completion,
drivers/block/drbd/drbd_worker.c:	 * Which means delayed successful completion,
drivers/block/drbd/drbd_worker.c:	 * We assume that a delayed *error* completion is OK,
drivers/block/drbd/drbd_worker.c:			drbd_emerg(device, "delayed completion of aborted local request; disk-timeout may be too aggressive\n");
drivers/block/drbd/drbd_worker.c:			drbd_panic_after_delayed_completion_of_aborted_request(device);
drivers/block/drbd/drbd_actlog.c:	bio_get(bio); /* one bio_put() is in the completion handler */
drivers/block/drbd/drbd_actlog.c:	atomic_inc(&device->md_io.in_use); /* drbd_md_put_buffer() is in the completion handler */
drivers/block/drbd/drbd_actlog.c:				 * delayed local completion of an application write),
drivers/block/drbd/drbd_interval.h:	unsigned int waiting:1;		/* someone is waiting for completion */
drivers/block/drbd/drbd_main.c:		init_completion(&thi->stop);
drivers/block/drbd/drbd_main.c:		init_completion(&thi->stop);
drivers/block/drbd/drbd_main.c:		wait_for_completion(&thi->stop);
drivers/block/drbd/drbd_main.c: * But this means that in protocol A we might signal IO completion too early!
drivers/block/drbd/drbd_main.c:	INIT_LIST_HEAD(&device->pending_master_completion[0]);
drivers/block/drbd/drbd_main.c:	INIT_LIST_HEAD(&device->pending_master_completion[1]);
drivers/block/drbd/drbd_main.c:	INIT_LIST_HEAD(&device->pending_completion[0]);
drivers/block/drbd/drbd_main.c:	INIT_LIST_HEAD(&device->pending_completion[1]);
drivers/block/drbd/drbd_main.c:			expect(atomic_read(&req->completion_ref) == 0) &&
drivers/block/drbd/drbd_main.c:			drbd_err(device, "req=%p completion_ref=%d rq_state=%x\n",
drivers/block/drbd/drbd_main.c:				req, atomic_read(&req->completion_ref),
drivers/block/drbd/drbd_main.c:		 * "completion_ref" going zero in the code path that queued it
drivers/block/drbd/drbd_main.c:/* called via drbd_req_put_completion_ref(),
drivers/block/drbd/drbd_main.c:struct completion_work {
drivers/block/drbd/drbd_main.c:	struct completion done;
drivers/block/drbd/drbd_main.c:	struct completion_work *completion_work =
drivers/block/drbd/drbd_main.c:		container_of(w, struct completion_work, w);
drivers/block/drbd/drbd_main.c:	complete(&completion_work->done);
drivers/block/drbd/drbd_main.c:	struct completion_work completion_work;
drivers/block/drbd/drbd_main.c:	completion_work.w.cb = w_complete;
drivers/block/drbd/drbd_main.c:	init_completion(&completion_work.done);
drivers/block/drbd/drbd_main.c:	drbd_queue_work(work_queue, &completion_work.w);
drivers/block/drbd/drbd_main.c:	wait_for_completion(&completion_work.done);
drivers/block/drbd/drbd_req.c:	INIT_LIST_HEAD(&req->req_pending_master_completion);
drivers/block/drbd/drbd_req.c:	atomic_set(&req->completion_ref, 1);
drivers/block/drbd/drbd_req.c:	/* one kref as long as completion_ref > 0 */
drivers/block/drbd/drbd_req.c:		atomic_read(&req->completion_ref) ||
drivers/block/drbd/drbd_req.c:		drbd_err(device, "drbd_req_destroy: Logic BUG rq_state = 0x%x, completion_ref = %d\n",
drivers/block/drbd/drbd_req.c:				s, atomic_read(&req->completion_ref));
drivers/block/drbd/drbd_req.c:		 * to the local io completion callback drbd_request_endio.
drivers/block/drbd/drbd_req.c:	 *	the bio_endio completion callbacks.
drivers/block/drbd/drbd_req.c:	 * local completion error, if any, has been stored as ERR_PTR
drivers/block/drbd/drbd_req.c:	/* Before we can signal completion to the upper layers,
drivers/block/drbd/drbd_req.c:	list_del_init(&req->req_pending_master_completion);
drivers/block/drbd/drbd_req.c:static int drbd_req_put_completion_ref(struct drbd_request *req, struct bio_and_error *m, int put)
drivers/block/drbd/drbd_req.c:	if (!atomic_sub_and_test(put, &req->completion_ref))
drivers/block/drbd/drbd_req.c: * req->completion_ref and req->kref. */
drivers/block/drbd/drbd_req.c:		atomic_inc(&req->completion_ref);
drivers/block/drbd/drbd_req.c:		atomic_inc(&req->completion_ref);
drivers/block/drbd/drbd_req.c:		atomic_inc(&req->completion_ref);
drivers/block/drbd/drbd_req.c:		atomic_inc(&req->completion_ref);
drivers/block/drbd/drbd_req.c:		/* local completion may still come in later,
drivers/block/drbd/drbd_req.c:		k_put += drbd_req_put_completion_ref(req, m, c_put);
drivers/block/drbd/drbd_req.c:		   (or the local completion?) was missing when we suspended.
drivers/block/drbd/drbd_req.c:	list_add_tail(&req->req_pending_master_completion,
drivers/block/drbd/drbd_req.c:			&device->pending_master_completion[1 /* WRITE */]);
drivers/block/drbd/drbd_req.c:	if (list_empty(&req->req_pending_master_completion))
drivers/block/drbd/drbd_req.c:		list_add_tail(&req->req_pending_master_completion,
drivers/block/drbd/drbd_req.c:			&device->pending_master_completion[rw == WRITE]);
drivers/block/drbd/drbd_req.c:			&device->pending_completion[rw == WRITE]);
drivers/block/drbd/drbd_req.c:		 * So we can not simply free it, we must go through drbd_req_put_completion_ref() */
drivers/block/drbd/drbd_req.c:	if (drbd_req_put_completion_ref(req, &m, 1))
drivers/block/drbd/drbd_req.c:	 * we hold a completion ref, and the request cannot disappear.
drivers/block/drbd/drbd_req.c:	req_read = list_first_entry_or_null(&device->pending_completion[0], struct drbd_request, req_pending_local);
drivers/block/drbd/drbd_req.c:	req_write = list_first_entry_or_null(&device->pending_completion[1], struct drbd_request, req_pending_local);
drivers/block/cciss.c:#include <linux/completion.h>
drivers/block/cciss.c:	wait_for_completion_interruptible(&h->scan_wait);
drivers/block/cciss.c:	wait_for_completion(&wait);
drivers/block/cciss.c:	wait_for_completion(&wait);
drivers/block/cciss.c:	CommandList_struct *c = rq->completion_data;
drivers/block/cciss.c:	/* Don't wait for completion, the reset won't complete.  Don't free
drivers/block/cciss.c:	wait_for_completion(&wait);
drivers/block/cciss.c:		reinit_completion(&wait);
drivers/block/cciss.c: * the Q to wait for completion.
drivers/block/cciss.c:	cmd->rq->completion_data = cmd;
drivers/block/cciss.c:static inline unsigned long get_next_completion(ctlr_info_t *h)
drivers/block/cciss.c:/* process completion of an indexed ("direct lookup") command */
drivers/block/cciss.c:/* process completion of a non-indexed command */
drivers/block/cciss.c: * Only need to check for this in the cciss_xxx_discard_completions
drivers/block/cciss.c:static irqreturn_t cciss_intx_discard_completions(int irq, void *dev_id)
drivers/block/cciss.c:		raw_tag = get_next_completion(h);
drivers/block/cciss.c:static irqreturn_t cciss_msix_discard_completions(int irq, void *dev_id)
drivers/block/cciss.c:	raw_tag = get_next_completion(h);
drivers/block/cciss.c:		raw_tag = get_next_completion(h);
drivers/block/cciss.c:	raw_tag = get_next_completion(h);
drivers/block/cciss.c:		reinit_completion(&h->scan_wait);
drivers/block/cciss.c:		wait_for_completion(&h->scan_wait);
drivers/block/cciss.c:	init_completion(&h->scan_wait);
drivers/block/cciss.c:		/* This is kind of gross.  We may or may not get a completion
drivers/block/cciss.c:		 * after the reset throwing away any completions we get during
drivers/block/cciss.c:		 * fake ones to scoop up any residual completions.
drivers/block/cciss.c:		rc = cciss_request_irq(h, cciss_msix_discard_completions,
drivers/block/cciss.c:					cciss_intx_discard_completions);
drivers/block/cciss.c:			"Waiting for stale completions to drain.\n");
drivers/dax/pmem.c:	struct completion cmp;
drivers/dax/pmem.c:	wait_for_completion(&dax_pmem->cmp);
drivers/dax/pmem.c:	init_completion(&dax_pmem->cmp);
drivers/hwtracing/coresight/coresight-tmc.c:		"timeout while waiting for completion of Manual Flush\n");
drivers/hwtracing/coresight/coresight-etb10.c:		"timeout while waiting for completion of Manual Flush\n");
drivers/edac/edac_core.h:#include <linux/completion.h>
drivers/edac/edac_core.h:	struct completion removal_complete;
drivers/edac/edac_core.h:	struct completion complete;
drivers/edac/edac_core.h:	struct completion kobj_complete;
fs/btrfs/qgroup.h:int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info,
fs/btrfs/volumes.h:	struct completion flush_wait;
fs/btrfs/volumes.h:	struct completion kobj_unregister;
fs/btrfs/ioctl.c:	return btrfs_qgroup_wait_for_completion(root->fs_info, true);
fs/btrfs/compression.c:	/* do io completion on the original bio */
fs/btrfs/qgroup.c:	btrfs_qgroup_wait_for_completion(fs_info, false);
fs/btrfs/qgroup.c:	complete_all(&fs_info->qgroup_rescan_completion);
fs/btrfs/qgroup.c:	init_completion(&fs_info->qgroup_rescan_completion);
fs/btrfs/qgroup.c:int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info,
fs/btrfs/qgroup.c:		ret = wait_for_completion_interruptible(
fs/btrfs/qgroup.c:					&fs_info->qgroup_rescan_completion);
fs/btrfs/qgroup.c:		wait_for_completion(&fs_info->qgroup_rescan_completion);
fs/btrfs/raid56.c:	 * This is a special bio which is used to hold the completion handler
fs/btrfs/raid56.c:	 * This is a special bio which is used to hold the completion handler
fs/btrfs/extent-tree.c:	struct completion wait;
fs/btrfs/extent-tree.c:	init_completion(&async->wait);
fs/btrfs/extent-tree.c:		wait_for_completion(&async->wait);
fs/btrfs/extent-tree.c: * elements, 1 is returned to signal completion of the search.
fs/btrfs/sysfs.c:#include <linux/completion.h>
fs/btrfs/sysfs.c:		wait_for_completion(&fs_devs->kobj_unregister);
fs/btrfs/sysfs.c:	init_completion(&fs_devs->kobj_unregister);
fs/btrfs/inode.c: * At IO completion time the cums attached on the ordered extent record
fs/btrfs/inode.c: * At IO completion time the cums attached on the ordered extent record
fs/btrfs/inode.c: * at IO completion time based on sums calculated at bio submission time.
fs/btrfs/inode.c: * where the in-ram extents might be locked pending data=ordered completion.
fs/btrfs/inode.c:	struct completion done;
fs/btrfs/inode.c:		init_completion(&done.done);
fs/btrfs/inode.c:		wait_for_completion(&done.done);
fs/btrfs/inode.c:		init_completion(&done.done);
fs/btrfs/inode.c:		wait_for_completion(&done.done);
fs/btrfs/inode.c:	complete(&delalloc_work->completion);
fs/btrfs/inode.c:	init_completion(&work->completion);
fs/btrfs/inode.c:	wait_for_completion(&work->completion);
fs/btrfs/ctree.h:#include <linux/completion.h>
fs/btrfs/ctree.h:	struct btrfs_workqueue *scrub_wr_completion_workers;
fs/btrfs/ctree.h:	struct completion qgroup_rescan_completion;
fs/btrfs/ctree.h:	struct completion completion;
fs/btrfs/ordered-data.h:	struct completion completion;
fs/btrfs/disk-io.c:		wait_for_completion(&device->flush_wait);
fs/btrfs/disk-io.c:	init_completion(&device->flush_wait);
fs/btrfs/disk-io.c:	btrfs_qgroup_wait_for_completion(fs_info, false);
fs/btrfs/disk-io.c:	 * This will just short circuit the ordered completion stuff which will
fs/btrfs/ordered-data.c:	init_completion(&entry->completion);
fs/btrfs/ordered-data.c:	complete(&ordered->completion);
fs/btrfs/ordered-data.c:		wait_for_completion(&ordered->completion);
fs/btrfs/ordered-data.c: * in the extent, and it waits on the io completion code to insert
fs/btrfs/super.c:	btrfs_workqueue_set_max(fs_info->scrub_wr_completion_workers,
fs/btrfs/check-integrity.c: *        written since then and the write completion callback
fs/btrfs/scrub.c:	struct completion event;
fs/btrfs/scrub.c:	init_completion(&done.event);
fs/btrfs/scrub.c:	wait_for_completion(&done.event);
fs/btrfs/scrub.c:	btrfs_queue_work(fs_info->scrub_wr_completion_workers, &sbio->work);
fs/btrfs/scrub.c:	/* last one frees, either here or in bio completion for last page */
fs/btrfs/scrub.c:	/* last one frees, either here or in bio completion for last page */
fs/btrfs/scrub.c:	 * completion. During readahead, the scrub is officially paused
fs/btrfs/scrub.c:		 * write requests that are submitted in the read completion
fs/btrfs/scrub.c:		fs_info->scrub_wr_completion_workers =
fs/btrfs/scrub.c:		if (!fs_info->scrub_wr_completion_workers)
fs/btrfs/scrub.c:			goto fail_scrub_wr_completion_workers;
fs/btrfs/scrub.c:	btrfs_destroy_workqueue(fs_info->scrub_wr_completion_workers);
fs/btrfs/scrub.c:fail_scrub_wr_completion_workers:
fs/btrfs/scrub.c:		btrfs_destroy_workqueue(fs_info->scrub_wr_completion_workers);
fs/mpage.c: * I/O completion handler for multipage BIOs.
fs/mpage.c: * Why is this?  If a page's completion depends on a number of different BIOs
fs/jffs2/README.Locking:upon write completion (jffs2_complete_reservation()). Note that
fs/jffs2/README.Locking:erase_completion_lock), etc.
fs/jffs2/README.Locking:	erase_completion_lock spinlock
fs/jffs2/README.Locking:As the MTD API no longer permits erase-completion callback functions
fs/jffs2/README.Locking:erase_completion_lock. So you can walk the list only while holding the
fs/jffs2/README.Locking:erase_completion_lock, and can drop the lock temporarily mid-walk as
fs/jffs2/README.Locking:The erase_completion_lock is also used to protect the c->gc_task
fs/jffs2/README.Locking:	If both erase_completion_lock and inocache_lock are needed, the
fs/jffs2/README.Locking:	c->erase_completion has to be acquired first.
fs/jffs2/README.Locking:erase_completion_lock cannot be held, so an alternative, more
fs/jffs2/background.c:#include <linux/completion.h>
fs/jffs2/background.c:	assert_spin_locked(&c->erase_completion_lock);
fs/jffs2/background.c:	init_completion(&c->gc_thread_start);
fs/jffs2/background.c:	init_completion(&c->gc_thread_exit);
fs/jffs2/background.c:		wait_for_completion(&c->gc_thread_start);
fs/jffs2/background.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/background.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/background.c:		wait_for_completion(&c->gc_thread_exit);
fs/jffs2/background.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/background.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/background.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/background.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/background.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/summary.c:			spin_lock(&c->erase_completion_lock);
fs/jffs2/summary.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/summary.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/summary.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/summary.c:	__must_hold(&c->erase_completion_block)
fs/jffs2/summary.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/summary.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/wbuf.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/wbuf.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/wbuf.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/wbuf.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/wbuf.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/wbuf.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/wbuf.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/wbuf.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/wbuf.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/readinode.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/readinode.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/readinode.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/readinode.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/readinode.c:			spin_lock(&c->erase_completion_lock);
fs/jffs2/readinode.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/readinode.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/readinode.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/readinode.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/readinode.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/scan.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/scan.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/erase.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/erase.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/erase.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/erase.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/erase.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/erase.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/erase.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/erase.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/erase.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/erase.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/erase.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/erase.c:			spin_lock(&c->erase_completion_lock);
fs/jffs2/erase.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/erase.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/erase.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/erase.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/erase.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/erase.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/erase.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:/* Called with erase_completion_lock held */
fs/jffs2/gc.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/gc.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/gc.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/gc.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:	/* We need to hold the inocache. Either the erase_completion_lock or
fs/jffs2/gc.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/gc.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/gc.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/gc.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/fs.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/fs.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/super.c:	spin_lock_init(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	if (atomic_dec_and_lock(&xd->refcnt, &c->erase_completion_lock)) {
fs/jffs2/xattr.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/xattr.c:					spin_lock(&c->erase_completion_lock);
fs/jffs2/xattr.c:					spin_unlock(&c->erase_completion_lock);
fs/jffs2/xattr.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/xattr.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/xattr.c:	/* must be called under spin_lock(&c->erase_completion_lock) */
fs/jffs2/xattr.c:	/* must be called under spin_lock(&c->erase_completion_lock) */
fs/jffs2/nodemgmt.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:				spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:				spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:				spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:					spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:					spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:			spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:			spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:/* Called with alloc sem _and_ erase_completion_lock */
fs/jffs2/nodemgmt.c:				spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:				spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:			   we hold c->erase_completion_lock in the majority of this function...
fs/jffs2/nodemgmt.c:			spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:			spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:			spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:		   jffs2_raw_node_ref without the erase_completion_lock. */
fs/jffs2/nodemgmt.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:		spin_lock(&c->erase_completion_lock);
fs/jffs2/nodemgmt.c:		spin_unlock(&c->erase_completion_lock);
fs/jffs2/debug.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/debug.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/debug.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/debug.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/debug.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/debug.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/debug.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/debug.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/debug.c:	spin_lock(&c->erase_completion_lock);
fs/jffs2/debug.c:	spin_unlock(&c->erase_completion_lock);
fs/jffs2/jffs2_fs_sb.h:#include <linux/completion.h>
fs/jffs2/jffs2_fs_sb.h:	struct completion gc_thread_start; /* GC thread start completion */
fs/jffs2/jffs2_fs_sb.h:	struct completion gc_thread_exit; /* GC thread exit completion port */
fs/jffs2/jffs2_fs_sb.h:	spinlock_t erase_completion_lock;	/* Protect free_list and erasing_list
fs/jffs2/jffs2_fs_sb.h:						   against erase completion handler */
fs/jffs2/jffs2_fs_sb.h:	   drop the erase_completion_lock while it's holding a pointer
fs/ecryptfs/crypto.c:	struct completion completion;
fs/ecryptfs/crypto.c:	complete(&ecr->completion);
fs/ecryptfs/crypto.c:	init_completion(&ecr.completion);
fs/ecryptfs/crypto.c:		wait_for_completion(&ecr->completion);
fs/ecryptfs/crypto.c:		reinit_completion(&ecr->completion);
fs/ecryptfs/kthread.c:	struct completion done;
fs/ecryptfs/kthread.c:	init_completion(&req.done);
fs/ecryptfs/kthread.c:	wait_for_completion(&req.done);
fs/ext4/page-io.c:/* BIO completion function for page writeback */
fs/ext4/page-io.c:		 * atomically as bio completions can be racing against each
fs/ext4/inline.c:	 * completion of syscall, but too many callers depend
fs/ext4/sysfs.c:	init_completion(&sbi->s_kobj_unregister);
fs/ext4/inode.c:	 * unwritten extents to written on IO completion. We allocate io_end
fs/ext4/inode.c:	 * our completion callback in 'private' argument.
fs/ext4/inode.c:		set_buffer_defer_completion(bh_result);
fs/ext4/ext4_jbd2.h: * I/O completion handler, and this conflicts with the jbd's use of
fs/ext4/super.c:	wait_for_completion(&sbi->s_kobj_unregister);
fs/ext4/namei.c:	 * completion of syscall, but too many callers depend
fs/ext4/mballoc.c:	/* wait for I/O completion */
fs/ext4/mballoc.c:	 * Wait for completion of call_rcu()'s on ext4_pspace_cachep
fs/ext4/readpage.c: * I/O completion handler for multipage BIOs.
fs/ext4/readpage.c: * Why is this?  If a page's completion depends on a number of different BIOs
fs/ext4/ext4.h:	struct completion s_kobj_unregister;
fs/ext4/ext4.h:	struct completion f_kobj_unregister;
fs/dlm/recover.c:			   lvb/VALNOTVALID is presented in the completion */
fs/dlm/user.c:	   for cases where a completion ast is received for an operation that
fs/dlm/lockspace.c:	init_completion(&ls->ls_members_done);
fs/dlm/lockspace.c:	wait_for_completion(&ls->ls_members_done);
fs/dlm/dlm_internal.h: * the caller's lksb.sb_flags prior to the dlm_lock/dlm_unlock completion
fs/dlm/dlm_internal.h:	struct completion	ls_members_done;
fs/gfs2/bmap.c:#include <linux/completion.h>
fs/gfs2/meta_io.c:#include <linux/completion.h>
fs/gfs2/lock_dlm.c:	wait_for_completion(&ls->ls_sync_wait);
fs/gfs2/lock_dlm.c:	wait_for_completion(&ls->ls_sync_wait);
fs/gfs2/lock_dlm.c:	init_completion(&ls->ls_sync_wait);
fs/gfs2/trans.c:#include <linux/completion.h>
fs/gfs2/util.c:#include <linux/completion.h>
fs/gfs2/util.c:			wait_for_completion(&sdp->sd_wdack);
fs/gfs2/sys.c:#include <linux/completion.h>
fs/gfs2/sys.c:	int val = completion_done(&sdp->sd_wdack) ? 1 : 0;
fs/gfs2/sys.c:	rv = wait_for_completion_killable(&sdp->sd_locking_init);
fs/gfs2/sys.c:	wait_for_completion(&sdp->sd_journal_ready);
fs/gfs2/sys.c:	rv = wait_for_completion_killable(&sdp->sd_locking_init);
fs/gfs2/aops.c:#include <linux/completion.h>
fs/gfs2/inode.c:#include <linux/completion.h>
fs/gfs2/incore.h:#include <linux/completion.h>
fs/gfs2/incore.h:	struct completion ls_sync_wait; /* {control,mounted}_{lock,unlock} */
fs/gfs2/incore.h:	struct completion sd_locking_init;
fs/gfs2/incore.h:	struct completion sd_wdack;
fs/gfs2/incore.h:	struct completion sd_journal_ready;
fs/gfs2/quota.c:#include <linux/completion.h>
fs/gfs2/rgrp.c:#include <linux/completion.h>
fs/gfs2/dentry.c:#include <linux/completion.h>
fs/gfs2/super.c:#include <linux/completion.h>
fs/gfs2/ops_fstype.c:#include <linux/completion.h>
fs/gfs2/ops_fstype.c:	init_completion(&sdp->sd_locking_init);
fs/gfs2/ops_fstype.c:	init_completion(&sdp->sd_wdack);
fs/gfs2/ops_fstype.c:	init_completion(&sdp->sd_journal_ready);
fs/gfs2/lops.c:#include <linux/completion.h>
fs/gfs2/xattr.c:#include <linux/completion.h>
fs/gfs2/export.c:#include <linux/completion.h>
fs/gfs2/acl.c:#include <linux/completion.h>
fs/gfs2/file.c:#include <linux/completion.h>
fs/gfs2/log.c:#include <linux/completion.h>
fs/gfs2/glops.c:#include <linux/completion.h>
fs/gfs2/main.c:#include <linux/completion.h>
fs/gfs2/recovery.c:#include <linux/completion.h>
fs/ceph/inode.c:			/* set dir completion flag? */
fs/ceph/addr.c: * async writeback completion handler.
fs/ceph/locks.c:static int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,
fs/ceph/locks.c:		req->r_wait_for_completion = ceph_lock_wait_for_completion;
fs/ceph/locks.c:static int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,
fs/ceph/locks.c:	err = wait_for_completion_interruptible(&req->r_completion);
fs/ceph/locks.c:	dout("ceph_lock_wait_for_completion: request %llu was interrupted\n",
fs/ceph/locks.c:	wait_for_completion(&req->r_completion);
fs/ceph/super.h:#include <linux/completion.h>
fs/ceph/mds_client.c:	complete_all(&req->r_safe_completion);
fs/ceph/mds_client.c:	init_completion(&req->r_completion);
fs/ceph/mds_client.c:	init_completion(&req->r_safe_completion);
fs/ceph/mds_client.c:		complete_all(&req->r_completion);
fs/ceph/mds_client.c:	if (!req->r_timeout && req->r_wait_for_completion) {
fs/ceph/mds_client.c:		err = req->r_wait_for_completion(mdsc, req);
fs/ceph/mds_client.c:		long timeleft = wait_for_completion_killable_timeout(
fs/ceph/mds_client.c:					&req->r_completion,
fs/ceph/mds_client.c:	init_completion(&mdsc->safe_umount_waiters);
fs/ceph/mds_client.c:		wait_for_completion_timeout(&mdsc->safe_umount_waiters,
fs/ceph/mds_client.c:			wait_for_completion(&req->r_safe_completion);
fs/ceph/caps.c:		ret = !wait_for_completion_timeout(&req1->r_safe_completion,
fs/ceph/caps.c:		ret = !wait_for_completion_timeout(&req2->r_safe_completion,
fs/ceph/file.c:		complete_all(&req->r_completion);
fs/ceph/file.c:		wait_for_completion(&req->r_safe_completion);
fs/ceph/mds_client.h:#include <linux/completion.h>
fs/ceph/mds_client.h: * request completion callback
fs/ceph/mds_client.h: * wait for request completion callback
fs/ceph/mds_client.h:	struct completion r_completion;
fs/ceph/mds_client.h:	struct completion r_safe_completion;
fs/ceph/mds_client.h:	ceph_mds_request_wait_callback_t r_wait_for_completion;
fs/ceph/mds_client.h:	struct completion       safe_umount_waiters;
fs/coredump.c:	init_completion(&core_state->startup);
fs/coredump.c:		wait_for_completion(&core_state->startup);
fs/exofs/ore.c:	struct completion *waiting = p;
fs/exofs/ore.c:		wait_for_completion(&wait);
fs/cachefiles/bind.c:#include <linux/completion.h>
fs/cachefiles/interface.c: * indication of lookup completion
fs/cachefiles/daemon.c:#include <linux/completion.h>
fs/cachefiles/rdwr.c: * - we use this to detect read completion of backing pages
fs/cachefiles/rdwr.c: *   - a read will be started which will call the callback on completion
fs/cachefiles/main.c:#include <linux/completion.h>
fs/nilfs2/sysfs.c:	struct completion *kobj_unregister; \
fs/nilfs2/sysfs.c:	init_completion(kobj_unregister); \
fs/nilfs2/sysfs.c:	init_completion(&root->snapshot_kobj_unregister);
fs/nilfs2/sysfs.c:	init_completion(&nilfs->ns_dev_kobj_unregister);
fs/nilfs2/segbuf.c:	init_completion(&segbuf->sb_bio_event);
fs/nilfs2/segbuf.c:		wait_for_completion(&segbuf->sb_bio_event);
fs/nilfs2/segbuf.c: * nilfs_segbuf_wait - wait for completion of requested BIOs
fs/nilfs2/segbuf.c:		wait_for_completion(&segbuf->sb_bio_event);
fs/nilfs2/segbuf.h:#include <linux/completion.h>
fs/nilfs2/segbuf.h:	struct completion	sb_bio_event;
fs/nilfs2/sysfs.h: * @sg_superblock_kobj_unregister: completion state
fs/nilfs2/sysfs.h: * @sg_segctor_kobj_unregister: completion state
fs/nilfs2/sysfs.h: * @sg_mounted_snapshots_kobj_unregister: completion state
fs/nilfs2/sysfs.h: * @sg_checkpoints_kobj_unregister: completion state
fs/nilfs2/sysfs.h: * @sg_segments_kobj_unregister: completion state
fs/nilfs2/sysfs.h:	struct completion sg_superblock_kobj_unregister;
fs/nilfs2/sysfs.h:	struct completion sg_segctor_kobj_unregister;
fs/nilfs2/sysfs.h:	struct completion sg_mounted_snapshots_kobj_unregister;
fs/nilfs2/sysfs.h:	struct completion sg_checkpoints_kobj_unregister;
fs/nilfs2/sysfs.h:	struct completion sg_segments_kobj_unregister;
fs/nilfs2/segment.c:#include <linux/completion.h>
fs/nilfs2/the_nilfs.h: * @ns_dev_kobj_unregister: completion state
fs/nilfs2/the_nilfs.h:	struct completion ns_dev_kobj_unregister;
fs/nilfs2/the_nilfs.h: * @snapshot_kobj_unregister: completion state for kernel object
fs/nilfs2/the_nilfs.h:	struct completion snapshot_kobj_unregister;
fs/ntfs/aops.c: * ntfs_end_buffer_async_read - async io completion for reading attributes
fs/ntfs/aops.c: * Asynchronous I/O completion handler for reading pages belonging to the
fs/ntfs/aops.c: * completion handler ntfs_end_buffer_read_async(), if required, automatically
fs/ntfs/aops.c:	/* Wait on i/o completion of buffers. */
fs/ntfs/inode.c:	 * completion handler for directories.
fs/ntfs/inode.c: * If @sync is true, commit the inode to disk and wait for io completion.  This
fs/ntfs/inode.c: * completion.  In 2.6 kernels, scheduling usually happens just by virtue of
fs/ntfs/mft.c: * in our asynchronous I/O completion handler end_buffer_read_mft_async()).
fs/ntfs/mft.c: * @sync:	if true, wait for i/o completion
fs/ntfs/mft.c:		/* Wait on i/o completion of buffers. */
fs/ntfs/mft.c: * @sync:	if true, wait for i/o completion
fs/ntfs/mft.c: * true, we write the mft record, wait for i/o completion, and only then write
fs/ntfs/mft.c: * false on the other hand, we start i/o on both and then wait for completion
fs/ntfs/mft.c:	/* Wait on i/o completion of buffers. */
fs/ntfs/compress.c:	/* Wait for io completion on all buffer heads. */
fs/ntfs/super.c:	 * completion handler for directories.
fs/ntfs/mft.h: * @sync:	if true, wait for i/o completion
fs/reiserfs/super.c: * completion on
fs/reiserfs/super.c:				 "completion. If that fails\n"
fs/orangefs/waitqueue.c:		wait_for_completion(&op->waitq);
fs/orangefs/waitqueue.c:	reinit_completion(&op->waitq);
fs/orangefs/waitqueue.c:		n = wait_for_completion_interruptible_timeout(&op->waitq,
fs/orangefs/waitqueue.c:		n = wait_for_completion_killable_timeout(&op->waitq, timeout);
fs/orangefs/orangefs-kernel.h:	struct completion waitq;
fs/orangefs/orangefs-kernel.h: * or even completion notification so that the VFS client-side daemon
fs/orangefs/orangefs-cache.c:		init_completion(&new_op->waitq);
fs/crypto/crypto.c: * page_crypt_complete() - completion callback for page crypto
fs/crypto/crypto.c:	struct fscrypt_completion_result *ecr = req->data;
fs/crypto/crypto.c:	complete(&ecr->completion);
fs/crypto/crypto.c:		wait_for_completion(&ecr.completion);
fs/crypto/crypto.c: * Called from the read completion callback.
fs/crypto/crypto.c:static void completion_pages(struct work_struct *work)
fs/crypto/crypto.c:	INIT_WORK(&ctx->r.work, completion_pages);
fs/crypto/keyinfo.c:	struct fscrypt_completion_result *ecr = req->data;
fs/crypto/keyinfo.c:	complete(&ecr->completion);
fs/crypto/keyinfo.c:		wait_for_completion(&ecr.completion);
fs/crypto/fname.c: * fname_crypt_complete() - completion callback for filename crypto
fs/crypto/fname.c:	struct fscrypt_completion_result *ecr = req->data;
fs/crypto/fname.c:	complete(&ecr->completion);
fs/crypto/fname.c:		wait_for_completion(&ecr.completion);
fs/crypto/fname.c:		wait_for_completion(&ecr.completion);
fs/buffer.c: * I/O completion handler for block_read_full_page() - pages
fs/buffer.c: * during I/O, and which have PageWriteback cleared upon I/O completion.
fs/buffer.c: * completion) then there is a possibility that another thread of
fs/buffer.c: * completion.  Any other dirty buffers which are not yet queued for
fs/buffer.c: * ll_rw_block sets b_end_io to simple completion handler that marks
fs/proc/generic.c:#include <linux/completion.h>
fs/proc/inode.c:#include <linux/completion.h>
fs/proc/inode.c:		complete(pde->pde_unload_completion);
fs/proc/inode.c:		wait_for_completion(&c);
fs/proc/inode.c:	de->pde_unload_completion = &c;
fs/proc/inode.c:		wait_for_completion(&c);
fs/proc/proc_sysctl.c:		struct completion wait;
fs/proc/proc_sysctl.c:		init_completion(&wait);
fs/proc/proc_sysctl.c:		wait_for_completion(&wait);
fs/proc/internal.h:	struct completion *pde_unload_completion;
fs/proc/internal.h:	struct completion *c;
fs/file_table.c: * risking deadlocks), need to wait for completion of __fput() and know
fs/dax.c: * @end_io: A filesystem callback for I/O completion
fs/dax.c: * on persistent storage prior to completion of the operation.
fs/fs-writeback.c:struct wb_completion {
fs/fs-writeback.c:	unsigned int auto_free:1;	/* free on completion */
fs/fs-writeback.c:	struct wb_completion *done;	/* set if the caller waits */
fs/fs-writeback.c: * ->done should be set to a wb_completion defined using the following
fs/fs-writeback.c: * can wait for the completion of all using wb_wait_for_completion().  Work
fs/fs-writeback.c: * items which are waited upon aren't freed automatically on completion.
fs/fs-writeback.c:	struct wb_completion cmpl = {					\
fs/fs-writeback.c: * wb_wait_for_completion - wait for completion of bdi_writeback_works
fs/fs-writeback.c: * @done: target wb_completion
fs/fs-writeback.c: * automatically on completion.
fs/fs-writeback.c:static void wb_wait_for_completion(struct backing_dev_info *bdi,
fs/fs-writeback.c:				   struct wb_completion *done)
fs/fs-writeback.c: * writeback completion, wbc_detach_inode() should be called.  This is used
fs/fs-writeback.c:		wb_wait_for_completion(bdi, &fallback_work_done);
fs/fs-writeback.c:		 * updates after data IO completion.
fs/fs-writeback.c:	 * I/O completion. We don't do it for sync(2) writeback because it has a
fs/fs-writeback.c:	 * separate, external IO completion path and ->sync_fs for guaranteeing
fs/fs-writeback.c:		 * The completion of the current batch does not necessarily
fs/fs-writeback.c:		struct wb_completion *done = work->done;
fs/fs-writeback.c:	 * completion.
fs/fs-writeback.c:		 * writeback tag. Writeback completion is responsible to remove
fs/fs-writeback.c:		 * do not have the mapping lock. Skip it here, wb completion
fs/fs-writeback.c:	wb_wait_for_completion(bdi, &done);
fs/fs-writeback.c: * for IO completion of submitted IO.
fs/fs-writeback.c: * for IO completion of submitted IO.
fs/fs-writeback.c:	wb_wait_for_completion(bdi, &done);
fs/fs-writeback.c: * Write an inode to disk and adjust its dirty state after completion.
fs/xfs/xfs_aops.c:/* flags for direct write completions */
fs/xfs/xfs_aops.c:	 * We hand off the transaction to the completion thread now, so
fs/xfs/xfs_aops.c: * IO write completion.
fs/xfs/xfs_aops.c:	 * Detecting and handling completion IO errors is done individually
fs/xfs/xfs_aops.c: * reference to the ioend to ensure that the ioend completion is only done once
fs/xfs/xfs_aops.c:	 * error and finish it. This will run IO completion immediately
fs/xfs/xfs_aops.c: * Test to see if we've been building up a completion structure for
fs/xfs/xfs_aops.c:	 * sure we run IO completion to mark the error state of the IO
fs/xfs/xfs_aops.c:	 * buffers from it in the ioend chain so that completion treats it
fs/xfs/xfs_aops.c: * extending the file size. We won't know for sure until IO completion is run
fs/xfs/xfs_aops.c: * and the actual max write offset is communicated to the IO completion
fs/xfs/xfs_aops.c:		set_buffer_defer_completion(bh_result);
fs/xfs/xfs_aops.c:		set_buffer_defer_completion(bh_result);
fs/xfs/xfs_aops.c:		set_buffer_defer_completion(bh_result);
fs/xfs/xfs_aops.c: * Note that in this case the completion can be called in interrupt context,
fs/xfs/xfs_aops.c:	 * other IO completions here to update the EOF. Failing to serialise
fs/xfs/xfs_log_cil.c:	 * that we process items during log IO completion in the correct order.
fs/xfs/xfs_log_cil.c: * to checkpoint completion, and then unlock all the items in the transaction.
fs/xfs/xfs_log_cil.c:	 * we can run checkpoint completion before we've updated and unlocked
fs/xfs/xfs_log_priv.h:#define XLOG_STATE_IOABORT   0x0100 /* force abort on I/O completion (debug) */
fs/xfs/xfs_log_priv.h:	struct xfs_log_callback	log_cb;		/* completion callback hook. */
fs/xfs/xfs_dquot.h:	struct completion q_flush;	/* flush completion queue */
fs/xfs/xfs_dquot.h: * Manage the q_flush completion queue embedded in the dquot.  This completion
fs/xfs/xfs_dquot.h:	wait_for_completion(&dqp->q_flush);
fs/xfs/xfs_dquot.h:	return try_wait_for_completion(&dqp->q_flush);
fs/xfs/xfs_linux.h:	struct completion	complete;
fs/xfs/xfs_bmap_util.c:	/* wait for the completion of any pending DIOs */
fs/xfs/xfs_sysfs.h:	init_completion(&kobj->complete);
fs/xfs/xfs_sysfs.h:	wait_for_completion(&kobj->complete);
fs/xfs/xfs_buf.h:#define XBF_ASYNC	 (1 << 4) /* initiator will not wait for completion */
fs/xfs/xfs_buf.h:	struct workqueue_struct	*b_ioend_wq;	/* I/O completion wq */
fs/xfs/xfs_buf.h:	xfs_buf_iodone_t	b_iodone;	/* I/O completion function */
fs/xfs/xfs_buf.h:	struct completion	b_iowait;	/* queue for I/O waiters */
fs/xfs/xfs_log_recover.c: * On error or completion, trans is freed.
fs/xfs/xfs_trans_ail.c: * of traffic on the lock, especially during IO completion.
fs/xfs/xfs_buf_item.c:		 * here - simulate a failed IO completion - requires 3
fs/xfs/xfs_buf_item.c:		 * completion processing doesn't free the buffer prematurely.
fs/xfs/xfs_buf_item.c: * buffer through IO completion processing.
fs/xfs/xfs_log.c: * Attaches a new iclog I/O completion callback routine during
fs/xfs/xfs_log.c:	/* use high priority wq for log I/O completion */
fs/xfs/xfs_log.c:		/* use high priority wq for log I/O completion */
fs/xfs/xfs_log.c: * We lock the iclogbufs here so that we can serialise against IO completion
fs/xfs/xfs_log.c:		 * doing it here. Similarly, IO completion will unlock the
fs/xfs/xfs_log.c:	 * write on I/O completion and shutdown the fs. The subsequent mount
fs/xfs/xfs_log.c:	 * Cycle all the iclogbuf locks to make sure all log IO completion
fs/xfs/xfs_log.c:				 * transaction completion callbacks on it.
fs/xfs/xfs_log.c:	 * DO_CALLBACK and the callbacks are deferred to the completion of the
fs/xfs/xfs_log.c:			 * SYNCING - i/o completion will go through logs
fs/xfs/xfs_log.c: * the second completion goes through.
fs/xfs/xfs_log.c:			 * Don't wait on completion if we know that we've
fs/xfs/xfs_aops.h: * Types of I/O for bmap clustering and I/O completion tracking.
fs/xfs/xfs_aops.h: * Structure for buffered I/O completions.
fs/xfs/xfs_inode.c:		 * completion.  This is safe as we've locked out tail pushing
fs/xfs/xfs_file.c:	 * completions here. We want to make sure that nobody is changing the
fs/xfs/xfs_file.c:			 * AIO can do EOF updates during IO completion and hence
fs/xfs/libxfs/xfs_btree.c:	struct completion	*done;
fs/xfs/libxfs/xfs_btree.c:	wait_for_completion(&done);
fs/xfs/libxfs/xfs_btree.c: * recovery completion writes the changes to disk.
fs/xfs/libxfs/xfs_refcount.c: * periodically relogged to avoid filling up the log.  Second, CoW completions
fs/xfs/xfs_buf.c:	init_completion(&bp->b_iowait);
fs/xfs/xfs_buf.c:	 * Pull in IO completion errors now. We are guaranteed to be running
fs/xfs/xfs_buf.c:	 * Initialize the I/O completion workqueue if we haven't yet or the
fs/xfs/xfs_buf.c:	 * The caller's reference is released during I/O completion.
fs/xfs/xfs_buf.c:	 * Set the count to 1 initially, this will stop an I/O completion
fs/xfs/xfs_buf.c:	 * reference we took above. If we drop it to zero, run completion so
fs/xfs/xfs_buf.c:	 * that we don't return to the caller with completion still pending.
fs/xfs/xfs_buf.c:	 * are about to take until we've waited for all IO completion to occur,
fs/xfs/xfs_buf.c:	 * Set the count to 1 initially, this will stop an I/O completion
fs/xfs/xfs_buf.c:	 * make sure we run completion synchronously if it raced with us and is
fs/xfs/xfs_buf.c:	/* wait for completion before gathering the error from the buffer */
fs/xfs/xfs_buf.c:	wait_for_completion(&bp->b_iowait);
fs/xfs/xfs_buf.c:	 * Next, flush the buffer workqueue to ensure all completion processing
fs/xfs/xfs_buf.c:		 * to wait for IO completion we need to take an extra
fs/xfs/xfs_buf.c: * out and not wait for I/O completion on any of the buffers.  This interface
fs/xfs/xfs_buf.c: * is only safely useable for callers that can track I/O completion by higher
fs/xfs/xfs_buf.c: * completion on all of the buffers. @buffer_list is consumed by the function,
fs/xfs/xfs_buf.c:		/* locking the buffer will wait for async IO completion. */
fs/xfs/xfs_inode_item.c: * This is the inode flushing I/O completion routine.  It is called
fs/xfs/xfs_inode_item.c: * buffer list so we can process all the inode IO completions in one AIL lock
fs/xfs/xfs_inode_item.c:	 * Scan the buffer IO completions for other inodes being completed and
fs/xfs/xfs_dquot.c:	 * Because we want to use a counting completion, complete
fs/xfs/xfs_dquot.c:	 * the flush completion once to allow a single access to
fs/xfs/xfs_dquot.c:	 * the flush completion without blocking.
fs/xfs/xfs_dquot.c:	init_completion(&dqp->q_flush);
fs/xfs/xfs_dquot.c: * This is the dquot flushing I/O completion routine.  It is called
fs/xfs/xfs_dquot.c:	ASSERT(!completion_done(&dqp->q_flush));
fs/xfs/xfs_reflink.c: * succeeded.  IO completion in this case is the process of removing the old
fs/xfs/xfs_reflink.c:	/* Wait for the completion of any pending IOs on both files */
fs/kernfs/dir.c: * for the completion of not only the winning kernfs_remove_self() but also
fs/jbd2/commit.c:                           completion later */
fs/jbd2/transaction.c:	 * atomically wrt. completion of any outstanding commits.
fs/jbd2/revoke.c:		/* Record it so that we can wait for IO completion later */
fs/jbd2/journal.c:		 * completion of that transaction.
fs/afs/cmservice.c:	 * callbacks because it hadn't received completion of the CBCallBack op
fs/afs/write.c: * completion of write to server
fs/afs/vnode.c: * operation completion
fs/afs/internal.h: * definition of how to wait for the completion of an operation
fs/afs/internal.h:	/* asynchronous call completion */
fs/afs/internal.h:	const struct afs_wait_mode *wait_mode;	/* completion wait mode */
fs/afs/internal.h:	wait_queue_head_t	waitq;		/* processes awaiting completion */
fs/afs/internal.h:	wait_queue_head_t	waitq;		/* completion and ready wait queue */
fs/afs/main.c:#include <linux/completion.h>
fs/namei.c: * complete_walk - successful completion of path walk
fs/sync.c:		laptop_sync_completion();
fs/sync.c: * completion of writeout of all pages in the range.  This will be used after an
fs/file.c: * Return <0 error code on error; 1 on successful completion.
fs/autofs4/inode.c:	 * Success! Install the root dentry now to indicate completion.
fs/autofs4/expire.c:			init_completion(&ino->expire_complete);
fs/autofs4/expire.c:	init_completion(&ino->expire_complete);
fs/autofs4/expire.c:		wait_for_completion(&ino->expire_complete);
fs/autofs4/autofs_i.h:	struct completion expire_complete;
fs/autofs4/root.c:	 * completion.
fs/f2fs/data.c:	/* wait for read completion */
fs/f2fs/f2fs.h:	struct completion event;
fs/f2fs/f2fs.h:	struct completion wait;
fs/f2fs/f2fs.h: *			with waiting the bio's completion
fs/f2fs/f2fs.h:	struct completion s_kobj_unregister;
fs/f2fs/super.c:	wait_for_completion(&sbi->s_kobj_unregister);
fs/f2fs/super.c:	init_completion(&sbi->s_kobj_unregister);
fs/f2fs/super.c:	wait_for_completion(&sbi->s_kobj_unregister);
fs/f2fs/segment.c:	init_completion(&cmd.wait);
fs/f2fs/segment.c:	wait_for_completion(&cmd.wait);
fs/f2fs/segment.c:	init_completion(&be->event);
fs/f2fs/segment.c:		wait_for_completion_io(&be->event);
fs/aio.c:	struct completion comp;
fs/aio.c:		spinlock_t	completion_lock;
fs/aio.c: * successful cancellation - io_cancel() - does deliver the completion to
fs/aio.c: * kiocb completion to be lockless when possible, we use ki_cancel to
fs/aio.c: * synchronize cancellation and completion - we only set it to KIOCB_CANCELLED
fs/aio.c:	__u64			ki_user_data;	/* user's data for completion */
fs/aio.c:	/* Take completion_lock to prevent other writes to the ring buffer
fs/aio.c:	spin_lock_irqsave(&ctx->completion_lock, flags);
fs/aio.c:	spin_unlock_irqrestore(&ctx->completion_lock, flags);
fs/aio.c:	spin_lock_init(&ctx->completion_lock);
fs/aio.c:	init_completion(&wait.comp);
fs/aio.c:		wait_for_completion(&wait.comp);
fs/aio.c: *	number of free slots in the completion ring.  This can be called
fs/aio.c: *	called holding ctx->completion_lock.
fs/aio.c: *	out of space in the completion ring.
fs/aio.c:	spin_lock_irq(&ctx->completion_lock);
fs/aio.c:		 * ctx->completion_lock.  Even if head is invalid, the check
fs/aio.c:	spin_unlock_irq(&ctx->completion_lock);
fs/aio.c:	 * Add a completion event to the ring buffer. Must be done holding
fs/aio.c:	 * ctx->completion_lock to prevent other code from messing with the tail
fs/aio.c:	spin_lock_irqsave(&ctx->completion_lock, flags);
fs/aio.c:	spin_unlock_irqrestore(&ctx->completion_lock, flags);
fs/aio.c: *	AIOs and block on completion.  Will fail with -ENOSYS if not
fs/aio.c:		init_completion(&wait.comp);
fs/aio.c:			wait_for_completion(&wait.comp);
fs/aio.c: *	into the completion queue and 0 is returned.  May fail with
fs/aio.c: *	the completion queue for the aio_context specified by ctx_id. If
fs/cifs/cifssmb.c:		init_completion(&wdata->done);
fs/cifs/cifssmb.c: * workqueue completion task.
fs/cifs/cifspdu.h:					  /* synchronize with the completion  */
fs/cifs/cifsglob.h:	struct completion		done;
fs/cifs/cifsglob.h:	struct completion		done;
fs/cifs/cifsglob.h:	mid_callback_t *callback; /* call completion callback */
fs/cifs/smb2pdu.c: * workqueue completion task.
fs/cifs/file.c:			rc = wait_for_completion_killable(&wdata->done);
fs/cifs/file.c:		init_completion(&rdata->done);
fs/cifs/file.c:			rc = wait_for_completion_killable(&rdata->done);
fs/cifs/connect.c:#include <linux/completion.h>
fs/ocfs2/cluster/tcp.c:	/* handshake completion will set nn->nn_sc_valid */
fs/ocfs2/cluster/heartbeat.c:	struct completion wc_io_complete;
fs/ocfs2/cluster/heartbeat.c:	init_completion(&wc->wc_io_complete);
fs/ocfs2/cluster/heartbeat.c:	wait_for_completion(&wc->wc_io_complete);
fs/ocfs2/aops.c:	set_buffer_defer_completion(bh_result);
fs/ocfs2/dlmglue.c:	struct completion	mw_complete;
fs/ocfs2/dlmglue.c:	init_completion(&mw->mw_complete);
fs/ocfs2/dlmglue.c:	wait_for_completion(&mw->mw_complete);
fs/ocfs2/dlmglue.c:	/* Re-arm the completion in case we want to wait on it again */
fs/ocfs2/dlmglue.c:	reinit_completion(&mw->mw_complete);
fs/ocfs2/dlmglue.c:		init_completion(&mw->mw_complete);
fs/ocfs2/dlmglue.c:	ret = wait_for_completion_interruptible(&mw->mw_complete);
fs/ocfs2/dlmglue.c:	/* Re-arm the completion in case we want to wait on it again */
fs/ocfs2/dlmglue.c:	reinit_completion(&mw->mw_complete);
fs/ocfs2/inode.c:static void ocfs2_signal_wipe_completion(struct ocfs2_super *osb,
fs/ocfs2/inode.c:		 * recovery completion on other nodes. */
fs/ocfs2/inode.c:	ocfs2_signal_wipe_completion(osb, orphaned_slot);
fs/ocfs2/file.c:		 * both two cases mean the completion of hole punching.
fs/ocfs2/stack_user.c:	struct completion               oc_sync_wait;
fs/ocfs2/stack_user.c:	wait_for_completion(&lc->oc_sync_wait);
fs/ocfs2/stack_user.c:	wait_for_completion(&lc->oc_sync_wait);
fs/ocfs2/stack_user.c:	init_completion(&lc->oc_sync_wait);
fs/ocfs2/journal.c:static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,
fs/ocfs2/journal.c:			ocfs2_queue_recovery_completion(osb->journal, i, NULL,
fs/ocfs2/journal.c:	 * launched, so wait for any recovery completion work to
fs/ocfs2/journal.c:static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,
fs/ocfs2/journal.c:	ocfs2_queue_recovery_completion(journal, osb->slot_num,
fs/ocfs2/journal.c:		ocfs2_queue_recovery_completion(osb->journal,
fs/ocfs2/journal.c:	ocfs2_queue_recovery_completion(osb->journal, osb->slot_num, NULL,
fs/ocfs2/journal.c:		ocfs2_queue_recovery_completion(osb->journal, rm_quota[i],
fs/ocfs2/journal.c:	ocfs2_queue_recovery_completion(osb->journal, slot_num, la_copy,
fs/ocfs2/journal.c: * ocfs2_queue_orphan_scan calls ocfs2_queue_recovery_completion for
fs/ocfs2/journal.c:		ocfs2_queue_recovery_completion(osb->journal, i, NULL, NULL,
fs/fscache/object.c: * Wait for completion of all active operations on this object and the death of
fs/fscache/main.c:#include <linux/completion.h>
fs/fscache/operation.c: * Record the completion or cancellation of an in-progress operation.
fs/jfs/resize.c:	 * block any new transactions and wait for completion of
fs/jfs/resize.c:	 * for crash before completion of write
fs/jfs/resize.c:	 * for crash after completion of write,
fs/jfs/resize.c:	/* mark extendfs() completion */
fs/jfs/jfs_logmgr.c:#include <linux/completion.h>
fs/jfs/jfs_logmgr.c:				 * at completion of pageout;
fs/jfs/jfs_logmgr.c:				 * at completion of pageout;
fs/jfs/jfs_logmgr.c:	/* upcount transaction waiting for completion
fs/jfs/jfs_logmgr.c: * buffer at head of pageout queue stays after completion of
fs/jfs/jfs_logmgr.c: * queue is released at the completion of its full-page pageout.
fs/jfs/jfs_logmgr.c:	 *	pagein completion
fs/jfs/jfs_logmgr.c:	 *	pageout completion
fs/jfs/jfs_txnmgr.h:					 * event for group commit completion.
fs/jfs/jfs_txnmgr.c:#include <linux/completion.h>
fs/jfs/jfs_txnmgr.c: *	completion
fs/jfs/super.c:#include <linux/completion.h>
fs/jfs/super.c:	 * I/O completion thread (endio)
fs/jfs/jfs_xtree.c:			/* page will be invalidated at tx completion
fs/jfs/jfs_xtree.c:				/* page will be invalidated at tx completion
fs/jfs/jfs_imap.c: *	read lock on the map is held on successful completion;
fs/lockd/clntproc.c: *      completion in order to be able to correctly track the lock
fs/lockd/clntproc.c:	err = rpc_wait_for_completion_task(task);
fs/logfs/dev_mtd.c:#include <linux/completion.h>
fs/logfs/dev_mtd.c: * declare a completion variable and wait for completion before returning
fs/logfs/dev_mtd.c:	complete((struct completion *)ei->priv);
fs/logfs/dev_mtd.c:	wait_for_completion(&complete);
fs/direct-io.c: *		added IO completion notifier.
fs/direct-io.c:	dio_iodone_t *end_io;		/* IO completion function */
fs/direct-io.c:	/* BIO completion state */
fs/direct-io.c:	bool defer_completion;		/* defer AIO completion to workqueue? */
fs/direct-io.c:	int io_error;			/* IO error in completion path */
fs/direct-io.c:		struct work_struct complete_work;/* deferred AIO completion */
fs/direct-io.c:	 * AIO submission can race with bio completion to get here while
fs/direct-io.c:	 * expecting to have the last io completed by bio completion.
fs/direct-io.c:		if (dio->result && dio->defer_completion) {
fs/direct-io.c: * The BIO completion handler simply queues the BIO up for the process-context
fs/direct-io.c: * has done it's completion work.
fs/direct-io.c: * During IO completion, any of these pages which happen to have been written
fs/direct-io.c:	 * completion drops the count, maybe adds to the list, and wakes while
fs/direct-io.c:static void dio_await_completion(struct dio *dio)
fs/direct-io.c: * Create workqueue for deferred direct IO completions. We allocate the
fs/direct-io.c:static int dio_set_defer_completion(struct dio *dio)
fs/direct-io.c:	if (dio->defer_completion)
fs/direct-io.c:	dio->defer_completion = true;
fs/direct-io.c:		/* Store for completion */
fs/direct-io.c:		if (ret == 0 && buffer_defer_completion(map_bh))
fs/direct-io.c:			ret = dio_set_defer_completion(dio);
fs/direct-io.c:	 * completion paths can drop their ref and use the remaining count to
fs/direct-io.c:	 * In that case we need to wait for I/O completion even if asked
fs/direct-io.c:	 * For AIO O_(D)SYNC writes we need to defer completions to a workqueue
fs/direct-io.c:		retval = dio_set_defer_completion(dio);
fs/direct-io.c:	 * Will be decremented at I/O completion time.
fs/direct-io.c:	 * bio completion will call aio_complete.  The only time it's safe to
fs/direct-io.c:		dio_await_completion(dio);
fs/ncpfs/sock.c:	server->completion = reply->completion_code;
fs/ncpfs/sock.c:	result = reply->completion_code;
fs/ncpfs/sock.c:		ncp_vdbg("completion code=%x\n", result);
fs/ncpfs/ncp_fs_sb.h:	u8 completion;		/* Status message from server */
fs/nfs/dir.c:	error = rpc_wait_for_completion_task(task);
fs/nfs/cache_lib.c:	complete(&dreq->completion);
fs/nfs/cache_lib.c:		init_completion(&dreq->completion);
fs/nfs/cache_lib.c:	if (wait_for_completion_timeout(&dreq->completion,
fs/nfs/fscache-index.c: * - This function can be absent if the completion function doesn't require a
fs/nfs/fscache-index.c: * - This function can be absent if the completion function doesn't require a
fs/nfs/pagelist.c:	hdr->completion_ops = desc->pg_completion_ops;
fs/nfs/pagelist.c:	if (hdr->completion_ops->init_hdr)
fs/nfs/pagelist.c:		hdr->completion_ops->init_hdr(hdr);
fs/nfs/pagelist.c:		ret = rpc_wait_for_completion_task(task);
fs/nfs/pagelist.c:	hdr->completion_ops->completion(hdr);
fs/nfs/pagelist.c:	hdr->completion_ops->completion(hdr);
fs/nfs/pagelist.c: * @compl_ops: pointer to pageio completion operations
fs/nfs/pagelist.c:		     const struct nfs_pgio_completion_ops *compl_ops,
fs/nfs/pagelist.c:	desc->pg_completion_ops = compl_ops;
fs/nfs/pagelist.c:		func = desc->pg_completion_ops->error_cleanup;
fs/nfs/pagelist.c: * nfs_pageio_cond_complete - Conditional I/O completion
fs/nfs/unlink.c: * nfs_complete_unlink - Initialize completion of the sillydelete
fs/nfs/unlink.c:	error = rpc_wait_for_completion_task(task);
fs/nfs/nfs4state.c:		reinit_completion(&tbl->complete);
fs/nfs/nfs4state.c:		return wait_for_completion_interruptible(&tbl->complete);
fs/nfs/nfs4session.c:	init_completion(&tbl->complete);
fs/nfs/direct.c:	/* completion state */
fs/nfs/direct.c:	spinlock_t		lock;		/* protect completion state */
fs/nfs/direct.c:	struct completion	completion;	/* wait for i/o completion */
fs/nfs/direct.c:static const struct nfs_pgio_completion_ops nfs_direct_write_completion_ops;
fs/nfs/direct.c:static const struct nfs_commit_completion_ops nfs_direct_commit_completion_ops;
fs/nfs/direct.c:	cinfo->completion_ops = &nfs_direct_commit_completion_ops;
fs/nfs/direct.c:	init_completion(&dreq->completion);
fs/nfs/direct.c:	result = wait_for_completion_killable(&dreq->completion);
fs/nfs/direct.c:	complete(&dreq->completion);
fs/nfs/direct.c:static void nfs_direct_read_completion(struct nfs_pgio_header *hdr)
fs/nfs/direct.c:static const struct nfs_pgio_completion_ops nfs_direct_read_completion_ops = {
fs/nfs/direct.c:	.completion = nfs_direct_read_completion,
fs/nfs/direct.c:			     &nfs_direct_read_completion_ops);
fs/nfs/direct.c:	 * generic layer handle the completion.
fs/nfs/direct.c:			      &nfs_direct_write_completion_ops);
fs/nfs/direct.c:static const struct nfs_commit_completion_ops nfs_direct_commit_completion_ops = {
fs/nfs/direct.c:	.completion = nfs_direct_commit_complete,
fs/nfs/direct.c:static void nfs_direct_write_completion(struct nfs_pgio_header *hdr)
fs/nfs/direct.c:static const struct nfs_pgio_completion_ops nfs_direct_write_completion_ops = {
fs/nfs/direct.c:	.completion = nfs_direct_write_completion,
fs/nfs/direct.c:			      &nfs_direct_write_completion_ops);
fs/nfs/direct.c:	 * generic layer handle the completion.
fs/nfs/objlayout/objlayout.c: * This is because the osd completion is called with ints-off from
fs/nfs/objlayout/objlayout.c: * This is because the osd completion is called with ints-off from
fs/nfs/write.c:static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops;
fs/nfs/write.c:static const struct nfs_commit_completion_ops nfs_commit_completion_ops;
fs/nfs/write.c:				false, &nfs_async_write_completion_ops);
fs/nfs/write.c:				&nfs_async_write_completion_ops);
fs/nfs/write.c:	cinfo->completion_ops = &nfs_commit_completion_ops;
fs/nfs/write.c:static void nfs_write_completion(struct nfs_pgio_header *hdr)
fs/nfs/write.c:static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops = {
fs/nfs/write.c:	.completion = nfs_write_completion,
fs/nfs/write.c:			       const struct nfs_pgio_completion_ops *compl_ops)
fs/nfs/write.c:		rpc_wait_for_completion_task(task);
fs/nfs/write.c:	data->completion_ops = cinfo->completion_ops;
fs/nfs/write.c:	data->completion_ops->completion(data);
fs/nfs/write.c:static const struct nfs_commit_completion_ops nfs_commit_completion_ops = {
fs/nfs/write.c:	.completion = nfs_commit_release_pages,
fs/nfs/delegation.c:#include <linux/completion.h>
fs/nfs/callback.c:#include <linux/completion.h>
fs/nfs/cache_lib.h:#include <linux/completion.h>
fs/nfs/cache_lib.h:	struct completion completion;
fs/nfs/nfs4session.h:	struct completion complete;
fs/nfs/pnfs_nfs.c:	data->completion_ops->completion(data);
fs/nfs/pnfs_nfs.c:			cinfo->completion_ops->resched_write(cinfo, req);
fs/nfs/flexfilelayout/flexfilelayout.c:	ktime_t completion_time = ktime_sub(time_completed, time_started);
fs/nfs/flexfilelayout/flexfilelayout.c:	iostat->aggregate_completion_time =
fs/nfs/flexfilelayout/flexfilelayout.c:			ktime_add(iostat->aggregate_completion_time,
fs/nfs/flexfilelayout/flexfilelayout.c:					completion_time);
fs/nfs/flexfilelayout/flexfilelayout.c:		hdr->completion_ops->reschedule_io(hdr);
fs/nfs/flexfilelayout/flexfilelayout.c:	ff_layout_encode_nfstime(xdr, stat->aggregate_completion_time);
fs/nfs/flexfilelayout/flexfilelayout.h:	ktime_t				aggregate_completion_time;
fs/nfs/read.c:static const struct nfs_pgio_completion_ops nfs_async_read_completion_ops;
fs/nfs/read.c:			      const struct nfs_pgio_completion_ops *compl_ops)
fs/nfs/read.c:			     &nfs_async_read_completion_ops);
fs/nfs/read.c:static void nfs_read_completion(struct nfs_pgio_header *hdr)
fs/nfs/read.c:static const struct nfs_pgio_completion_ops nfs_async_read_completion_ops = {
fs/nfs/read.c:	.completion = nfs_read_completion,
fs/nfs/read.c:			     &nfs_async_read_completion_ops);
fs/nfs/pnfs.c:			      hdr->completion_ops);
fs/nfs/pnfs.c:	nfs_pageio_init_read(&pgio, hdr->inode, true, hdr->completion_ops);
fs/nfs/pnfs.c:					hdr->completion_ops);
fs/nfs/internal.h:struct nfs_pgio_completion_ops;
fs/nfs/internal.h:			const struct nfs_pgio_completion_ops *compl_ops);
fs/nfs/internal.h:			const struct nfs_pgio_completion_ops *compl_ops);
fs/nfs/fscache.c: * Handle completion of a page being read from the cache.
fs/nfs/nfs4proc.c:static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)
fs/nfs/nfs4proc.c:	ret = rpc_wait_for_completion_task(task);
fs/nfs/nfs4proc.c:	status = nfs4_wait_for_completion_rpc_task(task);
fs/nfs/nfs4proc.c:        status = nfs4_wait_for_completion_rpc_task(task);
fs/nfs/nfs4proc.c:		status = rpc_wait_for_completion_task(task);
fs/nfs/nfs4proc.c:	status = nfs4_wait_for_completion_rpc_task(task);
fs/nfs/nfs4proc.c:	status = nfs4_wait_for_completion_rpc_task(task);
fs/nfs/nfs4proc.c:	ret = nfs4_wait_for_completion_rpc_task(task);
fs/nfs/nfs4proc.c:		status = rpc_wait_for_completion_task(task);
fs/nfs/nfs4proc.c:	ret = rpc_wait_for_completion_task(task);
fs/nfs/nfs4proc.c:	status = nfs4_wait_for_completion_rpc_task(task);
fs/nfs/nfs4proc.c:	status = nfs4_wait_for_completion_rpc_task(task);
fs/fuse/fuse_i.h:	/** Waitq for writepage completion */
fs/fuse/fuse_i.h:	struct completion *done;
fs/fuse/fuse_i.h:	/** Used to wake up the task waiting for completion of request*/
fs/fuse/fuse_i.h:	/** Request completion callback */
fs/fuse/fuse_i.h:	/** The number of requests waiting for completion */
fs/fuse/file.c:		 * now for completion of all in-flight requests.  This happens
fs/fuse/file.c:		wait_for_completion(&wait);
include/asm-generic/tlb.h: * IRQs delays the completion of the TLB flush we can never observe an already
include/video/imx-ipu-image-convert.h: * @status:	completion status of this run
include/video/imx-ipu-image-convert.h: * @complete:	run completion callback
include/video/imx-ipu-image-convert.h: * @complete_context:	a context pointer for the completion callback
include/video/imx-ipu-image-convert.h: * to this context are returned via the completion callback with an
include/video/imx-ipu-image-convert.h: * completion callback. The caller is responsible for freeing the run
include/video/imx-ipu-image-convert.h: * returned via the completion callback with an error run status.
include/video/imx-ipu-image-convert.h: * @complete:	run completion callback
include/video/imx-ipu-image-convert.h: * @complete_context:	a context pointer for the completion callback
include/video/uvesafb.h:	struct completion *done;
include/drm/drm_crtc.h:	 * Optional pointer to a DRM event to signal upon completion of the
include/drm/drm_crtc.h:	 * which the driver should call on the provided event upon completion of
include/drm/drm_crtc.h:	 * the provided event upon completion of the flip. Note that if
include/drm/drmP.h:	struct completion *completion;
include/drm/drm_atomic.h: *	...					send completion irq
include/drm/drm_atomic.h:	 * completions without the risk of the completion disappearing
include/drm/drm_atomic.h:	struct completion flip_done;
include/drm/drm_atomic.h:	struct completion hw_done;
include/drm/drm_atomic.h:	 * a vblank wait completed it might be a bit later. This completion is
include/drm/drm_atomic.h:	struct completion cleanup_done;
include/drm/drm_dp_helper.h: * @reply: upon completion, contains the reply type of the transaction
include/drm/ttm/ttm_bo_api.h: * @p_bo: On successful completion *p_bo points to the created object.
include/drm/ttm/ttm_object.h: * @existed: Upon completion, indicates that an identical reference object
include/pcmcia/ss.h:#include <linux/sched.h>	/* task_struct, completion */
include/pcmcia/ss.h:	struct completion		socket_released;
include/pcmcia/ss.h:	struct completion		thread_done;
include/sound/hda_register.h:#define SD_INT_COMPLETE		0x04	/* completion interrupt */
include/sound/core.h:struct completion;
include/sound/core.h:	struct completion *release_completion;
include/sound/soc-topology.h:	/* completion - called at completion of firmware loading */
include/uapi/asm-generic/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
include/uapi/drm/i915_drm.h: *	detection, and a 0 upon reset completion, signifying no more error
include/uapi/drm/i915_drm.h:	 * signaled completion for all pending requests that reference the
include/uapi/drm/vc4_drm.h: * DRM_VC4_SUBMIT_CL completion using its returned seqno.
include/uapi/drm/vc4_drm.h: * completion of the last DRM_VC4_SUBMIT_CL on a BO.
include/uapi/drm/vmwgfx_drm.h: * for the host. Does not wait for host completion.
include/uapi/drm/vmwgfx_drm.h: * Does not wait for host completion. The context ID can be used directly
include/uapi/drm/vmwgfx_drm.h: * for the host. Does not wait for host completion. The surface ID can be
include/uapi/drm/vmwgfx_drm.h: * Does not wait for completion.
include/uapi/drm/vmwgfx_drm.h: * The following actions should be take on completion:
include/uapi/drm/vmwgfx_drm.h: * @shader_handle: On successful completion contains a handle that
include/uapi/drm/vmwgfx_drm.h: * for the host. Does not wait for host completion.
include/uapi/rdma/hfi/hfi1_user.h: * SDMA completion ring entry
include/uapi/rdma/hfi/hfi1_user.h:	/* base address of SDMA completion ring */
include/uapi/rdma/hfi/hfi1_user.h:	 * Index of the slot in the SDMA completion ring
include/uapi/scsi/scsi_bsg_fc.h: * with the transport upon completion of the login.
include/uapi/scsi/scsi_bsg_fc.h:	 * The completion result. Result exists in two forms:
include/uapi/linux/usbdevice_fs.h:	unsigned int signr;	/* signal to be sent on completion,
include/uapi/linux/blktrace_api.h:	BLK_TC_COMPLETE	= 1 << 7,	/* completions */
include/uapi/linux/blktrace_api.h:	__u16 error;		/* completion error */
include/uapi/linux/ptrace.h: * On the successful completion, iov.len will be updated by the kernel,
include/uapi/linux/target_core_user.h:#define TCMU_MAILBOX_FLAG_CAP_OOOC (1 << 0) /* Out-of-order completions */
include/uapi/linux/rio_mport_cdev.h: * access and has its own completion code.
include/uapi/linux/rio_mport_cdev.h:	__u32 completion_code;	/* Completion code for this transfer */
include/uapi/linux/ethtool.h: *	(usecs > 0 && time_since_first_completion >= usecs) ||
include/uapi/linux/ethtool.h: * condition time_since_first_completion >= usecs
include/uapi/linux/ethtool.h: * counting completions should validate that max_frames == !rx_usecs.
include/uapi/linux/nl80211.h: *	as an event on the "mlme" multicast group indicating completion of the
include/uapi/linux/ncp.h:	__u8 completion_code;
include/uapi/linux/genwqe/genwqe_card.h:	__u64 cmplt_ts;			/* completion time stamp */
include/uapi/linux/virtio_scsi.h:	__u8 status;		/* Command completion status */
include/uapi/linux/fd.h:				    * completion */
include/uapi/linux/bsg.h:	__u32 device_status;	/* [o] {SCSI: command completion status} */
include/uapi/linux/pci_regs.h:#define  PCI_VPD_ADDR_F		0x8000	/* Write 0, 1 indicates completion */
include/uapi/linux/pci_regs.h:#define  PCI_EXP_DEVCTL2_IDO_CMP_EN	0x0200	/* Allow IDO for completions */
include/uapi/linux/ipmi.h: * commands and responses.  The completion code is always the first
include/uapi/linux/ipmi.h:/* Note that async events and received commands do not have a completion
include/rdma/rdmavt_qp.h: * RVT_S_SIGNAL_REQ_WR - set if QP send WRs contain completion signaled
include/rdma/rdmavt_qp.h: *                  next send completion entry not via send DMA
include/rdma/ib_verbs.h:	 * of I/O operations with single completion queue managed
include/rdma/ib_verbs.h: * Set value of IB_WC_RECV so consumers can test if a completion is a
include/rdma/ib_verbs.h:	IB_POLL_DIRECT,		/* caller context, no hw completions */
include/rdma/ib_verbs.h: *   work completion.
include/rdma/ib_verbs.h: * @wc: Work completion associated with the received message.
include/rdma/ib_verbs.h: *   ignored unless the work completion indicates that the GRH is valid.
include/rdma/ib_verbs.h: *   sender of the specified work completion.
include/rdma/ib_verbs.h: * @wc: Work completion information associated with a received message.
include/rdma/ib_verbs.h: *   ignored unless the work completion indicates that the GRH is valid.
include/rdma/ib_verbs.h: *   completion event occurs on the CQ.
include/rdma/ib_verbs.h: *   asynchronous event not associated with a completion occurs on the CQ.
include/rdma/ib_verbs.h: *   the associated completion and event handlers.
include/rdma/ib_verbs.h: * ib_poll_cq - poll a CQ for completion(s)
include/rdma/ib_verbs.h: * @num_entries:maximum number of completions to return
include/rdma/ib_verbs.h: * @wc:array of at least @num_entries &struct ib_wc where completions
include/rdma/ib_verbs.h: * Poll a CQ for (possibly multiple) completions.  If the return value
include/rdma/ib_verbs.h: * number of completions returned.  If the return value is
include/rdma/ib_verbs.h: * ib_peek_cq - Returns the number of unreaped completions currently
include/rdma/ib_verbs.h: * @wc_cnt: A minimum number of unreaped completions to check for.
include/rdma/ib_verbs.h: * If the number of unreaped completions is greater than or equal to wc_cnt,
include/rdma/ib_verbs.h: * unreaped completions.
include/rdma/ib_verbs.h: * ib_req_notify_cq - Request completion notification on a CQ.
include/rdma/ib_verbs.h: *   completion at any type, respectively. %IB_CQ_REPORT_MISSED_EVENTS
include/rdma/ib_verbs.h: *        this case is it guaranteed that any work completions added
include/rdma/ib_verbs.h: *        to the CQ since the last CQ poll will trigger a completion
include/rdma/ib_verbs.h: *        (but not guaranteed) that a work completion has been added
include/rdma/ib_verbs.h: *        completion notification event.
include/rdma/ib_verbs.h: * ib_req_ncomp_notif - Request completion notification when there are
include/rdma/ib_verbs.h: *   at least the specified number of unreaped completions on the CQ.
include/rdma/ib_verbs.h: * @wc_cnt: The number of unreaped completions that should be on the
include/rdma/rdmavt_mr.h:	struct completion comp; /* complete when refcount goes to zero */
include/rdma/ib_umem_odp.h:	struct completion	notifier_completion;
include/rdma/ib_mad.h: *   using RMPP, this applies per window.  On completion, returns the number
include/rdma/ib_mad.h: * @mad_send_wc: Send work completion information on the sent MAD.
include/rdma/ib_mad.h: * @mad_send_wc: Work completion information on the sent MAD.  Valid
include/rdma/ib_mad.h: *   only for snooping that occurs on a send completion.
include/rdma/ib_mad.h: * @mad_recv_wc: Received work completion information on the received MAD.
include/rdma/ib_mad.h: * ib_mad_send_wc - MAD send completion information.
include/rdma/ib_mad.h: * @send_handler: The completion callback routine invoked after a send
include/rdma/ib_mad.h: * @recv_handler: The completion callback routine invoked for a received
include/rdma/ib_mad.h: * @mad_recv_wc: Work completion information for a received MAD.
include/rdma/ib_mad.h: * routine to return the work completion buffers to the access layer.
include/rdma/ib_mad.h: * @send_handler: The completion callback routine invoked after a send
include/rdma/ib_mad.h: * @recv_handler: The completion callback routine invoked for a received
include/rdma/ib_mad.h: * ib_process_mad_wc - Processes a work completion associated with a
include/rdma/ib_mad.h: * @wc: References a work completion associated with a sent or received
include/rdma/ib_mad.h: * If the work completion is associated with a send operation, calling
include/rdma/ib_mad.h: * corresponding response, if it is a request.  If the work completion is
include/rdma/ib_addr.h:	struct completion comp;
include/rdma/rdmavt_cq.h: * and completion queue entries as a single memory allocation so
include/rdma/rdmavt_cq.h: * The completion queue structure.
include/rdma/ib_sa.h:#include <linux/completion.h>
include/rdma/ib_sa.h:	struct completion comp;
include/net/mac80211.h: *	completion of the channel switch.
include/net/cfg80211.h: * or aborted. This must be called to notify the completion of a CAC process,
include/net/nfc/nci_core.h:	struct completion	req_completion;
include/net/nfc/nci_core.h:	struct completion	req_completion;
include/net/nfc/nci_core.h:		 struct completion *write_handshake_completion,
include/net/caif/caif_spi.h:	struct completion comp;
include/net/genetlink.h: * @done: completion callback for dumps
include/soc/fsl/qman.h: * Active state), the completion will be via the message ring as a FQRN - but
include/soc/fsl/qe/ucc_fast.h:#define T_I	0x10000000	/* interrupt on completion */
include/soc/fsl/qe/ucc_fast.h:#define T_I_S	0x1000	/* interrupt on completion */
include/soc/fsl/qe/ucc_slow.h:#define T_I	0x10000000	/* interrupt on completion */
include/crypto/if_alg.h:#include <linux/completion.h>
include/crypto/if_alg.h:struct af_alg_completion {
include/crypto/if_alg.h:	struct completion completion;
include/crypto/if_alg.h:int af_alg_wait_for_completion(int err, struct af_alg_completion *completion);
include/crypto/if_alg.h:static inline void af_alg_init_completion(struct af_alg_completion *completion)
include/crypto/if_alg.h:	init_completion(&completion->completion);
include/crypto/drbg.h:	struct completion ctr_completion;	/* CTR mode async handler */
include/crypto/skcipher.h: * cipher request returns immediately before the completion of the operation.
include/crypto/skcipher.h: * the kernel crypto API to inform the caller about the completion of a cipher
include/crypto/skcipher.h: * have, because when calling the callback function upon completion of the
include/crypto/skcipher.h:						 crypto_completion_t compl,
include/crypto/kpp.h:					    crypto_completion_t cmpl,
include/crypto/aead.h:					     crypto_completion_t compl,
include/crypto/hash.h:					      crypto_completion_t compl,
include/crypto/mcryptd.h:	crypto_completion_t complete;
include/crypto/akcipher.h:						 crypto_completion_t cmpl,
include/scsi/libsas.h:	struct completion port_gone_completion;
include/scsi/libsas.h:	struct completion     completion;
include/scsi/libfc.h: * @RPORT_ST_FLOGI:   Waiting for FLOGI completion for point-to-multipoint
include/scsi/libfc.h: * @RPORT_ST_PLOGI:   Waiting for PLOGI completion
include/scsi/libfc.h: * @RPORT_ST_PRLI:    Waiting for PRLI completion
include/scsi/libfc.h: * @RPORT_ST_RTV:     Waiting for RTV completion
include/scsi/libfc.h: * @wait_for_comp:   Indicator to wait for completion of the I/O (in jiffies)
include/scsi/libfc.h:	struct completion tm_done;
include/scsi/libfc.h:#define FC_EX_RST_CLEANUP	(1 << 1) /* reset is forcing completion */
include/scsi/scsi_cmnd.h:	 *        to completion function.  Not used by mid/upper level code. */
include/scsi/scsi_host.h:struct completion;
include/scsi/scsi_host.h:	struct completion     * eh_action; /* Wait for specific actions on the
include/scsi/scsi_bsg_iscsi.h:	 * The completion result. Result exists in two forms:
include/scsi/scsi_transport_iscsi.h:	 * completion
include/scsi/fc/fc_fcp.h:#define	FCP_SPPF_CONF_COMPL	0x0080	/* confirmed completion allowed */
include/scsi/scsi_transport_fc.h:	 * Upon completion : the message handler must set reply_len
include/scsi/scsi_transport.h:	 * Used as callback for the completion of i_t_nexus request
include/scsi/scsi_transport.h:	 * Used as callback for the completion of task management
include/scsi/osd_initiator.h: * Calls blk_execute_rq to q the command and waits for completion.
include/target/target_core_base.h:	struct completion *tg_pt_gp_transition_complete;
include/target/target_core_base.h:	struct completion	cmd_wait_comp;
include/target/target_core_base.h:	struct completion	t_transport_stop_comp;
include/target/target_core_base.h:	struct completion	acl_free_comp;
include/target/target_core_base.h:	struct completion	pr_comp;
include/target/target_core_base.h:	struct completion	lun_ref_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	conn_post_wait_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	conn_wait_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	conn_wait_rcfr_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	conn_waiting_on_uc_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	conn_logout_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	tx_half_close_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	rx_half_close_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	rx_login_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	async_msg_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	reinstatement_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	session_wait_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	session_waiting_on_uc_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	np_restart_comp;
include/target/iscsi/iscsi_target_core.h:	struct completion	tpg_np_comp;
include/linux/regset.h: * @immediate:	zero if writeback at completion of next context switch is OK
include/linux/qed/iscsi_common.h:/* CQE completion status */
include/linux/qed/qed_eth_if.h:	bool eq_completion_only;
include/linux/qed/qed_eth_if.h:	int (*eth_cqe_completion)(struct qed_dev *cdev,
include/linux/qed/qed_if.h: * @brief - drains chip in case Tx completions fail to arrive due to pause.
include/linux/cpufreq.h:#include <linux/completion.h>
include/linux/cpufreq.h:	struct completion	kobj_unregister;
include/linux/mmc/core.h:#include <linux/completion.h>
include/linux/mmc/core.h:	struct completion	completion;
include/linux/mmc/core.h:	struct completion	cmd_completion;
include/linux/mmc/core.h:	void			(*done)(struct mmc_request *);/* completion function */
include/linux/mmc/dw_mmc.h: * @cmd_status: Snapshot of SR taken upon completion of the current
include/linux/mmc/dw_mmc.h: * @data_status: Snapshot of SR taken upon completion of the current
include/linux/freezer.h: * calls wait_for_completion(&vfork) and reset right after it returns from this
include/linux/kvm_host.h:void kvm_clear_async_pf_completion_queue(struct kvm_vcpu *vcpu);
include/linux/kvm_host.h:void kvm_check_async_pf_completion(struct kvm_vcpu *vcpu);
include/linux/workqueue.h: * flush_scheduled_work - ensure that any scheduled work has run to completion.
include/linux/workqueue.h: * completion.
include/linux/libata.h:	ATA_QCFLAG_CLEAR_EXCL	= (1 << 5), /* clear excl_link on completion */
include/linux/libata.h:enum ata_completion_errors {
include/linux/libata.h:	struct completion	park_req_pending;
include/linux/libata.h:	/* init result_tf such that it indicates normal completion */
include/linux/kernel.h:struct completion;
include/linux/kernel.h:void complete_and_exit(struct completion *, long) __noreturn;
include/linux/completion.h: * Atomic wait-for-completion handler data structures.
include/linux/completion.h: * See kernel/sched/completion.c for details.
include/linux/completion.h: * struct completion - structure used to maintain state for a "completion"
include/linux/completion.h: * This is the opaque structure used to maintain the state for a "completion".
include/linux/completion.h: * the "completion" event.
include/linux/completion.h: * See also:  complete(), wait_for_completion() (and friends _timeout,
include/linux/completion.h: * _interruptible, _interruptible_timeout, and _killable), init_completion(),
include/linux/completion.h: * reinit_completion(), and macros DECLARE_COMPLETION(),
include/linux/completion.h:struct completion {
include/linux/completion.h:	({ init_completion(&work); work; })
include/linux/completion.h: * DECLARE_COMPLETION - declare and initialize a completion structure
include/linux/completion.h: * @work:  identifier for the completion structure
include/linux/completion.h: * This macro declares and initializes a completion structure. Generally used
include/linux/completion.h:	struct completion work = COMPLETION_INITIALIZER(work)
include/linux/completion.h: * completions - so we use the _ONSTACK() variant for those that
include/linux/completion.h: * DECLARE_COMPLETION_ONSTACK - declare and initialize a completion structure
include/linux/completion.h: * @work:  identifier for the completion structure
include/linux/completion.h: * This macro declares and initializes a completion structure on the kernel
include/linux/completion.h:	struct completion work = COMPLETION_INITIALIZER_ONSTACK(work)
include/linux/completion.h: * init_completion - Initialize a dynamically allocated completion
include/linux/completion.h: * @x:  pointer to completion structure that is to be initialized
include/linux/completion.h: * This inline function will initialize a dynamically created completion
include/linux/completion.h:static inline void init_completion(struct completion *x)
include/linux/completion.h: * reinit_completion - reinitialize a completion structure
include/linux/completion.h: * @x:  pointer to completion structure that is to be reinitialized
include/linux/completion.h: * This inline function should be used to reinitialize a completion structure so it can
include/linux/completion.h:static inline void reinit_completion(struct completion *x)
include/linux/completion.h:extern void wait_for_completion(struct completion *);
include/linux/completion.h:extern void wait_for_completion_io(struct completion *);
include/linux/completion.h:extern int wait_for_completion_interruptible(struct completion *x);
include/linux/completion.h:extern int wait_for_completion_killable(struct completion *x);
include/linux/completion.h:extern unsigned long wait_for_completion_timeout(struct completion *x,
include/linux/completion.h:extern unsigned long wait_for_completion_io_timeout(struct completion *x,
include/linux/completion.h:extern long wait_for_completion_interruptible_timeout(
include/linux/completion.h:	struct completion *x, unsigned long timeout);
include/linux/completion.h:extern long wait_for_completion_killable_timeout(
include/linux/completion.h:	struct completion *x, unsigned long timeout);
include/linux/completion.h:extern bool try_wait_for_completion(struct completion *x);
include/linux/completion.h:extern bool completion_done(struct completion *x);
include/linux/completion.h:extern void complete(struct completion *);
include/linux/completion.h:extern void complete_all(struct completion *);
include/linux/tifm.h:	struct completion   *finish_me;
include/linux/nvme.h:struct nvme_completion {
include/linux/rcupdate.h:#include <linux/completion.h>
include/linux/rcupdate.h: * that the read-side critical sections end on completion of a softirq
include/linux/rcupdate.h:	struct completion completion;
include/linux/rcupdate.h: * both call_rcu_bh() and synchronize_rcu_bh() consider completion of a
include/linux/ntb.h:#include <linux/completion.h>
include/linux/ntb.h:	struct completion		released;
include/linux/ntb.h: * The drivers may wish to ring the peer doorbell at the completion of memory
include/linux/fscache-cache.h:#define FSCACHE_OP_UNUSE_COOKIE	7	/* call fscache_unuse_cookie() on completion */
include/linux/fscache-cache.h:	fscache_rw_complete_t	end_io_func;	/* function to call on I/O completion */
include/linux/fscache-cache.h: * fscache_retrieval_complete - Record (partial) completion of a retrieval
include/linux/fscache-cache.h: *   - defer writes until cache object lookup completion
include/linux/ptrace.h: * System call handlers that, upon successful completion, need to return a
include/linux/bio.h:	bio_end_io_t		*bip_end_io;	/* saved I/O completion fn */
include/linux/bio.h:	struct work_struct	bip_work;	/* I/O completion */
include/linux/ceph/mon_client.h:#include <linux/completion.h>
include/linux/ceph/mon_client.h:	struct completion completion;
include/linux/ceph/libceph.h:#include <linux/completion.h>
include/linux/ceph/osd_client.h:#include <linux/completion.h>
include/linux/ceph/osd_client.h: * completion callback for async writepages
include/linux/ceph/osd_client.h:	struct completion r_completion;
include/linux/ceph/osd_client.h:	struct completion r_safe_completion;  /* fsync waiter */
include/linux/ceph/osd_client.h:	struct completion reg_commit_wait;
include/linux/ceph/osd_client.h:	struct completion notify_finish_wait;
include/linux/mailbox_controller.h:#include <linux/completion.h>
include/linux/mailbox_controller.h: * @tx_complete:	Transmission completion
include/linux/mailbox_controller.h:	struct completion tx_complete;
include/linux/fscache.h:	 * - this function can be absent if the completion function doesn't
include/linux/fscache.h:	 * - this function can be absent if the completion function doesn't
include/linux/fscache.h: * completion or failure.  Note that the callback may be invoked before the
include/linux/fscache.h: * completion or failure.  Note that the callback may be invoked before the
include/linux/fscache.h: * be cleared at the completion of the write to indicate the success or failure
include/linux/fscache.h: * of the operation.  Note that the completion may happen before the return.
include/linux/dmaengine.h: *  control completion, and communicate status.
include/linux/dmaengine.h: * @DMA_PREP_INTERRUPT - trigger an interrupt (callback) upon completion of
include/linux/dmaengine.h: * @flags: flags to augment operation preparation, control completion, and
include/linux/dmaengine.h: * @next: at completion submit this descriptor
include/linux/dmaengine.h: * @device_tx_status: poll for transaction completion, the optional
include/linux/dmaengine.h: * @descriptor_reuse: a submitted transfer can be resubmitted after completion
include/linux/dmaengine.h: * freeing any resources accessed from within the completion callback of any
include/linux/dmaengine.h: * dma_async_is_tx_complete - poll for transaction completion
include/linux/amba/pl022.h: * @autosuspend_delay: delay in ms following transfer completion before the
include/linux/rndis.h:/* codes for "status" field of completion messages */
include/linux/ti_wilink_st.h: * @kim_rcvd: completion handler to notify when data was received,
include/linux/ti_wilink_st.h: * @ldisc_installed: completion handler to notify that the UIM accepted
include/linux/ti_wilink_st.h:	struct completion kim_rcvd, ldisc_installed;
include/linux/usb.h:#include <linux/completion.h>	/* for struct completion */
include/linux/usb.h: * URB support, for asynchronous request completions
include/linux/usb.h: * @status: This is read in non-iso completion functions to get the
include/linux/usb.h: * @actual_length: This is read in non-iso completion functions, and
include/linux/usb.h: * @context: For use in completion functions.  This normally points to
include/linux/usb.h: *	completion function.  The completion function may then do what
include/linux/usb.h: * breaking the queue's synchronization.  Upon URB completion, the
include/linux/usb.h: * in completion handlers, so
include/linux/usb.h: * The completion callback is made in_interrupt(), and one of the first
include/linux/usb.h: * things that a completion handler should do is check the status field.
include/linux/usb.h: * be examined before the URB is returned to the completion handler.
include/linux/usb.h: * When the completion callback is invoked for non-isochronous URBs, the
include/linux/usb.h: * usb_submit_urb() till the entry into the completion routine.
include/linux/usb.h:	void *context;			/* (in) context for completion */
include/linux/usb.h:	usb_complete_t complete;	/* (in) completion routine */
include/linux/usb.h: * After an error completion, drivers may need to clear a halt condition
include/linux/usb.h:	struct completion	complete;
include/linux/mm_types.h:#include <linux/completion.h>
include/linux/mm_types.h:	struct completion startup;
include/linux/fs.h: *	writes, but for reads or writes that someone waits for completion
include/linux/fs.h: *			non-volatile media on completion.
include/linux/fs.h: *			non-volatile media on completion.
include/linux/fs.h:	/* AIO completions deferred from interrupt context */
include/linux/fs.h: * Two bits are used for locking and completion notification, I_NEW and I_SYNC.
include/linux/fs.h: * I_NEW		Serves as both a mutex and completion notification.
include/linux/iio/adc/ad_sigma_delta.h:	struct completion	completion;
include/linux/uinput.h:	struct completion	done;
include/linux/i2c/bfin_twi.h:	struct completion	complete;
include/linux/i2c/twl4030-madc.h:/* MADC conversion completion */
include/linux/mlx5/mlx5_ifc.h:	u8         command_completion_vector[0x20];
include/linux/mlx5/driver.h:#include <linux/completion.h>
include/linux/mlx5/driver.h:	/* lock on completion tasklet list */
include/linux/mlx5/driver.h:	struct completion	free;
include/linux/mlx5/driver.h:	struct completion	free;
include/linux/mlx5/driver.h:	struct completion	done;
include/linux/mlx5/driver.h:void mlx5_cq_completion(struct mlx5_core_dev *dev, u32 cqn);
include/linux/mlx5/cq.h:	struct completion	free;
include/linux/pm.h:#include <linux/completion.h>
include/linux/pm.h:	struct completion	completion;
include/linux/skbuff.h: * called before TX completion of this packet can trigger.  Otherwise
include/linux/blkdev.h:	 * to queue the request for softirq completion, which is long
include/linux/blkdev.h:	 * completion_data share space with the rb_node.
include/linux/blkdev.h:		void *completion_data;
include/linux/blkdev.h:	 * completion callback.
include/linux/blkdev.h: * Request completion related functions.
include/linux/kmod.h:	struct completion *complete;
include/linux/firewire.h:#include <linux/completion.h>
include/linux/firewire.h:	struct completion done;
include/linux/firewire.h:int fw_iso_context_flush_completions(struct fw_iso_context *ctx);
include/linux/scif.h: * Upon successful completion, scif_open() returns an endpoint descriptor to
include/linux/scif.h: * Upon successful completion, scif_bind() returns the port number to which epd
include/linux/scif.h: * Upon successful completion, scif_listen() returns 0; otherwise in user mode
include/linux/scif.h: * Upon successful completion, scif_connect() returns the port ID to which the
include/linux/scif.h: * Upon successful completion, scif_accept() returns 0; otherwise in user mode
include/linux/scif.h: * Upon successful completion, scif_close() returns 0; otherwise in user mode
include/linux/scif.h: * Upon successful completion, scif_send() returns the number of bytes sent;
include/linux/scif.h: * Upon successful completion, scif_recv() returns the number of bytes
include/linux/scif.h: * Upon successful completion, scif_register() returns the offset at which the
include/linux/scif.h: * Upon successful completion, scif_unregister() returns 0; otherwise in user
include/linux/scif.h: * the completion of asynchronous RMA operations on the same endpoint.
include/linux/scif.h: * Upon successful completion, scif_readfrom() returns 0; otherwise in user
include/linux/scif.h: * the completion of asynchronous RMA operations on the same endpoint.
include/linux/scif.h: * Upon successful completion, scif_readfrom() returns 0; otherwise in user
include/linux/scif.h: * the completion of asynchronous RMA operations on the same endpoint.
include/linux/scif.h: * Upon successful completion, scif_vreadfrom() returns 0; otherwise in user
include/linux/scif.h: * the completion of asynchronous RMA operations on the same endpoint.
include/linux/scif.h: * Upon successful completion, scif_vwriteto() returns 0; otherwise in user
include/linux/scif.h: * scif_fence_wait(), passing the value returned at mark, to await completion
include/linux/scif.h: * Upon successful completion, scif_fence_mark() returns 0; otherwise in user
include/linux/scif.h: * scif_fence_wait() - Wait for completion of marked RMAs
include/linux/scif.h: * Upon successful completion, scif_fence_wait() returns 0; otherwise in user
include/linux/scif.h: * scif_fence_signal() - Request a memory update on completion of RMAs
include/linux/scif.h: * If flags includes SCIF_SIGNAL_LOCAL, then on completion of the RMAs in the
include/linux/scif.h: * registered window. If flags includes SCIF_SIGNAL_REMOTE, then on completion
include/linux/scif.h: * SCIF_SIGNAL_LOCAL - On completion of the marked set of RMAs, write lval to
include/linux/scif.h: * SCIF_SIGNAL_REMOTE - On completion of the marked set of RMAs, write rval to
include/linux/scif.h: * Upon successful completion, scif_fence_signal() returns 0; otherwise in
include/linux/scif.h: * Upon successful completion, scif_get_node_ids() returns the actual number of
include/linux/scif.h: * Upon successful completion, scif_pin_pages() returns 0; otherwise the
include/linux/scif.h: * Upon successful completion, scif_unpin_pages() returns 0; otherwise the
include/linux/scif.h: * Upon successful completion, scif_register_pinned_pages() returns the offset
include/linux/scif.h: * Upon successful completion, scif_get_pages() returns 0; otherwise the
include/linux/scif.h: * Upon successful completion, scif_put_pages() returns 0; otherwise the
include/linux/scif.h: * Upon successful completion, scif_poll() returns a non-negative value. A
include/linux/scif.h: * Upon successful completion, scif_client_register() returns a non-negative
include/linux/pktcdvd.h:#include <linux/completion.h>
include/linux/backing-dev-defs.h:	struct fprop_local_percpu completions;
include/linux/backing-dev-defs.h:	struct fprop_local_percpu memcg_completions;
include/linux/hw_random.h:#include <linux/completion.h>
include/linux/hw_random.h:	struct completion cleanup_done;
include/linux/fscrypto.h:struct fscrypt_completion_result {
include/linux/fscrypto.h:	struct completion completion;
include/linux/fscrypto.h:	struct fscrypt_completion_result ecr = { \
include/linux/fscrypto.h:		COMPLETION_INITIALIZER((ecr).completion), 0 }
include/linux/ipmi_smi.h: * response with an error code in the completion code location. When
include/linux/ipmi_smi.h:	   completion" mode.  If this call sets the value to true, the
include/linux/ipmi_smi.h:	   to completion immediately. */
include/linux/ipmi_smi.h:	void (*set_run_to_completion)(void *send_info, bool run_to_completion);
include/linux/ipmi_smi.h:      netfn << 2, cmd, completion code, data
include/linux/rwsem.h: *   proper abstraction for this case is completions. ]
include/linux/nfs_page.h:	const struct nfs_pgio_completion_ops *pg_completion_ops;
include/linux/nfs_page.h:			     const struct nfs_pgio_completion_ops *compl_ops,
include/linux/writeback.h:	 * on page writeback completions [end_page_writeback()]. Those
include/linux/writeback.h:	 * We use page writeout completions because we are interested in
include/linux/writeback.h:	 * of this period itself is measured in page writeback completions.
include/linux/writeback.h:	struct fprop_global completions;
include/linux/writeback.h:	struct timer_list period_timer;	/* timer for aging of completions */
include/linux/writeback.h:void laptop_io_completion(struct backing_dev_info *info);
include/linux/writeback.h:void laptop_sync_completion(void);
include/linux/writeback.h:static inline void laptop_sync_completion(void) { }
include/linux/mlx4/qp.h:	 * [3:2] C (generate completion queue entry)
include/linux/mlx4/cmd.h:void mlx4_cmd_wake_completions(struct mlx4_dev *dev);
include/linux/mlx4/device.h:#include <linux/completion.h>
include/linux/mlx4/device.h:	struct completion	free;
include/linux/mlx4/device.h:	struct completion	free;
include/linux/mlx4/device.h:	struct completion	free;
include/linux/torture.h:#include <linux/completion.h>
include/linux/sysctl.h:struct completion;
include/linux/sysctl.h:	struct completion *unregistering;
include/linux/i2c-algo-pca.h:	int  (*wait_for_completion)	(void *data);
include/linux/module.h:	struct completion *kobj_completion;
include/linux/platform_data/edma.h: *		also manually or by "chaining" from DMA completions.
include/linux/mISDNif.h:#include <linux/completion.h>
include/linux/mISDNif.h:	struct completion	*notify;
include/linux/hsi/hsi.h: * @complete: Transfer completion callback
include/linux/hsi/hsi.h: * @actual_len: Actual length of data transferred on completion
include/linux/errno.h:#define EIOCBQUEUED	529	/* iocb queued, will get completion event */
include/linux/dynamic_queue_limits.h: *   2) Periodically a completion process executes which retires consumed
include/linux/dynamic_queue_limits.h: *      actually been consumed, but completion processing has not yet run
include/linux/dynamic_queue_limits.h: *    dql_completed - called at completion time to indicate how many objects
include/linux/dynamic_queue_limits.h:	/* Fields accessed only by completion path (dql_completed) */
include/linux/async_tx.h: * struct async_submit_ctl - async_tx submission/completion modifiers
include/linux/async_tx.h: * @cb_fn: callback routine to run at operation completion
include/linux/rmi.h: * @post_delay_us - the delay after the completion of an SPI transaction.  This
include/linux/rmi.h: * and post_delay_us after completion of the SPI transfer(s) before calling it
include/linux/spi/spi.h:#include <linux/completion.h>
include/linux/spi/spi.h: * @xfer_completion: used by core transfer_one_message()
include/linux/spi/spi.h: * message's completion function when the transaction completes.
include/linux/spi/spi.h:	struct completion               xfer_completion;
include/linux/spi/spi.h: * and its transfers, ignore them until its completion callback.
include/linux/spi/spi.h: * @complete: called to report transaction completions
include/linux/spi/spi.h: * and its transfers, ignore them until its completion callback.
include/linux/spi/spi.h:	/* completion is reported through a callback */
include/linux/wkup_m3_ipc.h:	struct completion sync_complete;
include/linux/netdevice.h: *	@rx_cpu_rmap:	CPU reverse-mapping for RX completion interrupts,
include/linux/netdevice.h:	struct sk_buff		*completion_queue;
include/linux/netdevice.h: * BQL enabled drivers might use this helper in their TX completion path,
include/linux/netdevice.h: * 	Report the number of bytes queued for sending/completion to the network
include/linux/netdevice.h: *  Typically used in place of consume_skb(skb) in TX completion path
include/linux/usb/gadget.h: * @no_interrupt: If true, hints that no completion irq is needed.
include/linux/usb/gadget.h: *	until the completion function returns, so that any transfers
include/linux/usb/gadget.h: * @context: For use by the completion callback
include/linux/usb/gadget.h: * @status: Reports completion code, zero or a negative errno.
include/linux/usb/gadget.h: *	the completion callback returns.
include/linux/usb/gadget.h: *	Code "-ESHUTDOWN" indicates completion caused by device disconnect,
include/linux/usb/gadget.h: *	even when status otherwise indicates successful completion.
include/linux/usb/hcd.h:		/* CLEAR_TT_BUFFER completion callback */
include/linux/usb/hcd.h:static inline bool hcd_periodic_completion_in_progress(struct usb_hcd *hcd,
include/linux/usb/ehci_def.h:#define STS_ERR		(1<<1)		/* "error" completion (overflow, ...) */
include/linux/usb/ehci_def.h:#define STS_INT		(1<<0)		/* "normal" completion (short, ...) */
include/linux/pipe_fs_i.h:	 * to a file system, we may need to wait for IO completion in this
include/linux/edac.h:#include <linux/completion.h>
include/linux/edac.h:	struct completion complete;
include/linux/lightnvm.h:	struct completion *wait;
include/linux/mtd/onenand.h:#include <linux/completion.h>
include/linux/mtd/onenand.h:	struct completion	complete;
include/linux/mtd/sh_flctl.h:#include <linux/completion.h>
include/linux/mtd/sh_flctl.h:	struct completion	dma_complete;
include/linux/sunrpc/rpc_rdma.h:	RDMA_DONE = 3,		/* Client signals reply completion */
include/linux/sunrpc/sched.h:int		__rpc_wait_for_completion_task(struct rpc_task *task, wait_bit_action_f *);
include/linux/sunrpc/sched.h:static inline int rpc_wait_for_completion_task(struct rpc_task *task)
include/linux/sunrpc/sched.h:	return __rpc_wait_for_completion_task(task, NULL);
include/linux/i2c-pnx.h:	struct completion	complete;	/* I/O completion */
include/linux/sched.h:#include <linux/completion.h>
include/linux/sched.h:	u64 blkio_delay;	/* wait for sync block io completion */
include/linux/sched.h:	u64 swapin_delay;	/* wait for swapin block io completion */
include/linux/sched.h:	struct completion *vfork_done;		/* for vfork() */
include/linux/hyperv.h:#include <linux/completion.h>
include/linux/hyperv.h:	struct completion  waitevent;
include/linux/ccp.h: * called to notify the caller of completion (if the cmd was not
include/linux/ccp.h: * The iv variable is used as both input and output. On completion of the
include/linux/ccp.h: * The iv variable is used as both input and output. On completion of the
include/linux/ccp.h: * The ctx variable is used as both input and output. On completion of the
include/linux/ccp.h: * @callback: operation completion callback function
include/linux/remoteproc.h:#include <linux/completion.h>
include/linux/remoteproc.h: * @crash_comp: completion used to sync crash handler and the rproc reload
include/linux/remoteproc.h:	struct completion firmware_loading_complete;
include/linux/remoteproc.h:	struct completion crash_comp;
include/linux/mfd/twl6040.h:	struct completion ready;
include/linux/mfd/rtsx_pci.h:	struct completion		*done;
include/linux/mfd/rtsx_pci.h:	struct completion		*finish_me;
include/linux/mfd/wm8350/core.h:#include <linux/completion.h>
include/linux/mfd/wm8350/core.h:	struct completion auxadc_done;
include/linux/mfd/wm831x/core.h:#include <linux/completion.h>
include/linux/mfd/si476x-core.h: * completion.
include/linux/mfd/ipaq-micro.h:#include <linux/completion.h>
include/linux/mfd/ipaq-micro.h: * @ack: a completion that will be completed when RX is complete
include/linux/mfd/ipaq-micro.h:	struct completion ack;
include/linux/mfd/ipaq-micro.h:	init_completion(&msg->ack);
include/linux/mfd/ipaq-micro.h:	wait_for_completion(&msg->ack);
include/linux/mfd/ipaq-micro.h:	init_completion(&msg->ack);
include/linux/mfd/da9052/da9052.h:#include <linux/completion.h>
include/linux/mfd/da9052/da9052.h:	struct completion done;
include/linux/mfd/altera-a10sr.h:#include <linux/completion.h>
include/linux/cyclades.h:	struct completion       shutdown_wait;
include/linux/crypto.h:typedef void (*crypto_completion_t)(struct crypto_async_request *req, int err);
include/linux/crypto.h:	crypto_completion_t complete;
include/linux/crypto.h: * cipher request returns immediately before the completion of the operation.
include/linux/crypto.h: * the kernel crypto API to inform the caller about the completion of a cipher
include/linux/crypto.h: * have, because when calling the callback function upon completion of the
include/linux/crypto.h:	u32 flags, crypto_completion_t compl, void *data)
include/linux/crypto.h: * cipher text. After the completion of the cipher operation, the plaintext
include/linux/ide.h:#include <linux/completion.h>
include/linux/ide.h:	struct completion gendev_rel_comp;	/* to deal with device release() */
include/linux/ide.h:	struct completion gendev_rel_comp; /* To deal with device release() */
include/linux/ide.h: * the tail of our block device request queue and wait for their completion.
include/linux/libps2.h:	/* Used to signal completion from interrupt handler */
include/linux/timer.h: * the completion of the running instance from IRQ handlers, for example,
include/linux/blk-mq.h:	 * Called to poll for completion of a specific tag.
include/linux/buffer_head.h:			  * IO completion of other buffers in the page
include/linux/buffer_head.h:	BH_Defer_Completion, /* Defer AIO completion to workqueue */
include/linux/buffer_head.h:	bh_end_io_t *b_end_io;		/* I/O completion */
include/linux/buffer_head.h:BUFFER_FNS(Defer_Completion, defer_completion)
include/linux/dlm.h: * astarg: the arg used with the completion ast for the unlock
include/linux/hid-sensor-hub.h:	struct completion ready;
include/linux/dm-kcopyd.h: * or with an asynchronous completion notification.
include/linux/memstick.h:	struct completion        mrq_complete;
include/linux/i2c.h:#include <linux/sched.h>	/* for completion */
include/linux/i2c.h:	struct completion dev_released;
include/linux/bsg-lib.h:	 * Upon completion : the message handler must set reply_len
include/linux/nfs_xdr.h:	const struct nfs_pgio_completion_ops *completion_ops;
include/linux/nfs_xdr.h:struct nfs_commit_completion_ops {
include/linux/nfs_xdr.h:	void (*completion) (struct nfs_commit_data *data);
include/linux/nfs_xdr.h:	const struct nfs_commit_completion_ops *completion_ops;
include/linux/nfs_xdr.h:	const struct nfs_commit_completion_ops *completion_ops;
include/linux/nfs_xdr.h:struct nfs_pgio_completion_ops {
include/linux/nfs_xdr.h:	void	(*completion)(struct nfs_pgio_header *hdr);
include/media/soc_camera.h: * changed during this operation. After completion the host should detach sense.
include/media/cec.h:	struct completion c;
include/media/cec.h:	struct completion config_completion;
include/acpi/actbl2.h:	u8 completion_code;
include/acpi/acpi_bus.h:	struct completion kobj_done;
include/xen/xenbus.h:#include <linux/completion.h>
include/xen/xenbus.h:	struct completion down;
init/Kconfig:	  resources like cpu, synchronous block I/O completion and swapping
init/main.c:	wait_for_completion(&kthreadd_done);
ipc/sem.c:	int			status;	 /* completion status of operation */
kernel/acct.c:	struct completion	done;
kernel/acct.c:	wait_for_completion(&acct->done);
kernel/acct.c:	init_completion(&acct->done);
kernel/irq/manage.c: *	disable_irq - disable an irq and wait for completion
kernel/irq/manage.c: *	disable_hardirq - disables an irq and waits for hardirq completion
kernel/workqueue.c:#include <linux/completion.h>
kernel/workqueue.c:	struct completion	*detach_completion; /* all workers detached */
kernel/workqueue.c:	struct completion	done;		/* flush completion */
kernel/workqueue.c:	struct completion *detach_completion = NULL;
kernel/workqueue.c:		detach_completion = pool->detach_completion;
kernel/workqueue.c:	if (detach_completion)
kernel/workqueue.c:		complete(detach_completion);
kernel/workqueue.c:	struct completion	done;
kernel/workqueue.c:	init_completion(&barr->done);
kernel/workqueue.c: * flush_workqueue - ensure that any scheduled work has run to completion.
kernel/workqueue.c:		 * The next flush completion will assign us
kernel/workqueue.c:	wait_for_completion(&this_flusher.done);
kernel/workqueue.c:		wait_for_completion(&barr.done);
kernel/workqueue.c:		 * because we may get scheduled between @work's completion
kernel/workqueue.c:		 * Let's wait for completion using a waitqueue.  As this
kernel/workqueue.c:	DECLARE_COMPLETION_ONSTACK(detach_completion);
kernel/workqueue.c:		pool->detach_completion = &detach_completion;
kernel/workqueue.c:	if (pool->detach_completion)
kernel/workqueue.c:		wait_for_completion(pool->detach_completion);
kernel/cpu.c: * @done:	Signal completion to the issuer of the task
kernel/cpu.c:	struct completion	done;
kernel/cpu.c:	wait_for_completion(&st->done);
kernel/cpu.c:	init_completion(&st->done);
kernel/cpu.c:	wait_for_completion(&st->done);
kernel/cpu.c:	wait_for_completion(&st->done);
kernel/cpu.c:	wait_for_completion(&st->done);
kernel/backtracetest.c:#include <linux/completion.h>
kernel/backtracetest.c:	init_completion(&backtrace_work);
kernel/backtracetest.c:	wait_for_completion(&backtrace_work);
kernel/time/timer.c: * not hold locks which would prevent completion of the timer's
kernel/cgroup_freezer.c:			 * completion.  Consider it frozen in addition to
kernel/module.c:	mod->mkobj.kobj_completion = &c;
kernel/module.c:	wait_for_completion(&c);
kernel/kmod.c:#include <linux/completion.h>
kernel/kmod.c:	struct completion *comp = xchg(&sub_info->complete, NULL);
kernel/kmod.c:	 * Set the completion pointer only if there is a waiter.
kernel/kmod.c:		retval = wait_for_completion_killable(&done);
kernel/kmod.c:	wait_for_completion(&done);
kernel/rcu/tree.h:	struct completion barrier_completion;	/* Wake at barrier end. */
kernel/rcu/tree.c:#include <linux/completion.h>
kernel/rcu/tree.c:		/* Remember that we saw this grace-period completion. */
kernel/rcu/tree.c:		complete(&rsp->barrier_completion);
kernel/rcu/tree.c:	init_completion(&rsp->barrier_completion);
kernel/rcu/tree.c:		complete(&rsp->barrier_completion);
kernel/rcu/tree.c:	wait_for_completion(&rsp->barrier_completion);
kernel/rcu/tree_trace.c:#include <linux/completion.h>
kernel/rcu/rcutorture.c:#include <linux/completion.h>
kernel/rcu/tiny.c:#include <linux/completion.h>
kernel/rcu/update.c:	complete(&rcu->completion);
kernel/rcu/update.c:		init_completion(&rs_array[i].completion);
kernel/rcu/update.c:		wait_for_completion(&rs_array[i].completion);
kernel/rcu/srcu.c:	init_completion(&rcu.completion);
kernel/rcu/srcu.c:		wait_for_completion(&rcu.completion);
kernel/rcu/srcu.c: * synchronize_srcu - wait for prior SRCU read-side critical-section completion
kernel/rcu/srcu.c: * @sp: srcu_struct on which to report batch completion.
kernel/rcu/rcuperf.c:#include <linux/completion.h>
kernel/trace/ring_buffer.c:	struct completion		update_done;
kernel/trace/ring_buffer.c:	init_completion(&cpu_buffer->update_done);
kernel/trace/ring_buffer.c:				wait_for_completion(&cpu_buffer->update_done);
kernel/trace/ring_buffer.c:			wait_for_completion(&cpu_buffer->update_done);
kernel/trace/trace_selftest.c:	struct completion	is_ready;
kernel/trace/trace_selftest.c:	init_completion(&data.is_ready);
kernel/trace/trace_selftest.c:	wait_for_completion(&data.is_ready);
kernel/trace/trace_selftest.c:	init_completion(&data.is_ready);
kernel/trace/trace_selftest.c:	wait_for_completion(&data.is_ready);
kernel/trace/ring_buffer_benchmark.c:#include <linux/completion.h>
kernel/trace/ring_buffer_benchmark.c:	 * and is ready for the completion.
kernel/trace/ring_buffer_benchmark.c:		/* Init both completions here to avoid races */
kernel/trace/ring_buffer_benchmark.c:		init_completion(&read_start);
kernel/trace/ring_buffer_benchmark.c:		init_completion(&read_done);
kernel/trace/ring_buffer_benchmark.c:		/* the completions must be visible before the finish var */
kernel/trace/ring_buffer_benchmark.c:		wait_for_completion(&read_done);
kernel/trace/ring_buffer_benchmark.c:			wait_for_completion(&read_start);
kernel/params.c:	complete(mk->kobj_completion);
kernel/events/uprobes.c: * non-fatal signals until completion of singlestep.  When xol insn itself
kernel/events/uprobes.c: * mechanism. Set TIF_UPROBE flag and indicate completion of singlestep.
kernel/futex.c:	 * queue_me() calls spin_unlock() upon completion, both serializing
kernel/cgroup.c: * returns NULL.  On completion of iteration, css_task_iter_end() must be
kernel/cgroup.c:	 * association is stable, and, on completion of the parent's
kernel/torture.c:#include <linux/completion.h>
kernel/power/swap.c: *	@hb:		bio completion batch
kernel/smp.c:	struct completion	done;
kernel/smp.c:	wait_for_completion(&sscs.done);
kernel/kthread.c:#include <linux/completion.h>
kernel/kthread.c:	struct completion *done;
kernel/kthread.c:	struct completion parked;
kernel/kthread.c:	struct completion exited;
kernel/kthread.c:	struct completion *vfork = ACCESS_ONCE(k->vfork_done);
kernel/kthread.c:	struct completion *done;
kernel/kthread.c:	init_completion(&self.exited);
kernel/kthread.c:	init_completion(&self.parked);
kernel/kthread.c:		struct completion *done = xchg(&create->done, NULL);
kernel/kthread.c:	 * Wait for completion in killable state, for I might be chosen by
kernel/kthread.c:	if (unlikely(wait_for_completion_killable(&done))) {
kernel/kthread.c:		wait_for_completion(&done);
kernel/kthread.c:				wait_for_completion(&kthread->parked);
kernel/kthread.c:		wait_for_completion(&kthread->exited);
kernel/kthread.c:	struct completion	done;
kernel/kthread.c:		wait_for_completion(&fwork.done);
kernel/kthread.c:	wait_for_completion(&fwork.done);
kernel/kprobes.c:	/* Wait for unoptimizing completion */
kernel/debug/kdb/kdb_support.c: *	starts with this prefix (tab completion).
kernel/fork.c:#include <linux/completion.h>
kernel/fork.c:	struct completion *vfork;
kernel/fork.c:				struct completion *vfork)
kernel/fork.c:	killed = wait_for_completion_killable(vfork);
kernel/fork.c:	 * Also kthread_stop() uses this completion for synchronization.
kernel/fork.c:		struct completion vfork;
kernel/fork.c:			init_completion(&vfork);
kernel/stop_machine.c:#include <linux/completion.h>
kernel/stop_machine.c: * Structure to determine completion condition and record errors.  May
kernel/stop_machine.c:	struct completion	completion;	/* fired if nr_todo reaches 0 */
kernel/stop_machine.c:	init_completion(&done->completion);
kernel/stop_machine.c:/* signal completion unless @done is NULL */
kernel/stop_machine.c:		complete(&done->completion);
kernel/stop_machine.c:	wait_for_completion(&done.completion);
kernel/stop_machine.c:	wait_for_completion(&done.completion);
kernel/stop_machine.c: * stop_one_cpu_nowait - stop a cpu but don't wait for completion
kernel/stop_machine.c: * Similar to stop_one_cpu() but doesn't wait for completion.  The
kernel/stop_machine.c:	wait_for_completion(&done.completion);
kernel/stop_machine.c:	/* Busy wait for completion. */
kernel/stop_machine.c:	while (!completion_done(&done.completion))
kernel/sched/Makefile:obj-y += wait.o swait.o completion.o idle.o
kernel/sched/core.c:#include <linux/completion.h>
kernel/sched/completion.c: * Generic wait-for-completion handler;
kernel/sched/completion.c: * wait_for_completion default blocks whereas semaphore default non-block. The
kernel/sched/completion.c: * Waiting for completion is a typically sync point, but not an exclusion point.
kernel/sched/completion.c:#include <linux/completion.h>
kernel/sched/completion.c: * complete: - signals a single thread waiting on this completion
kernel/sched/completion.c: * @x:  holds the state of this particular completion
kernel/sched/completion.c: * This will wake up a single thread waiting on this completion. Threads will be
kernel/sched/completion.c: * See also complete_all(), wait_for_completion() and related routines.
kernel/sched/completion.c:void complete(struct completion *x)
kernel/sched/completion.c: * complete_all: - signals all threads waiting on this completion
kernel/sched/completion.c: * @x:  holds the state of this particular completion
kernel/sched/completion.c: * This will wake up all threads waiting on this particular completion event.
kernel/sched/completion.c:void complete_all(struct completion *x)
kernel/sched/completion.c:do_wait_for_common(struct completion *x,
kernel/sched/completion.c:__wait_for_common(struct completion *x,
kernel/sched/completion.c:wait_for_common(struct completion *x, long timeout, int state)
kernel/sched/completion.c:wait_for_common_io(struct completion *x, long timeout, int state)
kernel/sched/completion.c: * wait_for_completion: - waits for completion of a task
kernel/sched/completion.c: * @x:  holds the state of this particular completion
kernel/sched/completion.c: * This waits to be signaled for completion of a specific task. It is NOT
kernel/sched/completion.c: * See also similar routines (i.e. wait_for_completion_timeout()) with timeout
kernel/sched/completion.c:void __sched wait_for_completion(struct completion *x)
kernel/sched/completion.c:EXPORT_SYMBOL(wait_for_completion);
kernel/sched/completion.c: * wait_for_completion_timeout: - waits for completion of a task (w/timeout)
kernel/sched/completion.c: * @x:  holds the state of this particular completion
kernel/sched/completion.c: * This waits for either a completion of a specific task to be signaled or for a
kernel/sched/completion.c:wait_for_completion_timeout(struct completion *x, unsigned long timeout)
kernel/sched/completion.c:EXPORT_SYMBOL(wait_for_completion_timeout);
kernel/sched/completion.c: * wait_for_completion_io: - waits for completion of a task
kernel/sched/completion.c: * @x:  holds the state of this particular completion
kernel/sched/completion.c: * This waits to be signaled for completion of a specific task. It is NOT
kernel/sched/completion.c:void __sched wait_for_completion_io(struct completion *x)
kernel/sched/completion.c:EXPORT_SYMBOL(wait_for_completion_io);
kernel/sched/completion.c: * wait_for_completion_io_timeout: - waits for completion of a task (w/timeout)
kernel/sched/completion.c: * @x:  holds the state of this particular completion
kernel/sched/completion.c: * This waits for either a completion of a specific task to be signaled or for a
kernel/sched/completion.c:wait_for_completion_io_timeout(struct completion *x, unsigned long timeout)
kernel/sched/completion.c:EXPORT_SYMBOL(wait_for_completion_io_timeout);
kernel/sched/completion.c: * wait_for_completion_interruptible: - waits for completion of a task (w/intr)
kernel/sched/completion.c: * @x:  holds the state of this particular completion
kernel/sched/completion.c: * This waits for completion of a specific task to be signaled. It is
kernel/sched/completion.c:int __sched wait_for_completion_interruptible(struct completion *x)
kernel/sched/completion.c:EXPORT_SYMBOL(wait_for_completion_interruptible);
kernel/sched/completion.c: * wait_for_completion_interruptible_timeout: - waits for completion (w/(to,intr))
kernel/sched/completion.c: * @x:  holds the state of this particular completion
kernel/sched/completion.c: * This waits for either a completion of a specific task to be signaled or for a
kernel/sched/completion.c:wait_for_completion_interruptible_timeout(struct completion *x,
kernel/sched/completion.c:EXPORT_SYMBOL(wait_for_completion_interruptible_timeout);
kernel/sched/completion.c: * wait_for_completion_killable: - waits for completion of a task (killable)
kernel/sched/completion.c: * @x:  holds the state of this particular completion
kernel/sched/completion.c: * This waits to be signaled for completion of a specific task. It can be
kernel/sched/completion.c:int __sched wait_for_completion_killable(struct completion *x)
kernel/sched/completion.c:EXPORT_SYMBOL(wait_for_completion_killable);
kernel/sched/completion.c: * wait_for_completion_killable_timeout: - waits for completion of a task (w/(to,killable))
kernel/sched/completion.c: * @x:  holds the state of this particular completion
kernel/sched/completion.c: * This waits for either a completion of a specific task to be
kernel/sched/completion.c:wait_for_completion_killable_timeout(struct completion *x,
kernel/sched/completion.c:EXPORT_SYMBOL(wait_for_completion_killable_timeout);
kernel/sched/completion.c: *	try_wait_for_completion - try to decrement a completion without blocking
kernel/sched/completion.c: *	@x:	completion structure
kernel/sched/completion.c: *	If a completion is being used as a counting completion,
kernel/sched/completion.c: *	enables us to avoid waiting if the resource the completion
kernel/sched/completion.c:bool try_wait_for_completion(struct completion *x)
kernel/sched/completion.c:EXPORT_SYMBOL(try_wait_for_completion);
kernel/sched/completion.c: *	completion_done - Test to see if a completion has any waiters
kernel/sched/completion.c: *	@x:	completion structure
kernel/sched/completion.c: *	Return: 0 if there are waiters (wait_for_completion() in progress)
kernel/sched/completion.c:bool completion_done(struct completion *x)
kernel/sched/completion.c:	 * otherwise we can end up freeing the completion before complete()
kernel/sched/completion.c:EXPORT_SYMBOL(completion_done);
kernel/exit.c:#include <linux/completion.h>
kernel/exit.c:void complete_and_exit(struct completion *comp, long code)
kernel/signal.c: * %true if group stop completion should be notified to the parent, %false
kernel/signal.c:	 * Tell the caller to notify completion iff we are entering into a
kernel/signal.c: * expirations or I/O completions".  In the case of POSIX Timers
kernel/signal.c:		 * interested in the completion of group stop.  The states
kernel/signal.c:		 * completion and here.  During detach, it would have set
kernel/signal.c:		 * the real parent of the group stop completion is enough.
kernel/signal.c:		 * Notify the parent of the group stop completion.  Because
lib/percpu-refcount.c:	 * its completion.  If the caller ensures that ATOMIC switching
lib/percpu-refcount.c: * be collected to the main atomic counter.  On completion, when all CPUs
lib/dynamic_queue_limits.c:		 *     may have becomes starved between completion processing
lib/dynamic_queue_limits.c:		 * completion routine.
lib/asn1_decoder.c:			pr_err("ASN.1 decoder error: Stacks not empty at completion (%u, %u)\n",
lib/assoc_array.c: * array will be empty and ready to use again upon completion.  This function
lib/irq_poll.c: * @weight:   The default weight (or command completion budget)
lib/test_firmware.c:#include <linux/completion.h>
lib/test_firmware.c:	wait_for_completion(&async_fw_done);
mm/backing-dev.c:	err = fprop_local_init_percpu(&wb->completions, gfp);
mm/backing-dev.c:	fprop_local_destroy_percpu(&wb->completions);
mm/backing-dev.c:	fprop_local_destroy_percpu(&wb->completions);
mm/backing-dev.c: * protected.  cgwb_release_wait is used to wait for the completion of cgwb
mm/backing-dev.c:	fprop_local_destroy_percpu(&wb->memcg_completions);
mm/backing-dev.c:	ret = fprop_local_init_percpu(&wb->memcg_completions, gfp);
mm/backing-dev.c:	fprop_local_destroy_percpu(&wb->memcg_completions);
mm/page-writeback.c:	struct fprop_local_percpu *wb_completions;
mm/page-writeback.c:				.wb_completions = &(__wb)->completions
mm/page-writeback.c:				.wb_completions = &(__wb)->memcg_completions, \
mm/page-writeback.c:static struct fprop_local_percpu *wb_memcg_completions(struct bdi_writeback *wb)
mm/page-writeback.c:	return &wb->memcg_completions;
mm/page-writeback.c:				.wb_completions = &(__wb)->completions
mm/page-writeback.c:static struct fprop_local_percpu *wb_memcg_completions(struct bdi_writeback *wb)
mm/page-writeback.c:				   struct fprop_local_percpu *completions,
mm/page-writeback.c:	__fprop_inc_percpu_max(&dom->completions, completions,
mm/page-writeback.c: * Increment @wb's writeout completion count and the global writeout
mm/page-writeback.c: * completion count. Called from test_clear_page_writeback().
mm/page-writeback.c:	wb_domain_writeout_inc(&global_wb_domain, &wb->completions,
mm/page-writeback.c:		wb_domain_writeout_inc(cgdom, wb_memcg_completions(wb),
mm/page-writeback.c:	if (fprop_new_period(&dom->completions, miss_periods + 1)) {
mm/page-writeback.c:	return fprop_global_init(&dom->completions, gfp);
mm/page-writeback.c:	fprop_global_destroy(&dom->completions);
mm/page-writeback.c:	fprop_fraction_percpu(&dom->completions, dtc->wb_completions,
mm/page-writeback.c:void laptop_io_completion(struct backing_dev_info *info)
mm/page-writeback.c: * caused another writeback to be scheduled by laptop_io_completion.
mm/page-writeback.c:void laptop_sync_completion(void)
mm/madvise.c: * Schedule all required I/O operations.  Do not wait for completion.
mm/vmscan.c:	 * Stall direct reclaim for IO completions if underlying BDIs or zone
mm/huge_memory.c:	 * If there are potential migrations, wait for completion and retry
mm/migrate.c: * This function doesn't wait the completion of hugepage I/O
mm/page_alloc.c:	wait_for_completion(&pgdat_init_all_done_comp);
mm/swap_state.c:			 * I/O completion at scan_swap_map().
mm/swap_state.c:			 * if !CONFIG_PREEMPT and the I/O completion happens
mm/shmem.c:	 * standard mutex or completion: but we cannot take i_mutex in fault,
net/mac80211/util.c:	/* It's possible that we don't handle the scan completion in
net/mac80211/scan.c:	 * We have a scan running and the driver already reported completion,
net/mac80211/agg-tx.c: * setup completion.
net/mac80211/agg-tx.c: * the peer, the driver is notified of the completion of the
net/9p/trans_rdma.c:	struct completion cm_done;
net/9p/trans_rdma.c:	init_completion(&rdma->cm_done);
net/9p/trans_rdma.c:	err = wait_for_completion_interruptible(&rdma->cm_done);
net/9p/trans_rdma.c:	err = wait_for_completion_interruptible(&rdma->cm_done);
net/9p/trans_rdma.c:	err = wait_for_completion_interruptible(&rdma->cm_done);
net/decnet/af_decnet.c:	rcu_barrier_bh(); /* Wait for completion of call_rcu_bh()'s */
net/can/af_can.c:	rcu_barrier(); /* Wait for completion of call_rcu()'s */
net/can/gw.c:	rcu_barrier(); /* Wait for completion of call_rcu()'s */
net/ceph/osd_client.c:	init_completion(&req->r_completion);
net/ceph/osd_client.c:	init_completion(&req->r_safe_completion);
net/ceph/osd_client.c:		complete_all(&req->r_completion);
net/ceph/osd_client.c:	complete_all(&req->r_safe_completion);
net/ceph/osd_client.c:	init_completion(&lreq->reg_commit_wait);
net/ceph/osd_client.c:	init_completion(&lreq->notify_finish_wait);
net/ceph/osd_client.c:	if (!completion_done(&lreq->reg_commit_wait)) {
net/ceph/osd_client.c:	ret = wait_for_completion_interruptible(&lreq->reg_commit_wait);
net/ceph/osd_client.c:	ret = wait_for_completion_interruptible(&lreq->notify_finish_wait);
net/ceph/osd_client.c: * or do the completion to wake up the waiting thread.
net/ceph/osd_client.c: * first reply is OK (needed	r_cb/r_completion,	r_cb/r_completion,
net/ceph/osd_client.c: * any or needed/got safe)	r_safe_completion	r_safe_completion
net/ceph/osd_client.c: * when we get the safe reply	r_unsafe_cb(false),	r_cb/r_completion,
net/ceph/osd_client.c: *				r_safe_completion	r_safe_completion
net/ceph/osd_client.c:			complete_all(&req->r_safe_completion);
net/ceph/osd_client.c:		} else if (!completion_done(&lreq->notify_finish_wait)) {
net/ceph/osd_client.c:	left = wait_for_completion_killable_timeout(&req->r_completion,
net/ceph/osd_client.c:		complete_all(&req->r_safe_completion);
net/ceph/osd_client.c:			wait_for_completion(&req->r_safe_completion);
net/ceph/mon_client.c:	init_completion(&req->completion);
net/ceph/mon_client.c:		complete_all(&req->completion);
net/ceph/mon_client.c:	ret = wait_for_completion_interruptible(&req->completion);
net/mac802154/llsec.c:#include <linux/completion.h>
net/ipv4/tcp_vegas.c: * Instead we must wait until the completion of an RTT during
net/ipv4/udp.c: * Otherwise, csum completion requires chacksumming packet body,
net/ipv4/tcp.c: *		A.N.Kuznetsov	:	Don't time wait on completion of tidy
net/ipv4/tcp.c: * Because TX completion will happen shortly, it gives a chance
net/ipv4/tcp.c: * or if TX completion was delayed after we processed ACK packet.
net/ipv4/tcp.c:		/* It is possible TX completion already happened
net/ipv4/tcp_offload.c:	 * is freed at TX completion, and not right now when gso_skb
net/ipv4/tcp_output.c:		/* It is possible TX completion already happened
net/ipv4/netfilter/ipt_CLUSTERIP.c:	/* Wait for completion of call_rcu_bh()'s (clusterip_config_rcu_free) */
net/bluetooth/hci_event.c:	 * request completion callbacks used for connecting.
net/bluetooth/hci_event.c:		 * progress, then change discovery state to indicate completion.
net/bluetooth/hci_event.c:		 * state to indicate completion.
net/bluetooth/hci_event.c:		 * progress, then change discovery state to indicate completion.
net/bluetooth/hci_event.c:		 * state to indicate completion.
net/bluetooth/hci_event.c:	/* Indicate request completion if the command failed. Also, if
net/bluetooth/hci_request.c:/* Execute request and wait for completion. */
net/sctp/protocol.c:	rcu_barrier(); /* Wait for completion of call_rcu()'s */
net/ipv6/sit.c:	rcu_barrier(); /* Wait for completion of call_rcu()'s */
net/bridge/br.c:	rcu_barrier(); /* Wait for completion of call_rcu()'s */
net/iucv/af_iucv.c:	/* increment and save iucv message tag for msg_completion cbk */
net/iucv/iucv.c:	 *	0x20 - Flag to allow nonpriority message completion interrupts
net/iucv/iucv.c:	 *	0x10 - Flag to allow priority message completion interrupts
net/8021q/vlan.c:	rcu_barrier(); /* Wait for completion of call_rcu()'s */
net/core/flow.c:#include <linux/completion.h>
net/core/flow.c:	struct completion		completion;
net/core/flow.c:		complete(&info->completion);
net/core/flow.c:	init_completion(&info.completion);
net/core/flow.c:	wait_for_completion(&info.completion);
net/core/pktgen.c:	struct completion start_done;
net/core/pktgen.c:	init_completion(&t->start_done);
net/core/pktgen.c:	wait_for_completion(&t->start_done);
net/core/skbuff.c:		/* We usually free the clone (TX completion) before original skb
net/core/dev.c:	skb->next = __this_cpu_read(softnet_data.completion_queue);
net/core/dev.c:	__this_cpu_write(softnet_data.completion_queue, skb);
net/core/dev.c:	if (sd->completion_queue) {
net/core/dev.c:		clist = sd->completion_queue;
net/core/dev.c:		sd->completion_queue = NULL;
net/core/dev.c:	/* Find end of our completion_queue. */
net/core/dev.c:	list_skb = &sd->completion_queue;
net/core/dev.c:	/* Append completion queue from offline CPU. */
net/core/dev.c:	*list_skb = oldsd->completion_queue;
net/core/dev.c:	oldsd->completion_queue = NULL;
net/core/netpoll.c:static void zap_completion_queue(void);
net/core/netpoll.c:	zap_completion_queue();
net/core/netpoll.c:static void zap_completion_queue(void)
net/core/netpoll.c:	if (sd->completion_queue) {
net/core/netpoll.c:		clist = sd->completion_queue;
net/core/netpoll.c:		sd->completion_queue = NULL;
net/core/netpoll.c:	zap_completion_queue();
net/nfc/nci/core.c:#include <linux/completion.h>
net/nfc/nci/core.c:		complete(&ndev->req_completion);
net/nfc/nci/core.c:		complete(&ndev->req_completion);
net/nfc/nci/core.c:/* Execute request and wait for completion. */
net/nfc/nci/core.c:	long completion_rc;
net/nfc/nci/core.c:	reinit_completion(&ndev->req_completion);
net/nfc/nci/core.c:	completion_rc =
net/nfc/nci/core.c:		wait_for_completion_interruptible_timeout(&ndev->req_completion,
net/nfc/nci/core.c:	pr_debug("wait_for_completion return %ld\n", completion_rc);
net/nfc/nci/core.c:	if (completion_rc > 0) {
net/nfc/nci/core.c:		pr_err("wait_for_completion_interruptible_timeout failed %ld\n",
net/nfc/nci/core.c:		       completion_rc);
net/nfc/nci/core.c:		rc = ((completion_rc == 0) ? (-ETIMEDOUT) : (completion_rc));
net/nfc/nci/core.c:	init_completion(&ndev->req_completion);
net/nfc/nci/spi.c:		 struct completion *write_handshake_completion,
net/nfc/nci/spi.c:	long completion_rc;
net/nfc/nci/spi.c:	if (write_handshake_completion)	{
net/nfc/nci/spi.c:		if (wait_for_completion_timeout(write_handshake_completion,
net/nfc/nci/spi.c:	reinit_completion(&nspi->req_completion);
net/nfc/nci/spi.c:	completion_rc =	wait_for_completion_interruptible_timeout(
net/nfc/nci/spi.c:							&nspi->req_completion,
net/nfc/nci/spi.c:	if (completion_rc <= 0 || nspi->req_result == ACKNOWLEDGE_NACK)
net/nfc/nci/spi.c:	init_completion(&nspi->req_completion);
net/nfc/nci/spi.c:		 * unblock completion of latest frame sent.
net/nfc/nci/spi.c:			complete(&nspi->req_completion);
net/nfc/hci/hcp.c: * Guarantees that cb will be called upon completion or timeout delay
net/nfc/hci/hcp.c:			   unsigned long completion_delay)
net/nfc/hci/hcp.c:	cmd->completion_delay = completion_delay;
net/nfc/hci/hci.h:	unsigned long completion_delay;
net/nfc/hci/hci.h:			   unsigned long completion_delay);
net/nfc/hci/core.c:		  msecs_to_jiffies(hdev->cmd_pending_msg->completion_delay));
net/nfc/hci/core.c:static void __nfc_hci_cmd_completion(struct nfc_hci_dev *hdev, int err,
net/nfc/hci/core.c:	__nfc_hci_cmd_completion(hdev, nfc_hci_result_to_errno(result), skb);
net/nfc/hci/core.c:	__nfc_hci_cmd_completion(hdev, err, NULL);
net/nfc/hci/command.c: * HCI command execution completion callback.
net/sunrpc/sched.c: * Allow callers to wait for completion of an RPC call
net/sunrpc/sched.c:int __rpc_wait_for_completion_task(struct rpc_task *task, wait_bit_action_f *action)
net/sunrpc/sched.c:EXPORT_SYMBOL_GPL(__rpc_wait_for_completion_task);
net/sunrpc/sched.c:		/* Wake up anyone who may be waiting for task completion */
net/sunrpc/xprtrdma/transport.c: *  3.  Post a recv message to set up asynch completion, then send
net/sunrpc/xprtrdma/xprt_rdma.h:	struct completion	ri_done;
net/sunrpc/xprtrdma/xprt_rdma.h:	struct completion		fr_linv_done;
net/sunrpc/xprtrdma/svc_rdma_transport.c: * @cq:        completion queue
net/sunrpc/xprtrdma/svc_rdma_transport.c: * @cq:        completion queue
net/sunrpc/xprtrdma/svc_rdma_transport.c: * @cq:        completion queue
net/sunrpc/xprtrdma/svc_rdma_transport.c: * @cq:        completion queue
net/sunrpc/xprtrdma/svc_rdma_transport.c: * @cq:        completion queue
net/sunrpc/xprtrdma/svc_rdma_transport.c: * @cq:        completion queue
net/sunrpc/xprtrdma/svc_rdma_transport.c:	 * Destroy queued, but not processed read completions. Note
net/sunrpc/xprtrdma/svc_rdma_transport.c:	/* Destroy queued, but not processed recv completions */
net/sunrpc/xprtrdma/svc_rdma_recvfrom.c: * the RDMA_RECV completion. The SGL should contain full pages up until the
net/sunrpc/xprtrdma/frwr_ops.c: * under a spinlock) is needed in the completion upcall.
net/sunrpc/xprtrdma/frwr_ops.c:	init_completion(&f->fr_linv_done);
net/sunrpc/xprtrdma/frwr_ops.c:__frwr_sendcompletion_flush(struct ib_wc *wc, const char *wr)
net/sunrpc/xprtrdma/frwr_ops.c: * @cq:	completion queue (ignored)
net/sunrpc/xprtrdma/frwr_ops.c:		__frwr_sendcompletion_flush(wc, "fastreg");
net/sunrpc/xprtrdma/frwr_ops.c: * @cq:	completion queue (ignored)
net/sunrpc/xprtrdma/frwr_ops.c:		__frwr_sendcompletion_flush(wc, "localinv");
net/sunrpc/xprtrdma/frwr_ops.c: * @cq:	completion queue (ignored)
net/sunrpc/xprtrdma/frwr_ops.c:		__frwr_sendcompletion_flush(wc, "localinv");
net/sunrpc/xprtrdma/frwr_ops.c:	reinit_completion(&f->fr_linv_done);
net/sunrpc/xprtrdma/frwr_ops.c:	wait_for_completion(&f->fr_linv_done);
net/sunrpc/xprtrdma/verbs.c: * @cq:	completion queue (ignored)
net/sunrpc/xprtrdma/verbs.c: * @cq:	completion queue (ignored)
net/sunrpc/xprtrdma/verbs.c:	init_completion(&ia->ri_done);
net/sunrpc/xprtrdma/verbs.c:	wait_for_completion_interruptible_timeout(&ia->ri_done,
net/sunrpc/xprtrdma/verbs.c:	wait_for_completion_interruptible_timeout(&ia->ri_done,
net/sunrpc/xprtrdma/verbs.c:	/* set trigger for requesting send completion */
net/sunrpc/xprtrdma/verbs.c: * Receive buffer is donated to hardware, reclaimed upon recv completion.
net/sunrpc/xprtrdma/verbs.c:	else { /* Provider must take a send completion every now and then */
net/sunrpc/sunrpc_syms.c:	rcu_barrier(); /* Wait for completion of call_rcu()'s */
net/sunrpc/cache.c:	struct completion completion;
net/sunrpc/cache.c:	complete(&dr->completion);
net/sunrpc/cache.c:	sleeper.completion = COMPLETION_INITIALIZER_ONSTACK(sleeper.completion);
net/sunrpc/cache.c:	    wait_for_completion_interruptible_timeout(
net/sunrpc/cache.c:		    &sleeper.completion, req->thread_wait) <= 0) {
net/sunrpc/cache.c:		/* The completion wasn't completed, so we need
net/sunrpc/cache.c:			wait_for_completion(&sleeper.completion);
net/sunrpc/auth_gss/auth_gss.c:	rcu_barrier(); /* Wait for completion of call_rcu()'s */
net/rds/ib.h:	/* Batched completions */
net/rds/ib_ring.c: * the CQ completion handlers to wake it up after freeing some
net/rds/af_rds.c: *	update, or a RDMA completion).
net/rds/send.c:	 * completion handler.
net/rds/send.c: * the IB send completion on the RDMA op and the accompanying
net/rds/ib_frmr.c:					  "frmr completion <%pI4,%pI4> status %u(%s), vendor_err 0x%x, disconnecting and reconnecting\n",
net/rds/rdma.c:		 * we don't want to do that in the completion handler. We
net/rds/rdma.c:		 * we don't want to do that in the completion handler. We
net/rds/ib_cm.c:	 * completion queue and send queue. This extra space is used for FRMR
net/rds/ib_cm.c:		 * We want to wait for tx and rx completion to finish
net/rds/ib_recv.c: * room for it beyond the ring size.  Send completion notices its special
net/rds/ib_recv.c: *  1.	We call rds_ib_attempt_ack from the recv completion handler
net/rds/ib_recv.c: *	send queue completion handler, and check whether there's
net/rds/ib_recv.c: * We get here from the send completion handler, when the
net/rds/ib_recv.c:	 * to get a recv completion _before_ the rdmacm ESTABLISHED
net/rds/ib_recv.c:			rds_ib_conn_error(conn, "recv completion on %pI4 had status %u (%s), disconnecting and reconnecting\n",
net/rds/ib_send.c: * completion handler.
net/rds/ib_send.c:	/* If the user asked for a completion notification on this
net/rds/ib_send.c:	 *  2.	Notify when the IB stack gives us the completion event for
net/rds/ib_send.c:	 *  3.	Notify when the IB stack gives us the completion event for
net/rds/ib_send.c:	 * ib_dma_sync_sg_for_cpu - the completion for the RDMA
net/rds/ib_send.c:		rds_ib_conn_error(conn, "send completion on %pI4 had status %u (%s), disconnecting and reconnecting\n",
net/rds/ib_send.c:	 * We want to delay signaling completions just enough to get
net/rds/ib_send.c: * in order so we pass ownership of the message to the completion handler
net/rds/ib_send.c:	/* if we finished the message then send completion owns it */
net/rxrpc/call_accept.c:		rxrpc_set_call_completion(call, RXRPC_CALL_REMOTELY_ABORTED,
net/rxrpc/ar-internal.h: * Call completion condition (state == RXRPC_CALL_COMPLETE).
net/rxrpc/ar-internal.h:enum rxrpc_call_completion {
net/rxrpc/ar-internal.h:	enum rxrpc_call_completion completion;	/* Call completion condition */
net/rxrpc/ar-internal.h:extern const char *const rxrpc_call_completions[];
net/rxrpc/ar-internal.h:static inline bool __rxrpc_set_call_completion(struct rxrpc_call *call,
net/rxrpc/ar-internal.h:					       enum rxrpc_call_completion compl,
net/rxrpc/ar-internal.h:		call->completion = compl,
net/rxrpc/ar-internal.h:static inline bool rxrpc_set_call_completion(struct rxrpc_call *call,
net/rxrpc/ar-internal.h:					     enum rxrpc_call_completion compl,
net/rxrpc/ar-internal.h:	ret = __rxrpc_set_call_completion(call, compl, abort_code, error);
net/rxrpc/ar-internal.h:	return __rxrpc_set_call_completion(call, RXRPC_CALL_SUCCEEDED, 0, 0);
net/rxrpc/ar-internal.h:	return __rxrpc_set_call_completion(call, RXRPC_CALL_LOCALLY_ABORTED,
net/rxrpc/input.c:	if (rxrpc_set_call_completion(call, RXRPC_CALL_REMOTELY_ABORTED,
net/rxrpc/peer_event.c:	enum rxrpc_call_completion compl;
net/rxrpc/peer_event.c:	_debug("ISSUE ERROR %s %d", rxrpc_call_completions[compl], error);
net/rxrpc/peer_event.c:		if (rxrpc_set_call_completion(call, compl, 0, error))
net/rxrpc/conn_event.c:			      enum rxrpc_call_completion compl,
net/rxrpc/conn_event.c:			if (rxrpc_set_call_completion(call, compl,
net/rxrpc/recvmsg.c:	switch (call->completion) {
net/rxrpc/recvmsg.c:	if (call->completion == RXRPC_CALL_SUCCEEDED) {
net/rxrpc/call_object.c:const char *const rxrpc_call_completions[NR__RXRPC_CALL_COMPLETIONS] = {
net/rxrpc/call_object.c:	__rxrpc_set_call_completion(call, RXRPC_CALL_LOCAL_ERROR,
net/netfilter/nf_conntrack_extend.c:	rcu_barrier(); /* Wait for completion of call_rcu()'s */
net/netfilter/nfnetlink_queue.c:	rcu_barrier(); /* Wait for completion of call_rcu()'s */
net/netfilter/ipvs/ip_vs_sync.c:#include <linux/completion.h>
net/netfilter/ipvs/ip_vs_sed.c: * completion. The expected delay that the job will experience is
net/netfilter/ipvs/ip_vs_sed.c: * minimize its expected delay of completion.
net/sched/sch_netem.c:	 * place at TX completion time, so _before_ the link transit delay)
samples/bpf/tracex3_kern.c:SEC("kprobe/blk_account_io_completion")
scripts/spelling.txt:competion||completion
scripts/analyze_suspend.py:	print('    -postres t  Time after resume completion to wait for post-resume events (default: 0 S)')
scripts/checkpatch.pl:			     "consider using a completion\n" . $herecurr);
scripts/kconfig/confdata.c:	 * and this marks the successful completion of the previous steps.
security/integrity/ima/ima_crypto.c:struct ahash_completion {
security/integrity/ima/ima_crypto.c:	struct completion completion;
security/integrity/ima/ima_crypto.c:	struct ahash_completion *res = req->data;
security/integrity/ima/ima_crypto.c:	complete(&res->completion);
security/integrity/ima/ima_crypto.c:static int ahash_wait(int err, struct ahash_completion *res)
security/integrity/ima/ima_crypto.c:		wait_for_completion(&res->completion);
security/integrity/ima/ima_crypto.c:		reinit_completion(&res->completion);
security/integrity/ima/ima_crypto.c:	struct ahash_completion res;
security/integrity/ima/ima_crypto.c:	init_completion(&res.completion);
security/integrity/ima/ima_crypto.c:			 * read/request, wait for the completion of the
security/integrity/ima/ima_crypto.c:			 * read/request, wait for the completion of the
security/integrity/ima/ima_crypto.c:	struct ahash_completion res;
security/integrity/ima/ima_crypto.c:	init_completion(&res.completion);
security/keys/request_key.c: * completion of keys undergoing construction with a non-interruptible wait.
security/keys/request_key.c: * completion of keys undergoing construction with a non-interruptible wait.
security/keys/request_key.c: * completion of the returned key if it is still undergoing construction.
security/keys/request_key.c: * completion of the returned key if it is still undergoing construction.
sound/sparc/dbri.c:CPU interrupt to signal completion.
sound/pci/intel8x0.c:#define ICH_BCIS			0x08	/* buffer completion interrupt status */
sound/pci/intel8x0.c:#define ICH_LVBCI			0x04	/* last valid buffer completion interrupt */
sound/pci/intel8x0.c:#define ICH_IOCE			0x10	/* interrupt on completion enable */
sound/pci/intel8x0.c:#define   ICH_RCS		0x00008000	/* read completion status */
sound/pci/intel8x0.c:			bdbar[idx + 1] = cpu_to_le32(0x80000000 | /* interrupt on completion */
sound/pci/intel8x0.c:			bdbar[idx + 3] = cpu_to_le32(0x80000000 | /* interrupt on completion */
sound/pci/intel8x0.c:			bdbar[idx + 1] = cpu_to_le32(0x80000000 | /* interrupt on completion */
sound/pci/hda/hda_tegra.c:#include <linux/completion.h>
sound/pci/hda/hda_intel.c:#include <linux/completion.h>
sound/pci/hda/hda_intel.c:	wait_for_completion(&hda->probe_wait);
sound/pci/hda/hda_intel.c:	wait_for_completion(&hda->probe_wait);
sound/pci/hda/hda_intel.c:	init_completion(&hda->probe_wait);
sound/pci/hda/hda_intel.h:	struct completion probe_wait;
sound/pci/asihpi/hpi.h:is useful for checking completion of all stream operations across the adapter
sound/pci/intel8x0m.c:#define ICH_BCIS			0x08	/* buffer completion interrupt status */
sound/pci/intel8x0m.c:#define ICH_LVBCI			0x04	/* last valid buffer completion interrupt */
sound/pci/intel8x0m.c:#define ICH_IOCE			0x10	/* interrupt on completion enable */
sound/pci/intel8x0m.c:#define   ICH_RCS		0x00008000	/* read completion status */
sound/pci/intel8x0m.c:			bdbar[idx + 1] = cpu_to_le32(0x80000000 | /* interrupt on completion */
sound/pci/intel8x0m.c:			bdbar[idx + 3] = cpu_to_le32(0x80000000 | /* interrupt on completion */
sound/pci/intel8x0m.c:			bdbar[idx + 1] = cpu_to_le32(0x80000000 | /* interrupt on completion */
sound/pci/oxygen/oxygen_io.c: * where the controller indicates completion aren't guaranteed to have actually
sound/pci/lola/lola.h:#define LOLA_DSD_CTL_IOCE	0x04	/* interrupt on completion enable */
sound/pci/lola/lola.h:#define LOLA_DSD_STS_BCIS	0x04	/* buffer completion interrupt status */
sound/aoa/soundbus/i2sbus/pcm.c:	struct completion done;
sound/aoa/soundbus/i2sbus/pcm.c:		init_completion(&done);
sound/aoa/soundbus/i2sbus/pcm.c:		pi->stop_completion = &done;
sound/aoa/soundbus/i2sbus/pcm.c:		timeout = wait_for_completion_timeout(&done, HZ);
sound/aoa/soundbus/i2sbus/pcm.c:		pi->stop_completion = NULL;
sound/aoa/soundbus/i2sbus/pcm.c:		if (pi->stop_completion)
sound/aoa/soundbus/i2sbus/pcm.c:			complete(pi->stop_completion);
sound/aoa/soundbus/i2sbus/i2sbus.h:#include <linux/completion.h>
sound/aoa/soundbus/i2sbus/i2sbus.h:	struct completion *stop_completion;
sound/soc/codecs/wm8962.c:	struct completion fll_lock;
sound/soc/codecs/wm8962.c:	reinit_completion(&wm8962->fll_lock);
sound/soc/codecs/wm8962.c:	timeout = wait_for_completion_timeout(&wm8962->fll_lock,
sound/soc/codecs/wm8962.c:	init_completion(&wm8962->fll_lock);
sound/soc/codecs/wm_hubs.c:			wait_for_completion_timeout(&hubs->dcs_done,
sound/soc/codecs/wm_hubs.c:	init_completion(&hubs->dcs_done);
sound/soc/codecs/arizona.h:#include <linux/completion.h>
sound/soc/codecs/wm8994.h:#include <linux/completion.h>
sound/soc/codecs/wm8994.h:	struct completion fll_locked[2];
sound/soc/codecs/nau8825.c:			dev_warn(nau8825->dev, "Headset completion IRQ fired but no headset connected\n");
sound/soc/codecs/wm8993.c:	struct completion fll_lock;
sound/soc/codecs/wm8993.c:	try_wait_for_completion(&wm8993->fll_lock);
sound/soc/codecs/wm8993.c:	timeout = wait_for_completion_timeout(&wm8993->fll_lock, timeout);
sound/soc/codecs/wm8993.c:	init_completion(&wm8993->fll_lock);
sound/soc/codecs/wm8996.c:#include <linux/completion.h>
sound/soc/codecs/wm8996.c:	struct completion fll_lock;
sound/soc/codecs/wm8996.c:	struct completion dcs_done;
sound/soc/codecs/wm8996.c:			timeout = wait_for_completion_timeout(&wm8996->dcs_done,
sound/soc/codecs/wm8996.c:	/* Clear any pending completions (eg, from failed startups) */
sound/soc/codecs/wm8996.c:	try_wait_for_completion(&wm8996->fll_lock);
sound/soc/codecs/wm8996.c:		time_left = wait_for_completion_timeout(&wm8996->fll_lock,
sound/soc/codecs/wm8996.c:	init_completion(&wm8996->dcs_done);
sound/soc/codecs/wm8996.c:	init_completion(&wm8996->fll_lock);
sound/soc/codecs/da7213.c:	/* Begin auto calibration and wait for completion */
sound/soc/codecs/wm8994.c:	/* Clear any pending completion from a previous failure */
sound/soc/codecs/wm8994.c:	try_wait_for_completion(&wm8994->fll_locked[id]);
sound/soc/codecs/wm8994.c:			timeout = wait_for_completion_timeout(&wm8994->fll_locked[id],
sound/soc/codecs/wm8994.c:	struct completion *completion = data;
sound/soc/codecs/wm8994.c:	complete(completion);
sound/soc/codecs/wm8994.c:		init_completion(&wm8994->fll_locked[i]);
sound/soc/codecs/wm0010.c:	struct completion boot_completion;
sound/soc/codecs/wm0010.c:	struct completion *done;
sound/soc/codecs/wm0010.c:	struct completion done;
sound/soc/codecs/wm0010.c:	init_completion(&done);
sound/soc/codecs/wm0010.c:	wait_for_completion(&done);
sound/soc/codecs/wm0010.c:	if (!wait_for_completion_timeout(&wm0010->boot_completion,
sound/soc/codecs/wm0010.c:	if (!wait_for_completion_timeout(&wm0010->boot_completion,
sound/soc/codecs/wm0010.c:		complete(&wm0010->boot_completion);
sound/soc/codecs/wm0010.c:	init_completion(&wm0010->boot_completion);
sound/soc/codecs/wm8903.c:#include <linux/completion.h>
sound/soc/codecs/wm_hubs.h:#include <linux/completion.h>
sound/soc/codecs/wm_hubs.h:	struct completion dcs_done;
sound/soc/codecs/wm8350.c:	 * wait for its completion */
sound/soc/codecs/wm5100.c:	struct completion lock;
sound/soc/codecs/wm5100.c:	/* Clear any pending completions */
sound/soc/codecs/wm5100.c:	try_wait_for_completion(&fll->lock);
sound/soc/codecs/wm5100.c:			time_left = wait_for_completion_timeout(&fll->lock,
sound/soc/codecs/wm5100.c:		init_completion(&wm5100->fll[i].lock);
sound/soc/codecs/wm2200.c:	struct completion lock;
sound/soc/codecs/wm2200.c:	struct completion fll_lock;
sound/soc/codecs/wm2200.c:	/* Clear any pending completions */
sound/soc/codecs/wm2200.c:	try_wait_for_completion(&wm2200->fll_lock);
sound/soc/codecs/wm2200.c:			time_left = wait_for_completion_timeout(
sound/soc/codecs/wm2200.c:	init_completion(&wm2200->fll_lock);
sound/soc/intel/haswell/sst-haswell-ipc.c:	/* wait for DSP boot completion */
sound/soc/intel/haswell/sst-haswell-ipc.c:	/* wait for DSP boot completion */
sound/soc/intel/skylake/skl-sst-cldma.h:#define SKL_CL_DMA_SD_INT_COMPLETE		0x04 /* Buffer completion interrupt */
sound/soc/intel/common/sst-ipc.c:	/* wait for DSP completion (in all cases atm inc pending) */
sound/soc/intel/common/sst-ipc.c:	 * also postpone if we are in the middle of procesing completion irq*/
sound/soc/intel/baytrail/sst-baytrail-ipc.c:	/* wait for DSP boot completion */
sound/soc/intel/baytrail/sst-baytrail-ipc.c:	/* wait for DSP boot completion */
sound/soc/amd/acp-pcm-dma.c:	 * interrupt on completion of the dma transfer
sound/soc/samsung/ac97.c:	struct completion  done;
sound/soc/samsung/ac97.c:	reinit_completion(&s3c_ac97.done);
sound/soc/samsung/ac97.c:	if (!wait_for_completion_timeout(&s3c_ac97.done, HZ))
sound/soc/samsung/ac97.c:	reinit_completion(&s3c_ac97.done);
sound/soc/samsung/ac97.c:	if (!wait_for_completion_timeout(&s3c_ac97.done, HZ))
sound/soc/samsung/ac97.c:	reinit_completion(&s3c_ac97.done);
sound/soc/samsung/ac97.c:	if (!wait_for_completion_timeout(&s3c_ac97.done, HZ))
sound/soc/samsung/ac97.c:	init_completion(&s3c_ac97.done);
sound/soc/txx9/txx9aclc.c:	/* dma completion handler cannot submit new operations */
sound/soc/cirrus/ep93xx-ac97.c:	struct completion	done;
sound/soc/cirrus/ep93xx-ac97.c:	if (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT)) {
sound/soc/cirrus/ep93xx-ac97.c:	if (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT))
sound/soc/cirrus/ep93xx-ac97.c:	if (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT))
sound/soc/cirrus/ep93xx-ac97.c:	if (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT))
sound/soc/cirrus/ep93xx-ac97.c:	init_completion(&info->done);
sound/sh/aica.c:		dma_wait_for_completion(AICA_DMA_CHANNEL);
sound/core/init.c:#include <linux/completion.h>
sound/core/init.c:	if (card->release_completion)
sound/core/init.c:		complete(card->release_completion);
sound/core/init.c:	struct completion released;
sound/core/init.c:	init_completion(&released);
sound/core/init.c:	card->release_completion = &released;
sound/core/init.c:	wait_for_completion(&released);
sound/core/compress_offload.c:	 * It is expected that driver will notify the drain completion and then
sound/usb/endpoint.c: * from their completion handler.
sound/usb/midi.c: * Error handling for URB completion functions.
sound/usb/midi.c:	 * an URB's completion handler may start the timer and
sound/usb/line6/driver.c:	Notification of completion of asynchronous request transmission.
sound/usb/line6/midi.c:	Notification of completion of MIDI transmission.
sound/firewire/lib.c: * snd_fw_transaction - send a request and wait for its completion
sound/firewire/fcp.c:			 * on command completion once an INTERIM response has
sound/firewire/amdtp-stream.c:		fw_iso_context_flush_completions(s->context);
sound/firewire/dice/dice.c:	init_completion(&dice->clock_accepted);
sound/firewire/dice/dice-stream.c:	if (completion_done(&dice->clock_accepted))
sound/firewire/dice/dice-stream.c:		reinit_completion(&dice->clock_accepted);
sound/firewire/dice/dice-stream.c:	if (wait_for_completion_timeout(&dice->clock_accepted,
sound/firewire/dice/dice.h:#include <linux/completion.h>
sound/firewire/dice/dice.h:	struct completion clock_accepted;
sound/drivers/opl4/opl4_synth.c:	/* wait for completion of loading */
tools/testing/radix-tree/regression3.c: * This test should run to completion immediately. The above bug would
tools/testing/radix-tree/regression1.c: * This test should run to completion in a few seconds. The above bug would
tools/testing/radix-tree/regression2.c: * This test should run to completion immediately. The above bug would cause it
tools/net/bpf_dbg.c:static char **shell_completion(const char *buf, int start, int end)
tools/net/bpf_dbg.c:		matches = rl_completion_matches(buf, shell_comp_gen);
tools/net/bpf_dbg.c:	rl_attempted_completion_function = shell_completion;
tools/virtio/ringtest/ring.c:	/* simple in-order completion: we don't need
tools/power/cpupower/man/cpupower-monitor.1:statistics are printed upon its completion, or statistics are printed periodically.
tools/power/x86/turbostat/turbostat.8:upon its completion.
tools/perf/tests/make:installed_files_bin += etc/bash_completion.d/perf
tools/perf/perf-completion.sh:# perf bash and zsh completion
tools/perf/perf-completion.sh:# Taken from git.git's completion script.
tools/perf/perf-completion.sh:	# List of word completion separators has shrunk;
tools/perf/perf-completion.sh:# Define preload__ltrim_colon_completions="false", if the function
tools/perf/perf-completion.sh:# __perf__ltrim_colon_completions() is required instead.
tools/perf/perf-completion.sh:preload__ltrim_colon_completions="true"
tools/perf/perf-completion.sh:if [ $preload__ltrim_colon_completions = "true" ]; then
tools/perf/perf-completion.sh:	type __ltrim_colon_completions &>/dev/null ||
tools/perf/perf-completion.sh:	preload__ltrim_colon_completions="false"
tools/perf/perf-completion.sh:[ $preload__ltrim_colon_completions = "true" ] ||
tools/perf/perf-completion.sh:__perf__ltrim_colon_completions()
tools/perf/perf-completion.sh:	if [ $preload__ltrim_colon_completions = "true" ]; then
tools/perf/perf-completion.sh:		__ltrim_colon_completions $cur
tools/perf/perf-completion.sh:		__perf__ltrim_colon_completions $cur
tools/perf/Makefile.perf:	$(call QUIET_INSTALL, perf_completion-script) \
tools/perf/Makefile.perf:		$(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(sysconfdir_SQ)/bash_completion.d'; \
tools/perf/Makefile.perf:		$(INSTALL) perf-completion.sh '$(DESTDIR_SQ)$(sysconfdir_SQ)/bash_completion.d/perf'
virt/kvm/async_pf.c:	 * apf may be freed by kvm_check_async_pf_completion() after
virt/kvm/async_pf.c:void kvm_clear_async_pf_completion_queue(struct kvm_vcpu *vcpu)
virt/kvm/async_pf.c:void kvm_check_async_pf_completion(struct kvm_vcpu *vcpu)
